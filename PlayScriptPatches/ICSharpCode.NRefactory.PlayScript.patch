diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Analysis/ControlFlow.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Analysis/ControlFlow.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Analysis/ControlFlow.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Analysis/ControlFlow.cs	2013-04-23 21:04:54.000000000 -0700
@@ -21,14 +21,14 @@ using System.Collections.Generic;
 using System.Diagnostics;
 using System.Linq;
 using System.Threading;
-using ICSharpCode.NRefactory.CSharp.Resolver;
-using ICSharpCode.NRefactory.CSharp.TypeSystem;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
+using ICSharpCode.NRefactory.PlayScript.TypeSystem;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 using ICSharpCode.NRefactory.Utils;
 
-namespace ICSharpCode.NRefactory.CSharp.Analysis
+namespace ICSharpCode.NRefactory.PlayScript.Analysis
 {
 	/// <summary>
 	/// Represents a node in the control flow graph of a C# method.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Analysis/DefiniteAssignmentAnalysis.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Analysis/DefiniteAssignmentAnalysis.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Analysis/DefiniteAssignmentAnalysis.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Analysis/DefiniteAssignmentAnalysis.cs	2013-04-23 21:04:54.000000000 -0700
@@ -22,13 +22,13 @@ using System.Diagnostics;
 using System.Linq;
 using System.Threading;
 
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 using ICSharpCode.NRefactory.Utils;
 
-namespace ICSharpCode.NRefactory.CSharp.Analysis
+namespace ICSharpCode.NRefactory.PlayScript.Analysis
 {
 	/// <summary>
 	/// Represents the definite assignment status of a variable at a specific location.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Analysis/ReachabilityAnalysis.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Analysis/ReachabilityAnalysis.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Analysis/ReachabilityAnalysis.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Analysis/ReachabilityAnalysis.cs	2013-04-23 21:04:54.000000000 -0700
@@ -19,11 +19,11 @@
 using System;
 using System.Collections.Generic;
 using System.Threading;
-using ICSharpCode.NRefactory.CSharp.Resolver;
-using ICSharpCode.NRefactory.CSharp.TypeSystem;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
+using ICSharpCode.NRefactory.PlayScript.TypeSystem;
 using ICSharpCode.NRefactory.Semantics;
 
-namespace ICSharpCode.NRefactory.CSharp.Analysis
+namespace ICSharpCode.NRefactory.PlayScript.Analysis
 {
 	/// <summary>
 	/// Statement reachability analysis.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Analysis/SemanticHighlightingVisitor.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Analysis/SemanticHighlightingVisitor.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Analysis/SemanticHighlightingVisitor.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Analysis/SemanticHighlightingVisitor.cs	2013-04-23 21:04:54.000000000 -0700
@@ -20,12 +20,12 @@ using System;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Linq;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using System.Threading;
 
-namespace ICSharpCode.NRefactory.CSharp.Analysis
+namespace ICSharpCode.NRefactory.PlayScript.Analysis
 {
 	/// <summary>
 	/// C# Semantic highlighter.
@@ -580,7 +580,7 @@ namespace ICSharpCode.NRefactory.CSharp.
 		{
 		}
 		
-		public override void VisitAttribute(ICSharpCode.NRefactory.CSharp.Attribute attribute)
+		public override void VisitAttribute(ICSharpCode.NRefactory.PlayScript.Attribute attribute)
 		{
 			ITypeDefinition attrDef = resolver.Resolve(attribute.Type, cancellationToken).Type.GetDefinition();
 			if (attrDef != null && IsInactiveConditional(attrDef.Attributes)) {
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/AstNode.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/AstNode.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/AstNode.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/AstNode.cs	2013-04-23 21:04:54.000000000 -0700
@@ -33,7 +33,7 @@ using System.Linq;
 using System.Threading;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public abstract class AstNode : AbstractAnnotatable, ICSharpCode.NRefactory.TypeSystem.IFreezable, PatternMatching.INode
 	{
@@ -609,7 +609,51 @@ namespace ICSharpCode.NRefactory.CSharp
 		}
 
 		#endregion
-		
+
+		private static List<AstNode> _sortList = new List<AstNode>();
+
+		// For PlayScript, we want to fix out of order nodes, as the current parser puts the nodes in C# order, and PlayScript's 
+		// nodes typically don't go in the same order.  We need to fix the parser, but for the time being this actually puts the
+		// nodes in the right order so that the GetNodeAt() methods can actually find the right node.
+		public void FixOutOfOrderLocations()
+		{
+			// Get list of nodes
+			_sortList.Clear();
+			var node = firstChild;
+			while (node != null) {
+				_sortList.Add(node);
+				node = node.nextSibling;
+			}
+
+			// Resort list by start location (assuming some of them might be out of order due to incorrect placement in PlayScript).
+			if (_sortList.Count > 0) {
+				_sortList.Sort((a,b) => a.StartLocation.CompareTo(b.StartLocation));
+				for (var i = 0; i < _sortList.Count; i++) {
+					if (i == 0) {
+						firstChild = _sortList[i];
+						_sortList[i].prevSibling = null;
+					} else {
+						_sortList[i - 1].nextSibling = _sortList[i];
+						_sortList[i].prevSibling = _sortList[i - 1];
+					}
+					if (i == _sortList.Count - 1) {
+						lastChild = _sortList[i];
+						_sortList[i].nextSibling = null;
+					} else {
+						_sortList[i].nextSibling = _sortList[i + 1];
+						_sortList[i + 1].prevSibling = _sortList[i];
+					}
+				}
+			}
+
+			// Fix all children nodes
+			node = firstChild;
+			while (node != null) {
+				node.FixOutOfOrderLocations();
+				node = node.nextSibling;
+			}
+		}
+
 		public AstNode GetNextNode ()
 		{
 			if (NextSibling != null)
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/AstNodeCollection.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/AstNodeCollection.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/AstNodeCollection.cs	2013-03-14 23:31:36.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/AstNodeCollection.cs	2013-04-23 21:04:54.000000000 -0700
@@ -23,7 +23,7 @@ using System.Diagnostics;
 using System.Linq;
 using ICSharpCode.NRefactory.PatternMatching;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Represents the children of an AstNode that have a specific role.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/AstType.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/AstType.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/AstType.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/AstType.cs	2013-04-23 21:04:54.000000000 -0700
@@ -18,10 +18,10 @@
 
 using System;
 using System.Collections.Generic;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// A type reference in the C# AST.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/CSharpModifierToken.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/CSharpModifierToken.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/CSharpModifierToken.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/CSharpModifierToken.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public class CSharpModifierToken : CSharpTokenNode
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/CSharpTokenNode.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/CSharpTokenNode.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/CSharpTokenNode.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/CSharpTokenNode.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,7 +25,7 @@
 // THE SOFTWARE.
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Represents a token in C#. Note that the type of the token is defined through the TokenRole.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/CSharpUtil.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/CSharpUtil.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/CSharpUtil.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/CSharpUtil.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,9 +24,9 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 using System;
-using ICSharpCode.NRefactory.CSharp;
+using ICSharpCode.NRefactory.PlayScript;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public static class CSharpUtil
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/ComposedType.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/ComposedType.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/ComposedType.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/ComposedType.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,7 +29,7 @@ using System.Linq;
 using System.Text;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public class ComposedType : AstType
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/DepthFirstAstVisitor.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/DepthFirstAstVisitor.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/DepthFirstAstVisitor.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/DepthFirstAstVisitor.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// AST visitor with a default implementation that visits all node depth-first.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/DocumentationReference.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/DocumentationReference.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/DocumentationReference.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/DocumentationReference.cs	2013-04-23 21:04:54.000000000 -0700
@@ -19,7 +19,7 @@
 using System;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Represents a 'cref' reference in XML documentation.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/ErrorNode.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/ErrorNode.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/ErrorNode.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/ErrorNode.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,7 +25,7 @@
 // THE SOFTWARE.
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Represents a parsing error in the ast. At the moment it only represents missing closing bracket.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/AnonymousMethodExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/AnonymousMethodExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/AnonymousMethodExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/AnonymousMethodExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@
 using System.Collections.Generic;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// [async] delegate(Parameters) {Body}
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/AnonymousTypeCreateExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/AnonymousTypeCreateExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/AnonymousTypeCreateExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/AnonymousTypeCreateExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 using System;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// new { [ExpressionList] }
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/ArrayCreateExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/ArrayCreateExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/ArrayCreateExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/ArrayCreateExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -19,7 +19,7 @@
 using System;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// new Type[Dimensions]
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/ArrayInitializerExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/ArrayInitializerExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/ArrayInitializerExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/ArrayInitializerExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// { Elements }
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/AsExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/AsExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/AsExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/AsExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Expression as TypeReference
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/AssignmentExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/AssignmentExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/AssignmentExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/AssignmentExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@
 using System;
 using System.Linq.Expressions;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Left Operator= Right
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/BaseReferenceExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/BaseReferenceExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/BaseReferenceExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/BaseReferenceExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// base
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/BinaryOperatorExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/BinaryOperatorExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/BinaryOperatorExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/BinaryOperatorExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@
 using System;
 using System.Linq.Expressions;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Left Operator Right
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/CastExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/CastExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/CastExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/CastExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// (CastTo)Expression
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/CheckedExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/CheckedExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/CheckedExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/CheckedExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// checked(Expression)
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/ConditionalExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/ConditionalExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/ConditionalExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/ConditionalExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Condition ? TrueExpression : FalseExpression
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/DefaultValueExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/DefaultValueExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/DefaultValueExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/DefaultValueExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// default(Type)
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/DirectionExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/DirectionExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/DirectionExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/DirectionExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public enum FieldDirection
 	{
@@ -47,7 +47,7 @@ namespace ICSharpCode.NRefactory.CSharp
 		}
 		
 		public CSharpTokenNode FieldDirectionToken {
-			get { return FieldDirection == ICSharpCode.NRefactory.CSharp.FieldDirection.Ref ? GetChildByRole (RefKeywordRole) : GetChildByRole (OutKeywordRole); }
+			get { return FieldDirection == ICSharpCode.NRefactory.PlayScript.FieldDirection.Ref ? GetChildByRole (RefKeywordRole) : GetChildByRole (OutKeywordRole); }
 		}
 		
 		public Expression Expression {
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/EmptyExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/EmptyExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/EmptyExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/EmptyExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,7 +25,7 @@
 // THE SOFTWARE.
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Type&lt;[EMPTY]&gt;
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/ErrorExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/ErrorExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/ErrorExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/ErrorExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,7 +25,7 @@
 // THE SOFTWARE.
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public class ErrorExpression : Expression
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/Expression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/Expression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/Expression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/Expression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -19,7 +19,7 @@
 using System;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Base class for expressions.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/IdentifierExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/IdentifierExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/IdentifierExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/IdentifierExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,7 +25,7 @@
 // THE SOFTWARE.
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public class IdentifierExpression : Expression
 	{
@@ -40,7 +40,7 @@ namespace ICSharpCode.NRefactory.CSharp
 		
 		public IdentifierExpression(string identifier, TextLocation location)
 		{
-			SetChildByRole(Roles.Identifier, CSharp.Identifier.Create (identifier, location));
+			SetChildByRole(Roles.Identifier, PlayScript.Identifier.Create (identifier, location));
 		}
 		
 //		public Identifier IdentifierToken {
@@ -52,7 +52,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return GetChildByRole (Roles.Identifier).Name;
 			}
 			set {
-				SetChildByRole(Roles.Identifier, CSharp.Identifier.Create (value));
+				SetChildByRole(Roles.Identifier, PlayScript.Identifier.Create (value));
 			}
 		}
 
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/IndexerExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/IndexerExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/IndexerExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/IndexerExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Target[Arguments]
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/InvocationExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/InvocationExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/InvocationExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/InvocationExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Target(Arguments)
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/IsExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/IsExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/IsExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/IsExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Expression is Type
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/LambdaExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/LambdaExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/LambdaExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/LambdaExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 using System.Collections.Generic;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// [async] Parameters => Body
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/MemberReferenceExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/MemberReferenceExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/MemberReferenceExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/MemberReferenceExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Target.MemberName
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/NamedArgumentExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/NamedArgumentExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/NamedArgumentExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/NamedArgumentExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -18,7 +18,7 @@
 
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Represents a named argument passed to a method or attribute.
@@ -41,7 +41,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return GetChildByRole (Roles.Identifier).Name;
 			}
 			set {
-				SetChildByRole(Roles.Identifier, CSharp.Identifier.Create (value));
+				SetChildByRole(Roles.Identifier, PlayScript.Identifier.Create (value));
 			}
 		}
 		
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/NamedExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/NamedExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/NamedExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/NamedExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@
 using System.Collections.Generic;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// name = expression
@@ -51,7 +51,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return GetChildByRole (Roles.Identifier).Name;
 			}
 			set {
-				SetChildByRole(Roles.Identifier, CSharp.Identifier.Create (value));
+				SetChildByRole(Roles.Identifier, PlayScript.Identifier.Create (value));
 			}
 		}
 		
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/NullReferenceExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/NullReferenceExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/NullReferenceExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/NullReferenceExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// null
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/ObjectCreateExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/ObjectCreateExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/ObjectCreateExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/ObjectCreateExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// new Type(Arguments) { Initializer }
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/ParenthesizedExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/ParenthesizedExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/ParenthesizedExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/ParenthesizedExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// ( Expression )
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/PointerReferenceExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/PointerReferenceExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/PointerReferenceExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/PointerReferenceExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Target->MemberName
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/PrimitiveExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/PrimitiveExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/PrimitiveExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/PrimitiveExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Represents a literal value.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/QueryExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/QueryExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/QueryExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/QueryExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -19,7 +19,7 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public class QueryExpression : Expression
 	{
@@ -127,7 +127,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return GetChildByRole (Roles.Identifier).Name;
 			}
 			set {
-				SetChildByRole(Roles.Identifier, CSharp.Identifier.Create (value));
+				SetChildByRole(Roles.Identifier, PlayScript.Identifier.Create (value));
 			}
 		}
 		
@@ -176,7 +176,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return GetChildByRole (Roles.Identifier).Name;
 			}
 			set {
-				SetChildByRole(Roles.Identifier, CSharp.Identifier.Create (value));
+				SetChildByRole(Roles.Identifier, PlayScript.Identifier.Create (value));
 			}
 		}
 		
@@ -229,7 +229,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return GetChildByRole(Roles.Identifier).Name;
 			}
 			set {
-				SetChildByRole(Roles.Identifier, CSharp.Identifier.Create (value));
+				SetChildByRole(Roles.Identifier, PlayScript.Identifier.Create (value));
 			}
 		}
 		
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/SizeOfExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/SizeOfExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/SizeOfExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/SizeOfExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// sizeof(Type)
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/StackAllocExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/StackAllocExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/StackAllocExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/StackAllocExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// stackalloc Type[Count]
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/ThisReferenceExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/ThisReferenceExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/ThisReferenceExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/ThisReferenceExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// this
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/TypeOfExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/TypeOfExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/TypeOfExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/TypeOfExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,7 +25,7 @@
 // THE SOFTWARE.
 
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// typeof(Type)
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/TypeReferenceExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/TypeReferenceExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/TypeReferenceExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/TypeReferenceExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -18,7 +18,7 @@
 
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Represents an AstType as an expression.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/UnaryOperatorExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/UnaryOperatorExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/UnaryOperatorExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/UnaryOperatorExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@
 using System;
 using System.Linq.Expressions;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Operator Expression
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/UncheckedExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/UncheckedExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/UncheckedExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/UncheckedExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// unchecked(Expression)
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/UndocumentedExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/UndocumentedExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Expressions/UndocumentedExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Expressions/UndocumentedExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public enum UndocumentedExpressionType
 	{
@@ -54,14 +54,14 @@ namespace ICSharpCode.NRefactory.CSharp
 		public CSharpTokenNode UndocumentedToken {
 			get {
 				switch (UndocumentedExpressionType) {
-				case ICSharpCode.NRefactory.CSharp.UndocumentedExpressionType.ArgListAccess:
-				case ICSharpCode.NRefactory.CSharp.UndocumentedExpressionType.ArgList:
+				case ICSharpCode.NRefactory.PlayScript.UndocumentedExpressionType.ArgListAccess:
+				case ICSharpCode.NRefactory.PlayScript.UndocumentedExpressionType.ArgList:
 					return GetChildByRole (ArglistKeywordRole);
-				case ICSharpCode.NRefactory.CSharp.UndocumentedExpressionType.RefValue:
+				case ICSharpCode.NRefactory.PlayScript.UndocumentedExpressionType.RefValue:
 					return GetChildByRole (RefvalueKeywordRole);
-				case ICSharpCode.NRefactory.CSharp.UndocumentedExpressionType.RefType:
+				case ICSharpCode.NRefactory.PlayScript.UndocumentedExpressionType.RefType:
 					return GetChildByRole (ReftypeKeywordRole);
-				case ICSharpCode.NRefactory.CSharp.UndocumentedExpressionType.MakeRef:
+				case ICSharpCode.NRefactory.PlayScript.UndocumentedExpressionType.MakeRef:
 					return GetChildByRole (MakerefKeywordRole);
 				}
 				return CSharpTokenNode.Null;
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/Attribute.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/Attribute.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/Attribute.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/Attribute.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Attribute(Arguments)
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/AttributeSection.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/AttributeSection.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/AttributeSection.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/AttributeSection.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// [AttributeTarget: Attributes]
@@ -96,7 +96,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return GetChildByRole (Roles.Identifier).Name;
 			}
 			set {
-				SetChildByRole (Roles.Identifier, CSharp.Identifier.Create (value));
+				SetChildByRole (Roles.Identifier, PlayScript.Identifier.Create (value));
 			}
 		}
 		
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/Comment.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/Comment.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/Comment.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/Comment.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public enum CommentType 
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/Constraint.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/Constraint.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/Constraint.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/Constraint.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// where TypeParameter : BaseTypes
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/DelegateDeclaration.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/DelegateDeclaration.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/DelegateDeclaration.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/DelegateDeclaration.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// delegate ReturnType Name&lt;TypeParameters&gt;(Parameters) where Constraints;
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/ExternAliasDeclaration.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/ExternAliasDeclaration.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/ExternAliasDeclaration.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/ExternAliasDeclaration.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// extern alias <Identifier>;
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/NamespaceDeclaration.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/NamespaceDeclaration.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/NamespaceDeclaration.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/NamespaceDeclaration.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System.Collections.Generic;
 using System.Linq;
 using System.Text;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// namespace Name { Members }
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/NewLineNode.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/NewLineNode.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/NewLineNode.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/NewLineNode.cs	2013-04-23 21:04:54.000000000 -0700
@@ -1,5 +1,5 @@
 using System;
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public enum NewLineType {
 		Unix,
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/PreProcessorDirective.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/PreProcessorDirective.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/PreProcessorDirective.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/PreProcessorDirective.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,7 +25,7 @@
 // THE SOFTWARE.
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public enum PreProcessorDirectiveType : byte
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/TextNode.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/TextNode.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/TextNode.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/TextNode.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,7 +25,7 @@
 // THE SOFTWARE.
 
 using System;
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// A text node contains text without syntactic or semantic information.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/TypeDeclaration.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/TypeDeclaration.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/TypeDeclaration.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/TypeDeclaration.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System.Collections.Generic;
 using System.Linq;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public enum ClassType
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/TypeParameterDeclaration.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/TypeParameterDeclaration.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/TypeParameterDeclaration.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/TypeParameterDeclaration.cs	2013-04-23 21:04:54.000000000 -0700
@@ -19,7 +19,7 @@
 using System;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// [in|out] Name
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/UsingAliasDeclaration.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/UsingAliasDeclaration.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/UsingAliasDeclaration.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/UsingAliasDeclaration.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// using Alias = Import;
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/UsingDeclaration.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/UsingDeclaration.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/UsingDeclaration.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/UsingDeclaration.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System;
 using System.Linq;
 using System.Text;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// using Import;
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/WhitespaceNode.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/WhitespaceNode.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/GeneralScope/WhitespaceNode.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/GeneralScope/WhitespaceNode.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,7 +25,7 @@
 // THE SOFTWARE.
 
 using System;
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// A Whitespace node contains only whitespaces.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/IAstVisitor.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/IAstVisitor.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/IAstVisitor.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/IAstVisitor.cs	2013-04-23 21:04:54.000000000 -0700
@@ -18,7 +18,7 @@
 
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// AST visitor.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Identifier.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Identifier.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Identifier.cs	2013-03-14 23:31:36.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Identifier.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public class Identifier : AstNode
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/IdentifierExpressionBackreference.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/IdentifierExpressionBackreference.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/IdentifierExpressionBackreference.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/IdentifierExpressionBackreference.cs	2013-04-23 21:04:54.000000000 -0700
@@ -20,7 +20,7 @@ using System;
 using System.Linq;
 using ICSharpCode.NRefactory.PatternMatching;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Matches identifier expressions that have the same identifier as the referenced variable/type definition/method definition.
@@ -42,13 +42,13 @@ namespace ICSharpCode.NRefactory.CSharp
 		
 		public override bool DoMatch(INode other, Match match)
 		{
-			CSharp.IdentifierExpression ident = other as CSharp.IdentifierExpression;
+			PlayScript.IdentifierExpression ident = other as PlayScript.IdentifierExpression;
 			if (ident == null || ident.TypeArguments.Any())
 				return false;
-			CSharp.AstNode referenced = (CSharp.AstNode)match.Get(referencedGroupName).Last();
+			PlayScript.AstNode referenced = (PlayScript.AstNode)match.Get(referencedGroupName).Last();
 			if (referenced == null)
 				return false;
-			return ident.Identifier == referenced.GetChildByRole(CSharp.Roles.Identifier).Name;
+			return ident.Identifier == referenced.GetChildByRole(PlayScript.Roles.Identifier).Name;
 		}
 	}
 }
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/MemberType.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/MemberType.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/MemberType.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/MemberType.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,10 +28,10 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 using System.Text;
-using ICSharpCode.NRefactory.CSharp.TypeSystem;
+using ICSharpCode.NRefactory.PlayScript.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public class MemberType : AstType
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Modifiers.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Modifiers.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Modifiers.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Modifiers.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@
 
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	[Flags]
 	public enum Modifiers
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/NodeType.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/NodeType.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/NodeType.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/NodeType.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public enum NodeType
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/ObservableAstVisitor.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/ObservableAstVisitor.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/ObservableAstVisitor.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/ObservableAstVisitor.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public class ObservableAstVisitor : IAstVisitor
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/PrimitiveType.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/PrimitiveType.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/PrimitiveType.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/PrimitiveType.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,11 +26,11 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public class PrimitiveType : AstType
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Roles.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Roles.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Roles.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Roles.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,26 +26,26 @@
 
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public static class Roles
 	{
 		public static readonly Role<AstNode> Root = AstNode.RootRole;
 		
 		// some pre defined constants for common roles
-		public static readonly Role<Identifier> Identifier = new Role<Identifier> ("Identifier", CSharp.Identifier.Null);
-		public static readonly Role<BlockStatement> Body = new Role<BlockStatement> ("Body", CSharp.BlockStatement.Null);
+		public static readonly Role<Identifier> Identifier = new Role<Identifier> ("Identifier", PlayScript.Identifier.Null);
+		public static readonly Role<BlockStatement> Body = new Role<BlockStatement> ("Body", PlayScript.BlockStatement.Null);
 		public static readonly Role<ParameterDeclaration> Parameter = new Role<ParameterDeclaration> ("Parameter");
-		public static readonly Role<Expression> Argument = new Role<Expression> ("Argument", CSharp.Expression.Null);
-		public static readonly Role<AstType> Type = new Role<AstType> ("Type", CSharp.AstType.Null);
-		public static readonly Role<Expression> Expression = new Role<Expression> ("Expression", CSharp.Expression.Null);
-		public static readonly Role<Expression> TargetExpression = new Role<Expression> ("Target", CSharp.Expression.Null);
-		public readonly static Role<Expression> Condition = new Role<Expression> ("Condition", CSharp.Expression.Null);
+		public static readonly Role<Expression> Argument = new Role<Expression> ("Argument", PlayScript.Expression.Null);
+		public static readonly Role<AstType> Type = new Role<AstType> ("Type", PlayScript.AstType.Null);
+		public static readonly Role<Expression> Expression = new Role<Expression> ("Expression", PlayScript.Expression.Null);
+		public static readonly Role<Expression> TargetExpression = new Role<Expression> ("Target", PlayScript.Expression.Null);
+		public readonly static Role<Expression> Condition = new Role<Expression> ("Condition", PlayScript.Expression.Null);
 		public static readonly Role<TypeParameterDeclaration> TypeParameter = new Role<TypeParameterDeclaration> ("TypeParameter");
-		public static readonly Role<AstType> TypeArgument = new Role<AstType> ("TypeArgument", CSharp.AstType.Null);
+		public static readonly Role<AstType> TypeArgument = new Role<AstType> ("TypeArgument", PlayScript.AstType.Null);
 		public readonly static Role<Constraint> Constraint = new Role<Constraint> ("Constraint");
 		public static readonly Role<VariableInitializer> Variable = new Role<VariableInitializer> ("Variable", VariableInitializer.Null);
-		public static readonly Role<Statement> EmbeddedStatement = new Role<Statement> ("EmbeddedStatement", CSharp.Statement.Null);
+		public static readonly Role<Statement> EmbeddedStatement = new Role<Statement> ("EmbeddedStatement", PlayScript.Statement.Null);
 		public readonly static Role<EntityDeclaration> TypeMemberRole = new Role<EntityDeclaration> ("TypeMember");
 		
 
@@ -81,15 +81,18 @@ namespace ICSharpCode.NRefactory.CSharp
 
 		public readonly static TokenRole WhereKeyword = new TokenRole ("where");
 		public readonly static Role<SimpleType> ConstraintTypeParameter = new Role<SimpleType> ("TypeParameter", SimpleType.Null);
-		public readonly static TokenRole DelegateKeyword = new TokenRole ("delegate");
+		public readonly static TokenRole DelegateKeyword = new TokenRole ("function");
 		public static readonly TokenRole ExternKeyword = new TokenRole ("extern");
 		public static readonly TokenRole AliasKeyword = new TokenRole ("alias");
-		public static readonly TokenRole NamespaceKeyword = new TokenRole ("namespace");
+		public static readonly TokenRole NamespaceKeyword = new TokenRole ("package");
 
 		public static readonly TokenRole EnumKeyword = new TokenRole ("enum");
 		public static readonly TokenRole InterfaceKeyword = new TokenRole ("interface");
 		public static readonly TokenRole StructKeyword = new TokenRole ("struct");
 		public static readonly TokenRole ClassKeyword = new TokenRole ("class");
+		public static readonly TokenRole FunctionKeyword = new TokenRole ("function");
+		public static readonly TokenRole IndexerKeyword = new TokenRole ("indexer");
+		public static readonly TokenRole PropertyKeyword = new TokenRole ("property");
 
 	}
 }
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/SimpleType.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/SimpleType.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/SimpleType.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/SimpleType.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,11 +28,11 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 using System.Text;
-using ICSharpCode.NRefactory.CSharp.Resolver;
-using ICSharpCode.NRefactory.CSharp.TypeSystem;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
+using ICSharpCode.NRefactory.PlayScript.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public class SimpleType : AstType
 	{
@@ -89,7 +89,7 @@ namespace ICSharpCode.NRefactory.CSharp
 		
 		public SimpleType(string identifier, TextLocation location)
 		{
-			SetChildByRole (Roles.Identifier, CSharp.Identifier.Create (identifier, location));
+			SetChildByRole (Roles.Identifier, PlayScript.Identifier.Create (identifier, location));
 		}
 		
 		public SimpleType (string identifier, IEnumerable<AstType> typeArguments)
@@ -109,7 +109,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return GetChildByRole (Roles.Identifier).Name;
 			}
 			set {
-				SetChildByRole (Roles.Identifier, CSharp.Identifier.Create (value));
+				SetChildByRole (Roles.Identifier, PlayScript.Identifier.Create (value));
 			}
 		}
 		
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/BlockStatement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/BlockStatement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/BlockStatement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/BlockStatement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// { Statements }
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/BreakStatement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/BreakStatement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/BreakStatement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/BreakStatement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// break;
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/CheckedStatement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/CheckedStatement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/CheckedStatement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/CheckedStatement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// checked BodyBlock
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/ContinueStatement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/ContinueStatement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/ContinueStatement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/ContinueStatement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// continue;
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/DoWhileStatement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/DoWhileStatement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/DoWhileStatement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/DoWhileStatement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// "do EmbeddedStatement while(Condition);"
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/EmptyStatement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/EmptyStatement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/EmptyStatement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/EmptyStatement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// ;
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/ExpressionStatement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/ExpressionStatement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/ExpressionStatement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/ExpressionStatement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Expression;
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/FixedStatement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/FixedStatement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/FixedStatement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/FixedStatement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// fixed (Type Variables) EmbeddedStatement
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/ForStatement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/ForStatement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/ForStatement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/ForStatement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// for (Initializers; Condition; Iterators) EmbeddedStatement
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/ForeachStatement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/ForeachStatement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/ForeachStatement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/ForeachStatement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// foreach (Type VariableName in InExpression) EmbeddedStatement
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/GotoStatement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/GotoStatement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/GotoStatement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/GotoStatement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// "goto Label;"
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/IfElseStatement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/IfElseStatement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/IfElseStatement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/IfElseStatement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// if (Condition) TrueStatement else FalseStatement
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/LabelStatement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/LabelStatement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/LabelStatement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/LabelStatement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Label:
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/LockStatement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/LockStatement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/LockStatement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/LockStatement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// lock (Expression) EmbeddedStatement;
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/ReturnStatement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/ReturnStatement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/ReturnStatement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/ReturnStatement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// return Expression;
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/Statement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/Statement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/Statement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/Statement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -3,7 +3,7 @@
 
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Base class for statements.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/SwitchStatement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/SwitchStatement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/SwitchStatement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/SwitchStatement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@
 using System.Collections.Generic;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// switch (Expression) { SwitchSections }
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/ThrowStatement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/ThrowStatement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/ThrowStatement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/ThrowStatement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// throw Expression;
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/TryCatchStatement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/TryCatchStatement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/TryCatchStatement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/TryCatchStatement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@
 using System.Collections.Generic;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// try TryBlock CatchClauses finally FinallyBlock
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/UncheckedStatement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/UncheckedStatement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/UncheckedStatement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/UncheckedStatement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// unchecked BodyBlock
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/UnsafeStatement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/UnsafeStatement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/UnsafeStatement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/UnsafeStatement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// unsafe { Body }
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/UsingStatement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/UsingStatement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/UsingStatement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/UsingStatement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// using (ResourceAcquisition) EmbeddedStatement
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/VariableDeclarationStatement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/VariableDeclarationStatement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/VariableDeclarationStatement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/VariableDeclarationStatement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@
 using System.Collections.Generic;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public class VariableDeclarationStatement : Statement
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/WhileStatement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/WhileStatement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/WhileStatement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/WhileStatement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// "while (Condition) EmbeddedStatement"
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/YieldBreakStatement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/YieldBreakStatement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/YieldBreakStatement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/YieldBreakStatement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// yield break;
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/YieldReturnStatement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/YieldReturnStatement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/Statements/YieldReturnStatement.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/Statements/YieldReturnStatement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// yield return Expression;
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/SyntaxExtensions.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/SyntaxExtensions.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/SyntaxExtensions.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/SyntaxExtensions.cs	2013-04-23 21:04:54.000000000 -0700
@@ -20,7 +20,7 @@
 
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Extension methods for the syntax tree.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/SyntaxTree.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/SyntaxTree.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/SyntaxTree.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/SyntaxTree.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,15 +26,15 @@
 
 using System;
 using System.Collections.Generic;
-using ICSharpCode.NRefactory.CSharp.Resolver;
-using ICSharpCode.NRefactory.CSharp.TypeSystem;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
+using ICSharpCode.NRefactory.PlayScript.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem;
 using System.Threading;
-using Mono.CSharp;
+using Mono.CSharpPs;
 using System.IO;
 using ICSharpCode.NRefactory.Editor;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	[Obsolete("CompilationUnit was renamed to SyntaxTree", true)]
 	public class CompilationUnit {}
@@ -164,25 +164,25 @@ namespace ICSharpCode.NRefactory.CSharp
 		
 		public static SyntaxTree Parse (string program, string fileName = "", CompilerSettings settings = null, CancellationToken cancellationToken = default (CancellationToken))
 		{
-			var parser = new CSharpParser (settings);
+			var parser = new PlayScriptParser (settings);
 			return parser.Parse (program, fileName);
 		}
 		
 		public static SyntaxTree Parse (TextReader reader, string fileName = "", CompilerSettings settings = null, CancellationToken cancellationToken = default (CancellationToken))
 		{
-			var parser = new CSharpParser (settings);
+			var parser = new PlayScriptParser (settings);
 			return parser.Parse (reader, fileName);
 		}
 		
 		public static SyntaxTree Parse (Stream stream, string fileName = "", CompilerSettings settings = null, CancellationToken cancellationToken = default (CancellationToken))
 		{
-			var parser = new CSharpParser (settings);
+			var parser = new PlayScriptParser (settings);
 			return parser.Parse (stream, fileName);
 		}
 		
 		public static SyntaxTree Parse (ITextSource textSource, string fileName = "", CompilerSettings settings = null, CancellationToken cancellationToken = default (CancellationToken))
 		{
-			var parser = new CSharpParser (settings);
+			var parser = new PlayScriptParser (settings);
 			return parser.Parse (textSource, fileName);
 		}
 	}
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TokenRole.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TokenRole.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TokenRole.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TokenRole.cs	2013-04-23 21:04:54.000000000 -0700
@@ -1,7 +1,7 @@
 using System;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// A specific role only used for C# tokens
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/Accessor.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/Accessor.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/Accessor.cs	2013-03-14 23:31:36.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/Accessor.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@
 using System;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// get/set/add/remove
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/ConstructorDeclaration.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/ConstructorDeclaration.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/ConstructorDeclaration.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/ConstructorDeclaration.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public class ConstructorDeclaration : EntityDeclaration
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/DestructorDeclaration.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/DestructorDeclaration.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/DestructorDeclaration.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/DestructorDeclaration.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public class DestructorDeclaration : EntityDeclaration
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/EntityDeclaration.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/EntityDeclaration.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/EntityDeclaration.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/EntityDeclaration.cs	2013-04-23 21:04:54.000000000 -0700
@@ -20,7 +20,7 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public abstract class EntityDeclaration : AstNode
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/EnumMemberDeclaration.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/EnumMemberDeclaration.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/EnumMemberDeclaration.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/EnumMemberDeclaration.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@
 using System;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public class EnumMemberDeclaration : EntityDeclaration
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/EventDeclaration.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/EventDeclaration.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/EventDeclaration.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/EventDeclaration.cs	2013-04-23 21:04:54.000000000 -0700
@@ -30,7 +30,7 @@ using System.ComponentModel;
 
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public class EventDeclaration : EntityDeclaration
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/FieldDeclaration.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/FieldDeclaration.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/FieldDeclaration.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/FieldDeclaration.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System;
 using System.ComponentModel;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public class FieldDeclaration : EntityDeclaration
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/FixedFieldDeclaration.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/FixedFieldDeclaration.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/FixedFieldDeclaration.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/FixedFieldDeclaration.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 using System;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public class FixedFieldDeclaration : EntityDeclaration
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/FixedVariableInitializer.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/FixedVariableInitializer.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/FixedVariableInitializer.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/FixedVariableInitializer.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Name [ CountExpression ]
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/IndexerDeclaration.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/IndexerDeclaration.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/IndexerDeclaration.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/IndexerDeclaration.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System;
 using System.ComponentModel;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public class IndexerDeclaration : EntityDeclaration
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/MethodDeclaration.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/MethodDeclaration.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/MethodDeclaration.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/MethodDeclaration.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public class MethodDeclaration : EntityDeclaration
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/OperatorDeclaration.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/OperatorDeclaration.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/OperatorDeclaration.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/OperatorDeclaration.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,47 +28,47 @@ using System;
 using System.ComponentModel;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public enum OperatorType
 	{
-		// Values must correspond to Mono.CSharp.Operator.OpType
+		// Values must correspond to Mono.CSharpPs.Operator.OpType
 		// due to the casts used in OperatorDeclaration.
 		
 		// Unary operators
-		LogicalNot = Mono.CSharp.Operator.OpType.LogicalNot,
-		OnesComplement = Mono.CSharp.Operator.OpType.OnesComplement,
-		Increment = Mono.CSharp.Operator.OpType.Increment,
-		Decrement = Mono.CSharp.Operator.OpType.Decrement,
-		True = Mono.CSharp.Operator.OpType.True,
-		False = Mono.CSharp.Operator.OpType.False,
+		LogicalNot = Mono.CSharpPs.Operator.OpType.LogicalNot,
+		OnesComplement = Mono.CSharpPs.Operator.OpType.OnesComplement,
+		Increment = Mono.CSharpPs.Operator.OpType.Increment,
+		Decrement = Mono.CSharpPs.Operator.OpType.Decrement,
+		True = Mono.CSharpPs.Operator.OpType.True,
+		False = Mono.CSharpPs.Operator.OpType.False,
 
 		// Unary and Binary operators
-		Addition = Mono.CSharp.Operator.OpType.Addition,
-		Subtraction = Mono.CSharp.Operator.OpType.Subtraction,
+		Addition = Mono.CSharpPs.Operator.OpType.Addition,
+		Subtraction = Mono.CSharpPs.Operator.OpType.Subtraction,
 
-		UnaryPlus = Mono.CSharp.Operator.OpType.UnaryPlus,
-		UnaryNegation = Mono.CSharp.Operator.OpType.UnaryNegation,
+		UnaryPlus = Mono.CSharpPs.Operator.OpType.UnaryPlus,
+		UnaryNegation = Mono.CSharpPs.Operator.OpType.UnaryNegation,
 		
 		// Binary operators
-		Multiply = Mono.CSharp.Operator.OpType.Multiply,
-		Division = Mono.CSharp.Operator.OpType.Division,
-		Modulus = Mono.CSharp.Operator.OpType.Modulus,
-		BitwiseAnd = Mono.CSharp.Operator.OpType.BitwiseAnd,
-		BitwiseOr = Mono.CSharp.Operator.OpType.BitwiseOr,
-		ExclusiveOr = Mono.CSharp.Operator.OpType.ExclusiveOr,
-		LeftShift = Mono.CSharp.Operator.OpType.LeftShift,
-		RightShift = Mono.CSharp.Operator.OpType.RightShift,
-		Equality = Mono.CSharp.Operator.OpType.Equality,
-		Inequality = Mono.CSharp.Operator.OpType.Inequality,
-		GreaterThan = Mono.CSharp.Operator.OpType.GreaterThan,
-		LessThan = Mono.CSharp.Operator.OpType.LessThan,
-		GreaterThanOrEqual = Mono.CSharp.Operator.OpType.GreaterThanOrEqual,
-		LessThanOrEqual = Mono.CSharp.Operator.OpType.LessThanOrEqual,
+		Multiply = Mono.CSharpPs.Operator.OpType.Multiply,
+		Division = Mono.CSharpPs.Operator.OpType.Division,
+		Modulus = Mono.CSharpPs.Operator.OpType.Modulus,
+		BitwiseAnd = Mono.CSharpPs.Operator.OpType.BitwiseAnd,
+		BitwiseOr = Mono.CSharpPs.Operator.OpType.BitwiseOr,
+		ExclusiveOr = Mono.CSharpPs.Operator.OpType.ExclusiveOr,
+		LeftShift = Mono.CSharpPs.Operator.OpType.LeftShift,
+		RightShift = Mono.CSharpPs.Operator.OpType.RightShift,
+		Equality = Mono.CSharpPs.Operator.OpType.Equality,
+		Inequality = Mono.CSharpPs.Operator.OpType.Inequality,
+		GreaterThan = Mono.CSharpPs.Operator.OpType.GreaterThan,
+		LessThan = Mono.CSharpPs.Operator.OpType.LessThan,
+		GreaterThanOrEqual = Mono.CSharpPs.Operator.OpType.GreaterThanOrEqual,
+		LessThanOrEqual = Mono.CSharpPs.Operator.OpType.LessThanOrEqual,
 
 		// Implicit and Explicit
-		Implicit = Mono.CSharp.Operator.OpType.Implicit,
-		Explicit = Mono.CSharp.Operator.OpType.Explicit
+		Implicit = Mono.CSharpPs.Operator.OpType.Implicit,
+		Explicit = Mono.CSharpPs.Operator.OpType.Explicit
 	}
 	
 	public class OperatorDeclaration : EntityDeclaration
@@ -150,7 +150,7 @@ namespace ICSharpCode.NRefactory.CSharp
 		/// </summary>
 		public static OperatorType? GetOperatorType(string methodName)
 		{
-			return (OperatorType?)Mono.CSharp.Operator.GetType(methodName);
+			return (OperatorType?)Mono.CSharpPs.Operator.GetType(methodName);
 		}
 		
 		public static TokenRole GetRole (OperatorType type)
@@ -220,7 +220,7 @@ namespace ICSharpCode.NRefactory.CSharp
 		/// </summary>
 		public static string GetName (OperatorType type)
 		{
-			return Mono.CSharp.Operator.GetMetadataName ((Mono.CSharp.Operator.OpType)type);
+			return Mono.CSharpPs.Operator.GetMetadataName ((Mono.CSharpPs.Operator.OpType)type);
 		}
 		
 		/// <summary>
@@ -228,7 +228,7 @@ namespace ICSharpCode.NRefactory.CSharp
 		/// </summary>
 		public static string GetToken (OperatorType type)
 		{
-			return Mono.CSharp.Operator.GetName ((Mono.CSharp.Operator.OpType)type);
+			return Mono.CSharpPs.Operator.GetName ((Mono.CSharpPs.Operator.OpType)type);
 		}
 		
 		public override void AcceptVisitor (IAstVisitor visitor)
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/ParameterDeclaration.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/ParameterDeclaration.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/ParameterDeclaration.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/ParameterDeclaration.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public enum ParameterModifier {
 		None,
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/PropertyDeclaration.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/PropertyDeclaration.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/PropertyDeclaration.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/PropertyDeclaration.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,7 +25,7 @@
 // THE SOFTWARE.
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public class PropertyDeclaration : EntityDeclaration
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/VariableInitializer.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/VariableInitializer.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/TypeMembers/VariableInitializer.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/TypeMembers/VariableInitializer.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public class VariableInitializer : AstNode
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/old_ObservableAstVisitor.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/old_ObservableAstVisitor.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Ast/old_ObservableAstVisitor.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Ast/old_ObservableAstVisitor.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,7 +25,7 @@
 // THE SOFTWARE.
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	[Obsolete("Use the non-generic version of the ObservableAstVisitor instead (the 'data' parameter and return value cannot be used meaningfully when using events)")]
 	public class ObservableAstVisitor<T, S>: IAstVisitor<T, S>
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/CSharpProjectContent.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/CSharpProjectContent.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/CSharpProjectContent.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/CSharpProjectContent.cs	2013-04-23 21:04:54.000000000 -0700
@@ -20,12 +20,12 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 using System.Runtime.Serialization;
-using ICSharpCode.NRefactory.CSharp.TypeSystem;
+using ICSharpCode.NRefactory.PlayScript.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 using ICSharpCode.NRefactory.Utils;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	[Serializable]
 	public class CSharpProjectContent : IProjectContent
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Completion/CSharpCompletionEngine.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Completion/CSharpCompletionEngine.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Completion/CSharpCompletionEngine.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Completion/CSharpCompletionEngine.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,14 +29,14 @@ using System.Linq;
 using System.Text;
 
 using ICSharpCode.NRefactory.Completion;
-using ICSharpCode.NRefactory.CSharp.Refactoring;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Refactoring;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Editor;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
-using ICSharpCode.NRefactory.CSharp.TypeSystem;
+using ICSharpCode.NRefactory.PlayScript.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Completion
+namespace ICSharpCode.NRefactory.PlayScript.Completion
 {
 	public class CSharpCompletionEngine : CSharpCompletionEngineBase
 	{
@@ -347,6 +347,14 @@ namespace ICSharpCode.NRefactory.CSharp.
 			switch (completionChar) {
 				// Magic key completion
 				case ':':
+					var wrapper1 = new CompletionDataWrapper(this);
+					AddTypesAndNamespaces(
+						wrapper1,
+						GetState(),
+						null,
+						t => currentType != null && !currentType.ReflectionName.Equals(t.ReflectionName) ? t : null
+						);
+					return wrapper1.Result;
 				case '.':
 					if (IsInsideCommentStringOrDirective()) {
 						return Enumerable.Empty<ICompletionData>();
@@ -597,21 +605,20 @@ namespace ICSharpCode.NRefactory.CSharp.
 							}
 							return null;
 						case ":":
-							if (currentMember == null) {
+//							if (currentMember == null) {
 								token = GetPreviousToken(ref tokenIndex, false);
 								token = GetPreviousToken(ref tokenIndex, false);
 								if (token == "enum")
 									return HandleEnumContext();
-								var wrapper = new CompletionDataWrapper(this);
-								
+								var wrapper2 = new CompletionDataWrapper(this);
 								AddTypesAndNamespaces(
-									wrapper,
+									wrapper2,
 									GetState(),
 									null,
 									t => currentType != null && !currentType.ReflectionName.Equals(t.ReflectionName) ? t : null
 									);
-								return wrapper.Result;
-							}
+								return wrapper2.Result;
+//							}
 							return null;
 					}
 					
@@ -702,7 +709,7 @@ namespace ICSharpCode.NRefactory.CSharp.
 					// Do not pop up completion on identifier identifier (should be handled by keyword completion).
 					tokenIndex = offset - 1;
 					token = GetPreviousToken(ref tokenIndex, false);
-					if (token == "class" || token == "interface" || token == "struct" || token == "enum" || token == "namespace") {
+					if (token == "class" || token == "interface" || token == "struct" || token == "enum" || token == "package" || token == "var" || token == "const") {
 						// after these always follows a name
 						return null;
 					}
@@ -723,7 +730,7 @@ namespace ICSharpCode.NRefactory.CSharp.
 					
 					int prevTokenIndex = tokenIndex;
 					var prevToken2 = GetPreviousToken(ref prevTokenIndex, false);
-					if (prevToken2 == "delegate") {
+					if (prevToken2 == "function") {
 						// after these always follows a name
 						return null;
 					}
@@ -913,7 +920,7 @@ namespace ICSharpCode.NRefactory.CSharp.
 						csResolver = new CSharpResolver(ctx);
 						var nodes = new List<AstNode>();
 						nodes.Add(n);
-						if (n.Parent is ICSharpCode.NRefactory.CSharp.Attribute) {
+						if (n.Parent is ICSharpCode.NRefactory.PlayScript.Attribute) {
 							nodes.Add(n.Parent);
 						}
 						var astResolver = CompletionContextProvider.GetResolver(csResolver, identifierStart.Unit);
@@ -924,7 +931,7 @@ namespace ICSharpCode.NRefactory.CSharp.
 							csResolver = GetState();
 						}
 						// add attribute properties.
-						if (n.Parent is ICSharpCode.NRefactory.CSharp.Attribute) {
+						if (n.Parent is ICSharpCode.NRefactory.PlayScript.Attribute) {
 							var rr = ResolveExpression(n.Parent);
 							if (rr != null)
 								AddAttributeProperties(contextList, rr.Item1);
@@ -1566,9 +1573,9 @@ namespace ICSharpCode.NRefactory.CSharp.
 				return null;
 			}
 			switch (word) {
-				case "namespace":
+				case "package":
 					return null;
-				case "using":
+				case "import":
 					if (currentType != null) {
 						return null;
 					}
@@ -1773,11 +1780,11 @@ namespace ICSharpCode.NRefactory.CSharp.
 						return accessorContext;
 					}
 					wrapper = new CompletionDataWrapper(this);
-					state = GetState();
-					if (currentType != null) {
-						AddTypesAndNamespaces(wrapper, state, null, null, m => false);
-						AddKeywords(wrapper, primitiveTypesKeywords);
-					}
+//					state = GetState();
+//					if (currentType != null) {
+//						AddTypesAndNamespaces(wrapper, state, null, null, m => false);
+//						AddKeywords(wrapper, primitiveTypesKeywords);
+//					}
 					AddKeywords(wrapper, typeLevelKeywords);
 					return wrapper.Result;
 				case "new":
@@ -2887,7 +2894,7 @@ namespace ICSharpCode.NRefactory.CSharp.
 		
 		ExpressionResult GetExpressionAt(int offset)
 		{
-			var parser = new CSharpParser();
+			var parser = new PlayScriptParser();
 			string text = this.document.GetText(0, this.offset); 
 			var sb = new StringBuilder(text);
 			sb.Append("a;");
@@ -2907,7 +2914,7 @@ namespace ICSharpCode.NRefactory.CSharp.
 		
 		ExpressionResult GetNewExpressionAt(int offset)
 		{
-			var parser = new CSharpParser();
+			var parser = new PlayScriptParser();
 			string text = this.document.GetText(0, this.offset); 
 			var sb = new StringBuilder(text);
 			sb.Append("a ();");
@@ -3184,7 +3191,8 @@ namespace ICSharpCode.NRefactory.CSharp.
 			"out",
 			"ref",
 			"null",
-			"delegate",
+			"undefined",
+			"function",
 			"default"
 		};
 		static string[] primitiveTypesKeywords = new string [] {
@@ -3203,7 +3211,10 @@ namespace ICSharpCode.NRefactory.CSharp.
 			"float",
 			"double",
 			"decimal",
-			"string"
+			"string",
+			"String",
+			"Number",
+			"Boolean"
 		};
 		static string[] statementStartKeywords = new string [] { "base", "new", "sizeof", "this", 
 			"true", "false", "typeof", "checked", "unchecked", "from", "break", "checked",
@@ -3213,7 +3224,7 @@ namespace ICSharpCode.NRefactory.CSharp.
 			"catch", "await"
 		};
 		static string[] globalLevelKeywords = new string [] {
-			"namespace", "using", "extern", "public", "internal", 
+			"package", "import", "use", "extern", "public", "internal", 
 			"class", "interface", "struct", "enum", "delegate",
 			"abstract", "sealed", "static", "unsafe", "partial"
 		};
@@ -3224,9 +3235,10 @@ namespace ICSharpCode.NRefactory.CSharp.
 			"public", "internal", "protected", "private", "async",
 			"class", "interface", "struct", "enum", "delegate",
 			"abstract", "sealed", "static", "unsafe", "partial",
-			"const", "event", "extern", "fixed","new", 
+			"const", "var", "event", "extern", "fixed","new", 
 			"operator", "explicit", "implicit", 
-			"override", "readonly", "virtual", "volatile"
+			"override", "readonly", "virtual", "volatile",
+			"function", "indexer", "operator"
 		};
 		static string[] linqKeywords = new string[] {
 			"from",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Completion/CSharpCompletionEngineBase.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Completion/CSharpCompletionEngineBase.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Completion/CSharpCompletionEngineBase.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Completion/CSharpCompletionEngineBase.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,14 +28,14 @@ using System.Collections.Generic;
 using System.Linq;
 using System.Text;
 
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Editor;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
-using ICSharpCode.NRefactory.CSharp.TypeSystem;
+using ICSharpCode.NRefactory.PlayScript.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Completion
+namespace ICSharpCode.NRefactory.PlayScript.Completion
 {
 	/// <summary>
 	/// Acts as a common base between code completion and parameter completion.
@@ -689,14 +689,14 @@ namespace ICSharpCode.NRefactory.CSharp.
 
 			string memberText = mt.Item1;
 			var memberLocation = mt.Item2;
-			int closingBrackets = 1;
+			int closingBrackets = 0;
 			int generatedLines = 0;
 			var wrapper = new StringBuilder();
 			bool wrapInClass = memberLocation != new TextLocation(1, 1);
 			if (wrapInClass) {
-				wrapper.Append("class Stub {");
+				wrapper.Append("package { class Stub {");
 				wrapper.AppendLine();
-				closingBrackets++;
+				closingBrackets += 2;
 				generatedLines++;
 			}
 			wrapper.Append(memberText);
@@ -706,7 +706,7 @@ namespace ICSharpCode.NRefactory.CSharp.
 			if (closingBrackets > 0) { 
 				wrapper.Append(new string('}', closingBrackets));
 			}
-			var parser = new CSharpParser ();
+			var parser = new PlayScriptParser ();
 			foreach (var sym in CompletionContextProvider.ConditionalSymbols)
 				parser.CompilerSettings.ConditionalSymbols.Add (sym);
 			parser.InitialLocation = new TextLocation(memberLocation.Line - generatedLines, 1);
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Completion/CSharpParameterCompletionEngine.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Completion/CSharpParameterCompletionEngine.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Completion/CSharpParameterCompletionEngine.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Completion/CSharpParameterCompletionEngine.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,11 +29,11 @@ using ICSharpCode.NRefactory.Completion;
 using System.Collections.Generic;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
-using ICSharpCode.NRefactory.CSharp.Resolver;
-using ICSharpCode.NRefactory.CSharp.TypeSystem;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
+using ICSharpCode.NRefactory.PlayScript.TypeSystem;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Completion
+namespace ICSharpCode.NRefactory.PlayScript.Completion
 {
 	public class CSharpParameterCompletionEngine : CSharpCompletionEngineBase
 	{
@@ -204,7 +204,7 @@ namespace ICSharpCode.NRefactory.CSharp.
 						return factory.CreateConstructorProvider(document.GetOffset(invoke.Node.StartLocation), createType.Item1.Type);
 					}
 					
-					if (invoke.Node is ICSharpCode.NRefactory.CSharp.Attribute) {
+					if (invoke.Node is ICSharpCode.NRefactory.PlayScript.Attribute) {
 						var attribute = ResolveExpression(invoke);
 						if (attribute == null || attribute.Item1 == null) {
 							return null;
@@ -267,7 +267,7 @@ namespace ICSharpCode.NRefactory.CSharp.
 						return factory.CreateConstructorProvider(document.GetOffset(invoke.Node.StartLocation), createType.Item1.Type);
 					}
 					
-					if (invoke.Node is ICSharpCode.NRefactory.CSharp.Attribute) {
+					if (invoke.Node is ICSharpCode.NRefactory.PlayScript.Attribute) {
 						var attribute = ResolveExpression(invoke);
 						if (attribute == null || attribute.Item1 == null) {
 							return null;
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Completion/CompletionDataWrapper.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Completion/CompletionDataWrapper.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Completion/CompletionDataWrapper.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Completion/CompletionDataWrapper.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,9 +28,9 @@ using System.Collections.Generic;
 using ICSharpCode.NRefactory.Completion;
 using ICSharpCode.NRefactory.TypeSystem;
 using System.Linq;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 
-namespace ICSharpCode.NRefactory.CSharp.Completion
+namespace ICSharpCode.NRefactory.PlayScript.Completion
 {
 	class CompletionDataWrapper
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Completion/ICompletionContextProvider.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Completion/ICompletionContextProvider.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Completion/ICompletionContextProvider.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Completion/ICompletionContextProvider.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,11 +27,11 @@ using System;
 using System.Collections.Generic;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.Editor;
-using ICSharpCode.NRefactory.CSharp.TypeSystem;
+using ICSharpCode.NRefactory.PlayScript.TypeSystem;
 using System.Linq;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 
-namespace ICSharpCode.NRefactory.CSharp.Completion
+namespace ICSharpCode.NRefactory.PlayScript.Completion
 {
 	public interface ICompletionContextProvider
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Completion/ICompletionDataFactory.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Completion/ICompletionDataFactory.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Completion/ICompletionDataFactory.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Completion/ICompletionDataFactory.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System.Collections.Generic;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.Completion;
 
-namespace ICSharpCode.NRefactory.CSharp.Completion
+namespace ICSharpCode.NRefactory.PlayScript.Completion
 {
 	public interface ICompletionDataFactory
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Completion/IParameterCompletionDataFactory.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Completion/IParameterCompletionDataFactory.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Completion/IParameterCompletionDataFactory.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Completion/IParameterCompletionDataFactory.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,10 +26,10 @@
 using System;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.Completion;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Completion
+namespace ICSharpCode.NRefactory.PlayScript.Completion
 {
 	public interface IParameterCompletionDataFactory
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Formatter/AstFormattingVisitor.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Formatter/AstFormattingVisitor.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Formatter/AstFormattingVisitor.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Formatter/AstFormattingVisitor.cs	2013-04-23 21:04:54.000000000 -0700
@@ -30,9 +30,9 @@ using System.Collections.Generic;
 using System.Linq;
 using ICSharpCode.NRefactory.Editor;
 using ICSharpCode.NRefactory.TypeSystem;
-using ICSharpCode.NRefactory.CSharp.Refactoring;
+using ICSharpCode.NRefactory.PlayScript.Refactoring;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public enum FormattingMode {
 		OnTheFly,
@@ -920,7 +920,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				rParToken = methodDeclaration.RParToken;
 				parameters = methodDeclaration.Parameters;
 			}
-			if (FormattingMode == ICSharpCode.NRefactory.CSharp.FormattingMode.OnTheFly)
+			if (FormattingMode == ICSharpCode.NRefactory.PlayScript.FormattingMode.OnTheFly)
 				methodCallArgumentWrapping = Wrapping.DoNotChange;
 			
 			bool wrapMethodCall = DoWrap(methodCallArgumentWrapping, rParToken, parameters.Count);
@@ -1851,7 +1851,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				arguments = invocationExpression.Arguments;
 			}
 			
-			if (FormattingMode == ICSharpCode.NRefactory.CSharp.FormattingMode.OnTheFly)
+			if (FormattingMode == ICSharpCode.NRefactory.PlayScript.FormattingMode.OnTheFly)
 				methodCallArgumentWrapping = Wrapping.DoNotChange;
 			
 			bool wrapMethodCall = DoWrap(methodCallArgumentWrapping, rParToken, arguments.Count);
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Formatter/CSharpFormattingOptions.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Formatter/CSharpFormattingOptions.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Formatter/CSharpFormattingOptions.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Formatter/CSharpFormattingOptions.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System;
 using System.Reflection;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public enum BraceStyle
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Formatter/CSharpIndentEngine.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Formatter/CSharpIndentEngine.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Formatter/CSharpIndentEngine.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Formatter/CSharpIndentEngine.cs	2013-04-23 21:04:54.000000000 -0700
@@ -31,7 +31,7 @@ using System.Collections.Generic;
 using System.Linq;
 using System.Globalization;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public class CSharpIndentEngine
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Formatter/FormattingOptionsFactory.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Formatter/FormattingOptionsFactory.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Formatter/FormattingOptionsFactory.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Formatter/FormattingOptionsFactory.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,7 +25,7 @@
 // THE SOFTWARE.
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// The formatting options factory creates pre defined formatting option styles.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Formatter/GeneratedCodeSettings.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Formatter/GeneratedCodeSettings.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Formatter/GeneratedCodeSettings.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Formatter/GeneratedCodeSettings.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@
 using System;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public enum GeneratedCodeMember
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Formatter/Indent.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Formatter/Indent.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Formatter/Indent.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Formatter/Indent.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 using System;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public enum IndentType {
 		Block,
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Formatter/TextEditorOptions.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Formatter/TextEditorOptions.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Formatter/TextEditorOptions.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Formatter/TextEditorOptions.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// The text editor options class holds basic information about the text editor settings that influences code generation and formatting beside
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/ICSharpCode.NRefactory.CSharp.csproj ./main/src/addins/ICSharpCode.NRefactory.PlayScript/ICSharpCode.NRefactory.CSharp.csproj
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/ICSharpCode.NRefactory.CSharp.csproj	2013-04-23 01:10:29.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/ICSharpCode.NRefactory.CSharp.csproj	2013-04-23 21:04:54.000000000 -0700
@@ -1,551 +1,555 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" DefaultTargets="Build">
-  <PropertyGroup>
-    <ProjectGuid>{53DCA265-3C3C-42F9-B647-F72BA678122B}</ProjectGuid>
-    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
-    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <OutputType>Library</OutputType>
-    <RootNamespace>ICSharpCode.NRefactory.CSharp</RootNamespace>
-    <AssemblyName>ICSharpCode.NRefactory.CSharp</AssemblyName>
-    <AppDesignerFolder>Properties</AppDesignerFolder>
-    <AllowUnsafeBlocks>False</AllowUnsafeBlocks>
-    <NoStdLib>False</NoStdLib>
-    <WarningLevel>4</WarningLevel>
-    <TreatWarningsAsErrors>false</TreatWarningsAsErrors>
-    <ProductVersion>10.0.0</ProductVersion>
-    <SchemaVersion>2.0</SchemaVersion>
-    <SignAssembly>True</SignAssembly>
-    <AssemblyOriginatorKeyFile>..\ICSharpCode.NRefactory.snk</AssemblyOriginatorKeyFile>
-    <DelaySign>False</DelaySign>
-    <AssemblyOriginatorKeyMode>File</AssemblyOriginatorKeyMode>
-    <DocumentationFile>..\bin\$(Configuration)\ICSharpCode.NRefactory.CSharp.xml</DocumentationFile>
-    <NoWarn>1591,1587,1570</NoWarn>
-    <OutputPath>..\bin\$(Configuration)\</OutputPath>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Platform)' == 'AnyCPU' ">
-    <PlatformTarget>AnyCPU</PlatformTarget>
-    <RegisterForComInterop>False</RegisterForComInterop>
-    <GenerateSerializationAssemblies>Auto</GenerateSerializationAssemblies>
-    <BaseAddress>4194304</BaseAddress>
-    <FileAlignment>4096</FileAlignment>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
-    <Optimize>False</Optimize>
-    <CheckForOverflowUnderflow>False</CheckForOverflowUnderflow>
-    <DefineConstants>DEBUG;TRACE;FULL_AST;NET_4_0</DefineConstants>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
-    <Optimize>True</Optimize>
-    <CheckForOverflowUnderflow>False</CheckForOverflowUnderflow>
-    <DefineConstants>TRACE;FULL_AST;NET_4_0</DefineConstants>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
-    <DebugType>none</DebugType>
-    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
-    <DebugType>full</DebugType>
-    <DebugSymbols>True</DebugSymbols>
-    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)' == 'net_4_5_Debug' ">
-    <Optimize>False</Optimize>
-    <CheckForOverflowUnderflow>False</CheckForOverflowUnderflow>
-    <DefineConstants>DEBUG;TRACE;FULL_AST;NET_4_0;NET_4_5</DefineConstants>
-    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'net_4_5_Debug|AnyCPU' ">
-    <DebugType>full</DebugType>
-    <DebugSymbols>True</DebugSymbols>
-    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
-    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)' == 'net_4_5_Release' ">
-    <Optimize>True</Optimize>
-    <CheckForOverflowUnderflow>False</CheckForOverflowUnderflow>
-    <DefineConstants>TRACE;FULL_AST;NET_4_0;NET_4_5</DefineConstants>
-    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'net_4_5_Release|AnyCPU' ">
-    <DebugType>none</DebugType>
-    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
-    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
-  </PropertyGroup>
-  <ItemGroup>
-    <Reference Include="System" />
-    <Reference Include="System.Core">
-      <RequiredTargetFramework>3.5</RequiredTargetFramework>
-    </Reference>
-    <Reference Include="System.Xml" />
-    <Reference Include="System.Xml.Linq">
-      <RequiredTargetFramework>3.5</RequiredTargetFramework>
-    </Reference>
-  </ItemGroup>
-  <ItemGroup>
-    <Compile Include="..\ICSharpCode.NRefactory\Properties\GlobalAssemblyInfo.cs">
-      <Link>Properties\GlobalAssemblyInfo.cs</Link>
-    </Compile>
-    <Compile Include="Analysis\ControlFlow.cs" />
-    <Compile Include="Analysis\DefiniteAssignmentAnalysis.cs" />
-    <Compile Include="Analysis\ReachabilityAnalysis.cs" />
-    <Compile Include="Analysis\SemanticHighlightingVisitor.cs" />
-    <Compile Include="Ast\AstNode.cs" />
-    <Compile Include="Ast\AstNodeCollection.cs" />
-    <Compile Include="Ast\AstType.cs" />
-    <Compile Include="Ast\DocumentationReference.cs" />
-    <Compile Include="Ast\IdentifierExpressionBackreference.cs" />
-    <Compile Include="Ast\SyntaxExtensions.cs" />
-    <Compile Include="Ast\SyntaxTree.cs" />
-    <Compile Include="Ast\ComposedType.cs" />
-    <Compile Include="Ast\CSharpModifierToken.cs" />
-    <Compile Include="Ast\CSharpTokenNode.cs" />
-    <Compile Include="Ast\CSharpUtil.cs" />
-    <Compile Include="Ast\DepthFirstAstVisitor.cs" />
-    <Compile Include="Ast\ErrorNode.cs" />
-    <Compile Include="Ast\Expressions\AnonymousMethodExpression.cs" />
-    <Compile Include="Ast\Expressions\AnonymousTypeCreateExpression.cs" />
-    <Compile Include="Ast\Expressions\ArrayCreateExpression.cs" />
-    <Compile Include="Ast\Expressions\ArrayInitializerExpression.cs" />
-    <Compile Include="Ast\Expressions\AsExpression.cs" />
-    <Compile Include="Ast\Expressions\AssignmentExpression.cs" />
-    <Compile Include="Ast\Expressions\BaseReferenceExpression.cs" />
-    <Compile Include="Ast\Expressions\BinaryOperatorExpression.cs" />
-    <Compile Include="Ast\Expressions\CastExpression.cs" />
-    <Compile Include="Ast\Expressions\CheckedExpression.cs" />
-    <Compile Include="Ast\Expressions\ConditionalExpression.cs" />
-    <Compile Include="Ast\Expressions\DefaultValueExpression.cs" />
-    <Compile Include="Ast\Expressions\DirectionExpression.cs" />
-    <Compile Include="Ast\Expressions\EmptyExpression.cs" />
-    <Compile Include="Ast\Expressions\Expression.cs" />
-    <Compile Include="Ast\Expressions\IdentifierExpression.cs" />
-    <Compile Include="Ast\Expressions\IndexerExpression.cs" />
-    <Compile Include="Ast\Expressions\InvocationExpression.cs" />
-    <Compile Include="Ast\Expressions\IsExpression.cs" />
-    <Compile Include="Ast\Expressions\LambdaExpression.cs" />
-    <Compile Include="Ast\Expressions\MemberReferenceExpression.cs" />
-    <Compile Include="Ast\Expressions\NamedArgumentExpression.cs" />
-    <Compile Include="Ast\Expressions\NamedExpression.cs" />
-    <Compile Include="Ast\Expressions\NullReferenceExpression.cs" />
-    <Compile Include="Ast\Expressions\ObjectCreateExpression.cs" />
-    <Compile Include="Ast\Expressions\ParenthesizedExpression.cs" />
-    <Compile Include="Ast\Expressions\PointerReferenceExpression.cs" />
-    <Compile Include="Ast\Expressions\PrimitiveExpression.cs" />
-    <Compile Include="Ast\Expressions\QueryExpression.cs" />
-    <Compile Include="Ast\Expressions\SizeOfExpression.cs" />
-    <Compile Include="Ast\Expressions\StackAllocExpression.cs" />
-    <Compile Include="Ast\Expressions\ThisReferenceExpression.cs" />
-    <Compile Include="Ast\Expressions\TypeOfExpression.cs" />
-    <Compile Include="Ast\Expressions\TypeReferenceExpression.cs" />
-    <Compile Include="Ast\Expressions\UnaryOperatorExpression.cs" />
-    <Compile Include="Ast\Expressions\UncheckedExpression.cs" />
-    <Compile Include="Ast\Expressions\UndocumentedExpression.cs" />
-    <Compile Include="Ast\GeneralScope\Attribute.cs" />
-    <Compile Include="Ast\GeneralScope\AttributeSection.cs" />
-    <Compile Include="Ast\GeneralScope\Comment.cs" />
-    <Compile Include="Ast\GeneralScope\Constraint.cs" />
-    <Compile Include="Ast\GeneralScope\DelegateDeclaration.cs" />
-    <Compile Include="Ast\GeneralScope\ExternAliasDeclaration.cs" />
-    <Compile Include="Ast\GeneralScope\NamespaceDeclaration.cs" />
-    <Compile Include="Ast\GeneralScope\TypeDeclaration.cs" />
-    <Compile Include="Ast\GeneralScope\TypeParameterDeclaration.cs" />
-    <Compile Include="Ast\GeneralScope\UsingAliasDeclaration.cs" />
-    <Compile Include="Ast\GeneralScope\UsingDeclaration.cs" />
-    <Compile Include="Ast\IAstVisitor.cs" />
-    <Compile Include="Ast\Identifier.cs" />
-    <Compile Include="Ast\MemberType.cs" />
-    <Compile Include="Ast\Modifiers.cs" />
-    <Compile Include="Ast\NodeType.cs" />
-    <Compile Include="Ast\ObservableAstVisitor.cs" />
-    <Compile Include="Ast\old_ObservableAstVisitor.cs" />
-    <Compile Include="Ast\PrimitiveType.cs" />
-    <Compile Include="Ast\SimpleType.cs" />
-    <Compile Include="Ast\Statements\BlockStatement.cs" />
-    <Compile Include="Ast\Statements\BreakStatement.cs" />
-    <Compile Include="Ast\Statements\CheckedStatement.cs" />
-    <Compile Include="Ast\Statements\ContinueStatement.cs" />
-    <Compile Include="Ast\Statements\DoWhileStatement.cs" />
-    <Compile Include="Ast\Statements\EmptyStatement.cs" />
-    <Compile Include="Ast\Statements\ExpressionStatement.cs" />
-    <Compile Include="Ast\Statements\FixedStatement.cs" />
-    <Compile Include="Ast\Statements\ForeachStatement.cs" />
-    <Compile Include="Ast\Statements\ForStatement.cs" />
-    <Compile Include="Ast\Statements\GotoStatement.cs" />
-    <Compile Include="Ast\Statements\IfElseStatement.cs" />
-    <Compile Include="Ast\Statements\LabelStatement.cs" />
-    <Compile Include="Ast\Statements\LockStatement.cs" />
-    <Compile Include="Ast\Statements\ReturnStatement.cs" />
-    <Compile Include="Ast\Statements\Statement.cs" />
-    <Compile Include="Ast\Statements\SwitchStatement.cs" />
-    <Compile Include="Ast\Statements\ThrowStatement.cs" />
-    <Compile Include="Ast\Statements\TryCatchStatement.cs" />
-    <Compile Include="Ast\Statements\UncheckedStatement.cs" />
-    <Compile Include="Ast\Statements\UnsafeStatement.cs" />
-    <Compile Include="Ast\Statements\UsingStatement.cs" />
-    <Compile Include="Ast\Statements\VariableDeclarationStatement.cs" />
-    <Compile Include="Ast\Statements\WhileStatement.cs" />
-    <Compile Include="Ast\Statements\YieldBreakStatement.cs" />
-    <Compile Include="Ast\Statements\YieldReturnStatement.cs" />
-    <Compile Include="Ast\TypeMembers\Accessor.cs" />
-    <Compile Include="Ast\TypeMembers\EntityDeclaration.cs" />
-    <Compile Include="Ast\TypeMembers\ConstructorDeclaration.cs" />
-    <Compile Include="Ast\TypeMembers\DestructorDeclaration.cs" />
-    <Compile Include="Ast\TypeMembers\EnumMemberDeclaration.cs" />
-    <Compile Include="Ast\TypeMembers\EventDeclaration.cs" />
-    <Compile Include="Ast\TypeMembers\FieldDeclaration.cs" />
-    <Compile Include="Ast\TypeMembers\FixedFieldDeclaration.cs" />
-    <Compile Include="Ast\TypeMembers\FixedVariableInitializer.cs" />
-    <Compile Include="Ast\TypeMembers\IndexerDeclaration.cs" />
-    <Compile Include="Ast\TypeMembers\MethodDeclaration.cs" />
-    <Compile Include="Ast\TypeMembers\OperatorDeclaration.cs" />
-    <Compile Include="Ast\TypeMembers\ParameterDeclaration.cs" />
-    <Compile Include="Ast\TypeMembers\PropertyDeclaration.cs" />
-    <Compile Include="Ast\TypeMembers\VariableInitializer.cs" />
-    <Compile Include="CSharpProjectContent.cs" />
-    <Compile Include="Formatter\AstFormattingVisitor.cs" />
-    <Compile Include="Formatter\CSharpFormattingOptions.cs" />
-    <Compile Include="Formatter\Indent.cs" />
-    <Compile Include="OutputVisitor\CodeDomConvertVisitor.cs" />
-    <Compile Include="OutputVisitor\CSharpAmbience.cs" />
-    <Compile Include="OutputVisitor\InsertParenthesesVisitor.cs" />
-    <Compile Include="OutputVisitor\IOutputFormatter.cs" />
-    <Compile Include="OutputVisitor\CSharpOutputVisitor.cs" />
-    <Compile Include="OutputVisitor\TextWriterOutputFormatter.cs" />
-    <Compile Include="Parser\CompilerSettings.cs" />
-    <Compile Include="Parser\CSharpParser.cs" />
-    <Compile Include="Parser\mcs\anonymous.cs" />
-    <Compile Include="Parser\mcs\argument.cs" />
-    <Compile Include="Parser\mcs\assembly.cs" />
-    <Compile Include="Parser\mcs\assign.cs" />
-    <Compile Include="Parser\mcs\async.cs" />
-    <Compile Include="Parser\mcs\attribute.cs" />
-    <Compile Include="Parser\mcs\cfold.cs" />
-    <Compile Include="Parser\mcs\class.cs" />
-    <Compile Include="Parser\mcs\codegen.cs" />
-    <Compile Include="Parser\mcs\complete.cs" />
-    <Compile Include="Parser\mcs\const.cs" />
-    <Compile Include="Parser\mcs\constant.cs" />
-    <Compile Include="Parser\mcs\context.cs" />
-    <Compile Include="Parser\mcs\convert.cs" />
-    <Compile Include="Parser\mcs\CryptoConvert.cs" />
-    <Compile Include="Parser\mcs\cs-parser.cs" />
-    <Compile Include="Parser\mcs\cs-tokenizer.cs" />
-    <Compile Include="Parser\mcs\decl.cs" />
-    <Compile Include="Parser\mcs\delegate.cs" />
-    <Compile Include="Parser\mcs\doc.cs" />
-    <Compile Include="Parser\mcs\driver.cs" />
-    <Compile Include="Parser\mcs\dynamic.cs" />
-    <Compile Include="Parser\mcs\ecore.cs" />
-    <Compile Include="Parser\mcs\enum.cs" />
-    <Compile Include="Parser\mcs\eval.cs" />
-    <Compile Include="Parser\mcs\expression.cs" />
-    <Compile Include="Parser\mcs\field.cs" />
-    <Compile Include="Parser\mcs\flowanalysis.cs" />
-    <Compile Include="Parser\mcs\generic.cs" />
-    <Compile Include="Parser\mcs\import.cs" />
-    <Compile Include="Parser\mcs\iterators.cs" />
-    <Compile Include="Parser\mcs\lambda.cs" />
-    <Compile Include="Parser\mcs\linq.cs" />
-    <Compile Include="Parser\mcs\literal.cs" />
-    <Compile Include="Parser\mcs\location.cs" />
-    <Compile Include="Parser\mcs\membercache.cs" />
-    <Compile Include="Parser\mcs\method.cs" />
-    <Compile Include="Parser\mcs\modifiers.cs" />
-    <Compile Include="Parser\mcs\MonoSymbolFile.cs" />
-    <Compile Include="Parser\mcs\MonoSymbolTable.cs" />
-    <Compile Include="Parser\mcs\MonoSymbolWriter.cs" />
-    <Compile Include="Parser\mcs\namespace.cs" />
-    <Compile Include="Parser\mcs\nullable.cs" />
-    <Compile Include="Parser\mcs\outline.cs" />
-    <Compile Include="Parser\mcs\parameter.cs" />
-    <Compile Include="Parser\mcs\pending.cs" />
-    <Compile Include="Parser\mcs\property.cs" />
-    <Compile Include="Parser\mcs\reflection.cs" />
-    <Compile Include="Parser\mcs\report.cs" />
-    <Compile Include="Parser\mcs\statement.cs" />
-    <Compile Include="Parser\mcs\support.cs" />
-    <Compile Include="Parser\mcs\symbolwriter.cs" />
-    <Compile Include="Parser\mcs\typemanager.cs" />
-    <Compile Include="Parser\mcs\typespec.cs" />
-    <Compile Include="Parser\mcs\visit.cs" />
-    <Compile Include="Properties\AssemblyInfo.cs" />
-    <Compile Include="QueryExpressionExpander.cs" />
-    <Compile Include="Refactoring\CodeActions\AddUsingAction.cs" />
-    <Compile Include="Refactoring\CodeActions\ConvertAsToCastAction.cs" />
-    <Compile Include="Refactoring\CodeActions\ConvertCastToAsAction.cs" />
-    <Compile Include="Refactoring\CodeActions\ConvertConditionalToIfAction.cs" />
-    <Compile Include="Refactoring\CodeActions\ConvertExplicitToImplicitImplementationAction.cs" />
-    <Compile Include="Refactoring\CodeActions\ConvertIfToConditionalAction.cs" />
-    <Compile Include="Refactoring\CodeActions\ConvertIfToSwitchAction.cs" />
-    <Compile Include="Refactoring\CodeActions\ConvertImplicitToExplicitImplementationAction.cs" />
-    <Compile Include="Refactoring\CodeActions\ConvertLambdaBodyExpressionToStatementAction.cs" />
-    <Compile Include="Refactoring\CodeActions\ConvertLambdaBodyStatementToExpressionAction.cs" />
-    <Compile Include="Refactoring\CodeActions\ConvertSwitchToIfAction.cs" />
-    <Compile Include="Refactoring\CodeActions\CreateCustomEventImplementationAction.cs" />
-    <Compile Include="Refactoring\CodeActions\CreateOverloadWithoutParameterAction.cs" />
-    <Compile Include="Refactoring\CodeActions\JoinDeclarationAndAssignmentAction.cs" />
-    <Compile Include="Refactoring\CodeActions\JoinStringAction.cs" />
-    <Compile Include="Refactoring\CodeActions\MergeNestedIfAction.cs" />
-    <Compile Include="Refactoring\CodeActions\NegateRelationalExpressionAction.cs" />
-    <Compile Include="Refactoring\CodeActions\PutInsideUsingAction.cs" />
-    <Compile Include="Refactoring\CodeActions\SplitDeclarationListAction.cs" />
-    <Compile Include="Refactoring\CodeActions\UseStringFormatAction.cs" />
-    <Compile Include="Refactoring\CodeIssues\AccessToClosureIssues\AccessToClosureIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\AccessToClosureIssues\AccessToDisposedClosureIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\AccessToClosureIssues\AccessToModifiedClosureIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\AccessToClosureIssues\LocalVariableNamePicker.cs" />
-    <Compile Include="Refactoring\CodeIssues\AssignmentMadeToSameVariableIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\BitwiseOperationOnNonFlagsEnumIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\CastExpressionOfIncompatibleTypeIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\CompareBooleanWithTrueOrFalseIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\CompareFloatWithEqualityOperatorIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\ConstantConditionIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\DoubleNegationIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\ExpressionIsAlwaysOfProvidedTypeIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\ExpressionIsNeverOfProvidedTypeIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\MethodNeverReturnsIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\MethodOverloadHidesOptionalParameterIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\MissingStringComparisonIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\NegativeRelationalExpressionIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\ExplicitConversionInForEachIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\ForControlVariableNotModifiedIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\IdenticalConditionalBranchIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\MultipleEnumerationIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\RedundantArrayInitializerCommaIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\RedundantAssignmentIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\RedundantAttributeParenthesesIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\RedundantCaseLabelIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\RedundantElseIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\RedundantFieldInitializerIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\RedundantObjectCreationArgumentListIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\RedundantObjectOrCollectionInitializerIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\RedundantTypeCastIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\ReferenceEqualsCalledWithValueTypeIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\ResultOfAsyncCallShouldNotBeIgnoredIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\UnreachableCodeIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\VariableHidesMemberIssue\LocalVariableHidesMemberIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\VariableHidesMemberIssue\ParameterHidesMemberIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\VariableHidesMemberIssue\VariableHidesMemberIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\VariableNotUsedIssues\LocalVariableNotUsedIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\VariableNotUsedIssues\ParameterNotUsedIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\TypeParameterNotUsedIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\VariableOnlyAssignedIssues\ParameterOnlyAssignedIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\VariableOnlyAssignedIssues\VariableOnlyAssignedIssue.cs" />
-    <Compile Include="Refactoring\DocumentScript.cs" />
-    <Compile Include="Refactoring\CodeActions\ExtractAnonymousMethodAction.cs" />
-    <Compile Include="Refactoring\UsingHelper.cs" />
-    <Compile Include="Refactoring\LambdaHelper.cs" />
-    <Compile Include="Refactoring\PatternHelper.cs" />
-    <Compile Include="Refactoring\RefactoringAstHelper.cs" />
-    <Compile Include="Refactoring\RefactoringContext.cs" />
-    <Compile Include="Refactoring\Script.cs" />
-    <Compile Include="Refactoring\TypeSystemAstBuilder.cs" />
-    <Compile Include="Refactoring\VariableReferenceGraph.cs" />
-    <Compile Include="Resolver\CompositeResolveVisitorNavigator.cs" />
-    <Compile Include="Resolver\AwaitResolveResult.cs" />
-    <Compile Include="Resolver\DynamicInvocationResolveResult.cs" />
-    <Compile Include="Resolver\DynamicMemberResolveResult.cs" />
-    <Compile Include="Resolver\CSharpConversions.cs" />
-    <Compile Include="Resolver\CSharpAstResolver.cs" />
-    <Compile Include="Resolver\CSharpInvocationResolveResult.cs" />
-    <Compile Include="Resolver\CSharpOperators.cs" />
-    <Compile Include="Resolver\CSharpResolver.cs" />
-    <Compile Include="Resolver\DetectSkippableNodesNavigator.cs" />
-    <Compile Include="Resolver\FindReferencedEntities.cs" />
-    <Compile Include="Resolver\FindReferences.cs" />
-    <Compile Include="Resolver\FindReferenceSearchScope.cs" />
-    <Compile Include="Resolver\IResolveVisitorNavigator.cs" />
-    <Compile Include="Resolver\LambdaResolveResult.cs" />
-    <Compile Include="Resolver\Log.cs" />
-    <Compile Include="Resolver\MemberLookup.cs" />
-    <Compile Include="Resolver\MethodGroupResolveResult.cs" />
-    <Compile Include="Resolver\NodeListResolveVisitorNavigator.cs" />
-    <Compile Include="Resolver\OverloadResolution.cs" />
-    <Compile Include="Resolver\OverloadResolutionErrors.cs" />
-    <Compile Include="Resolver\ResolveAtLocation.cs" />
-    <Compile Include="Resolver\ResolveVisitor.cs" />
-    <Compile Include="Resolver\TypeInference.cs" />
-    <Compile Include="Completion\ICompletionDataFactory.cs" />
-    <Compile Include="Completion\IParameterCompletionDataFactory.cs" />
-    <Compile Include="NameLookupMode.cs" />
-    <Compile Include="TypeSystem\AliasNamespaceReference.cs" />
-    <Compile Include="TypeSystem\AttributeTypeReference.cs" />
-    <Compile Include="TypeSystem\ConstantValues.cs" />
-    <Compile Include="TypeSystem\CSharpAssembly.cs" />
-    <Compile Include="TypeSystem\CSharpAttribute.cs" />
-    <Compile Include="TypeSystem\CSharpDocumentationComment.cs" />
-    <Compile Include="TypeSystem\CSharpUnresolvedFile.cs" />
-    <Compile Include="TypeSystem\CSharpUnresolvedTypeDefinition.cs" />
-    <Compile Include="TypeSystem\CSharpTypeResolveContext.cs" />
-    <Compile Include="TypeSystem\ResolvedUsingScope.cs" />
-    <Compile Include="TypeSystem\TypeOrNamespaceReference.cs" />
-    <Compile Include="TypeSystem\MemberTypeOrNamespaceReference.cs" />
-    <Compile Include="TypeSystem\SimpleTypeOrNamespaceReference.cs" />
-    <Compile Include="TypeSystem\MethodTypeParameterWithInheritedConstraints.cs" />
-    <Compile Include="TypeSystem\TypeSystemConvertVisitor.cs" />
-    <Compile Include="TypeSystem\UsingScope.cs" />
-    <Compile Include="Ast\GeneralScope\PreProcessorDirective.cs" />
-    <Compile Include="Ast\Expressions\ErrorExpression.cs" />
-    <Compile Include="Completion\CompletionDataWrapper.cs" />
-    <Compile Include="Completion\CSharpCompletionEngine.cs" />
-    <Compile Include="Completion\CSharpCompletionEngineBase.cs" />
-    <Compile Include="Completion\CSharpParameterCompletionEngine.cs" />
-    <Compile Include="Parser\mcs\module.cs" />
-    <Compile Include="Parser\mcs\settings.cs" />
-    <Compile Include="Parser\mcs\SourceMethodBuilder.cs" />
-    <Compile Include="Ast\TokenRole.cs" />
-    <Compile Include="Ast\Roles.cs" />
-    <Compile Include="Refactoring\BaseRefactoringContext.cs" />
-    <Compile Include="Refactoring\CodeIssue.cs" />
-    <Compile Include="Refactoring\CodeAction.cs" />
-    <Compile Include="Refactoring\ICodeActionProvider.cs" />
-    <Compile Include="Refactoring\ICodeIssueProvider.cs" />
-    <Compile Include="Refactoring\ContextActionAttribute.cs" />
-    <Compile Include="Refactoring\IssueAttribute.cs" />
-    <Compile Include="Refactoring\CodeIssues\IssueCategories.cs" />
-    <Compile Include="Refactoring\Severity.cs" />
-    <Compile Include="Refactoring\IssueMarker.cs" />
-    <Compile Include="Refactoring\CodeIssues\GatherVisitorBase.cs" />
-    <Compile Include="Refactoring\CodeIssues\ConditionalToNullCoalescingIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\NotImplementedExceptionIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\RedundantInternalIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\RedundantNamespaceUsageIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\RedundantPrivateIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\RedundantThisIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\RedundantUsingIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\StringIsNullOrEmptyIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\UseVarKeywordIssue.cs" />
-    <Compile Include="Refactoring\CodeActions\UseVarKeywordAction.cs" />
-    <Compile Include="Refactoring\CodeActions\UseExplicitTypeAction.cs" />
-    <Compile Include="Refactoring\CodeActions\SplitStringAction.cs" />
-    <Compile Include="Refactoring\CodeActions\SplitDeclarationAndAssignmentAction.cs" />
-    <Compile Include="Refactoring\CodeActions\ReplaceEmptyStringAction.cs" />
-    <Compile Include="Refactoring\CodeActions\RemoveRegionAction.cs" />
-    <Compile Include="Refactoring\CodeActions\RemoveBracesAction.cs" />
-    <Compile Include="Refactoring\CodeActions\RemoveBackingStoreAction.cs" />
-    <Compile Include="Refactoring\CodeActions\InvertIfAction.cs" />
-    <Compile Include="Refactoring\CodeActions\IntroduceFormatItemAction.cs" />
-    <Compile Include="Refactoring\CodeActions\InsertAnonymousMethodSignatureAction.cs" />
-    <Compile Include="Refactoring\CodeActions\GenerateSwitchLabelsAction.cs" />
-    <Compile Include="Refactoring\CodeActions\GeneratePropertyAction.cs" />
-    <Compile Include="Refactoring\CodeActions\GenerateGetterAction.cs" />
-    <Compile Include="Refactoring\CodeActions\FlipOperatorArgumentsAction.cs" />
-    <Compile Include="Refactoring\CodeActions\CreatePropertyAction.cs" />
-    <Compile Include="Refactoring\CodeActions\CreateLocalVariableAction.cs" />
-    <Compile Include="Refactoring\CodeActions\CreateFieldAction.cs" />
-    <Compile Include="Refactoring\CodeActions\CreateEventInvocatorAction.cs" />
-    <Compile Include="Refactoring\CodeActions\CreateBackingStoreAction.cs" />
-    <Compile Include="Refactoring\CodeActions\ConvertHexToDecAction.cs" />
-    <Compile Include="Refactoring\CodeActions\ConvertForeachToForAction.cs" />
-    <Compile Include="Refactoring\CodeActions\ConvertDecToHexAction.cs" />
-    <Compile Include="Refactoring\CodeActions\CheckIfParameterIsNullAction.cs" />
-    <Compile Include="Refactoring\CodeActions\AddAnotherAccessorAction.cs" />
-    <Compile Include="Refactoring\CodeIssues\InconsistentNamingIssue\NamingStyle.cs" />
-    <Compile Include="Refactoring\CodeIssues\InconsistentNamingIssue\NamingRule.cs" />
-    <Compile Include="Refactoring\CodeIssues\InconsistentNamingIssue\AffectedEntity.cs" />
-    <Compile Include="Refactoring\CodeIssues\InconsistentNamingIssue\DefaultRules.cs" />
-    <Compile Include="Refactoring\CodeIssues\InconsistentNamingIssue\InconsistentNamingIssue.cs" />
-    <Compile Include="Refactoring\CodeActions\CreateMethodDeclarationAction.cs" />
-    <Compile Include="Refactoring\CodeIssues\InconsistentNamingIssue\NamingConventionService.cs" />
-    <Compile Include="Refactoring\CodeActions\CreateIndexerAction.cs" />
-    <Compile Include="Refactoring\CodeActions\InlineLocalVariableAction.cs" />
-    <Compile Include="Refactoring\CodeActions\DeclareLocalVariableAction.cs" />
-    <Compile Include="Refactoring\CodeIssues\InconsistentNamingIssue\WordParser.cs" />
-    <Compile Include="Refactoring\CodeActions\CreateConstructorDeclarationAction.cs" />
-    <Compile Include="Refactoring\CodeActions\CreateClassDeclarationAction.cs" />
-    <Compile Include="Refactoring\CodeActions\CreateDelegateAction.cs" />
-    <Compile Include="Formatter\TextEditorOptions.cs" />
-    <Compile Include="Refactoring\CodeActions\IntroduceConstantAction.cs" />
-    <Compile Include="Refactoring\CodeActions\ExtractMethod\ExtractMethodAction.cs" />
-    <Compile Include="Refactoring\CodeActions\ExtractMethod\StaticVisitor.cs" />
-    <Compile Include="Refactoring\CodeActions\ExtractMethod\VariableLookupVisitor.cs" />
-    <Compile Include="Refactoring\CodeActions\SpecializedCodeAction.cs" />
-    <Compile Include="Formatter\GeneratedCodeSettings.cs" />
-    <Compile Include="Ast\GeneralScope\NewLineNode.cs" />
-    <Compile Include="Ast\GeneralScope\WhitespaceNode.cs" />
-    <Compile Include="Ast\GeneralScope\TextNode.cs" />
-    <Compile Include="Formatter\FormattingOptionsFactory.cs" />
-    <Compile Include="Refactoring\CodeActions\ImplementInterfaceAction.cs" />
-    <Compile Include="Refactoring\CodeActions\ImplementInterfaceExplicitAction.cs" />
-    <Compile Include="Refactoring\CodeActions\ImplementAbstractMembersAction.cs" />
-    <Compile Include="Refactoring\CodeActions\RemoveRedundantCatchTypeAction.cs" />
-    <Compile Include="Refactoring\CodeActions\AddCatchTypeAction.cs" />
-    <Compile Include="Refactoring\CodeIssues\IncorrectExceptionParameterOrderingIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\CallToVirtualFunctionFromConstructorIssue.cs" />
-    <Compile Include="Refactoring\CodeActions\StaticMethodInvocationToExtensionMethodInvocationAction.cs" />
-    <Compile Include="Refactoring\CodeActions\ExtensionMethodInvocationToStaticMethodInvocationAction.cs" />
-    <Compile Include="Refactoring\CodeActions\IterateViaForeachAction.cs" />
-    <Compile Include="Refactoring\CodeActions\ExtractFieldAction.cs" />
-    <Compile Include="Completion\ICompletionContextProvider.cs" />
-    <Compile Include="Refactoring\CodeIssues\ValueParameterUnusedIssue.cs" />
-    <Compile Include="Refactoring\NamingHelper.cs" />
-    <Compile Include="Refactoring\CodeActions\ConvertToInitializer\ConvertToInitializerAction.cs" />
-    <Compile Include="Refactoring\CodeActions\ConvertToInitializer\StatementsToInitializerConverter.cs" />
-    <Compile Include="Refactoring\CodeActions\MoveToOuterScopeAction.cs" />
-    <Compile Include="Refactoring\CodeIssues\VariableDeclaredInWideScopeIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\ParameterCanBeDemotedIssue\ParameterCanBeDemotedIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\ParameterCanBeDemotedIssue\ITypeCriterion.cs" />
-    <Compile Include="Refactoring\CodeIssues\ParameterCanBeDemotedIssue\HasMemberCriterion.cs" />
-    <Compile Include="Refactoring\CodeIssues\ParameterCanBeDemotedIssue\TypeCriteriaCollector.cs" />
-    <Compile Include="Refactoring\CodeIssues\ReferenceToStaticMemberViaDerivedTypeIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\ParameterCanBeDemotedIssue\IsTypeCriterion.cs" />
-    <Compile Include="Refactoring\CodeIssues\OptionalParameterCouldBeSkippedIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\RedundantCatchIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\RedundantToStringIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\CallToObjectEqualsViaBaseIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\IncorrectCallToObjectGetHashCodeIssue.cs" />
-    <Compile Include="Refactoring\CodeActions\ExtractMethod\VariableUsageAnalyzation.cs" />
-    <Compile Include="Refactoring\CodeIssues\FormatStringIssues\FormatStringIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\FormatStringIssues\FormatStringHelper.cs" />
-    <Compile Include="Refactoring\CodeActions\ConvertToInitializer\ConvertInitializerToExplicitInitializationsAction.cs" />
-    <Compile Include="Refactoring\CodeIssues\ExceptionRethrowIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\ThreadStaticOnInstanceFieldIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\StaticFieldInGenericTypeIssue.cs" />
-    <Compile Include="Parser\SeekableStreamReader.cs" />
-    <Compile Include="Refactoring\CodeActions\ConvertAnonymousDelegateToLambdaAction.cs" />
-    <Compile Include="Refactoring\CodeActions\ConvertLambdaToAnonymousDelegateAction.cs" />
-    <Compile Include="Refactoring\CodeIssues\ParameterCanBeDemotedIssue\IsArrayTypeCriterion.cs" />
-    <Compile Include="Refactoring\CodeIssues\ParameterCanBeDemotedIssue\SupportsIndexingCriterion.cs" />
-    <Compile Include="Refactoring\CodeIssues\RedundantWhereWithPredicateIssue.cs" />
-    <Compile Include="Refactoring\CodeActions\ConvertToInitializer\AccessPath.cs" />
-    <Compile Include="Refactoring\LocalReferenceFinder.cs" />
-    <Compile Include="Refactoring\CodeActions\SortUsingsAction.cs" />
-    <Compile Include="Formatter\CSharpIndentEngine.cs" />
-    <Compile Include="Refactoring\CodeActions\CreateEnumValue.cs" />
-    <Compile Include="Resolver\AliasTypeResolveResult.cs" />
-    <Compile Include="Resolver\AliasNamespaceResolveResult.cs" />
-    <Compile Include="Resolver\ReducedExtensionMethod.cs" />
-    <Compile Include="Refactoring\CodeIssues\SimplifyAnonymousMethodToDelegateIssue.cs" />
-    <Compile Include="Refactoring\CodeIssues\CompilerErrors\CS0127ReturnMustNotBeFollowedByAnyExpression.cs" />
-  </ItemGroup>
-  <ItemGroup>
-    <ProjectReference Include="..\ICSharpCode.NRefactory\ICSharpCode.NRefactory.csproj">
-      <Project>{3B2A5653-EC97-4001-BB9B-D90F1AF2C371}</Project>
-      <Name>ICSharpCode.NRefactory</Name>
-    </ProjectReference>
-  </ItemGroup>
-  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.Targets" />
-  <ItemGroup>
-    <Folder Include="Completion\" />
-    <Folder Include="Refactoring\CodeIssues\" />
-    <Folder Include="Refactoring\CodeIssues\InconsistentNamingIssue\" />
-    <Folder Include="Refactoring\CodeActions\ExtractMethod\" />
-    <Folder Include="Refactoring\CodeActions\ConvertToInitializer\" />
-    <Folder Include="Refactoring\CodeIssues\FormatStringIssues\" />
-    <Folder Include="Refactoring\CodeIssues\CompilerErrors\" />
-  </ItemGroup>
-  <ProjectExtensions>
-    <MonoDevelop>
-      <Properties>
-        <Policies>
-          <TextStylePolicy TabsToSpaces="False" EolMarker="Unix" inheritsSet="VisualStudio" inheritsScope="text/plain" scope="text/plain" />
-          <TextStylePolicy FileWidth="120" TabsToSpaces="False" EolMarker="Unix" inheritsSet="VisualStudio" inheritsScope="text/plain" scope="text/x-csharp" />
-          <CSharpFormattingPolicy IndentSwitchBody="True" BeforeMethodDeclarationParentheses="False" BeforeMethodCallParentheses="False" BeforeConstructorDeclarationParentheses="False" BeforeDelegateDeclarationParentheses="False" NewParentheses="False" inheritsSet="Mono" inheritsScope="text/x-csharp" scope="text/x-csharp" />
-          <TextStylePolicy inheritsSet="null" scope="text/x-jay" />
-        </Policies>
-      </Properties>
-    </MonoDevelop>
-  </ProjectExtensions>
-  <ItemGroup>
-    <None Include="Parser\mcs\cs-parser.jay" />
-  </ItemGroup>
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" DefaultTargets="Build">
+  <PropertyGroup>
+    <ProjectGuid>{6587E3E6-B14F-4924-B39D-512A78C4C1B2}</ProjectGuid>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <OutputType>Library</OutputType>
+    <RootNamespace>ICSharpCode.NRefactory.PlayScript</RootNamespace>
+    <AssemblyName>ICSharpCode.NRefactory.PlayScript</AssemblyName>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <AllowUnsafeBlocks>False</AllowUnsafeBlocks>
+    <NoStdLib>False</NoStdLib>
+    <WarningLevel>4</WarningLevel>
+    <TreatWarningsAsErrors>false</TreatWarningsAsErrors>
+    <ProductVersion>10.0.0</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <SignAssembly>True</SignAssembly>
+    <AssemblyOriginatorKeyFile>ICSharpCode.NRefactory.snk</AssemblyOriginatorKeyFile>
+    <DelaySign>False</DelaySign>
+    <AssemblyOriginatorKeyMode>File</AssemblyOriginatorKeyMode>
+    <DocumentationFile>bin\$(Configuration)\ICSharpCode.NRefactory.PlayScript.xml</DocumentationFile>
+    <NoWarn>1591,1587,1570</NoWarn>
+    <OutputPath>bin\$(Configuration)\</OutputPath>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Platform)' == 'AnyCPU' ">
+    <PlatformTarget>AnyCPU</PlatformTarget>
+    <RegisterForComInterop>False</RegisterForComInterop>
+    <GenerateSerializationAssemblies>Auto</GenerateSerializationAssemblies>
+    <BaseAddress>4194304</BaseAddress>
+    <FileAlignment>4096</FileAlignment>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
+    <Optimize>False</Optimize>
+    <CheckForOverflowUnderflow>False</CheckForOverflowUnderflow>
+    <DefineConstants>DEBUG;TRACE;FULL_AST;NET_4_0</DefineConstants>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
+    <Optimize>True</Optimize>
+    <CheckForOverflowUnderflow>False</CheckForOverflowUnderflow>
+    <DefineConstants>TRACE;FULL_AST;NET_4_0</DefineConstants>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>none</DebugType>
+    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugType>full</DebugType>
+    <DebugSymbols>True</DebugSymbols>
+    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)' == 'net_4_5_Debug' ">
+    <Optimize>False</Optimize>
+    <CheckForOverflowUnderflow>False</CheckForOverflowUnderflow>
+    <DefineConstants>DEBUG;TRACE;FULL_AST;NET_4_0;NET_4_5</DefineConstants>
+    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'net_4_5_Debug|AnyCPU' ">
+    <DebugType>full</DebugType>
+    <DebugSymbols>True</DebugSymbols>
+    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
+    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)' == 'net_4_5_Release' ">
+    <Optimize>True</Optimize>
+    <CheckForOverflowUnderflow>False</CheckForOverflowUnderflow>
+    <DefineConstants>TRACE;FULL_AST;NET_4_0;NET_4_5</DefineConstants>
+    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'net_4_5_Release|AnyCPU' ">
+    <DebugType>none</DebugType>
+    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
+    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Core">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+    <Reference Include="System.Xml" />
+    <Reference Include="System.Xml.Linq">
+      <RequiredTargetFramework>3.5</RequiredTargetFramework>
+    </Reference>
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="Properties\GlobalAssemblyInfo.cs">
+      <Link>Properties\GlobalAssemblyInfo.cs</Link>
+    </Compile>
+    <Compile Include="Analysis\ControlFlow.cs" />
+    <Compile Include="Analysis\DefiniteAssignmentAnalysis.cs" />
+    <Compile Include="Analysis\ReachabilityAnalysis.cs" />
+    <Compile Include="Analysis\SemanticHighlightingVisitor.cs" />
+    <Compile Include="Ast\AstNode.cs" />
+    <Compile Include="Ast\AstNodeCollection.cs" />
+    <Compile Include="Ast\AstType.cs" />
+    <Compile Include="Ast\DocumentationReference.cs" />
+    <Compile Include="Ast\IdentifierExpressionBackreference.cs" />
+    <Compile Include="Ast\SyntaxExtensions.cs" />
+    <Compile Include="Ast\SyntaxTree.cs" />
+    <Compile Include="Ast\ComposedType.cs" />
+    <Compile Include="Ast\CSharpModifierToken.cs" />
+    <Compile Include="Ast\CSharpTokenNode.cs" />
+    <Compile Include="Ast\CSharpUtil.cs" />
+    <Compile Include="Ast\DepthFirstAstVisitor.cs" />
+    <Compile Include="Ast\ErrorNode.cs" />
+    <Compile Include="Ast\Expressions\AnonymousMethodExpression.cs" />
+    <Compile Include="Ast\Expressions\AnonymousTypeCreateExpression.cs" />
+    <Compile Include="Ast\Expressions\ArrayCreateExpression.cs" />
+    <Compile Include="Ast\Expressions\ArrayInitializerExpression.cs" />
+    <Compile Include="Ast\Expressions\AsExpression.cs" />
+    <Compile Include="Ast\Expressions\AssignmentExpression.cs" />
+    <Compile Include="Ast\Expressions\BaseReferenceExpression.cs" />
+    <Compile Include="Ast\Expressions\BinaryOperatorExpression.cs" />
+    <Compile Include="Ast\Expressions\CastExpression.cs" />
+    <Compile Include="Ast\Expressions\CheckedExpression.cs" />
+    <Compile Include="Ast\Expressions\ConditionalExpression.cs" />
+    <Compile Include="Ast\Expressions\DefaultValueExpression.cs" />
+    <Compile Include="Ast\Expressions\DirectionExpression.cs" />
+    <Compile Include="Ast\Expressions\EmptyExpression.cs" />
+    <Compile Include="Ast\Expressions\Expression.cs" />
+    <Compile Include="Ast\Expressions\IdentifierExpression.cs" />
+    <Compile Include="Ast\Expressions\IndexerExpression.cs" />
+    <Compile Include="Ast\Expressions\InvocationExpression.cs" />
+    <Compile Include="Ast\Expressions\IsExpression.cs" />
+    <Compile Include="Ast\Expressions\LambdaExpression.cs" />
+    <Compile Include="Ast\Expressions\MemberReferenceExpression.cs" />
+    <Compile Include="Ast\Expressions\NamedArgumentExpression.cs" />
+    <Compile Include="Ast\Expressions\NamedExpression.cs" />
+    <Compile Include="Ast\Expressions\NullReferenceExpression.cs" />
+    <Compile Include="Ast\Expressions\ObjectCreateExpression.cs" />
+    <Compile Include="Ast\Expressions\ParenthesizedExpression.cs" />
+    <Compile Include="Ast\Expressions\PointerReferenceExpression.cs" />
+    <Compile Include="Ast\Expressions\PrimitiveExpression.cs" />
+    <Compile Include="Ast\Expressions\QueryExpression.cs" />
+    <Compile Include="Ast\Expressions\SizeOfExpression.cs" />
+    <Compile Include="Ast\Expressions\StackAllocExpression.cs" />
+    <Compile Include="Ast\Expressions\ThisReferenceExpression.cs" />
+    <Compile Include="Ast\Expressions\TypeOfExpression.cs" />
+    <Compile Include="Ast\Expressions\TypeReferenceExpression.cs" />
+    <Compile Include="Ast\Expressions\UnaryOperatorExpression.cs" />
+    <Compile Include="Ast\Expressions\UncheckedExpression.cs" />
+    <Compile Include="Ast\Expressions\UndocumentedExpression.cs" />
+    <Compile Include="Ast\GeneralScope\Attribute.cs" />
+    <Compile Include="Ast\GeneralScope\AttributeSection.cs" />
+    <Compile Include="Ast\GeneralScope\Comment.cs" />
+    <Compile Include="Ast\GeneralScope\Constraint.cs" />
+    <Compile Include="Ast\GeneralScope\DelegateDeclaration.cs" />
+    <Compile Include="Ast\GeneralScope\ExternAliasDeclaration.cs" />
+    <Compile Include="Ast\GeneralScope\NamespaceDeclaration.cs" />
+    <Compile Include="Ast\GeneralScope\TypeDeclaration.cs" />
+    <Compile Include="Ast\GeneralScope\TypeParameterDeclaration.cs" />
+    <Compile Include="Ast\GeneralScope\UsingAliasDeclaration.cs" />
+    <Compile Include="Ast\GeneralScope\UsingDeclaration.cs" />
+    <Compile Include="Ast\IAstVisitor.cs" />
+    <Compile Include="Ast\Identifier.cs" />
+    <Compile Include="Ast\MemberType.cs" />
+    <Compile Include="Ast\Modifiers.cs" />
+    <Compile Include="Ast\NodeType.cs" />
+    <Compile Include="Ast\ObservableAstVisitor.cs" />
+    <Compile Include="Ast\old_ObservableAstVisitor.cs" />
+    <Compile Include="Ast\PrimitiveType.cs" />
+    <Compile Include="Ast\SimpleType.cs" />
+    <Compile Include="Ast\Statements\BlockStatement.cs" />
+    <Compile Include="Ast\Statements\BreakStatement.cs" />
+    <Compile Include="Ast\Statements\CheckedStatement.cs" />
+    <Compile Include="Ast\Statements\ContinueStatement.cs" />
+    <Compile Include="Ast\Statements\DoWhileStatement.cs" />
+    <Compile Include="Ast\Statements\EmptyStatement.cs" />
+    <Compile Include="Ast\Statements\ExpressionStatement.cs" />
+    <Compile Include="Ast\Statements\FixedStatement.cs" />
+    <Compile Include="Ast\Statements\ForeachStatement.cs" />
+    <Compile Include="Ast\Statements\ForStatement.cs" />
+    <Compile Include="Ast\Statements\GotoStatement.cs" />
+    <Compile Include="Ast\Statements\IfElseStatement.cs" />
+    <Compile Include="Ast\Statements\LabelStatement.cs" />
+    <Compile Include="Ast\Statements\LockStatement.cs" />
+    <Compile Include="Ast\Statements\ReturnStatement.cs" />
+    <Compile Include="Ast\Statements\Statement.cs" />
+    <Compile Include="Ast\Statements\SwitchStatement.cs" />
+    <Compile Include="Ast\Statements\ThrowStatement.cs" />
+    <Compile Include="Ast\Statements\TryCatchStatement.cs" />
+    <Compile Include="Ast\Statements\UncheckedStatement.cs" />
+    <Compile Include="Ast\Statements\UnsafeStatement.cs" />
+    <Compile Include="Ast\Statements\UsingStatement.cs" />
+    <Compile Include="Ast\Statements\VariableDeclarationStatement.cs" />
+    <Compile Include="Ast\Statements\WhileStatement.cs" />
+    <Compile Include="Ast\Statements\YieldBreakStatement.cs" />
+    <Compile Include="Ast\Statements\YieldReturnStatement.cs" />
+    <Compile Include="Ast\TypeMembers\Accessor.cs" />
+    <Compile Include="Ast\TypeMembers\EntityDeclaration.cs" />
+    <Compile Include="Ast\TypeMembers\ConstructorDeclaration.cs" />
+    <Compile Include="Ast\TypeMembers\DestructorDeclaration.cs" />
+    <Compile Include="Ast\TypeMembers\EnumMemberDeclaration.cs" />
+    <Compile Include="Ast\TypeMembers\EventDeclaration.cs" />
+    <Compile Include="Ast\TypeMembers\FieldDeclaration.cs" />
+    <Compile Include="Ast\TypeMembers\FixedFieldDeclaration.cs" />
+    <Compile Include="Ast\TypeMembers\FixedVariableInitializer.cs" />
+    <Compile Include="Ast\TypeMembers\IndexerDeclaration.cs" />
+    <Compile Include="Ast\TypeMembers\MethodDeclaration.cs" />
+    <Compile Include="Ast\TypeMembers\OperatorDeclaration.cs" />
+    <Compile Include="Ast\TypeMembers\ParameterDeclaration.cs" />
+    <Compile Include="Ast\TypeMembers\PropertyDeclaration.cs" />
+    <Compile Include="Ast\TypeMembers\VariableInitializer.cs" />
+    <Compile Include="CSharpProjectContent.cs" />
+    <Compile Include="Formatter\AstFormattingVisitor.cs" />
+    <Compile Include="Formatter\CSharpFormattingOptions.cs" />
+    <Compile Include="Formatter\Indent.cs" />
+    <Compile Include="OutputVisitor\CodeDomConvertVisitor.cs" />
+    <Compile Include="OutputVisitor\CSharpAmbience.cs" />
+    <Compile Include="OutputVisitor\InsertParenthesesVisitor.cs" />
+    <Compile Include="OutputVisitor\IOutputFormatter.cs" />
+    <Compile Include="OutputVisitor\CSharpOutputVisitor.cs" />
+    <Compile Include="OutputVisitor\TextWriterOutputFormatter.cs" />
+    <Compile Include="Parser\CompilerSettings.cs" />
+    <Compile Include="Parser\CSharpParser.cs" />
+    <Compile Include="Parser\mcs\anonymous.cs" />
+    <Compile Include="Parser\mcs\argument.cs" />
+    <Compile Include="Parser\mcs\assembly.cs" />
+    <Compile Include="Parser\mcs\assign.cs" />
+    <Compile Include="Parser\mcs\async.cs" />
+    <Compile Include="Parser\mcs\attribute.cs" />
+    <Compile Include="Parser\mcs\cfold.cs" />
+    <Compile Include="Parser\mcs\class.cs" />
+    <Compile Include="Parser\mcs\codegen.cs" />
+    <Compile Include="Parser\mcs\complete.cs" />
+    <Compile Include="Parser\mcs\const.cs" />
+    <Compile Include="Parser\mcs\constant.cs" />
+    <Compile Include="Parser\mcs\context.cs" />
+    <Compile Include="Parser\mcs\convert.cs" />
+    <Compile Include="Parser\mcs\CryptoConvert.cs" />
+    <Compile Include="Parser\mcs\cs-parser.cs" />
+    <Compile Include="Parser\mcs\cs-tokenizer.cs" />
+    <Compile Include="Parser\mcs\decl.cs" />
+    <Compile Include="Parser\mcs\delegate.cs" />
+    <Compile Include="Parser\mcs\doc.cs" />
+    <Compile Include="Parser\mcs\driver.cs" />
+    <Compile Include="Parser\mcs\dynamic.cs" />
+    <Compile Include="Parser\mcs\ecore.cs" />
+    <Compile Include="Parser\mcs\enum.cs" />
+    <Compile Include="Parser\mcs\eval.cs" />
+    <Compile Include="Parser\mcs\expression.cs" />
+    <Compile Include="Parser\mcs\field.cs" />
+    <Compile Include="Parser\mcs\flowanalysis.cs" />
+    <Compile Include="Parser\mcs\generic.cs" />
+    <Compile Include="Parser\mcs\import.cs" />
+    <Compile Include="Parser\mcs\iterators.cs" />
+    <Compile Include="Parser\mcs\lambda.cs" />
+    <Compile Include="Parser\mcs\linq.cs" />
+    <Compile Include="Parser\mcs\literal.cs" />
+    <Compile Include="Parser\mcs\location.cs" />
+    <Compile Include="Parser\mcs\membercache.cs" />
+    <Compile Include="Parser\mcs\method.cs" />
+    <Compile Include="Parser\mcs\modifiers.cs" />
+    <Compile Include="Parser\mcs\MonoSymbolFile.cs" />
+    <Compile Include="Parser\mcs\MonoSymbolTable.cs" />
+    <Compile Include="Parser\mcs\MonoSymbolWriter.cs" />
+    <Compile Include="Parser\mcs\namespace.cs" />
+    <Compile Include="Parser\mcs\nullable.cs" />
+    <Compile Include="Parser\mcs\outline.cs" />
+    <Compile Include="Parser\mcs\parameter.cs" />
+    <Compile Include="Parser\mcs\pending.cs" />
+    <Compile Include="Parser\mcs\property.cs" />
+    <Compile Include="Parser\mcs\reflection.cs" />
+    <Compile Include="Parser\mcs\report.cs" />
+    <Compile Include="Parser\mcs\statement.cs" />
+    <Compile Include="Parser\mcs\support.cs" />
+    <Compile Include="Parser\mcs\symbolwriter.cs" />
+    <Compile Include="Parser\mcs\typemanager.cs" />
+    <Compile Include="Parser\mcs\typespec.cs" />
+    <Compile Include="Parser\mcs\visit.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+    <Compile Include="QueryExpressionExpander.cs" />
+    <Compile Include="Refactoring\CodeActions\AddUsingAction.cs" />
+    <Compile Include="Refactoring\CodeActions\ConvertAsToCastAction.cs" />
+    <Compile Include="Refactoring\CodeActions\ConvertCastToAsAction.cs" />
+    <Compile Include="Refactoring\CodeActions\ConvertConditionalToIfAction.cs" />
+    <Compile Include="Refactoring\CodeActions\ConvertExplicitToImplicitImplementationAction.cs" />
+    <Compile Include="Refactoring\CodeActions\ConvertIfToConditionalAction.cs" />
+    <Compile Include="Refactoring\CodeActions\ConvertIfToSwitchAction.cs" />
+    <Compile Include="Refactoring\CodeActions\ConvertImplicitToExplicitImplementationAction.cs" />
+    <Compile Include="Refactoring\CodeActions\ConvertLambdaBodyExpressionToStatementAction.cs" />
+    <Compile Include="Refactoring\CodeActions\ConvertLambdaBodyStatementToExpressionAction.cs" />
+    <Compile Include="Refactoring\CodeActions\ConvertSwitchToIfAction.cs" />
+    <Compile Include="Refactoring\CodeActions\CreateCustomEventImplementationAction.cs" />
+    <Compile Include="Refactoring\CodeActions\CreateOverloadWithoutParameterAction.cs" />
+    <Compile Include="Refactoring\CodeActions\JoinDeclarationAndAssignmentAction.cs" />
+    <Compile Include="Refactoring\CodeActions\JoinStringAction.cs" />
+    <Compile Include="Refactoring\CodeActions\MergeNestedIfAction.cs" />
+    <Compile Include="Refactoring\CodeActions\NegateRelationalExpressionAction.cs" />
+    <Compile Include="Refactoring\CodeActions\PutInsideUsingAction.cs" />
+    <Compile Include="Refactoring\CodeActions\SplitDeclarationListAction.cs" />
+    <Compile Include="Refactoring\CodeActions\UseStringFormatAction.cs" />
+    <Compile Include="Refactoring\CodeIssues\AccessToClosureIssues\AccessToClosureIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\AccessToClosureIssues\AccessToDisposedClosureIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\AccessToClosureIssues\AccessToModifiedClosureIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\AccessToClosureIssues\LocalVariableNamePicker.cs" />
+    <Compile Include="Refactoring\CodeIssues\AssignmentMadeToSameVariableIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\BitwiseOperationOnNonFlagsEnumIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\CastExpressionOfIncompatibleTypeIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\CompareBooleanWithTrueOrFalseIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\CompareFloatWithEqualityOperatorIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\ConstantConditionIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\DoubleNegationIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\ExpressionIsAlwaysOfProvidedTypeIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\ExpressionIsNeverOfProvidedTypeIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\MethodNeverReturnsIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\MethodOverloadHidesOptionalParameterIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\MissingStringComparisonIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\NegativeRelationalExpressionIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\ExplicitConversionInForEachIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\ForControlVariableNotModifiedIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\IdenticalConditionalBranchIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\MultipleEnumerationIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\RedundantArrayInitializerCommaIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\RedundantAssignmentIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\RedundantAttributeParenthesesIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\RedundantCaseLabelIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\RedundantElseIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\RedundantFieldInitializerIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\RedundantObjectCreationArgumentListIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\RedundantObjectOrCollectionInitializerIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\RedundantTypeCastIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\ReferenceEqualsCalledWithValueTypeIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\ResultOfAsyncCallShouldNotBeIgnoredIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\UnreachableCodeIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\VariableHidesMemberIssue\LocalVariableHidesMemberIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\VariableHidesMemberIssue\ParameterHidesMemberIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\VariableHidesMemberIssue\VariableHidesMemberIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\VariableNotUsedIssues\LocalVariableNotUsedIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\VariableNotUsedIssues\ParameterNotUsedIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\TypeParameterNotUsedIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\VariableOnlyAssignedIssues\ParameterOnlyAssignedIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\VariableOnlyAssignedIssues\VariableOnlyAssignedIssue.cs" />
+    <Compile Include="Refactoring\DocumentScript.cs" />
+    <Compile Include="Refactoring\CodeActions\ExtractAnonymousMethodAction.cs" />
+    <Compile Include="Refactoring\UsingHelper.cs" />
+    <Compile Include="Refactoring\LambdaHelper.cs" />
+    <Compile Include="Refactoring\PatternHelper.cs" />
+    <Compile Include="Refactoring\RefactoringAstHelper.cs" />
+    <Compile Include="Refactoring\RefactoringContext.cs" />
+    <Compile Include="Refactoring\Script.cs" />
+    <Compile Include="Refactoring\TypeSystemAstBuilder.cs" />
+    <Compile Include="Refactoring\VariableReferenceGraph.cs" />
+    <Compile Include="Resolver\CompositeResolveVisitorNavigator.cs" />
+    <Compile Include="Resolver\AwaitResolveResult.cs" />
+    <Compile Include="Resolver\DynamicInvocationResolveResult.cs" />
+    <Compile Include="Resolver\DynamicMemberResolveResult.cs" />
+    <Compile Include="Resolver\CSharpConversions.cs" />
+    <Compile Include="Resolver\CSharpAstResolver.cs" />
+    <Compile Include="Resolver\CSharpInvocationResolveResult.cs" />
+    <Compile Include="Resolver\CSharpOperators.cs" />
+    <Compile Include="Resolver\CSharpResolver.cs" />
+    <Compile Include="Resolver\DetectSkippableNodesNavigator.cs" />
+    <Compile Include="Resolver\FindReferencedEntities.cs" />
+    <Compile Include="Resolver\FindReferences.cs" />
+    <Compile Include="Resolver\FindReferenceSearchScope.cs" />
+    <Compile Include="Resolver\IResolveVisitorNavigator.cs" />
+    <Compile Include="Resolver\LambdaResolveResult.cs" />
+    <Compile Include="Resolver\Log.cs" />
+    <Compile Include="Resolver\MemberLookup.cs" />
+    <Compile Include="Resolver\MethodGroupResolveResult.cs" />
+    <Compile Include="Resolver\NodeListResolveVisitorNavigator.cs" />
+    <Compile Include="Resolver\OverloadResolution.cs" />
+    <Compile Include="Resolver\OverloadResolutionErrors.cs" />
+    <Compile Include="Resolver\ResolveAtLocation.cs" />
+    <Compile Include="Resolver\ResolveVisitor.cs" />
+    <Compile Include="Resolver\TypeInference.cs" />
+    <Compile Include="Completion\ICompletionDataFactory.cs" />
+    <Compile Include="Completion\IParameterCompletionDataFactory.cs" />
+    <Compile Include="NameLookupMode.cs" />
+    <Compile Include="TypeSystem\AliasNamespaceReference.cs" />
+    <Compile Include="TypeSystem\AttributeTypeReference.cs" />
+    <Compile Include="TypeSystem\ConstantValues.cs" />
+    <Compile Include="TypeSystem\CSharpAssembly.cs" />
+    <Compile Include="TypeSystem\CSharpAttribute.cs" />
+    <Compile Include="TypeSystem\CSharpDocumentationComment.cs" />
+    <Compile Include="TypeSystem\CSharpUnresolvedFile.cs" />
+    <Compile Include="TypeSystem\CSharpUnresolvedTypeDefinition.cs" />
+    <Compile Include="TypeSystem\CSharpTypeResolveContext.cs" />
+    <Compile Include="TypeSystem\ResolvedUsingScope.cs" />
+    <Compile Include="TypeSystem\TypeOrNamespaceReference.cs" />
+    <Compile Include="TypeSystem\MemberTypeOrNamespaceReference.cs" />
+    <Compile Include="TypeSystem\SimpleTypeOrNamespaceReference.cs" />
+    <Compile Include="TypeSystem\MethodTypeParameterWithInheritedConstraints.cs" />
+    <Compile Include="TypeSystem\TypeSystemConvertVisitor.cs" />
+    <Compile Include="TypeSystem\UsingScope.cs" />
+    <Compile Include="Ast\GeneralScope\PreProcessorDirective.cs" />
+    <Compile Include="Ast\Expressions\ErrorExpression.cs" />
+    <Compile Include="Completion\CompletionDataWrapper.cs" />
+    <Compile Include="Completion\CSharpCompletionEngine.cs" />
+    <Compile Include="Completion\CSharpCompletionEngineBase.cs" />
+    <Compile Include="Completion\CSharpParameterCompletionEngine.cs" />
+    <Compile Include="Parser\mcs\module.cs" />
+    <Compile Include="Parser\mcs\settings.cs" />
+    <Compile Include="Parser\mcs\SourceMethodBuilder.cs" />
+    <Compile Include="Ast\TokenRole.cs" />
+    <Compile Include="Ast\Roles.cs" />
+    <Compile Include="Refactoring\BaseRefactoringContext.cs" />
+    <Compile Include="Refactoring\CodeIssue.cs" />
+    <Compile Include="Refactoring\CodeAction.cs" />
+    <Compile Include="Refactoring\ICodeActionProvider.cs" />
+    <Compile Include="Refactoring\ICodeIssueProvider.cs" />
+    <Compile Include="Refactoring\ContextActionAttribute.cs" />
+    <Compile Include="Refactoring\IssueAttribute.cs" />
+    <Compile Include="Refactoring\CodeIssues\IssueCategories.cs" />
+    <Compile Include="Refactoring\Severity.cs" />
+    <Compile Include="Refactoring\IssueMarker.cs" />
+    <Compile Include="Refactoring\CodeIssues\GatherVisitorBase.cs" />
+    <Compile Include="Refactoring\CodeIssues\ConditionalToNullCoalescingIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\NotImplementedExceptionIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\RedundantInternalIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\RedundantNamespaceUsageIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\RedundantPrivateIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\RedundantThisIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\RedundantUsingIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\StringIsNullOrEmptyIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\UseVarKeywordIssue.cs" />
+    <Compile Include="Refactoring\CodeActions\UseVarKeywordAction.cs" />
+    <Compile Include="Refactoring\CodeActions\UseExplicitTypeAction.cs" />
+    <Compile Include="Refactoring\CodeActions\SplitStringAction.cs" />
+    <Compile Include="Refactoring\CodeActions\SplitDeclarationAndAssignmentAction.cs" />
+    <Compile Include="Refactoring\CodeActions\ReplaceEmptyStringAction.cs" />
+    <Compile Include="Refactoring\CodeActions\RemoveRegionAction.cs" />
+    <Compile Include="Refactoring\CodeActions\RemoveBracesAction.cs" />
+    <Compile Include="Refactoring\CodeActions\RemoveBackingStoreAction.cs" />
+    <Compile Include="Refactoring\CodeActions\InvertIfAction.cs" />
+    <Compile Include="Refactoring\CodeActions\IntroduceFormatItemAction.cs" />
+    <Compile Include="Refactoring\CodeActions\InsertAnonymousMethodSignatureAction.cs" />
+    <Compile Include="Refactoring\CodeActions\GenerateSwitchLabelsAction.cs" />
+    <Compile Include="Refactoring\CodeActions\GeneratePropertyAction.cs" />
+    <Compile Include="Refactoring\CodeActions\GenerateGetterAction.cs" />
+    <Compile Include="Refactoring\CodeActions\FlipOperatorArgumentsAction.cs" />
+    <Compile Include="Refactoring\CodeActions\CreatePropertyAction.cs" />
+    <Compile Include="Refactoring\CodeActions\CreateLocalVariableAction.cs" />
+    <Compile Include="Refactoring\CodeActions\CreateFieldAction.cs" />
+    <Compile Include="Refactoring\CodeActions\CreateEventInvocatorAction.cs" />
+    <Compile Include="Refactoring\CodeActions\CreateBackingStoreAction.cs" />
+    <Compile Include="Refactoring\CodeActions\ConvertHexToDecAction.cs" />
+    <Compile Include="Refactoring\CodeActions\ConvertForeachToForAction.cs" />
+    <Compile Include="Refactoring\CodeActions\ConvertDecToHexAction.cs" />
+    <Compile Include="Refactoring\CodeActions\CheckIfParameterIsNullAction.cs" />
+    <Compile Include="Refactoring\CodeActions\AddAnotherAccessorAction.cs" />
+    <Compile Include="Refactoring\CodeIssues\InconsistentNamingIssue\NamingStyle.cs" />
+    <Compile Include="Refactoring\CodeIssues\InconsistentNamingIssue\NamingRule.cs" />
+    <Compile Include="Refactoring\CodeIssues\InconsistentNamingIssue\AffectedEntity.cs" />
+    <Compile Include="Refactoring\CodeIssues\InconsistentNamingIssue\DefaultRules.cs" />
+    <Compile Include="Refactoring\CodeIssues\InconsistentNamingIssue\InconsistentNamingIssue.cs" />
+    <Compile Include="Refactoring\CodeActions\CreateMethodDeclarationAction.cs" />
+    <Compile Include="Refactoring\CodeIssues\InconsistentNamingIssue\NamingConventionService.cs" />
+    <Compile Include="Refactoring\CodeActions\CreateIndexerAction.cs" />
+    <Compile Include="Refactoring\CodeActions\InlineLocalVariableAction.cs" />
+    <Compile Include="Refactoring\CodeActions\DeclareLocalVariableAction.cs" />
+    <Compile Include="Refactoring\CodeIssues\InconsistentNamingIssue\WordParser.cs" />
+    <Compile Include="Refactoring\CodeActions\CreateConstructorDeclarationAction.cs" />
+    <Compile Include="Refactoring\CodeActions\CreateClassDeclarationAction.cs" />
+    <Compile Include="Refactoring\CodeActions\CreateDelegateAction.cs" />
+    <Compile Include="Formatter\TextEditorOptions.cs" />
+    <Compile Include="Refactoring\CodeActions\IntroduceConstantAction.cs" />
+    <Compile Include="Refactoring\CodeActions\ExtractMethod\ExtractMethodAction.cs" />
+    <Compile Include="Refactoring\CodeActions\ExtractMethod\StaticVisitor.cs" />
+    <Compile Include="Refactoring\CodeActions\ExtractMethod\VariableLookupVisitor.cs" />
+    <Compile Include="Refactoring\CodeActions\SpecializedCodeAction.cs" />
+    <Compile Include="Formatter\GeneratedCodeSettings.cs" />
+    <Compile Include="Ast\GeneralScope\NewLineNode.cs" />
+    <Compile Include="Ast\GeneralScope\WhitespaceNode.cs" />
+    <Compile Include="Ast\GeneralScope\TextNode.cs" />
+    <Compile Include="Formatter\FormattingOptionsFactory.cs" />
+    <Compile Include="Refactoring\CodeActions\ImplementInterfaceAction.cs" />
+    <Compile Include="Refactoring\CodeActions\ImplementInterfaceExplicitAction.cs" />
+    <Compile Include="Refactoring\CodeActions\ImplementAbstractMembersAction.cs" />
+    <Compile Include="Refactoring\CodeActions\RemoveRedundantCatchTypeAction.cs" />
+    <Compile Include="Refactoring\CodeActions\AddCatchTypeAction.cs" />
+    <Compile Include="Refactoring\CodeIssues\IncorrectExceptionParameterOrderingIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\CallToVirtualFunctionFromConstructorIssue.cs" />
+    <Compile Include="Refactoring\CodeActions\StaticMethodInvocationToExtensionMethodInvocationAction.cs" />
+    <Compile Include="Refactoring\CodeActions\ExtensionMethodInvocationToStaticMethodInvocationAction.cs" />
+    <Compile Include="Refactoring\CodeActions\IterateViaForeachAction.cs" />
+    <Compile Include="Refactoring\CodeActions\ExtractFieldAction.cs" />
+    <Compile Include="Completion\ICompletionContextProvider.cs" />
+    <Compile Include="Refactoring\CodeIssues\ValueParameterUnusedIssue.cs" />
+    <Compile Include="Refactoring\NamingHelper.cs" />
+    <Compile Include="Refactoring\CodeActions\ConvertToInitializer\ConvertToInitializerAction.cs" />
+    <Compile Include="Refactoring\CodeActions\ConvertToInitializer\StatementsToInitializerConverter.cs" />
+    <Compile Include="Refactoring\CodeActions\MoveToOuterScopeAction.cs" />
+    <Compile Include="Refactoring\CodeIssues\VariableDeclaredInWideScopeIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\ParameterCanBeDemotedIssue\ParameterCanBeDemotedIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\ParameterCanBeDemotedIssue\ITypeCriterion.cs" />
+    <Compile Include="Refactoring\CodeIssues\ParameterCanBeDemotedIssue\HasMemberCriterion.cs" />
+    <Compile Include="Refactoring\CodeIssues\ParameterCanBeDemotedIssue\TypeCriteriaCollector.cs" />
+    <Compile Include="Refactoring\CodeIssues\ReferenceToStaticMemberViaDerivedTypeIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\ParameterCanBeDemotedIssue\IsTypeCriterion.cs" />
+    <Compile Include="Refactoring\CodeIssues\OptionalParameterCouldBeSkippedIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\RedundantCatchIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\RedundantToStringIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\CallToObjectEqualsViaBaseIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\IncorrectCallToObjectGetHashCodeIssue.cs" />
+    <Compile Include="Refactoring\CodeActions\ExtractMethod\VariableUsageAnalyzation.cs" />
+    <Compile Include="Refactoring\CodeIssues\FormatStringIssues\FormatStringIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\FormatStringIssues\FormatStringHelper.cs" />
+    <Compile Include="Refactoring\CodeActions\ConvertToInitializer\ConvertInitializerToExplicitInitializationsAction.cs" />
+    <Compile Include="Refactoring\CodeIssues\ExceptionRethrowIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\ThreadStaticOnInstanceFieldIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\StaticFieldInGenericTypeIssue.cs" />
+    <Compile Include="Parser\SeekableStreamReader.cs" />
+    <Compile Include="Refactoring\CodeActions\ConvertAnonymousDelegateToLambdaAction.cs" />
+    <Compile Include="Refactoring\CodeActions\ConvertLambdaToAnonymousDelegateAction.cs" />
+    <Compile Include="Refactoring\CodeIssues\ParameterCanBeDemotedIssue\IsArrayTypeCriterion.cs" />
+    <Compile Include="Refactoring\CodeIssues\ParameterCanBeDemotedIssue\SupportsIndexingCriterion.cs" />
+    <Compile Include="Refactoring\CodeIssues\RedundantWhereWithPredicateIssue.cs" />
+    <Compile Include="Refactoring\CodeActions\ConvertToInitializer\AccessPath.cs" />
+    <Compile Include="Refactoring\LocalReferenceFinder.cs" />
+    <Compile Include="Refactoring\CodeActions\SortUsingsAction.cs" />
+    <Compile Include="Formatter\CSharpIndentEngine.cs" />
+    <Compile Include="Refactoring\CodeActions\CreateEnumValue.cs" />
+    <Compile Include="Resolver\AliasTypeResolveResult.cs" />
+    <Compile Include="Resolver\AliasNamespaceResolveResult.cs" />
+    <Compile Include="Resolver\ReducedExtensionMethod.cs" />
+    <Compile Include="Refactoring\CodeIssues\SimplifyAnonymousMethodToDelegateIssue.cs" />
+    <Compile Include="Refactoring\CodeIssues\CompilerErrors\CS0127ReturnMustNotBeFollowedByAnyExpression.cs" />
+    <Compile Include="Parser\mcs\ps-lang.cs" />
+    <Compile Include="Parser\mcs\ps-parser.cs" />
+    <Compile Include="Parser\mcs\ps-tokenizer.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\..\external\nrefactory\ICSharpCode.NRefactory\ICSharpCode.NRefactory.csproj">
+      <Project>{3B2A5653-EC97-4001-BB9B-D90F1AF2C371}</Project>
+      <Name>ICSharpCode.NRefactory</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.Targets" />
+  <ItemGroup>
+    <Folder Include="Completion\" />
+    <Folder Include="Refactoring\CodeIssues\" />
+    <Folder Include="Refactoring\CodeIssues\InconsistentNamingIssue\" />
+    <Folder Include="Refactoring\CodeActions\ExtractMethod\" />
+    <Folder Include="Refactoring\CodeActions\ConvertToInitializer\" />
+    <Folder Include="Refactoring\CodeIssues\FormatStringIssues\" />
+    <Folder Include="Refactoring\CodeIssues\CompilerErrors\" />
+  </ItemGroup>
+  <ProjectExtensions>
+    <MonoDevelop>
+      <Properties>
+        <Policies>
+          <TextStylePolicy TabsToSpaces="False" EolMarker="Unix" inheritsSet="VisualStudio" inheritsScope="text/plain" scope="text/plain" />
+          <TextStylePolicy FileWidth="120" TabsToSpaces="False" EolMarker="Unix" inheritsSet="VisualStudio" inheritsScope="text/plain" scope="text/x-csharp" />
+          <CSharpFormattingPolicy IndentSwitchBody="True" BeforeMethodDeclarationParentheses="False" BeforeMethodCallParentheses="False" BeforeConstructorDeclarationParentheses="False" BeforeDelegateDeclarationParentheses="False" NewParentheses="False" inheritsSet="Mono" inheritsScope="text/x-csharp" scope="text/x-csharp" />
+          <TextStylePolicy inheritsSet="null" scope="text/x-jay" />
+        </Policies>
+      </Properties>
+    </MonoDevelop>
+  </ProjectExtensions>
+  <ItemGroup>
+    <None Include="Parser\mcs\cs-parser.jay" />
+    <None Include="Parser\mcs\ps-parser.jay" />
+  </ItemGroup>
 </Project>
\ No newline at end of file
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Makefile ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Makefile
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Makefile	2013-04-23 21:04:54.000000000 -0700
@@ -0,0 +1,629 @@
+# Makefile.in generated by automake 1.12.2 from Makefile.am.
+# src/addins/ICSharpCode.NRefactory.PlayScript/Makefile.  Generated from Makefile.in by configure.
+
+# Copyright (C) 1994-2012 Free Software Foundation, Inc.
+
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
+pkgdatadir = $(datadir)/monodevelop
+pkgincludedir = $(includedir)/monodevelop
+pkglibdir = $(libdir)/monodevelop
+pkglibexecdir = $(libexecdir)/monodevelop
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
+	$(top_srcdir)/xbuild.include
+subdir = src/addins/ICSharpCode.NRefactory.PlayScript
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+SOURCES =
+DIST_SOURCES =
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-dvi-recursive install-exec-recursive \
+	install-html-recursive install-info-recursive \
+	install-pdf-recursive install-ps-recursive install-recursive \
+	installcheck-recursive installdirs-recursive pdf-recursive \
+	ps-recursive uninstall-recursive
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
+AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \
+	$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS \
+	distdir
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = $(SUBDIRS)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+am__relativize = \
+  dir0=`pwd`; \
+  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
+  sed_rest='s,^[^/]*/*,,'; \
+  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
+  sed_butlast='s,/*[^/]*$$,,'; \
+  while test -n "$$dir1"; do \
+    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
+    if test "$$first" != "."; then \
+      if test "$$first" = ".."; then \
+        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
+        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
+      else \
+        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
+        if test "$$first2" = "$$first"; then \
+          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
+        else \
+          dir2="../$$dir2"; \
+        fi; \
+        dir0="$$dir0"/"$$first"; \
+      fi; \
+    fi; \
+    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
+  done; \
+  reldir="$$dir2"
+ACLOCAL = ${SHELL} /Users/bcooley/projects/monodevelop-as3/main/missing --run aclocal-1.12
+ACLOCAL_FLAGS = -I /Library/Frameworks/Mono.framework/Versions/Current/share/aclocal
+ALL_LINGUAS = cs da de es fr ja pt_BR tr pl it zh_TW zh_CN ru sl ca gl pt sv nl id hu nb
+AMTAR = $${TAR-tar}
+ASSEMBLY_VERSION = 4.0.0.0
+AUTOCONF = ${SHELL} /Users/bcooley/projects/monodevelop-as3/main/missing --run autoconf
+AUTOHEADER = ${SHELL} /Users/bcooley/projects/monodevelop-as3/main/missing --run autoheader
+AUTOMAKE = ${SHELL} /Users/bcooley/projects/monodevelop-as3/main/missing --run automake-1.12
+AWK = gawk
+CSC = /Library/Frameworks/Mono.framework/Versions/Current/bin/dmcs
+CSC_FLAGS = -debug -codepage:utf8
+CYGPATH_W = echo
+DEFS = -DPACKAGE_NAME=\"monodevelop\" -DPACKAGE_TARNAME=\"monodevelop\" -DPACKAGE_VERSION=\"4.0.4\" -DPACKAGE_STRING=\"monodevelop\ 4.0.4\" -DPACKAGE_BUGREPORT=\"monodevelop-list@lists.ximian.com\" -DPACKAGE_URL=\"\" -DPACKAGE=\"monodevelop\" -DVERSION=\"4.0.4\" -DGETTEXT_PACKAGE=\"monodevelop\"
+DYLD_FALLBACK_LIBRARY_PATH = /Library/Frameworks/Mono.framework/Versions/Current/lib:/lib:/usr/lib
+ECHO_C = \c
+ECHO_N = 
+ECHO_T = 
+GCONF_SHARP_CFLAGS = 
+GCONF_SHARP_LIBS = 
+GETTEXT_PACKAGE = monodevelop
+GLADE_SHARP_CFLAGS = -I:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../share/gapi-2.0/glade-api.xml -I:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../share/gapi-2.0/pango-api.xml -I:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../share/gapi-2.0/atk-api.xml -I:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../share/gapi-2.0/gdk-api.xml -I:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../share/gapi-2.0/gtk-api.xml -I:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../share/gapi-2.0/glib-api.xml  
+GLADE_SHARP_LIBS = -r:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../lib/mono/gtk-sharp-2.0/glade-sharp.dll -r:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../lib/mono/gtk-sharp-2.0/pango-sharp.dll -r:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../lib/mono/gtk-sharp-2.0/atk-sharp.dll -r:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../lib/mono/gtk-sharp-2.0/gdk-sharp.dll -r:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../lib/mono/gtk-sharp-2.0/gtk-sharp.dll -r:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../lib/mono/gtk-sharp-2.0/glib-sharp.dll  
+GLIB_SHARP_CFLAGS = -I:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../share/gapi-2.0/glib-api.xml  
+GLIB_SHARP_LIBS = -r:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../lib/mono/gtk-sharp-2.0/glib-sharp.dll  
+GNOME_SHARP_CFLAGS = 
+GNOME_SHARP_LIBS = 
+GNOME_VFS_SHARP_CFLAGS = 
+GNOME_VFS_SHARP_LIBS = 
+GTK_SHARP_CFLAGS = -I:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../share/gapi-2.0/pango-api.xml -I:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../share/gapi-2.0/atk-api.xml -I:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../share/gapi-2.0/gdk-api.xml -I:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../share/gapi-2.0/gtk-api.xml -I:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../share/gapi-2.0/glib-api.xml  
+GTK_SHARP_LIBS = -r:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../lib/mono/gtk-sharp-2.0/pango-sharp.dll -r:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../lib/mono/gtk-sharp-2.0/atk-sharp.dll -r:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../lib/mono/gtk-sharp-2.0/gdk-sharp.dll -r:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../lib/mono/gtk-sharp-2.0/gtk-sharp.dll -r:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../lib/mono/gtk-sharp-2.0/glib-sharp.dll  
+INSTALL = /usr/bin/install -c
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_STRIP_PROGRAM = $(install_sh) -c -s
+LD_LIBRARY_PATH = 
+LIBOBJS = 
+LIBS = 
+LIB_PREFIX = 
+LIB_SUFFIX = .dylib
+LTLIBOBJS = 
+MAINT = 
+MAKEINFO = ${SHELL} /Users/bcooley/projects/monodevelop-as3/main/missing --run makeinfo
+MCS = /Library/Frameworks/Mono.framework/Versions/Current/bin/gmcs
+MD_ADDIN_DIR = $(prefix)/lib/monodevelop/AddIns
+MD_ASSEMBLY_DIR = $(prefix)/lib/monodevelop/bin
+MD_DIR = $(prefix)/lib/monodevelop
+MKDIR_P = ../../.././install-sh -c -d
+MONO = /Library/Frameworks/Mono.framework/Versions/Current/bin/mono
+MONODOC_CFLAGS =  
+MONODOC_LIBS = /r:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/mono/monodoc/monodoc.dll  
+MONO_GAC_PREFIX = /usr/local:
+MONO_NUNIT_CFLAGS =  
+MONO_NUNIT_LIBS = -r:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../lib/mono/2.0/nunit.core.dll -r:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../lib/mono/2.0/nunit.core.interfaces.dll -r:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../lib/mono/2.0/nunit.core.extensions.dll -r:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../lib/mono/2.0/nunit.framework.dll -r:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../lib/mono/2.0/nunit.framework.extensions.dll -r:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../lib/mono/2.0/nunit.mocks.dll -r:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../lib/mono/2.0/nunit.util.dll -r:/Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../../lib/mono/2.0/nunit-console-runner.dll  
+MSGFMT = /Library/Frameworks/Mono.framework/Versions/Current/bin/msgfmt
+MSGMERGE = /Library/Frameworks/Mono.framework/Versions/Current/bin/msgmerge
+PACKAGE = monodevelop
+PACKAGE_BUGREPORT = monodevelop-list@lists.ximian.com
+PACKAGE_NAME = monodevelop
+PACKAGE_STRING = monodevelop 4.0.4
+PACKAGE_TARNAME = monodevelop
+PACKAGE_URL = 
+PACKAGE_VERSION = 4.0.4
+PACKAGE_VERSION_LABEL = 4.0.4
+PATH = /Library/Frameworks/Mono.framework/Versions/Current/bin:/opt/local/bin:/opt/local/sbin:/Applications/Adobe Flash Builder 4.7/sdks/4.6.0/bin:~flascc/sdk/usr/bin:/Library/Frameworks/Mono.framework/Versions/Current/bin:/Developer/MonoTouch/usr/bin:/Developer/MonoAndroid/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/X11/bin
+PATH_SEPARATOR = :
+PKG_CONFIG = /Library/Frameworks/Mono.framework/Versions/Current/bin/pkg-config
+PKG_CONFIG_LIBDIR = 
+PKG_CONFIG_PATH = /Users/bcooley/projects/monodevelop-as3/local-config:/usr/local/lib/pkgconfig:/usr/local/share/pkgconfig:
+RUNTIME = /Library/Frameworks/Mono.framework/Versions/Current/bin/mono
+SET_MAKE = 
+SHELL = /bin/sh
+SQLITE_XML = 
+STRIP = 
+UNMANAGED_DEPENDENCIES_MONO_CFLAGS =  
+UNMANAGED_DEPENDENCIES_MONO_LIBS =  
+UPDATE_DESKTOP_DB = 
+UPDATE_MIME_DB = 
+VERSION = 4.0.4
+abs_builddir = /Users/bcooley/projects/monodevelop-as3/main/src/addins/ICSharpCode.NRefactory.PlayScript
+abs_srcdir = /Users/bcooley/projects/monodevelop-as3/main/src/addins/ICSharpCode.NRefactory.PlayScript
+abs_top_builddir = /Users/bcooley/projects/monodevelop-as3/main
+abs_top_srcdir = /Users/bcooley/projects/monodevelop-as3/main
+am__leading_dot = .
+am__tar = false
+am__untar = false
+bindir = ${exec_prefix}/bin
+build_alias = 
+builddir = .
+datadir = ${datarootdir}
+datarootdir = ${prefix}/share
+docdir = ${datarootdir}/doc/${PACKAGE_TARNAME}
+dvidir = ${docdir}
+exec_prefix = ${prefix}
+gtksharp_prefix = /Library/Frameworks/Mono.framework/Versions/3.0.10/lib/pkgconfig/../..
+host_alias = 
+htmldir = ${docdir}
+includedir = ${prefix}/include
+infodir = ${datarootdir}/info
+install_sh = ${SHELL} /Users/bcooley/projects/monodevelop-as3/main/install-sh
+libdir = ${exec_prefix}/lib
+libexecdir = ${exec_prefix}/libexec
+localedir = ${datarootdir}/locale
+localstatedir = ${prefix}/var
+mandir = ${datarootdir}/man
+mkdir_p = $(MKDIR_P)
+oldincludedir = /usr/include
+pdfdir = ${docdir}
+prefix = /usr/local
+program_transform_name = s,x,x,
+psdir = ${docdir}
+sbindir = ${exec_prefix}/sbin
+sharedstatedir = ${prefix}/com
+srcdir = .
+sysconfdir = ${prefix}/etc
+target_alias = 
+top_build_prefix = ../../../
+top_builddir = ../../..
+top_srcdir = ../../..
+SUBDIRS = .
+ALL_CSPROJ = $(wildcard *.csproj)
+MAIN_SLN = $(top_builddir)/Main.sln
+#PROFILE_NAME = Debug
+PROFILE_NAME = DebugMac
+#PROFILE_NAME = DebugWin32
+XBUILD = xbuild
+XBUILD_VERBOSITY = quiet
+XBUILD_ARGS = /verbosity:$(XBUILD_VERBOSITY) /nologo /property:CodePage=65001
+XBUILD_PROFILE = /property:Configuration=$(PROFILE_NAME)
+
+# Figure out how far we are from top_builddir
+DEPTH = $(shell echo "$(top_builddir)" | tr '/' '\n' | grep -c '..')
+EXTS := *.bmp *.cs *.csproj *.html *.png *.snk *.config *.stetic *.glade *.xml *.xsd *.exe.addins *.template *.tt *.txt
+ALL_FILES := $(EXTS) \
+		$(addprefix */,$(EXTS))		\
+		$(addprefix */*/,$(EXTS))	\
+		$(addprefix */*/*/,$(EXTS))	\
+		$(addprefix */*/*/*/,$(EXTS))	\
+		$(addprefix */*/*/*/*/,$(EXTS))	\
+		$(wildcard icons/*)		\
+		$(wildcard templates/*)
+
+WILDCARDED_FILES := $(wildcard $(ALL_FILES))
+EXTRA_DIST = \
+	$(wildcard $(ALL_FILES))
+
+TESTFILES = 
+TESTDLLS = \
+	$(NUNIT_LIBS)
+
+TESTASSEMBLY = $(top_builddir)/build/bin/ICSharpCode.NRefactory.PlayScript.Test.dll
+CLEANFILES = $(PARSE) $(PARSE).mdb
+all: all-recursive
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am $(top_srcdir)/xbuild.include $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/addins/ICSharpCode.NRefactory.PlayScript/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/addins/ICSharpCode.NRefactory.PlayScript/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+$(top_srcdir)/xbuild.include:
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run 'make' without going through this Makefile.
+# To change the values of 'make' variables: instead of editing Makefiles,
+# (1) if the variable is set in 'config.status', edit 'config.status'
+#     (which will cause the Makefiles to be regenerated when you run 'make');
+# (2) otherwise, pass the desired values on the 'make' command line.
+$(RECURSIVE_TARGETS) $(RECURSIVE_CLEAN_TARGETS):
+	@fail= failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+cscopelist-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) cscopelist); \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+cscopelist: cscopelist-recursive $(HEADERS) $(SOURCES) $(LISP)
+	list='$(SOURCES) $(HEADERS) $(LISP)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    $(am__make_dryrun) \
+	      || test -d "$(distdir)/$$subdir" \
+	      || $(MKDIR_P) "$(distdir)/$$subdir" \
+	      || exit 1; \
+	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
+	    $(am__relativize); \
+	    new_distdir=$$reldir; \
+	    dir1=$$subdir; dir2="$(top_distdir)"; \
+	    $(am__relativize); \
+	    new_top_distdir=$$reldir; \
+	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
+	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
+	    ($(am__cd) $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$new_top_distdir" \
+	        distdir="$$new_distdir" \
+		am__remove_distdir=: \
+		am__skip_length_check=: \
+		am__skip_mode_fix=: \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-recursive
+all-am: Makefile
+installdirs: installdirs-recursive
+installdirs-am:
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
+mostlyclean-generic:
+
+clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean-am: clean-generic mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+html-am:
+
+info: info-recursive
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-recursive
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-recursive
+
+install-html-am:
+
+install-info: install-info-recursive
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-recursive
+
+install-pdf-am:
+
+install-ps: install-ps-recursive
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-generic
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) \
+	cscopelist-recursive ctags-recursive install-am install-strip \
+	tags-recursive
+
+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
+	all all-am check check-am clean clean-generic cscopelist \
+	cscopelist-recursive ctags ctags-recursive distclean \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs installdirs-am maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic pdf \
+	pdf-am ps ps-am tags tags-recursive uninstall uninstall-am
+
+
+all: csproj_build
+
+clean: csproj_clean
+
+csproj_build:
+	@if test x$(SKIP) != xy -a $(DEPTH) -gt $(MAKELEVEL); then \
+	echo Building $(ALL_CSPROJ); \
+	for p in $(ALL_CSPROJ); do $(XBUILD) $(XBUILD_ARGS) $$p; done \
+	fi
+
+csproj_clean:
+	@if test x$(SKIP) != xy -a $(DEPTH) -gt $(MAKELEVEL); then \
+	echo Cleaning $(ALL_CSPROJ); \
+	for p in $(ALL_CSPROJ); do $(XBUILD) $(XBUILD_ARGS) $$p /t:Clean; done \
+	fi
+
+sln_build:
+	@echo Building $(MAIN_SLN)
+	$(XBUILD) $(XBUILD_ARGS) $(MAIN_SLN) $(XBUILD_PROFILE)
+
+sln_clean:
+	@echo Cleaning $(MAIN_SLN)
+	$(XBUILD) $(XBUILD_ARGS) $(MAIN_SLN) $(XBUILD_PROFILE) /t:Clean
+
+print_extradist:
+	@echo $(WILDCARDED_FILES)
+
+.PHONY: all clean csproj_build csproj_clean sln_build sln_clean
+
+$(TESTASSEMBLY) : $(build_test_sources) $(build_resources)
+	$(CSC) $(CSC_FLAGS) -debug "-define:GMCS_SOURCE;NET_2_0;MS_COMPATIBLE;FULL_AST;BOOTSTRAP_BASIC" -unsafe  -codepage:utf8 -out:$@ -target:library $(DLLS) $(TESTDLLS) $(REFS) /r:$(ASSEMBLY) \
+	$(monodoc_libflags) $(build_resources:%=/resource:%) $(build_test_sources)
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Makefile.am ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Makefile.am
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Makefile.am	1969-12-31 16:00:00.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Makefile.am	2013-04-23 21:04:54.000000000 -0700
@@ -0,0 +1,16 @@
+SUBDIRS = .
+
+include $(top_srcdir)/xbuild.include
+
+TESTFILES =  
+
+TESTDLLS = \
+	$(NUNIT_LIBS)
+
+TESTASSEMBLY = $(top_builddir)/build/bin/ICSharpCode.NRefactory.PlayScript.Test.dll
+
+$(TESTASSEMBLY) : $(build_test_sources) $(build_resources)
+	$(CSC) $(CSC_FLAGS) -debug "-define:GMCS_SOURCE;NET_2_0;MS_COMPATIBLE;FULL_AST;BOOTSTRAP_BASIC" -unsafe  -codepage:utf8 -out:$@ -target:library $(DLLS) $(TESTDLLS) $(REFS) /r:$(ASSEMBLY) \
+	$(monodoc_libflags) $(build_resources:%=/resource:%) $(build_test_sources)
+
+CLEANFILES = $(PARSE) $(PARSE).mdb
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Makefile.in ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Makefile.in
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Makefile.in	1969-12-31 16:00:00.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Makefile.in	2013-04-23 21:04:54.000000000 -0700
@@ -0,0 +1,629 @@
+# Makefile.in generated by automake 1.12.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994-2012 Free Software Foundation, Inc.
+
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
+	$(top_srcdir)/xbuild.include
+subdir = src/addins/ICSharpCode.NRefactory.PlayScript
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+SOURCES =
+DIST_SOURCES =
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-dvi-recursive install-exec-recursive \
+	install-html-recursive install-info-recursive \
+	install-pdf-recursive install-ps-recursive install-recursive \
+	installcheck-recursive installdirs-recursive pdf-recursive \
+	ps-recursive uninstall-recursive
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
+AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \
+	$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS \
+	distdir
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = $(SUBDIRS)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+am__relativize = \
+  dir0=`pwd`; \
+  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
+  sed_rest='s,^[^/]*/*,,'; \
+  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
+  sed_butlast='s,/*[^/]*$$,,'; \
+  while test -n "$$dir1"; do \
+    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
+    if test "$$first" != "."; then \
+      if test "$$first" = ".."; then \
+        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
+        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
+      else \
+        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
+        if test "$$first2" = "$$first"; then \
+          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
+        else \
+          dir2="../$$dir2"; \
+        fi; \
+        dir0="$$dir0"/"$$first"; \
+      fi; \
+    fi; \
+    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
+  done; \
+  reldir="$$dir2"
+ACLOCAL = @ACLOCAL@
+ACLOCAL_FLAGS = @ACLOCAL_FLAGS@
+ALL_LINGUAS = @ALL_LINGUAS@
+AMTAR = @AMTAR@
+ASSEMBLY_VERSION = @ASSEMBLY_VERSION@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CSC = @CSC@
+CSC_FLAGS = @CSC_FLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DYLD_FALLBACK_LIBRARY_PATH = @DYLD_FALLBACK_LIBRARY_PATH@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+GCONF_SHARP_CFLAGS = @GCONF_SHARP_CFLAGS@
+GCONF_SHARP_LIBS = @GCONF_SHARP_LIBS@
+GETTEXT_PACKAGE = @GETTEXT_PACKAGE@
+GLADE_SHARP_CFLAGS = @GLADE_SHARP_CFLAGS@
+GLADE_SHARP_LIBS = @GLADE_SHARP_LIBS@
+GLIB_SHARP_CFLAGS = @GLIB_SHARP_CFLAGS@
+GLIB_SHARP_LIBS = @GLIB_SHARP_LIBS@
+GNOME_SHARP_CFLAGS = @GNOME_SHARP_CFLAGS@
+GNOME_SHARP_LIBS = @GNOME_SHARP_LIBS@
+GNOME_VFS_SHARP_CFLAGS = @GNOME_VFS_SHARP_CFLAGS@
+GNOME_VFS_SHARP_LIBS = @GNOME_VFS_SHARP_LIBS@
+GTK_SHARP_CFLAGS = @GTK_SHARP_CFLAGS@
+GTK_SHARP_LIBS = @GTK_SHARP_LIBS@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD_LIBRARY_PATH = @LD_LIBRARY_PATH@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIB_PREFIX = @LIB_PREFIX@
+LIB_SUFFIX = @LIB_SUFFIX@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MCS = @MCS@
+MD_ADDIN_DIR = @MD_ADDIN_DIR@
+MD_ASSEMBLY_DIR = @MD_ASSEMBLY_DIR@
+MD_DIR = @MD_DIR@
+MKDIR_P = @MKDIR_P@
+MONO = @MONO@
+MONODOC_CFLAGS = @MONODOC_CFLAGS@
+MONODOC_LIBS = @MONODOC_LIBS@
+MONO_GAC_PREFIX = @MONO_GAC_PREFIX@
+MONO_NUNIT_CFLAGS = @MONO_NUNIT_CFLAGS@
+MONO_NUNIT_LIBS = @MONO_NUNIT_LIBS@
+MSGFMT = @MSGFMT@
+MSGMERGE = @MSGMERGE@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PACKAGE_VERSION_LABEL = @PACKAGE_VERSION_LABEL@
+PATH = @PATH@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PKG_CONFIG = @PKG_CONFIG@
+PKG_CONFIG_LIBDIR = @PKG_CONFIG_LIBDIR@
+PKG_CONFIG_PATH = @PKG_CONFIG_PATH@
+RUNTIME = @RUNTIME@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SQLITE_XML = @SQLITE_XML@
+STRIP = @STRIP@
+UNMANAGED_DEPENDENCIES_MONO_CFLAGS = @UNMANAGED_DEPENDENCIES_MONO_CFLAGS@
+UNMANAGED_DEPENDENCIES_MONO_LIBS = @UNMANAGED_DEPENDENCIES_MONO_LIBS@
+UPDATE_DESKTOP_DB = @UPDATE_DESKTOP_DB@
+UPDATE_MIME_DB = @UPDATE_MIME_DB@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+am__leading_dot = @am__leading_dot@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build_alias = @build_alias@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+gtksharp_prefix = @gtksharp_prefix@
+host_alias = @host_alias@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+SUBDIRS = .
+ALL_CSPROJ = $(wildcard *.csproj)
+MAIN_SLN = $(top_builddir)/Main.sln
+@ENABLE_GNOMEPLATFORM_TRUE@PROFILE_NAME = Debug
+@ENABLE_MACPLATFORM_TRUE@PROFILE_NAME = DebugMac
+@ENABLE_WINDOWSPLATFORM_TRUE@PROFILE_NAME = DebugWin32
+XBUILD = xbuild
+XBUILD_VERBOSITY = quiet
+XBUILD_ARGS = /verbosity:$(XBUILD_VERBOSITY) /nologo /property:CodePage=65001
+XBUILD_PROFILE = /property:Configuration=$(PROFILE_NAME)
+
+# Figure out how far we are from top_builddir
+DEPTH = $(shell echo "$(top_builddir)" | tr '/' '\n' | grep -c '..')
+EXTS := *.bmp *.cs *.csproj *.html *.png *.snk *.config *.stetic *.glade *.xml *.xsd *.exe.addins *.template *.tt *.txt
+ALL_FILES := $(EXTS) \
+		$(addprefix */,$(EXTS))		\
+		$(addprefix */*/,$(EXTS))	\
+		$(addprefix */*/*/,$(EXTS))	\
+		$(addprefix */*/*/*/,$(EXTS))	\
+		$(addprefix */*/*/*/*/,$(EXTS))	\
+		$(wildcard icons/*)		\
+		$(wildcard templates/*)
+
+WILDCARDED_FILES := $(wildcard $(ALL_FILES))
+EXTRA_DIST = \
+	$(wildcard $(ALL_FILES))
+
+TESTFILES = 
+TESTDLLS = \
+	$(NUNIT_LIBS)
+
+TESTASSEMBLY = $(top_builddir)/build/bin/ICSharpCode.NRefactory.PlayScript.Test.dll
+CLEANFILES = $(PARSE) $(PARSE).mdb
+all: all-recursive
+
+.SUFFIXES:
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/xbuild.include $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/addins/ICSharpCode.NRefactory.PlayScript/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/addins/ICSharpCode.NRefactory.PlayScript/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+$(top_srcdir)/xbuild.include:
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run 'make' without going through this Makefile.
+# To change the values of 'make' variables: instead of editing Makefiles,
+# (1) if the variable is set in 'config.status', edit 'config.status'
+#     (which will cause the Makefiles to be regenerated when you run 'make');
+# (2) otherwise, pass the desired values on the 'make' command line.
+$(RECURSIVE_TARGETS) $(RECURSIVE_CLEAN_TARGETS):
+	@fail= failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+cscopelist-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) cscopelist); \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+cscopelist: cscopelist-recursive $(HEADERS) $(SOURCES) $(LISP)
+	list='$(SOURCES) $(HEADERS) $(LISP)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    $(am__make_dryrun) \
+	      || test -d "$(distdir)/$$subdir" \
+	      || $(MKDIR_P) "$(distdir)/$$subdir" \
+	      || exit 1; \
+	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
+	    $(am__relativize); \
+	    new_distdir=$$reldir; \
+	    dir1=$$subdir; dir2="$(top_distdir)"; \
+	    $(am__relativize); \
+	    new_top_distdir=$$reldir; \
+	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
+	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
+	    ($(am__cd) $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$new_top_distdir" \
+	        distdir="$$new_distdir" \
+		am__remove_distdir=: \
+		am__skip_length_check=: \
+		am__skip_mode_fix=: \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-recursive
+all-am: Makefile
+installdirs: installdirs-recursive
+installdirs-am:
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
+mostlyclean-generic:
+
+clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean-am: clean-generic mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+html-am:
+
+info: info-recursive
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-recursive
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-recursive
+
+install-html-am:
+
+install-info: install-info-recursive
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-recursive
+
+install-pdf-am:
+
+install-ps: install-ps-recursive
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-generic
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) \
+	cscopelist-recursive ctags-recursive install-am install-strip \
+	tags-recursive
+
+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
+	all all-am check check-am clean clean-generic cscopelist \
+	cscopelist-recursive ctags ctags-recursive distclean \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs installdirs-am maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic pdf \
+	pdf-am ps ps-am tags tags-recursive uninstall uninstall-am
+
+
+all: csproj_build
+
+clean: csproj_clean
+
+csproj_build:
+	@if test x$(SKIP) != xy -a $(DEPTH) -gt $(MAKELEVEL); then \
+	echo Building $(ALL_CSPROJ); \
+	for p in $(ALL_CSPROJ); do $(XBUILD) $(XBUILD_ARGS) $$p; done \
+	fi
+
+csproj_clean:
+	@if test x$(SKIP) != xy -a $(DEPTH) -gt $(MAKELEVEL); then \
+	echo Cleaning $(ALL_CSPROJ); \
+	for p in $(ALL_CSPROJ); do $(XBUILD) $(XBUILD_ARGS) $$p /t:Clean; done \
+	fi
+
+sln_build:
+	@echo Building $(MAIN_SLN)
+	$(XBUILD) $(XBUILD_ARGS) $(MAIN_SLN) $(XBUILD_PROFILE)
+
+sln_clean:
+	@echo Cleaning $(MAIN_SLN)
+	$(XBUILD) $(XBUILD_ARGS) $(MAIN_SLN) $(XBUILD_PROFILE) /t:Clean
+
+print_extradist:
+	@echo $(WILDCARDED_FILES)
+
+.PHONY: all clean csproj_build csproj_clean sln_build sln_clean
+
+$(TESTASSEMBLY) : $(build_test_sources) $(build_resources)
+	$(CSC) $(CSC_FLAGS) -debug "-define:GMCS_SOURCE;NET_2_0;MS_COMPATIBLE;FULL_AST;BOOTSTRAP_BASIC" -unsafe  -codepage:utf8 -out:$@ -target:library $(DLLS) $(TESTDLLS) $(REFS) /r:$(ASSEMBLY) \
+	$(monodoc_libflags) $(build_resources:%=/resource:%) $(build_test_sources)
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/NameLookupMode.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/NameLookupMode.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/NameLookupMode.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/NameLookupMode.cs	2013-04-23 21:04:54.000000000 -0700
@@ -18,7 +18,7 @@
 
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public enum NameLookupMode
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/OutputVisitor/CSharpAmbience.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/OutputVisitor/CSharpAmbience.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/OutputVisitor/CSharpAmbience.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/OutputVisitor/CSharpAmbience.cs	2013-04-23 21:04:54.000000000 -0700
@@ -18,10 +18,10 @@
 
 using System;
 using System.IO;
-using ICSharpCode.NRefactory.CSharp.Refactoring;
+using ICSharpCode.NRefactory.PlayScript.Refactoring;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// C# ambience.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/OutputVisitor/CSharpOutputVisitor.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/OutputVisitor/CSharpOutputVisitor.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/OutputVisitor/CSharpOutputVisitor.cs	2013-03-14 23:31:36.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/OutputVisitor/CSharpOutputVisitor.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@ using System.Threading.Tasks;
 using ICSharpCode.NRefactory.PatternMatching;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Outputs the AST.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/OutputVisitor/CodeDomConvertVisitor.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/OutputVisitor/CodeDomConvertVisitor.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/OutputVisitor/CodeDomConvertVisitor.cs	2013-03-14 23:31:36.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/OutputVisitor/CodeDomConvertVisitor.cs	2013-04-23 21:04:54.000000000 -0700
@@ -21,14 +21,14 @@ using System.CodeDom;
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
-using ICSharpCode.NRefactory.CSharp.Refactoring;
-using ICSharpCode.NRefactory.CSharp.Resolver;
-using ICSharpCode.NRefactory.CSharp.TypeSystem;
+using ICSharpCode.NRefactory.PlayScript.Refactoring;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
+using ICSharpCode.NRefactory.PlayScript.TypeSystem;
 using ICSharpCode.NRefactory.PatternMatching;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Converts from C# AST to CodeDom.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/OutputVisitor/IOutputFormatter.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/OutputVisitor/IOutputFormatter.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/OutputVisitor/IOutputFormatter.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/OutputVisitor/IOutputFormatter.cs	2013-04-23 21:04:54.000000000 -0700
@@ -18,7 +18,7 @@
 
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Output formatter for the Output visitor.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/OutputVisitor/InsertParenthesesVisitor.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/OutputVisitor/InsertParenthesesVisitor.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/OutputVisitor/InsertParenthesesVisitor.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/OutputVisitor/InsertParenthesesVisitor.cs	2013-04-23 21:04:54.000000000 -0700
@@ -18,7 +18,7 @@
 
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Inserts the parentheses into the AST that are needed to ensure the AST can be printed correctly.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/OutputVisitor/TextWriterOutputFormatter.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/OutputVisitor/TextWriterOutputFormatter.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/OutputVisitor/TextWriterOutputFormatter.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/OutputVisitor/TextWriterOutputFormatter.cs	2013-04-23 21:04:54.000000000 -0700
@@ -19,7 +19,7 @@
 using System;
 using System.IO;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// Writes C# code into a TextWriter.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/CSharpParser.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/CSharpParser.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/CSharpParser.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/CSharpParser.cs	2013-04-23 21:04:54.000000000 -0700
@@ -1,5 +1,5 @@
 ﻿// 
-// CSharpParser.cs
+// PlayScriptParser.cs
 //
 // Author:
 //       Mike Krüger <mkrueger@novell.com>
@@ -29,12 +29,13 @@ using System.Collections.Generic;
 using System.IO;
 using System.Text;
 using ICSharpCode.NRefactory.Editor;
-using Mono.CSharp;
+using Mono.CSharpPs;
+using Mono.PlayScript;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
-	public class CSharpParser
+	public class PlayScriptParser
 	{
 		CompilerSettings compilerSettings;
 		
@@ -63,7 +64,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				this.LocationsBag = locationsBag;
 			}
 			
-			public static TextLocation Convert (Mono.CSharp.Location loc)
+			public static TextLocation Convert (Mono.CSharpPs.Location loc)
 			{
 				return new TextLocation (loc.Row, loc.Column);
 			}
@@ -184,18 +185,18 @@ namespace ICSharpCode.NRefactory.CSharp
 				return result;
 			}
 			
-			AstType ConvertToType (Mono.CSharp.Expression typeName)
+			AstType ConvertToType (Mono.CSharpPs.Expression typeName)
 			{
 				if (typeName == null) // may happen in typeof(Generic<,,,,>)
 					return new SimpleType ();
 				
 				if (typeName is TypeExpression) {
-					var typeExpr = (Mono.CSharp.TypeExpression)typeName;
+					var typeExpr = (Mono.CSharpPs.TypeExpression)typeName;
 					return new PrimitiveType (typeExpr.GetSignatureForError (), Convert (typeExpr.Location));
 				}
 				
-				if (typeName is Mono.CSharp.QualifiedAliasMember) {
-					var qam = (Mono.CSharp.QualifiedAliasMember)typeName;
+				if (typeName is Mono.CSharpPs.QualifiedAliasMember) {
+					var qam = (Mono.CSharpPs.QualifiedAliasMember)typeName;
 					var loc = LocationsBag.GetLocations (typeName);
 					var memberType = new MemberType ();
 					memberType.Target = new SimpleType (qam.alias, Convert (qam.Location));
@@ -267,7 +268,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return new SimpleType ("unknown");
 			}
 			
-			IEnumerable<Attribute> GetAttributes (IEnumerable<Mono.CSharp.Attribute> optAttributes)
+			IEnumerable<Attribute> GetAttributes (IEnumerable<Mono.CSharpPs.Attribute> optAttributes)
 			{
 				if (optAttributes == null)
 					yield break;
@@ -323,7 +324,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				}
 			}
 			
-			AttributeSection ConvertAttributeSection (IEnumerable<Mono.CSharp.Attribute> optAttributes)
+			AttributeSection ConvertAttributeSection (IEnumerable<Mono.CSharpPs.Attribute> optAttributes)
 			{
 				if (optAttributes == null)
 					return null;
@@ -518,7 +519,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				
 				if (c.TypeBaseExpressions != null) {
 					if (location != null && curLoc < location.Count)
-						newType.AddChild (new CSharpTokenNode (Convert (location [curLoc++]), Roles.Colon), Roles.Colon);
+						newType.AddChild (new CSharpTokenNode (Convert (location [curLoc++]), Roles.ClassKeyword), Roles.ClassKeyword);
 					
 					var commaLocations = LocationsBag.GetLocations (c.TypeBaseExpressions);
 					int i = 0;
@@ -567,7 +568,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				
 				if (s.TypeBaseExpressions != null) {
 					if (location != null && curLoc < location.Count)
-						newType.AddChild (new CSharpTokenNode (Convert (location [curLoc++]), Roles.Colon), Roles.Colon);
+						newType.AddChild (new CSharpTokenNode (Convert (location [curLoc++]), Roles.ClassKeyword), Roles.ClassKeyword);
 					var commaLocations = LocationsBag.GetLocations (s.TypeBaseExpressions);
 					int i = 0;
 					foreach (var baseTypes in s.TypeBaseExpressions) {
@@ -612,7 +613,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				
 				if (i.TypeBaseExpressions != null) {
 					if (location != null && curLoc < location.Count)
-						newType.AddChild (new CSharpTokenNode (Convert (location [curLoc++]), Roles.Colon), Roles.Colon);
+						newType.AddChild (new CSharpTokenNode (Convert (location [curLoc++]), Roles.ClassKeyword), Roles.ClassKeyword);
 					var commaLocations = LocationsBag.GetLocations (i.TypeBaseExpressions);
 					int j = 0;
 					foreach (var baseTypes in i.TypeBaseExpressions) {
@@ -642,7 +643,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				AddType (newType);
 			}
 			
-			public override void Visit(Mono.CSharp.Delegate d)
+			public override void Visit(Mono.CSharpPs.Delegate d)
 			{
 				DelegateDeclaration newDelegate = new DelegateDeclaration ();
 				var location = LocationsBag.GetMemberLocation(d);
@@ -688,7 +689,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				}
 			}
 			
-			public override void Visit(Mono.CSharp.Enum e)
+			public override void Visit(Mono.CSharpPs.Enum e)
 			{
 				var newType = new TypeDeclaration();
 				newType.ClassType = ClassType.Enum;
@@ -1026,12 +1027,13 @@ namespace ICSharpCode.NRefactory.CSharp
 				AddAttributeSection (newMethod, m);
 				var location = LocationsBag.GetMemberLocation (m);
 				AddModifiers (newMethod, location);
-				newMethod.AddChild (ConvertToType (m.TypeExpression), Roles.Type);
 				AddExplicitInterface (newMethod, m.MethodName);
 				newMethod.AddChild (Identifier.Create (m.MethodName.Name, Convert (m.Location)), Roles.Identifier);
 				
 				AddTypeParameters (newMethod, m.MemberName);
-				
+
+				newMethod.AddChild (ConvertToType (m.TypeExpression), Roles.Type);
+
 				if (location != null && location.Count > 0)
 					newMethod.AddChild (new CSharpTokenNode (Convert (location [0]), Roles.LPar), Roles.LPar);
 				AddParameter (newMethod, m.ParameterInfo);
@@ -1059,27 +1061,27 @@ namespace ICSharpCode.NRefactory.CSharp
 				typeStack.Peek ().AddChild (newMethod, Roles.TypeMemberRole);
 			}
 			
-			static Dictionary<Mono.CSharp.Modifiers, ICSharpCode.NRefactory.CSharp.Modifiers> modifierTable = new Dictionary<Mono.CSharp.Modifiers, ICSharpCode.NRefactory.CSharp.Modifiers> ();
+			static Dictionary<Mono.CSharpPs.Modifiers, ICSharpCode.NRefactory.PlayScript.Modifiers> modifierTable = new Dictionary<Mono.CSharpPs.Modifiers, ICSharpCode.NRefactory.PlayScript.Modifiers> ();
 			static string[] keywordTable;
 			
 			static ConversionVisitor ()
 			{
-				modifierTable [Mono.CSharp.Modifiers.NEW] = ICSharpCode.NRefactory.CSharp.Modifiers.New;
-				modifierTable [Mono.CSharp.Modifiers.PUBLIC] = ICSharpCode.NRefactory.CSharp.Modifiers.Public;
-				modifierTable [Mono.CSharp.Modifiers.PROTECTED] = ICSharpCode.NRefactory.CSharp.Modifiers.Protected;
-				modifierTable [Mono.CSharp.Modifiers.PRIVATE] = ICSharpCode.NRefactory.CSharp.Modifiers.Private;
-				modifierTable [Mono.CSharp.Modifiers.INTERNAL] = ICSharpCode.NRefactory.CSharp.Modifiers.Internal;
-				modifierTable [Mono.CSharp.Modifiers.ABSTRACT] = ICSharpCode.NRefactory.CSharp.Modifiers.Abstract;
-				modifierTable [Mono.CSharp.Modifiers.VIRTUAL] = ICSharpCode.NRefactory.CSharp.Modifiers.Virtual;
-				modifierTable [Mono.CSharp.Modifiers.SEALED] = ICSharpCode.NRefactory.CSharp.Modifiers.Sealed;
-				modifierTable [Mono.CSharp.Modifiers.STATIC] = ICSharpCode.NRefactory.CSharp.Modifiers.Static;
-				modifierTable [Mono.CSharp.Modifiers.OVERRIDE] = ICSharpCode.NRefactory.CSharp.Modifiers.Override;
-				modifierTable [Mono.CSharp.Modifiers.READONLY] = ICSharpCode.NRefactory.CSharp.Modifiers.Readonly;
-				modifierTable [Mono.CSharp.Modifiers.PARTIAL] = ICSharpCode.NRefactory.CSharp.Modifiers.Partial;
-				modifierTable [Mono.CSharp.Modifiers.EXTERN] = ICSharpCode.NRefactory.CSharp.Modifiers.Extern;
-				modifierTable [Mono.CSharp.Modifiers.VOLATILE] = ICSharpCode.NRefactory.CSharp.Modifiers.Volatile;
-				modifierTable [Mono.CSharp.Modifiers.UNSAFE] = ICSharpCode.NRefactory.CSharp.Modifiers.Unsafe;
-				modifierTable [Mono.CSharp.Modifiers.ASYNC] = ICSharpCode.NRefactory.CSharp.Modifiers.Async;
+				modifierTable [Mono.CSharpPs.Modifiers.NEW] = ICSharpCode.NRefactory.PlayScript.Modifiers.New;
+				modifierTable [Mono.CSharpPs.Modifiers.PUBLIC] = ICSharpCode.NRefactory.PlayScript.Modifiers.Public;
+				modifierTable [Mono.CSharpPs.Modifiers.PROTECTED] = ICSharpCode.NRefactory.PlayScript.Modifiers.Protected;
+				modifierTable [Mono.CSharpPs.Modifiers.PRIVATE] = ICSharpCode.NRefactory.PlayScript.Modifiers.Private;
+				modifierTable [Mono.CSharpPs.Modifiers.INTERNAL] = ICSharpCode.NRefactory.PlayScript.Modifiers.Internal;
+				modifierTable [Mono.CSharpPs.Modifiers.ABSTRACT] = ICSharpCode.NRefactory.PlayScript.Modifiers.Abstract;
+				modifierTable [Mono.CSharpPs.Modifiers.VIRTUAL] = ICSharpCode.NRefactory.PlayScript.Modifiers.Virtual;
+				modifierTable [Mono.CSharpPs.Modifiers.SEALED] = ICSharpCode.NRefactory.PlayScript.Modifiers.Sealed;
+				modifierTable [Mono.CSharpPs.Modifiers.STATIC] = ICSharpCode.NRefactory.PlayScript.Modifiers.Static;
+				modifierTable [Mono.CSharpPs.Modifiers.OVERRIDE] = ICSharpCode.NRefactory.PlayScript.Modifiers.Override;
+				modifierTable [Mono.CSharpPs.Modifiers.READONLY] = ICSharpCode.NRefactory.PlayScript.Modifiers.Readonly;
+				modifierTable [Mono.CSharpPs.Modifiers.PARTIAL] = ICSharpCode.NRefactory.PlayScript.Modifiers.Partial;
+				modifierTable [Mono.CSharpPs.Modifiers.EXTERN] = ICSharpCode.NRefactory.PlayScript.Modifiers.Extern;
+				modifierTable [Mono.CSharpPs.Modifiers.VOLATILE] = ICSharpCode.NRefactory.PlayScript.Modifiers.Volatile;
+				modifierTable [Mono.CSharpPs.Modifiers.UNSAFE] = ICSharpCode.NRefactory.PlayScript.Modifiers.Unsafe;
+				modifierTable [Mono.CSharpPs.Modifiers.ASYNC] = ICSharpCode.NRefactory.PlayScript.Modifiers.Async;
 				
 				keywordTable = new string[255];
 				for (int i = 0; i< keywordTable.Length; i++)
@@ -1108,7 +1110,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				if (location == null || location.Modifiers == null)
 					return;
 				foreach (var modifier in location.Modifiers) {
-					ICSharpCode.NRefactory.CSharp.Modifiers mod;
+					ICSharpCode.NRefactory.PlayScript.Modifiers mod;
 					if (!modifierTable.TryGetValue (modifier.Item1, out mod)) {
 						Console.WriteLine ("modifier " + modifier.Item1 + " can't be converted,");
 					}
@@ -1356,7 +1358,7 @@ namespace ICSharpCode.NRefactory.CSharp
 			#endregion
 			
 			#region Statements
-			public override object Visit (Mono.CSharp.Statement stmt)
+			public override object Visit (Mono.CSharpPs.Statement stmt)
 			{
 				Console.WriteLine ("unknown statement:" + stmt);
 				return null;
@@ -1405,7 +1407,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				
 				var location = LocationsBag.GetLocations (blockVariableDeclaration);
 				if (location != null && location.Count > 0)
-					result.AddChild (new CSharpModifierToken (Convert (location [0]), ICSharpCode.NRefactory.CSharp.Modifiers.Const), VariableDeclarationStatement.ModifierRole);
+					result.AddChild (new CSharpModifierToken (Convert (location [0]), ICSharpCode.NRefactory.PlayScript.Modifiers.Const), VariableDeclarationStatement.ModifierRole);
 				
 				result.AddChild (ConvertToType (blockVariableDeclaration.TypeExpression), Roles.Type);
 				
@@ -1446,21 +1448,21 @@ namespace ICSharpCode.NRefactory.CSharp
 				return result;
 			}
 			
-			public override object Visit (Mono.CSharp.EmptyStatement emptyStatement)
+			public override object Visit (Mono.CSharpPs.EmptyStatement emptyStatement)
 			{
 				var result = new EmptyStatement ();
 				result.Location = Convert (emptyStatement.loc);
 				return result;
 			}
 			
-			public override object Visit (Mono.CSharp.EmptyExpression emptyExpression)
+			public override object Visit (Mono.CSharpPs.EmptyExpression emptyExpression)
 			{
-				return new ICSharpCode.NRefactory.CSharp.EmptyExpression (Convert (emptyExpression.Location));
+				return new ICSharpCode.NRefactory.PlayScript.EmptyExpression (Convert (emptyExpression.Location));
 			}
 			
-			public override object Visit (Mono.CSharp.ErrorExpression emptyExpression)
+			public override object Visit (Mono.CSharpPs.ErrorExpression emptyExpression)
 			{
-				return new ICSharpCode.NRefactory.CSharp.ErrorExpression (Convert (emptyExpression.Location));
+				return new ICSharpCode.NRefactory.PlayScript.ErrorExpression (Convert (emptyExpression.Location));
 			}
 			
 			public override object Visit (EmptyExpressionStatement emptyExpressionStatement)
@@ -1533,7 +1535,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return result;
 			}
 			
-			void AddStatementOrList (ForStatement forStatement, Mono.CSharp.Statement init, Role<Statement> role)
+			void AddStatementOrList (ForStatement forStatement, Mono.CSharpPs.Statement init, Role<Statement> role)
 			{
 				if (init == null)
 					return;
@@ -1541,7 +1543,7 @@ namespace ICSharpCode.NRefactory.CSharp
 					foreach (var stmt in ((StatementList)init).Statements) {
 						forStatement.AddChild ((Statement)stmt.Accept (this), role);
 					}
-				} else if (init is Mono.CSharp.EmptyStatement) {
+				} else if (init is Mono.CSharpPs.EmptyStatement) {
 					
 				} else {
 					forStatement.AddChild ((Statement)init.Accept (this), role);
@@ -1725,7 +1727,7 @@ namespace ICSharpCode.NRefactory.CSharp
 			public UsingStatement CreateUsingStatement (Block blockStatement)
 			{
 				var usingResult = new UsingStatement ();
-				Mono.CSharp.Statement cur = blockStatement.Statements [0];
+				Mono.CSharpPs.Statement cur = blockStatement.Statements [0];
 				if (cur is Using) {
 					Using u = (Using)cur;
 					usingResult.AddChild (new CSharpTokenNode (Convert (u.loc), UsingStatement.UsingKeywordRole), UsingStatement.UsingKeywordRole);
@@ -1777,7 +1779,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				if (convertTypeSystemMode) {
 					return;
 				}
-				foreach (Mono.CSharp.Statement stmt in blockStatement.Statements) {
+				foreach (Mono.CSharpPs.Statement stmt in blockStatement.Statements) {
 					if (stmt == null)
 						continue;
 					/*					if (curLocal < localVariables.Count && IsLower (localVariables[curLocal].Location, stmt.loc)) {
@@ -2103,14 +2105,14 @@ namespace ICSharpCode.NRefactory.CSharp
 			#endregion
 			
 			#region Expression
-			public override object Visit (Mono.CSharp.Expression expression)
+			public override object Visit (Mono.CSharpPs.Expression expression)
 			{
 				Console.WriteLine ("Visit unknown expression:" + expression);
 				System.Console.WriteLine (Environment.StackTrace);
 				return null;
 			}
 			
-			public override object Visit (Mono.CSharp.DefaultParameterValueExpression defaultParameterValueExpression)
+			public override object Visit (Mono.CSharpPs.DefaultParameterValueExpression defaultParameterValueExpression)
 			{
 				return defaultParameterValueExpression.Child.Accept (this);
 			}
@@ -2193,7 +2195,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return booleanExpression.Expr.Accept (this);
 			}
 			
-			public override object Visit (Mono.CSharp.ParenthesizedExpression parenthesizedExpression)
+			public override object Visit (Mono.CSharpPs.ParenthesizedExpression parenthesizedExpression)
 			{
 				var result = new ParenthesizedExpression ();
 				var location = LocationsBag.GetLocations (parenthesizedExpression);
@@ -2339,7 +2341,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return result;
 			}
 			
-			public override object Visit (Mono.CSharp.DefaultValueExpression defaultValueExpression)
+			public override object Visit (Mono.CSharpPs.DefaultValueExpression defaultValueExpression)
 			{
 				var result = new DefaultValueExpression ();
 				result.AddChild (new CSharpTokenNode (Convert (defaultValueExpression.Location), DefaultValueExpression.DefaultKeywordRole), DefaultValueExpression.DefaultKeywordRole);
@@ -2424,7 +2426,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return result;
 			}
 			
-			public override object Visit (Mono.CSharp.Nullable.NullCoalescingOperator nullCoalescingOperator)
+			public override object Visit (Mono.CSharpPs.Nullable.NullCoalescingOperator nullCoalescingOperator)
 			{
 				var result = new BinaryOperatorExpression ();
 				result.Operator = BinaryOperatorType.NullCoalescing;
@@ -2456,7 +2458,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return result;
 			}
 			
-			void AddParameter (AstNode parent, Mono.CSharp.AParametersCollection parameters)
+			void AddParameter (AstNode parent, Mono.CSharpPs.AParametersCollection parameters)
 			{
 				if (parameters == null)
 					return;
@@ -2681,7 +2683,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return (Expression)arg.Expr.Accept (this);
 			}
 			
-			void AddArguments (AstNode parent, object location, Mono.CSharp.Arguments args)
+			void AddArguments (AstNode parent, object location, Mono.CSharpPs.Arguments args)
 			{
 				if (args == null)
 					return;
@@ -2794,7 +2796,7 @@ namespace ICSharpCode.NRefactory.CSharp
 							if (arg == null)
 								continue;
 							parent.AddChild(
-								(ICSharpCode.NRefactory.CSharp.Expression)arg.Expr.Accept(this),
+								(ICSharpCode.NRefactory.PlayScript.Expression)arg.Expr.Accept(this),
 								Roles.Expression
 							);
 						}
@@ -3172,7 +3174,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return result;
 			}
 			
-			public override object Visit (Mono.CSharp.AnonymousMethodExpression anonymousMethodExpression)
+			public override object Visit (Mono.CSharpPs.AnonymousMethodExpression anonymousMethodExpression)
 			{
 				var result = new AnonymousMethodExpression ();
 				var location = LocationsBag.GetLocations (anonymousMethodExpression);
@@ -3196,7 +3198,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return result;
 			}
 
-			public override object Visit (Mono.CSharp.LambdaExpression lambdaExpression)
+			public override object Visit (Mono.CSharpPs.LambdaExpression lambdaExpression)
 			{
 				var result = new LambdaExpression ();
 				var location = LocationsBag.GetLocations (lambdaExpression);
@@ -3263,7 +3265,7 @@ namespace ICSharpCode.NRefactory.CSharp
 			#region LINQ expressions
 			QueryOrderClause currentQueryOrderClause;
 
-			public override object Visit (Mono.CSharp.Linq.QueryExpression queryExpression)
+			public override object Visit (Mono.CSharpPs.Linq.QueryExpression queryExpression)
 			{
 				var oldQueryOrderClause = currentQueryOrderClause;
 				try {
@@ -3293,7 +3295,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				}
 			}
 			
-			public override object Visit (Mono.CSharp.Linq.QueryStartClause queryStart)
+			public override object Visit (Mono.CSharpPs.Linq.QueryStartClause queryStart)
 			{
 				if (queryStart.Expr == null) {
 					var intoClause = new QueryContinuationClause ();
@@ -3320,7 +3322,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return fromClause;
 			}
 			
-			public override object Visit (Mono.CSharp.Linq.SelectMany queryStart)
+			public override object Visit (Mono.CSharpPs.Linq.SelectMany queryStart)
 			{
 				var fromClause = new QueryFromClause ();
 
@@ -3340,7 +3342,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return fromClause;
 			}
 			
-			public override object Visit (Mono.CSharp.Linq.Select sel)
+			public override object Visit (Mono.CSharpPs.Linq.Select sel)
 			{
 				var result = new QuerySelectClause ();
 				result.AddChild (new CSharpTokenNode (Convert (sel.Location), QuerySelectClause.SelectKeywordRole), QuerySelectClause.SelectKeywordRole);
@@ -3349,7 +3351,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return result;
 			}
 			
-			public override object Visit (Mono.CSharp.Linq.GroupBy groupBy)
+			public override object Visit (Mono.CSharpPs.Linq.GroupBy groupBy)
 			{
 				var result = new QueryGroupClause ();
 				var location = LocationsBag.GetLocations (groupBy);
@@ -3363,7 +3365,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return result;
 			}
 			
-			public override object Visit (Mono.CSharp.Linq.Let l)
+			public override object Visit (Mono.CSharpPs.Linq.Let l)
 			{
 				var result = new QueryLetClause ();
 				var location = LocationsBag.GetLocations (l);
@@ -3377,7 +3379,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return result;
 			}
 			
-			public override object Visit (Mono.CSharp.Linq.Where w)
+			public override object Visit (Mono.CSharpPs.Linq.Where w)
 			{
 				var result = new QueryWhereClause ();
 				result.AddChild (new CSharpTokenNode (Convert (w.Location), QueryWhereClause.WhereKeywordRole), QueryWhereClause.WhereKeywordRole);
@@ -3386,7 +3388,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return result;
 			}
 			
-			public override object Visit (Mono.CSharp.Linq.Join join)
+			public override object Visit (Mono.CSharpPs.Linq.Join join)
 			{
 				var result = new QueryJoinClause ();
 				var location = LocationsBag.GetLocations (join);
@@ -3416,7 +3418,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return result;
 			}
 			
-			public override object Visit (Mono.CSharp.Linq.GroupJoin join)
+			public override object Visit (Mono.CSharpPs.Linq.GroupJoin join)
 			{
 				var result = new QueryJoinClause ();
 				var location = LocationsBag.GetLocations (join);
@@ -3452,7 +3454,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return result;
 			}
 			
-			public override object Visit (Mono.CSharp.Linq.OrderByAscending orderByAscending)
+			public override object Visit (Mono.CSharpPs.Linq.OrderByAscending orderByAscending)
 			{
 				currentQueryOrderClause = new QueryOrderClause();
 				var location2 = LocationsBag.GetLocations (orderByAscending.block);
@@ -3470,7 +3472,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return currentQueryOrderClause;
 			}
 			
-			public override object Visit (Mono.CSharp.Linq.OrderByDescending orderByDescending)
+			public override object Visit (Mono.CSharpPs.Linq.OrderByDescending orderByDescending)
 			{
 				currentQueryOrderClause = new QueryOrderClause ();
 				
@@ -3486,7 +3488,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return currentQueryOrderClause;
 			}
 			
-			public override object Visit (Mono.CSharp.Linq.ThenByAscending thenByAscending)
+			public override object Visit (Mono.CSharpPs.Linq.ThenByAscending thenByAscending)
 			{
 				var ordering = new QueryOrdering ();
 				if (thenByAscending.Expr != null)
@@ -3500,7 +3502,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				return null;
 			}
 			
-			public override object Visit (Mono.CSharp.Linq.ThenByDescending thenByDescending)
+			public override object Visit (Mono.CSharpPs.Linq.ThenByDescending thenByDescending)
 			{
 				var ordering = new QueryOrdering ();
 				if (thenByDescending.Expr != null)
@@ -3593,12 +3595,12 @@ namespace ICSharpCode.NRefactory.CSharp
 			#endregion
 		}
 		
-		public CSharpParser ()
+		public PlayScriptParser ()
 		{
 			compilerSettings = new CompilerSettings();
 		}
 		
-		public CSharpParser (CompilerSettings args)
+		public PlayScriptParser (CompilerSettings args)
 		{
 			compilerSettings = args ?? new CompilerSettings();
 		}
@@ -3647,7 +3649,7 @@ namespace ICSharpCode.NRefactory.CSharp
 				} else {
 					var directive = special as SpecialsBag.PreProcessorDirective;
 					if (directive != null) {
-						newLeaf = new PreProcessorDirective ((ICSharpCode.NRefactory.CSharp.PreProcessorDirectiveType)((int)directive.Cmd & 0xF), new TextLocation (directive.Line, directive.Col), new TextLocation (directive.EndLine, directive.EndCol)) {
+						newLeaf = new PreProcessorDirective ((ICSharpCode.NRefactory.PlayScript.PreProcessorDirectiveType)((int)directive.Cmd & 0xF), new TextLocation (directive.Line, directive.Col), new TextLocation (directive.EndLine, directive.EndCol)) {
 							Argument = directive.Arg,
 							Take = directive.Take
 						};
@@ -3795,21 +3797,22 @@ namespace ICSharpCode.NRefactory.CSharp
 		}
 
 		/// <summary>
-		/// Converts a Mono.CSharp syntax tree into an NRefactory syntax tree.
+		/// Converts a Mono.CSharpPs syntax tree into an NRefactory syntax tree.
 		/// </summary>
 		public SyntaxTree Parse(CompilerCompilationUnit top, string fileName)
 		{
 			if (top == null) {
 				return null;
 			}
-			CSharpParser.ConversionVisitor conversionVisitor = new ConversionVisitor (GenerateTypeSystemMode, top.LocationsBag);
+			PlayScriptParser.ConversionVisitor conversionVisitor = new ConversionVisitor (GenerateTypeSystemMode, top.LocationsBag);
 			top.ModuleCompiled.Accept(conversionVisitor);
+			conversionVisitor.Unit.FixOutOfOrderLocations(); // Reorder locations that are incorrect for PlayScript
 			InsertComments(top, conversionVisitor);
 			if (CompilationUnitCallback != null) {
 				CompilationUnitCallback(top);
 			}
-			if (top.LastYYValue is Mono.CSharp.Expression) {
-				conversionVisitor.Unit.TopExpression = ((Mono.CSharp.Expression)top.LastYYValue).Accept(conversionVisitor) as AstNode;
+			if (top.LastYYValue is Mono.CSharpPs.Expression) {
+				conversionVisitor.Unit.TopExpression = ((Mono.CSharpPs.Expression)top.LastYYValue).Accept(conversionVisitor) as AstNode;
 			}
 
 			conversionVisitor.Unit.FileName = fileName;
@@ -3827,7 +3830,7 @@ namespace ICSharpCode.NRefactory.CSharp
 		}
 		
 		/// <summary>
-		/// Callback that gets called with the Mono.CSharp syntax tree whenever some code is parsed.
+		/// Callback that gets called with the Mono.CSharpPs syntax tree whenever some code is parsed.
 		/// </summary>
 		public Action<CompilerCompilationUnit> CompilationUnitCallback {
 			get;
@@ -3898,13 +3901,26 @@ namespace ICSharpCode.NRefactory.CSharp
 				var session = new ParserSession ();
 				session.LocationsBag = new LocationsBag ();
 				var report = new Report (ctx, errorReportPrinter);
-				var parser = Driver.Parse (reader, file, module, session, report, initialLine - 1, initialColumn - 1);
-				var top = new CompilerCompilationUnit () {
-					ModuleCompiled = module,
-					LocationsBag = session.LocationsBag,
-					SpecialsBag = parser.Lexer.sbag,
-					Conditionals = parser.Lexer.SourceFile.Conditionals
-				};
+				CompilerCompilationUnit top;
+				if (String.IsNullOrEmpty(fileName) || fileName.EndsWith(".play") || fileName.EndsWith(".as")) {
+					if (String.IsNullOrEmpty(fileName) || fileName.EndsWith(".play"))
+						file.PsExtended = true; // Assume playscript unless we have an actual file ext.
+					var parser = (Mono.PlayScript.PlayScriptParser)Driver.Parse(reader, file, module, session, report, initialLine - 1, initialColumn - 1);
+					top = new CompilerCompilationUnit() {
+						ModuleCompiled = module,
+						LocationsBag = session.LocationsBag,
+						SpecialsBag = parser.Lexer.sbag,
+						Conditionals = parser.Lexer.SourceFile.Conditionals
+					};
+				} else {
+					var parser = (Mono.CSharpPs.CSharpParser)Driver.Parse(reader, file, module, session, report, initialLine - 1, initialColumn - 1);
+					top = new CompilerCompilationUnit() {
+						ModuleCompiled = module,
+						LocationsBag = session.LocationsBag,
+						SpecialsBag = parser.Lexer.sbag,
+						Conditionals = parser.Lexer.SourceFile.Conditionals
+					};
+				}
 				var unit = Parse (top, fileName);
 				unit.Errors.AddRange (errorReportPrinter.Errors);
 				CompilerCallableEntryPoint.Reset ();
@@ -3996,7 +4012,7 @@ namespace ICSharpCode.NRefactory.CSharp
 		
 		public DocumentationReference ParseDocumentationReference (string cref)
 		{
-			// see Mono.CSharp.DocumentationBuilder.HandleXrefCommon
+			// see Mono.CSharpPs.DocumentationBuilder.HandleXrefCommon
 			if (cref == null)
 				throw new ArgumentNullException ("cref");
 			
@@ -4016,10 +4032,11 @@ namespace ICSharpCode.NRefactory.CSharp
 				var report = new Report (ctx, errorReportPrinter);
 				ParserSession session = new ParserSession ();
 				session.LocationsBag = new LocationsBag ();
-				var parser = new Mono.CSharp.CSharpParser (reader, source_file, report, session);
+				var parser = new Mono.PlayScript.PlayScriptParser (reader, source_file, report, session);
+				parser.parsing_playscript = (source_file.SourceFile != null) ? source_file.SourceFile.PsExtended : true;
 				parser.Lexer.Line += initialLocation.Line - 1;
 				parser.Lexer.Column += initialLocation.Column - 1;
-				parser.Lexer.putback_char = Tokenizer.DocumentationXref;
+				parser.Lexer.putback_char = Mono.PlayScript.Tokenizer.DocumentationXref;
 				parser.Lexer.parsing_generic_declaration_doc = true;
 				parser.parse ();
 				if (report.Errors > 0) {
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/CompilerSettings.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/CompilerSettings.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/CompilerSettings.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/CompilerSettings.cs	2013-04-23 21:04:54.000000000 -0700
@@ -20,7 +20,7 @@ using System;
 using System.Collections.Generic;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// C# compiler settings.
@@ -68,7 +68,7 @@ namespace ICSharpCode.NRefactory.CSharp
 			set { checkForOverflow = value; }
 		}
 		
-		Version languageVersion = new Version((int)Mono.CSharp.LanguageVersion.Default, 0);
+		Version languageVersion = new Version((int)Mono.CSharpPs.LanguageVersion.Default, 0);
 		
 		/// <summary>
 		/// Gets/Sets the language version used by the parser.
@@ -131,12 +131,12 @@ namespace ICSharpCode.NRefactory.CSharp
 			get { return disabledWarnings; }
 		}
 		
-		internal Mono.CSharp.CompilerSettings ToMono()
+		internal Mono.CSharpPs.CompilerSettings ToMono()
 		{
-			var s = new Mono.CSharp.CompilerSettings();
+			var s = new Mono.CSharpPs.CompilerSettings();
 			s.Unsafe = allowUnsafeBlocks;
 			s.Checked = checkForOverflow;
-			s.Version = (Mono.CSharp.LanguageVersion)languageVersion.Major;
+			s.Version = (Mono.CSharpPs.LanguageVersion)languageVersion.Major;
 			s.WarningsAreErrors = treatWarningsAsErrors;
 			s.WarningLevel = warningLevel;
 			foreach (int code in disabledWarnings)
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/SeekableStreamReader.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/SeekableStreamReader.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/SeekableStreamReader.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/SeekableStreamReader.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using ICSharpCode.NRefactory.Editor;
 using System.IO;
 using System.Text;
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	public class SeekableStreamReader : IDisposable
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/MonoSymbolTable.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/MonoSymbolTable.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/MonoSymbolTable.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/MonoSymbolTable.cs	2013-04-23 21:04:54.000000000 -0700
@@ -1,5 +1,5 @@
 //
-// Mono.CSharp.Debugger/MonoSymbolTable.cs
+// Mono.CSharpPs.Debugger/MonoSymbolTable.cs
 //
 // Author:
 //   Martin Baulig (martin@ximian.com)
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/MonoSymbolWriter.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/MonoSymbolWriter.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/MonoSymbolWriter.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/MonoSymbolWriter.cs	2013-04-23 21:04:54.000000000 -0700
@@ -1,5 +1,5 @@
 //
-// Mono.CSharp.Debugger/MonoSymbolWriter.cs
+// Mono.CSharpPs.Debugger/MonoSymbolWriter.cs
 //
 // Author:
 //   Martin Baulig (martin@ximian.com)
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/anonymous.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/anonymous.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/anonymous.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/anonymous.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@ using System.Reflection;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp {
+namespace Mono.CSharpPs {
 
 	public abstract class CompilerGeneratedContainer : ClassOrStruct
 	{
@@ -935,10 +935,18 @@ namespace Mono.CSharp {
 
 		public ParametersBlock Block;
 
-		public AnonymousMethodExpression (Location loc)
+		// PlayScript requires us to remember both parameters and return type.  (Will be null in C#)
+		public ParametersCompiled AsParameters;
+		public FullNamedExpression AsReturnType;
+
+		public AnonymousMethodExpression (Location loc, ParametersCompiled asParameters = null, FullNamedExpression asReturnType = null)
 		{
 			this.loc = loc;
 			this.compatibles = new Dictionary<TypeSpec, Expression> ();
+
+			// Actionscript anon function declarations include concrete parameter types and return types.
+			this.AsParameters = asParameters;
+			this.AsReturnType = asReturnType;
 		}
 
 		#region Properties
@@ -1966,7 +1974,7 @@ namespace Mono.CSharp {
 
 			Method tostring = new Method (this, new TypeExpression (Compiler.BuiltinTypes.String, loc),
 				Modifiers.PUBLIC | Modifiers.OVERRIDE | Modifiers.DEBUGGER_HIDDEN, new MemberName ("ToString", loc),
-				Mono.CSharp.ParametersCompiled.EmptyReadOnlyParameters, null);
+				Mono.CSharpPs.ParametersCompiled.EmptyReadOnlyParameters, null);
 
 			ToplevelBlock equals_block = new ToplevelBlock (Compiler, equals.ParameterInfo, loc);
 
@@ -2074,7 +2082,7 @@ namespace Mono.CSharp {
 			Method hashcode = new Method (this, new TypeExpression (Compiler.BuiltinTypes.Int, loc),
 				Modifiers.PUBLIC | Modifiers.OVERRIDE | Modifiers.DEBUGGER_HIDDEN,
 				new MemberName ("GetHashCode", loc),
-				Mono.CSharp.ParametersCompiled.EmptyReadOnlyParameters, null);
+				Mono.CSharpPs.ParametersCompiled.EmptyReadOnlyParameters, null);
 
 			//
 			// Modified FNV with good avalanche behavior and uniform
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/argument.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/argument.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/argument.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/argument.cs	2013-04-23 21:04:54.000000000 -0700
@@ -19,7 +19,7 @@ using IKVM.Reflection.Emit;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	//
 	// Argument expression used for invocation
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/assembly.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/assembly.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/assembly.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/assembly.cs	2013-04-23 21:04:54.000000000 -0700
@@ -31,7 +31,7 @@ using System.Reflection;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	public interface IAssemblyDefinition
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/assign.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/assign.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/assign.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/assign.cs	2013-04-23 21:04:54.000000000 -0700
@@ -20,7 +20,7 @@ using IKVM.Reflection.Emit;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp {
+namespace Mono.CSharpPs {
 
 	/// <summary>
 	///   This interface is implemented by expressions that can be assigned to.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/async.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/async.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/async.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/async.cs	2013-04-23 21:04:54.000000000 -0700
@@ -23,7 +23,7 @@ using System.Reflection;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	public class Await : ExpressionStatement
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/attribute.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/attribute.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/attribute.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/attribute.cs	2013-04-23 21:04:54.000000000 -0700
@@ -32,7 +32,7 @@ using System.Reflection;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp {
+namespace Mono.CSharpPs {
 
 	/// <summary>
 	///   Base class for objects that can have Attributes applied to them.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/build-psparser.sh ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/build-psparser.sh
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/build-psparser.sh	1969-12-31 16:00:00.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/build-psparser.sh	2013-04-23 21:04:54.000000000 -0700
@@ -0,0 +1,2 @@
+echo "./../../../../../../../playscript-mono/mcs/jay/jay -c < ./../../../../../../../playscript-mono/mcs/jay/skeleton.cs ps-parser.jay > jay-tmp.out && mv jay-tmp.out ps-parser.cs"
+./../../../../../../../playscript-mono/mcs/jay/jay -c < ./../../../../../../../playscript-mono/mcs/jay/skeleton.cs ps-parser.jay > jay-tmp.out && mv jay-tmp.out ps-parser.cs
\ No newline at end of file
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/cfold.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/cfold.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/cfold.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/cfold.cs	2013-04-23 21:04:54.000000000 -0700
@@ -10,7 +10,7 @@
 // 
 using System;
 
-namespace Mono.CSharp {
+namespace Mono.CSharpPs {
 
 	public static class ConstantFold
 	{
@@ -22,6 +22,14 @@ namespace Mono.CSharp {
 			};
 		}
 
+		public static TypeSpec[] CreateAsBinaryPromotionsTypes (BuiltinTypes types)
+		{
+			return new TypeSpec[] { 
+				types.Bool, types.Decimal, types.Double, types.Float,
+				types.ULong, types.Long, types.UInt 
+			};
+		}
+
 		//
 		// Performs the numeric promotions on the left and right expresions
 		// and deposits the results on `lc' and `rc'.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/class.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/class.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/class.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/class.cs	2013-04-23 21:04:54.000000000 -0700
@@ -36,7 +36,7 @@ using System.Reflection;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	//
 	// General types container, used as a base class for all constructs which can hold types
@@ -476,6 +476,13 @@ namespace Mono.CSharp
 				return tc.Parent.LookupNamespaceOrType (name, arity, mode, loc);
 			}
 
+			public SourceFileType FileType 
+			{ 
+				get {
+					return tc.Location.SourceFile != null ? tc.Location.SourceFile.FileType : SourceFileType.CSharp;
+				}
+			}
+
 			#endregion
 		}
 
@@ -772,6 +779,15 @@ namespace Mono.CSharp
 			members.Add (symbol);
 		}
 
+		public void ReplaceMember (MemberCore oldsymbol, MemberCore newsymbol)
+		{
+			var i = members.IndexOf (oldsymbol);
+			if (i == -1)
+				throw new InvalidOperationException("No member to replace");
+			members[i] = newsymbol;
+			ReplaceNameInContainer (newsymbol, newsymbol.MemberName.Basename);
+		}
+
 		public override void AddTypeContainer (TypeContainer tc)
 		{
 			AddNameToContainer (tc, tc.Basename);
@@ -832,6 +848,20 @@ namespace Mono.CSharp
 			return;
 		}
 
+		//
+		// Replaces the member in the defined_names table.
+		//
+		public virtual void ReplaceNameInContainer (MemberCore newsymbol, string name)
+		{
+			if (((ModFlags | newsymbol.ModFlags) & Modifiers.COMPILER_GENERATED) != 0)
+				return;
+			
+			MemberCore mc;
+			if (PartialContainer.defined_names.TryGetValue (name, out mc)) {
+				PartialContainer.defined_names[name] = newsymbol;
+			}
+		}
+
 		public void AddConstructor (Constructor c)
 		{
 			AddConstructor (c, false);
@@ -1089,9 +1119,20 @@ namespace Mono.CSharp
 			}
 		}
 
+		public virtual void AddBaseForPart (FullNamedExpression aBase)
+		{
+			if (type_bases == null)
+				type_bases = new List<FullNamedExpression> ();
+			type_bases.Add (aBase);
+		}		
+		
 		public virtual void AddBasesForPart (List<FullNamedExpression> bases)
 		{
-			type_bases = bases;
+			if (bases.Count > 0) {
+				if (type_bases == null)
+					type_bases = new List<FullNamedExpression> ();
+				type_bases.AddRange (bases);
+			}
 		}
 
 		/// <summary>
@@ -1106,7 +1147,18 @@ namespace Mono.CSharp
 		/// </summary>
 		protected virtual TypeSpec[] ResolveBaseTypes (out FullNamedExpression base_class)
 		{
+			// PlayScript will default to the "_root.Object" base class.. not null.
+			if (this.Location.SourceFile != null &&
+			    this.Location.SourceFile.FileType == SourceFileType.PlayScript &&
+			    this is Class && !this.IsStatic) {
+				base_class = new MemberAccess(new SimpleName(PsConsts.PsRootNamespace, Location), "Object");
+				base_type = base_class.ResolveAsType (new BaseContext (this));
+				if (base_type == null)
+					base_class = null;
+			} else {
 			base_class = null;
+			}
+
 			if (type_bases == null)
 				return null;
 
@@ -2597,7 +2649,17 @@ namespace Mono.CSharp
 			: base (parent, name, attrs, MemberKind.Class)
 		{
 			var accmods = IsTopLevel ? Modifiers.INTERNAL : Modifiers.PRIVATE;
-			this.ModFlags = ModifiersExtensions.Check (AllowedModifiers, mod, accmods, Location, Report);
+			var allowedMods = AllowedModifiers;
+			// Modify allowed modifiers for classes in PlayScript
+			if (this.Location.SourceFile != null && this.Location.SourceFile.FileType == SourceFileType.PlayScript) {
+				allowedMods = allowedMods | Modifiers.AS_DYNAMIC & ~Modifiers.UNSAFE; // Dynamic classes yes, but no unsafe code in AS
+				if (!this.Location.SourceFile.PsExtended) { // Normal AS does not support STATIC or ABSTRACT classes either
+					allowedMods &= ~(Modifiers.ABSTRACT | Modifiers.NEW);
+					if (!name.Basename.EndsWith("_fn"))
+						allowedMods &= ~Modifiers.STATIC;  // Only function classes can be static in standard AS
+				}
+			}
+			this.ModFlags = ModifiersExtensions.Check (allowedMods, mod, accmods, Location, Report);
 			spec = new TypeSpec (Kind, null, this, null, ModFlags);
 		}
 
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/codegen.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/codegen.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/codegen.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/codegen.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@ using System.Reflection;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	/// <summary>
 	///   An Emit Context is created for each body of code (from methods,
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/complete.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/complete.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/complete.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/complete.cs	2013-04-23 21:04:54.000000000 -0700
@@ -17,7 +17,7 @@
 using System.Collections.Generic;
 using System.Linq;
 
-namespace Mono.CSharp {
+namespace Mono.CSharpPs {
 
 	//
 	// A common base class for Completing expressions, it
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/const.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/const.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/const.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/const.cs	2013-04-23 21:04:54.000000000 -0700
@@ -15,7 +15,7 @@ using IKVM.Reflection;
 using System.Reflection;
 #endif
 
-namespace Mono.CSharp {
+namespace Mono.CSharpPs {
 
 	public class Const : FieldBase
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/constant.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/constant.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/constant.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/constant.cs	2013-04-23 21:04:54.000000000 -0700
@@ -19,7 +19,7 @@ using IKVM.Reflection.Emit;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp {
+namespace Mono.CSharpPs {
 
 	/// <summary>
 	///   Base class for constants and literals.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/context.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/context.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/context.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/context.cs	2013-04-23 21:04:54.000000000 -0700
@@ -15,7 +15,7 @@ using System.Collections.Generic;
 using System.IO;
 using System.Security.Cryptography;
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	public enum LookupMode
 	{
@@ -318,7 +318,9 @@ namespace Mono.CSharp
 
 			ExpressionTreeConversion = 1 << 25,
 
-			InvokeSpecialName = 1 << 26
+			InvokeSpecialName = 1 << 26,
+
+			PsExtended = 1 << 27
 		}
 
 		// utility helper for CheckExpr, UnCheckExpr, Checked and Unchecked statements
@@ -355,6 +357,8 @@ namespace Mono.CSharp
 
 		protected Options flags;
 
+		protected SourceFileType fileType;
+
 		//
 		// Whether we are inside an anonymous method.
 		//
@@ -391,6 +395,21 @@ namespace Mono.CSharp
 			// The constant check state is always set to true
 			//
 			flags |= Options.ConstantCheckState;
+
+			//
+			// File type set from member context module sourcefile.
+			//
+			var memberCore = mc as MemberCore;
+			if (memberCore != null && memberCore.Location.SourceFile != null) {
+				fileType = memberCore.Location.SourceFile.FileType;
+			} else if (mc.Module != null && mc.Module.Location.SourceFile != null) {
+				fileType = mc.Module.Location.SourceFile.FileType;
+				if (mc.Module.Location.SourceFile.PsExtended)
+					flags |= Options.PsExtended;
+			} else {
+				fileType = SourceFileType.CSharp;
+			}
+
 		}
 
 		public ResolveContext (IMemberContext mc, Options options)
@@ -497,6 +516,25 @@ namespace Mono.CSharp
 			}
 		}
 
+		public SourceFileType FileType {
+			get { return fileType; }
+			set { fileType = value; }
+		}
+
+		public bool PsExtended {
+			get { return (flags & Options.PsExtended) != 0; }
+			set { 
+				if (value) 
+					flags |= Options.PsExtended; 
+				else 
+					flags &= ~Options.PsExtended; 
+			}
+		}
+
+		public Target Target {
+			get { return Module.Compiler.Settings.Target; }
+		}
+
 		#endregion
 
 		public bool MustCaptureVariable (INamedBlockVariable local)
@@ -783,6 +821,7 @@ namespace Mono.CSharp
 		public LocationsBag LocationsBag { get; set; }
 		public bool UseJayGlobalArrays { get; set; }
 		public Tokenizer.LocatedToken[] LocatedTokens { get; set; }
+		public Mono.PlayScript.Tokenizer.LocatedToken[] AsLocatedTokens { get; set; }
 
 		public MD5 GetChecksumAlgorithm ()
 		{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/convert.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/convert.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/convert.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/convert.cs	2013-04-23 21:04:54.000000000 -0700
@@ -20,7 +20,7 @@ using IKVM.Reflection.Emit;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp {
+namespace Mono.CSharpPs {
 
 	//
 	// A container class for all the conversion operations
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/cs-parser.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/cs-parser.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/cs-parser.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/cs-parser.cs	2013-04-23 21:04:54.000000000 -0700
@@ -20,7 +20,7 @@ using System.IO;
 using System;
 using System.Collections.Generic;
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	/// <summary>
 	///    The C# Parser
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/cs-parser.jay ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/cs-parser.jay
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/cs-parser.jay	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/cs-parser.jay	2013-04-23 21:04:54.000000000 -0700
@@ -18,7 +18,7 @@ using System.IO;
 using System;
 using System.Collections.Generic;
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	/// <summary>
 	///    The C# Parser
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/cs-tokenizer.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/cs-tokenizer.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/cs-tokenizer.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/cs-tokenizer.cs	2013-04-23 21:04:54.000000000 -0700
@@ -18,7 +18,7 @@ using System.Globalization;
 using System.Diagnostics;
 using System.Collections;
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	/// <summary>
 	///    Tokenizer for C# source code. 
@@ -3582,7 +3582,7 @@ namespace Mono.CSharp
 							continue;
 						}
 
-						if (c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\v' ) {
+						if (c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\v') {
 							sbag.PushCommentChar (c);
 							continue;
 						}
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/decl.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/decl.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/decl.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/decl.cs	2013-04-23 21:04:54.000000000 -0700
@@ -32,7 +32,7 @@ using System.Reflection;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp {
+namespace Mono.CSharpPs {
 
 	//
 	// Better name would be DottenName
@@ -266,7 +266,7 @@ namespace Mono.CSharp {
 		///   Location where this declaration happens
 		/// </summary>
 		public Location Location {
-			get { return member_name.Location; }
+			get { return member_name != null ? member_name.Location : new Location(); }
 		}
 
 		/// <summary>
@@ -280,6 +280,12 @@ namespace Mono.CSharp {
 		/// </summary>
 		public abstract string DocCommentHeader { get; }
 
+		public virtual SourceFileType FileType { 
+			get {
+				return member_name.Location.SourceFile != null ? member_name.Location.SourceFile.FileType : SourceFileType.CSharp;
+			}
+		}
+
 		[Flags]
 		public enum Flags {
 			Obsolete_Undetected = 1,		// Obsolete attribute has not been detected yet
@@ -702,7 +708,11 @@ namespace Mono.CSharp {
 
 		public virtual FullNamedExpression LookupNamespaceOrType (string name, int arity, LookupMode mode, Location loc)
 		{
-			return Parent.LookupNamespaceOrType (name, arity, mode, loc);
+			if (Parent != null) {
+				return Parent.LookupNamespaceOrType (name, arity, mode, loc);
+			} else {
+				return null;
+			}
 		}
 
 		/// <summary>
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/delegate.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/delegate.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/delegate.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/delegate.cs	2013-04-23 21:04:54.000000000 -0700
@@ -23,7 +23,7 @@ using System.Reflection;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp {
+namespace Mono.CSharpPs {
 
 	//
 	// Delegate container implementation
@@ -68,6 +68,66 @@ namespace Mono.CSharp {
 			spec = new TypeSpec (Kind, null, this, null, ModFlags | Modifiers.SEALED);
 		}
 
+		public static TypeSpec CreateDelegateType (ResolveContext rc, AParametersCollection parameters, TypeSpec returnType, Location loc)
+		{
+			Namespace type_ns = rc.Module.GlobalRootNamespace.GetNamespace ("System", true);
+			if (type_ns == null) {
+				return null;
+			}
+			if (returnType == rc.BuiltinTypes.Void) {
+				var actArgs = parameters.Types;
+				var actionSpec = type_ns.LookupType (rc.Module, "Action", actArgs.Length, LookupMode.Normal, loc).ResolveAsType(rc);
+				if (actionSpec == null) {
+					return null;
+				}
+				if (actArgs.Length == 0)
+					return actionSpec;
+				else
+					return actionSpec.MakeGenericType(rc, actArgs);
+			} else {
+				TypeSpec[] funcArgs = new TypeSpec[parameters.Types.Length + 1];
+				parameters.Types.CopyTo(funcArgs, 0);
+				funcArgs[parameters.Types.Length] = returnType;
+				var funcSpec = type_ns.LookupType (rc.Module, "Func", funcArgs.Length, LookupMode.Normal, loc).ResolveAsType(rc);
+				if (funcSpec == null)
+					return null;
+				return funcSpec.MakeGenericType(rc, funcArgs);
+			}
+		}
+
+		public static FullNamedExpression CreateDelegateTypeExpression (BuiltinTypes builtinTypes, ParametersCompiled parameters, FullNamedExpression retType, Location loc){
+			bool hasParams = parameters != null && parameters.Count > 0;
+			int paramCount = hasParams ? parameters.Count : 0;
+			bool hasRetType = !(retType is TypeExpression && ((TypeExpression)retType).Type == builtinTypes.Void);
+			int typeParamCount = paramCount;
+			if (hasRetType)
+				typeParamCount++;
+			TypeArguments typeArgs = null;
+			if (typeParamCount > 0) {
+				var typeArgArray = new FullNamedExpression[typeParamCount];
+				for (var i = 0; i < paramCount; i++) {
+					if (i < paramCount) {
+						var param = parameters.FixedParameters[i] as Parameter;
+						typeArgArray[i] = param.TypeExpression;
+					} else {
+						typeArgArray[i] = retType;
+					}
+				}
+				typeArgs = new TypeArguments (typeArgArray);
+			}
+			if (!hasRetType) {
+				return new MemberAccess(new SimpleName("System", loc), "Action", typeArgs, loc);
+			} else {
+				return new MemberAccess(new SimpleName("System", loc), "Func", typeArgs, loc);
+			}
+		}
+
+
+		public static TypeSpec CreateDelegateTypeFromMethodSpec (ResolveContext rc, MethodSpec ms, Location loc)
+		{
+			return CreateDelegateType (rc, ms.Parameters, ms.ReturnType, loc);
+		}
+
 		#region Properties
 		public TypeSpec MemberType {
 			get {
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/doc.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/doc.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/doc.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/doc.cs	2013-04-23 21:04:54.000000000 -0700
@@ -19,7 +19,7 @@ using System.Text;
 using System.Xml;
 using System.Linq;
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	//
 	// Implements XML documentation generation.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/driver.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/driver.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/driver.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/driver.cs	2013-04-23 21:04:54.000000000 -0700
@@ -21,8 +21,9 @@ using System.Text;
 using System.Globalization;
 using System.Diagnostics;
 using System.Threading;
+using Mono.PlayScript;
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	/// <summary>
 	///    The compiler driver.
@@ -57,15 +58,26 @@ namespace Mono.CSharp
 				SeekableStreamReader reader = new SeekableStreamReader (input, ctx.Settings.Encoding);
 				var file = new CompilationSourceFile (module, sourceFile);
 
-				Tokenizer lexer = new Tokenizer (reader, file, session);
-				int token, tokens = 0, errors = 0;
-
-				while ((token = lexer.token ()) != Token.EOF){
-					tokens++;
-					if (token == Token.ERROR)
-						errors++;
+				if (sourceFile.FileType == SourceFileType.CSharp) {
+					Tokenizer lexer = new Tokenizer (reader, file, session);
+					int token, tokens = 0, errors = 0;
+
+					while ((token = lexer.token ()) != Token.EOF){
+						tokens++;
+						if (token == Token.ERROR)
+							errors++;
+					}
+				} else {
+					Mono.PlayScript.Tokenizer lexer = new Mono.PlayScript.Tokenizer (reader, file, session);
+					lexer.ParsingPlayScript = sourceFile.PsExtended;
+					int token, tokens = 0, errors = 0;
+	
+					while ((token = lexer.token ()) != Mono.PlayScript.Token.EOF){
+						tokens++;
+						if (token == Mono.PlayScript.Token.ERROR)
+							errors++;
+					}
 				}
-				Console.WriteLine ("Tokenized: " + tokens + " found " + errors + " errors");
 			}
 			
 			return;
@@ -80,7 +92,8 @@ namespace Mono.CSharp
 
 			var session = new ParserSession () {
 				UseJayGlobalArrays = true,
-				LocatedTokens = new Tokenizer.LocatedToken[15000]
+				LocatedTokens = new Tokenizer.LocatedToken[15000],
+				AsLocatedTokens = new Mono.PlayScript.Tokenizer.LocatedToken[15000]
 			};
 
 			for (int i = 0; i < sources.Count; ++i) {
@@ -161,16 +174,30 @@ namespace Mono.CSharp
 			input.Close ();
 		}
 
-		public static CSharpParser Parse (SeekableStreamReader reader, SourceFile sourceFile, ModuleContainer module, ParserSession session, Report report, int lineModifier = 0, int colModifier = 0)
+		public static object Parse (SeekableStreamReader reader, SourceFile sourceFile, ModuleContainer module, ParserSession session, Report report, int lineModifier = 0, int colModifier = 0)
 		{
 			var file = new CompilationSourceFile (module, sourceFile);
 			module.AddTypeContainer(file);
 
-			CSharpParser parser = new CSharpParser (reader, file, report, session);
-			parser.Lexer.Line += lineModifier;
-			parser.Lexer.Column += colModifier;
-			parser.Lexer.sbag = new SpecialsBag ();
-			parser.parse ();
+			object parser = null;
+			
+			if (sourceFile.FileType == SourceFileType.CSharp) {
+				CSharpParser csParser = new CSharpParser (reader, file, report, session);
+				csParser.Lexer.Line += lineModifier;
+				csParser.Lexer.Column += colModifier;
+				csParser.Lexer.sbag = new SpecialsBag ();
+				csParser.parse ();
+				parser = csParser;
+			} else {
+				PlayScriptParser psParser = new PlayScriptParser (reader, file, report, session);
+				psParser.parsing_playscript = sourceFile.PsExtended;
+				psParser.Lexer.Line += lineModifier;
+				psParser.Lexer.Column += colModifier;
+				psParser.Lexer.sbag = new SpecialsBag ();
+				psParser.parse ();
+				parser = psParser;
+			}
+			
 			return parser;
 		}
 
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/dynamic.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/dynamic.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/dynamic.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/dynamic.cs	2013-04-23 21:04:54.000000000 -0700
@@ -17,7 +17,7 @@ using SLE = System.Linq.Expressions;
 using System.Dynamic;
 #endif
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	//
 	// A copy of Microsoft.CSharp/Microsoft.CSharp.RuntimeBinder/CSharpBinderFlags.cs
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/ecore.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/ecore.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/ecore.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/ecore.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,7 +25,7 @@ using System.Reflection;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp {
+namespace Mono.CSharpPs {
 
 	/// <remarks>
 	///   The ExprClass class contains the is used to pass the 
@@ -678,7 +678,8 @@ namespace Mono.CSharp {
 			None = 0,
 			InvocableOnly = 1,
 			ExactArity = 1 << 2,
-			ReadAccess = 1 << 3
+			ReadAccess = 1 << 3,
+			AsTypeCast = 1 << 4
 		}
 
 		//
@@ -6683,12 +6684,12 @@ namespace Mono.CSharp {
 			// nothing
 		}
 		
-		public override Mono.CSharp.Expression CreateExpressionTree (ResolveContext ec)
+		public override Mono.CSharpPs.Expression CreateExpressionTree (ResolveContext ec)
 		{
 			return null;
 		}
 		
-		public override object Accept (Mono.CSharp.StructuralVisitor visitor)
+		public override object Accept (Mono.CSharpPs.StructuralVisitor visitor)
 		{
 			return visitor.Visit (this);
 		}
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/enum.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/enum.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/enum.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/enum.cs	2013-04-23 21:04:54.000000000 -0700
@@ -22,7 +22,7 @@ using MetaType = System.Type;
 using System.Reflection;
 #endif
 
-namespace Mono.CSharp {
+namespace Mono.CSharpPs {
 
 	public class EnumMember : Const
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/eval.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/eval.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/eval.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/eval.cs	2013-04-23 21:04:54.000000000 -0700
@@ -21,7 +21,7 @@ using System.IO;
 using System.Text;
 using System.Linq;
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 
 	/// <summary>
@@ -146,7 +146,7 @@ namespace Mono.CSharp
 		///
 		///   This is the base class that will host the code
 		///   executed by the Evaluator.  By default
-		///   this is the Mono.CSharp.InteractiveBase class
+		///   this is the Mono.CSharpPs.InteractiveBase class
 		///   which is useful for interactive use.
 		///
 		///   By changing this property you can control the
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/expression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/expression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/expression.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/expression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,7 +25,7 @@ using System.Reflection;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	//
 	// This is an user operator expression, automatically created during
@@ -101,6 +101,12 @@ namespace Mono.CSharp
 			loc = expr.Location;
 		}
 
+		public ParenthesizedExpression (Expression expr, Location loc)
+			: base (expr)
+		{
+			this.loc = loc;
+		}
+
 		protected override Expression DoResolve (ResolveContext ec)
 		{
 			var res = expr.Resolve (ec);
@@ -129,7 +135,7 @@ namespace Mono.CSharp
 	{
 		public enum Operator : byte {
 			UnaryPlus, UnaryNegation, LogicalNot, OnesComplement,
-			AddressOf,  TOP
+			AddressOf, AsE4xAttribute, TOP
 		}
 
 		public readonly Operator Oper;
@@ -690,16 +696,16 @@ namespace Mono.CSharp
 		//
 		protected virtual Expression ResolveUserOperator (ResolveContext ec, Expression expr)
 		{
-			CSharp.Operator.OpType op_type;
+			CSharpPs.Operator.OpType op_type;
 			switch (Oper) {
 			case Operator.LogicalNot:
-				op_type = CSharp.Operator.OpType.LogicalNot; break;
+				op_type = CSharpPs.Operator.OpType.LogicalNot; break;
 			case Operator.OnesComplement:
-				op_type = CSharp.Operator.OpType.OnesComplement; break;
+				op_type = CSharpPs.Operator.OpType.OnesComplement; break;
 			case Operator.UnaryNegation:
-				op_type = CSharp.Operator.OpType.UnaryNegation; break;
+				op_type = CSharpPs.Operator.OpType.UnaryNegation; break;
 			case Operator.UnaryPlus:
-				op_type = CSharp.Operator.OpType.UnaryPlus; break;
+				op_type = CSharpPs.Operator.OpType.UnaryPlus; break;
 			default:
 				throw new InternalErrorException (Oper.ToString ());
 			}
@@ -1858,23 +1864,34 @@ namespace Mono.CSharp
 			protected readonly TypeSpec right;
 			public readonly Operator OperatorsMask;
 			public TypeSpec ReturnType;
+			public bool ImplicitConv;
 
 			public PredefinedOperator (TypeSpec ltype, TypeSpec rtype, Operator op_mask)
-				: this (ltype, rtype, op_mask, ltype)
+				: this (ltype, rtype, op_mask, ltype, false)
 			{
 			}
 
 			public PredefinedOperator (TypeSpec type, Operator op_mask, TypeSpec return_type)
-				: this (type, type, op_mask, return_type)
+				: this (type, type, op_mask, return_type, false)
+			{
+			}
+
+			public PredefinedOperator (TypeSpec type, Operator op_mask, TypeSpec return_type, bool implicit_conv)
+				: this (type, type, op_mask, return_type, implicit_conv)
 			{
 			}
 
 			public PredefinedOperator (TypeSpec type, Operator op_mask)
-				: this (type, type, op_mask, type)
+				: this (type, type, op_mask, type, false)
 			{
 			}
 
 			public PredefinedOperator (TypeSpec ltype, TypeSpec rtype, Operator op_mask, TypeSpec return_type)
+				: this (ltype, rtype, op_mask, return_type, false)
+			{
+			}
+
+			public PredefinedOperator (TypeSpec ltype, TypeSpec rtype, Operator op_mask, TypeSpec return_type, bool implicit_conv)
 			{
 				if ((op_mask & Operator.ValuesOnlyMask) != 0)
 					throw new InternalErrorException ("Only masked values can be used");
@@ -1883,6 +1900,7 @@ namespace Mono.CSharp
 				this.right = rtype;
 				this.OperatorsMask = op_mask;
 				this.ReturnType = return_type;
+				this.ImplicitConv = implicit_conv;
 			}
 
 			public virtual Expression ConvertResult (ResolveContext ec, Binary b)
@@ -2159,34 +2177,43 @@ namespace Mono.CSharp
 
 			LeftShift	= 5 | ShiftMask,
 			RightShift	= 6 | ShiftMask,
+			AsURightShift = 7 | ShiftMask,  // PlayScript Unsigned Right Shift
 
-			LessThan	= 7 | ComparisonMask | RelationalMask,
-			GreaterThan	= 8 | ComparisonMask | RelationalMask,
-			LessThanOrEqual		= 9 | ComparisonMask | RelationalMask,
-			GreaterThanOrEqual	= 10 | ComparisonMask | RelationalMask,
-			Equality	= 11 | ComparisonMask | EqualityMask,
-			Inequality	= 12 | ComparisonMask | EqualityMask,
-
-			BitwiseAnd	= 13 | BitwiseMask,
-			ExclusiveOr	= 14 | BitwiseMask,
-			BitwiseOr	= 15 | BitwiseMask,
-
-			LogicalAnd	= 16 | LogicalMask,
-			LogicalOr	= 17 | LogicalMask,
+			LessThan	= 8 | ComparisonMask | RelationalMask,
+			GreaterThan	= 9 | ComparisonMask | RelationalMask,
+			LessThanOrEqual		= 10 | ComparisonMask | RelationalMask,
+			GreaterThanOrEqual	= 11 | ComparisonMask | RelationalMask,
+			Equality	= 12 | ComparisonMask | EqualityMask,
+			Inequality	= 13 | ComparisonMask | EqualityMask,
+			AsRefEquality = 14 | ComparisonMask | EqualityMask,
+			AsRefInequality = 15 | ComparisonMask | EqualityMask,
+
+			BitwiseAnd	= 16 | BitwiseMask,
+			ExclusiveOr	= 17 | BitwiseMask,
+			BitwiseOr	= 18 | BitwiseMask,
+
+			LogicalAnd	= 19 | LogicalMask,
+			LogicalOr	= 20 | LogicalMask,
+
+			AsE4xChild				= 21 | AsE4xMask,
+			AsE4xDescendant			= 22 | AsE4xMask,
+			AsE4xChildAttribute		= 23 | AsE4xMask,
+			AsE4xDescendantAttribute = 24 | AsE4xMask,
 
 			//
 			// Operator masks
 			//
 			ValuesOnlyMask	= ArithmeticMask - 1,
-			ArithmeticMask	= 1 << 5,
-			ShiftMask		= 1 << 6,
-			ComparisonMask	= 1 << 7,
-			EqualityMask	= 1 << 8,
-			BitwiseMask		= 1 << 9,
-			LogicalMask		= 1 << 10,
-			AdditionMask	= 1 << 11,
-			SubtractionMask	= 1 << 12,
-			RelationalMask	= 1 << 13
+			ArithmeticMask	= 1 << 6,
+			ShiftMask		= 1 << 7,
+			ComparisonMask	= 1 << 8,
+			EqualityMask	= 1 << 9,
+			BitwiseMask		= 1 << 10,
+			LogicalMask		= 1 << 11,
+			AdditionMask	= 1 << 12,
+			SubtractionMask	= 1 << 13,
+			RelationalMask	= 1 << 14,
+			AsE4xMask		= 1 << 15
 		}
 
 		protected enum State
@@ -2273,6 +2300,9 @@ namespace Mono.CSharp
 			case Operator.RightShift:
 				s = ">>";
 				break;
+			case Operator.AsURightShift:
+				s = ">>>";
+				break;
 			case Operator.LessThan:
 				s = "<";
 				break;
@@ -2288,9 +2318,15 @@ namespace Mono.CSharp
 			case Operator.Equality:
 				s = "==";
 				break;
+			case Operator.AsRefEquality:
+				s = "===";
+				break;
 			case Operator.Inequality:
 				s = "!=";
 				break;
+			case Operator.AsRefInequality:
+				s = "!==";
+				break;
 			case Operator.BitwiseAnd:
 				s = "&";
 				break;
@@ -2358,12 +2394,16 @@ namespace Mono.CSharp
 				return IsCompound ? "ExclusiveOrAssign" : "ExclusiveOr";
 			case Operator.Equality:
 				return "Equal";
+			case Operator.AsRefEquality:
+				return "ReferenceEqual";
 			case Operator.GreaterThan:
 				return "GreaterThan";
 			case Operator.GreaterThanOrEqual:
 				return "GreaterThanOrEqual";
 			case Operator.Inequality:
 				return "NotEqual";
+			case Operator.AsRefInequality:
+				return "ReferenceNotEqual";
 			case Operator.LeftShift:
 				return IsCompound ? "LeftShiftAssign" : "LeftShift";
 			case Operator.LessThan:
@@ -2380,6 +2420,8 @@ namespace Mono.CSharp
 				return IsCompound ? "MultiplyAssign" : "Multiply";
 			case Operator.RightShift:
 				return IsCompound ? "RightShiftAssign" : "RightShift";
+			case Operator.AsURightShift:
+				return IsCompound ? "UnsignedRightShiftAssign" : "UnsignedRightShift";
 			case Operator.Subtraction:
 				return IsCompound ? "SubtractAssign" : "Subtract";
 			default:
@@ -2387,43 +2429,43 @@ namespace Mono.CSharp
 			}
 		}
 
-		static CSharp.Operator.OpType ConvertBinaryToUserOperator (Operator op)
+		static Mono.CSharpPs.Operator.OpType ConvertBinaryToUserOperator (Operator op)
 		{
 			switch (op) {
 			case Operator.Addition:
-				return CSharp.Operator.OpType.Addition;
+				return CSharpPs.Operator.OpType.Addition;
 			case Operator.BitwiseAnd:
 			case Operator.LogicalAnd:
-				return CSharp.Operator.OpType.BitwiseAnd;
+				return CSharpPs.Operator.OpType.BitwiseAnd;
 			case Operator.BitwiseOr:
 			case Operator.LogicalOr:
-				return CSharp.Operator.OpType.BitwiseOr;
+				return CSharpPs.Operator.OpType.BitwiseOr;
 			case Operator.Division:
-				return CSharp.Operator.OpType.Division;
+				return CSharpPs.Operator.OpType.Division;
 			case Operator.Equality:
-				return CSharp.Operator.OpType.Equality;
+				return CSharpPs.Operator.OpType.Equality;
 			case Operator.ExclusiveOr:
-				return CSharp.Operator.OpType.ExclusiveOr;
+				return CSharpPs.Operator.OpType.ExclusiveOr;
 			case Operator.GreaterThan:
-				return CSharp.Operator.OpType.GreaterThan;
+				return CSharpPs.Operator.OpType.GreaterThan;
 			case Operator.GreaterThanOrEqual:
-				return CSharp.Operator.OpType.GreaterThanOrEqual;
+				return CSharpPs.Operator.OpType.GreaterThanOrEqual;
 			case Operator.Inequality:
-				return CSharp.Operator.OpType.Inequality;
+				return CSharpPs.Operator.OpType.Inequality;
 			case Operator.LeftShift:
-				return CSharp.Operator.OpType.LeftShift;
+				return CSharpPs.Operator.OpType.LeftShift;
 			case Operator.LessThan:
-				return CSharp.Operator.OpType.LessThan;
+				return CSharpPs.Operator.OpType.LessThan;
 			case Operator.LessThanOrEqual:
-				return CSharp.Operator.OpType.LessThanOrEqual;
+				return CSharpPs.Operator.OpType.LessThanOrEqual;
 			case Operator.Modulus:
-				return CSharp.Operator.OpType.Modulus;
+				return CSharpPs.Operator.OpType.Modulus;
 			case Operator.Multiply:
-				return CSharp.Operator.OpType.Multiply;
+				return CSharpPs.Operator.OpType.Multiply;
 			case Operator.RightShift:
-				return CSharp.Operator.OpType.RightShift;
+				return CSharpPs.Operator.OpType.RightShift;
 			case Operator.Subtraction:
-				return CSharp.Operator.OpType.Subtraction;
+				return CSharpPs.Operator.OpType.Subtraction;
 			default:
 				throw new InternalErrorException (op.ToString ());
 			}
@@ -2772,7 +2814,49 @@ namespace Mono.CSharp
 				new PredefinedShiftOperator (types.Int, types.Int, Operator.ShiftMask),
 				new PredefinedShiftOperator (types.UInt, types.Int, Operator.ShiftMask),
 				new PredefinedShiftOperator (types.Long, types.Int, Operator.ShiftMask),
-				new PredefinedShiftOperator (types.ULong, types.Int, Operator.ShiftMask)
+				new PredefinedShiftOperator (types.ULong, types.Int, Operator.ShiftMask),
+			};
+		}
+
+		// PlayScript - We allow implicit conversion of numeric types to bools.
+		public static PredefinedOperator[] CreateAsStandardOperatorsTable (BuiltinTypes types)
+		{
+			TypeSpec bool_type = types.Bool;
+			return new PredefinedOperator[] {
+				new PredefinedOperator (types.Int, Operator.ArithmeticMask | Operator.BitwiseMask),
+				new PredefinedOperator (types.UInt, Operator.ArithmeticMask | Operator.BitwiseMask),
+				new PredefinedOperator (types.Long, Operator.ArithmeticMask | Operator.BitwiseMask),
+				new PredefinedOperator (types.ULong, Operator.ArithmeticMask | Operator.BitwiseMask),
+				new PredefinedOperator (types.Float, Operator.ArithmeticMask),
+				new PredefinedOperator (types.Double, Operator.ArithmeticMask),
+				new PredefinedOperator (types.Decimal, Operator.ArithmeticMask),
+				
+				new PredefinedOperator (types.Int, Operator.ComparisonMask, bool_type),
+				new PredefinedOperator (types.UInt, Operator.ComparisonMask, bool_type),
+				new PredefinedOperator (types.Long, Operator.ComparisonMask, bool_type),
+				new PredefinedOperator (types.ULong, Operator.ComparisonMask, bool_type),
+				new PredefinedOperator (types.Float, Operator.ComparisonMask, bool_type),
+				new PredefinedOperator (types.Double, Operator.ComparisonMask, bool_type),
+				new PredefinedOperator (types.Decimal, Operator.ComparisonMask, bool_type),
+
+				new PredefinedOperator (types.Int, Operator.LogicalMask, bool_type, true),
+				new PredefinedOperator (types.UInt, Operator.LogicalMask, bool_type, true),
+				new PredefinedOperator (types.Long, Operator.LogicalMask, bool_type, true),
+				new PredefinedOperator (types.ULong, Operator.LogicalMask, bool_type, true),
+				new PredefinedOperator (types.Float, Operator.LogicalMask, bool_type, true),
+				new PredefinedOperator (types.Double, Operator.LogicalMask, bool_type, true),
+				new PredefinedOperator (types.Decimal, Operator.LogicalMask, bool_type, true),
+
+				new PredefinedStringOperator (types.String, Operator.AdditionMask, types.String),
+				new PredefinedStringOperator (types.String, types.Object, Operator.AdditionMask, types.String),
+				new PredefinedStringOperator (types.Object, types.String, Operator.AdditionMask, types.String),
+				
+				new PredefinedOperator (bool_type, Operator.BitwiseMask | Operator.LogicalMask | Operator.EqualityMask, bool_type),
+
+				new PredefinedShiftOperator (types.Int, types.Int, Operator.ShiftMask),
+				new PredefinedShiftOperator (types.UInt, types.Int, Operator.ShiftMask),
+				new PredefinedShiftOperator (types.Long, types.Int, Operator.ShiftMask),
+				new PredefinedShiftOperator (types.ULong, types.Int, Operator.ShiftMask),
 			};
 		}
 
@@ -3464,12 +3548,12 @@ namespace Mono.CSharp
 			if (!TypeSpec.IsReferenceType (l) || !TypeSpec.IsReferenceType (r))
 				return null;
 
-			if (l.BuiltinType == BuiltinTypeSpec.Type.String || l.BuiltinType == BuiltinTypeSpec.Type.Delegate || MemberCache.GetUserOperator (l, CSharp.Operator.OpType.Equality, false) != null)
+			if (l.BuiltinType == BuiltinTypeSpec.Type.String || l.BuiltinType == BuiltinTypeSpec.Type.Delegate || MemberCache.GetUserOperator (l, CSharpPs.Operator.OpType.Equality, false) != null)
 				ec.Report.Warning (253, 2, loc,
 					"Possible unintended reference comparison. Consider casting the right side expression to type `{0}' to get value comparison",
 					l.GetSignatureForError ());
 
-			if (r.BuiltinType == BuiltinTypeSpec.Type.String || r.BuiltinType == BuiltinTypeSpec.Type.Delegate || MemberCache.GetUserOperator (r, CSharp.Operator.OpType.Equality, false) != null)
+			if (r.BuiltinType == BuiltinTypeSpec.Type.String || r.BuiltinType == BuiltinTypeSpec.Type.Delegate || MemberCache.GetUserOperator (r, CSharpPs.Operator.OpType.Equality, false) != null)
 				ec.Report.Warning (252, 2, loc,
 					"Possible unintended reference comparison. Consider casting the left side expression to type `{0}' to get value comparison",
 					r.GetSignatureForError ());
@@ -5989,8 +6073,8 @@ namespace Mono.CSharp
 	//
 	public class ArrayInitializer : Expression
 	{
-		List<Expression> elements;
-		BlockVariableDeclaration variable;
+		protected List<Expression> elements;
+		protected BlockVariableDeclaration variable;
 
 		public ArrayInitializer (List<Expression> init, Location loc)
 		{
@@ -7882,6 +7966,17 @@ namespace Mono.CSharp
 	/// </summary>
 	public class MemberAccess : ATypeNameExpression
 	{
+		public enum Accessor {
+			Member,
+			AsE4xDescendant,				// The PlayScript E4X .. operator.
+			AsE4xChildAll,					// The PlayScript E4X .* operator.
+			AsE4xChildAttribute,			// The PlayScript E4X .@ operator.
+			AsE4xDescendantAll,				// The PlayScript E4X ..* operator.
+			AsE4xNamespace					// The PlayScript :: operator.
+		}
+
+		public Accessor AccessorType = Accessor.Member;
+
 		protected Expression expr;
 
 #if FULL_AST
@@ -8496,6 +8591,14 @@ namespace Mono.CSharp
 		public Arguments Arguments;
 		public Expression Expr;
 
+		public enum Accessor {
+			ElementAccess,
+			AsE4xNamespaceAccess,
+			AsE4xAttributeAccess
+		}
+
+		public Accessor AccessorType = Accessor.ElementAccess;
+
 		public ElementAccess (Expression e, Arguments args, Location loc)
 		{
 			Expr = e;
@@ -10153,9 +10256,9 @@ namespace Mono.CSharp
 		{
 			NewInitialize new_instance;
 
-			public InitializerTargetExpression (NewInitialize newInstance)
+			public InitializerTargetExpression (NewInitialize newInstance, TypeSpec castType = null)
 			{
-				this.type = newInstance.type;
+				this.type = castType ?? newInstance.type;
 				this.loc = newInstance.loc;
 				this.eclass = newInstance.eclass;
 				this.new_instance = newInstance;
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/field.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/field.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/field.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/field.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@ using System.Reflection;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	public class FieldDeclarator
 	{
@@ -36,9 +36,19 @@ namespace Mono.CSharp
 			this.Initializer = initializer;
 		}
 
+		// PlayScript - field declarators have types
+		public FieldDeclarator (SimpleMemberName name, Expression initializer, FullNamedExpression type_expr)
+		{
+			this.Name = name;
+			this.TypeExpression = type_expr;
+			this.Initializer = initializer;
+		}
+
 		#region Properties
 
 		public SimpleMemberName Name { get; private set; }
+		public FullNamedExpression TypeExpression { get; private set; }
+		public TypeSpec Type { get; private set; }
 		public Expression Initializer { get; private set; }
 
 		#endregion
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/flowanalysis.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/flowanalysis.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/flowanalysis.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/flowanalysis.cs	2013-04-23 21:04:54.000000000 -0700
@@ -15,7 +15,7 @@ using System;
 using System.Text;
 using System.Collections.Generic;
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	// <summary>
 	//   A new instance of this class is created every time a new block is resolved
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/generic.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/generic.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/generic.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/generic.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@ using System.Reflection;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp {
+namespace Mono.CSharpPs {
 	public enum Variance
 	{
 		//
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/import.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/import.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/import.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/import.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@ using System.Reflection;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	public abstract class MetadataImporter
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/iterators.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/iterators.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/iterators.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/iterators.cs	2013-04-23 21:04:54.000000000 -0700
@@ -21,7 +21,7 @@ using IKVM.Reflection.Emit;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	public abstract class YieldStatement<T> : ResumableStatement where T : StateMachineInitializer
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/lambda.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/lambda.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/lambda.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/lambda.cs	2013-04-23 21:04:54.000000000 -0700
@@ -16,7 +16,7 @@ using IKVM.Reflection.Emit;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp {
+namespace Mono.CSharpPs {
 	public class LambdaExpression : AnonymousMethodExpression
 	{
 		//
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/linq.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/linq.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/linq.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/linq.cs	2013-04-23 21:04:54.000000000 -0700
@@ -12,7 +12,7 @@
 using System;
 using System.Collections.Generic;
 
-namespace Mono.CSharp.Linq
+namespace Mono.CSharpPs.Linq
 {
 	public class QueryExpression : AQueryClause
 	{
@@ -376,6 +376,12 @@ namespace Mono.CSharp.Linq
 
 		public string Name { get; private set; }
 
+		// PlayScript - Not used.
+		FullNamedExpression INamedBlockVariable.TypeExpr {
+			get { return null; }
+			set { }
+		}
+
 		#endregion
 
 		public Expression CreateReferenceExpression (ResolveContext rc, Location loc)
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/literal.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/literal.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/literal.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/literal.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@ using IKVM.Reflection.Emit;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	public interface ILiteralConstant
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/location.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/location.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/location.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/location.cs	2013-04-23 21:04:54.000000000 -0700
@@ -14,10 +14,17 @@ using System;
 using System.Collections.Generic;
 using Mono.CompilerServices.SymbolWriter;
 using System.Diagnostics;
+using System.IO;
 using System.Linq;
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
+	public enum SourceFileType 
+	{
+		CSharp,
+		PlayScript
+	}
+	
 	//
 	//  This is one single source file.
 	//
@@ -59,6 +66,10 @@ namespace Mono.CSharp
 		public readonly int Index;
 		public bool AutoGenerated;
 
+		// AS Support
+		public SourceFileType FileType; // FileType is PlayScript or CSharp
+		public bool PsExtended;  		// Allow PlayScript Extended Syntax (C# constructs/types)
+
 		SourceFileEntry file;
 		byte[] algGuid, checksum;
 		List<LocationRegion> hidden_lines;
@@ -68,6 +79,16 @@ namespace Mono.CSharp
 			this.Index = index;
 			this.Name = name;
 			this.FullPathName = path;
+			var ext = Path.GetExtension (path);
+			if (String.IsNullOrEmpty(name) || String.IsNullOrEmpty(ext) || ext.ToLower() == ".play" || ext.ToLower() == ".asx") {
+				FileType = SourceFileType.PlayScript;
+				PsExtended = true;
+			} else if (ext.ToLower() == ".as") {
+				FileType = SourceFileType.PlayScript;
+				PsExtended = false;
+			} else {
+				FileType = SourceFileType.CSharp;
+			}
 		}
 
 		public byte[] Checksum {
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/membercache.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/membercache.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/membercache.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/membercache.cs	2013-04-23 21:04:54.000000000 -0700
@@ -15,7 +15,7 @@
 using System;
 using System.Collections.Generic;
 
-namespace Mono.CSharp {
+namespace Mono.CSharpPs {
 
 	[Flags]
 	public enum MemberKind
@@ -93,7 +93,7 @@ namespace Mono.CSharp {
 
 		public static MemberFilter Constructor (AParametersCollection param)
 		{
-			return new MemberFilter (Mono.CSharp.Constructor.ConstructorName, 0, MemberKind.Constructor, param, null);
+			return new MemberFilter (Mono.CSharpPs.Constructor.ConstructorName, 0, MemberKind.Constructor, param, null);
 		}
 
 		public static MemberFilter Property (string name, TypeSpec type)
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/method.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/method.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/method.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/method.cs	2013-04-23 21:04:54.000000000 -0700
@@ -39,7 +39,7 @@ using System.Reflection;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp {
+namespace Mono.CSharpPs {
 
 	public abstract class MethodCore : InterfaceMemberBase, IParametersMember
 	{
@@ -1369,6 +1369,9 @@ namespace Mono.CSharp {
 		Arguments argument_list;
 		MethodSpec base_ctor;
 
+		// PlayScript: Initializer is explicitly called via super() call in constructor method.
+		public bool IsAsExplicitSuperCall;
+
 		public ConstructorInitializer (Arguments argument_list, Location loc)
 		{
 			this.argument_list = argument_list;
@@ -2464,6 +2467,10 @@ namespace Mono.CSharp {
 			GreaterThanOrEqual,
 			LessThanOrEqual,
 
+			// PlayScript binary operators
+			AsIn, 			// PlayScript "in" operator
+			AsURightShift, 	// PlayScript unsigned shift right
+
 			// Implicit and Explicit
 			Implicit,
 			Explicit,
@@ -2503,6 +2510,8 @@ namespace Mono.CSharp {
 			names [(int) OpType.LessThan] = new string [] { "<", "op_LessThan" };
 			names [(int) OpType.GreaterThanOrEqual] = new string [] { ">=", "op_GreaterThanOrEqual" };
 			names [(int) OpType.LessThanOrEqual] = new string [] { "<=", "op_LessThanOrEqual" };
+			names [(int) OpType.AsIn] = new string [] { "in", "op_In" };
+			names [(int) OpType.AsURightShift] = new string [] { ">>>", "op_UnsignedRightShift" };
 			names [(int) OpType.Implicit] = new string [] { "implicit", "op_Implicit" };
 			names [(int) OpType.Explicit] = new string [] { "explicit", "op_Explicit" };
 		}
@@ -2620,7 +2629,7 @@ namespace Mono.CSharp {
 						return false;
 					}
 				}
-			} else if (OperatorType == OpType.LeftShift || OperatorType == OpType.RightShift) {
+			} else if (OperatorType == OpType.LeftShift || OperatorType == OpType.RightShift || OperatorType == OpType.AsURightShift) {
 				if (first_arg_type != declaring_type || parameters.Types[1].BuiltinType != BuiltinTypeSpec.Type.Int) {
 					Report.Error (564, Location, "Overloaded shift operator must have the type of the first operand be the containing type, and the type of the second operand must be int");
 					return false;
@@ -2747,6 +2756,8 @@ namespace Mono.CSharp {
 				return OpType.LessThanOrEqual;
 			case OpType.LessThanOrEqual:
 				return OpType.GreaterThanOrEqual;
+			case OpType.AsIn:  // PlayScript "in" operator
+				return OpType.AsIn;
 			default:
 				return OpType.TOP;
 			}
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/modifiers.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/modifiers.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/modifiers.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/modifiers.cs	2013-04-23 21:04:54.000000000 -0700
@@ -18,7 +18,7 @@ using IKVM.Reflection;
 using System.Reflection;
 #endif
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	[Flags]
 	public enum Modifiers
@@ -38,7 +38,8 @@ namespace Mono.CSharp
 		VOLATILE  = 0x1000,
 		UNSAFE    = 0x2000,
 		ASYNC     = 0x4000,
-		TOP       = 0x8000,
+		AS_DYNAMIC = 0x8000,
+		TOP       = 0x10000,
 
 		//
 		// Compiler specific flags
@@ -111,6 +112,8 @@ namespace Mono.CSharp
 				s = "unsafe"; break;
 			case Modifiers.ASYNC:
 				s = "async"; break;
+			case Modifiers.AS_DYNAMIC:
+				s = "dynamic"; break;
 			}
 
 			return s;
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/module.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/module.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/module.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/module.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,7 +25,7 @@ using System.Reflection;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	//
 	// Module (top-level type) container
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/namespace.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/namespace.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/namespace.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/namespace.cs	2013-04-23 21:04:54.000000000 -0700
@@ -14,7 +14,7 @@ using System.Collections.Generic;
 using System.Linq;
 using Mono.CompilerServices.SymbolWriter;
 
-namespace Mono.CSharp {
+namespace Mono.CSharpPs {
 
 	public class RootNamespace : Namespace {
 
@@ -252,7 +252,7 @@ namespace Mono.CSharp {
 
 			case "System.Windows.Forms":
 			case "System.Windows.Forms.Layout":
-				assembly = "System.Windows.Name";
+				assembly = "System.Windows.Forms";
 				break;
 			}
 
@@ -436,6 +436,23 @@ namespace Mono.CSharp {
 			return texpr;
 		}
 
+		public ATypeNameExpression MakeTypeNameExpression(Location loc) 
+		{
+			string[] names = Name.Split(new [] {'.'});
+
+			ATypeNameExpression exp = null;
+			for (var i = 0; i < names.Length; i++) {
+				var name = names[i];
+				if (exp == null) {
+					exp = new SimpleName (name, loc);
+				} else {
+					exp = new MemberAccess(exp, name, loc);
+				}
+			}
+
+			return exp;
+		}
+
 		//
 		// Completes types with the given `prefix'
 		//
@@ -780,6 +797,7 @@ namespace Mono.CSharp {
 	public class NamespaceContainer : TypeContainer, IMemberContext
 	{
 		static readonly Namespace[] empty_namespaces = new Namespace[0];
+		static readonly Tuple<TypeExpr,TypeSpec>[] empty_types = new Tuple<TypeExpr,TypeSpec>[0]; /* AS SUPPORT */
 
 		readonly Namespace ns;
 
@@ -791,9 +809,12 @@ namespace Mono.CSharp {
 		public bool DeclarationFound;
 
 		Namespace[] namespace_using_table;
+		Tuple<TypeExpr,TypeSpec>[] type_using_table; /* AS SUPPORT */
 		Dictionary<string, UsingAliasNamespace> aliases;
 		public readonly MemberName RealMemberName;
 
+		CompilationSourceFile compSourceFile;
+		
 		public NamespaceContainer (MemberName name, NamespaceContainer parent)
 			: base (parent, name, null, MemberKind.Namespace)
 		{
@@ -802,6 +823,12 @@ namespace Mono.CSharp {
 			this.ns = parent.NS.AddNamespace (name);
 
 			containers = new List<TypeContainer> ();
+
+			var topParent = this;
+			while (topParent.Parent != null) {
+				topParent = topParent.Parent;
+			}
+			compSourceFile = topParent as CompilationSourceFile;
 		}
 
 		protected NamespaceContainer (ModuleContainer parent)
@@ -843,11 +870,21 @@ namespace Mono.CSharp {
 			}
 		}
 
+		public override SourceFileType FileType {
+			get {
+				return compSourceFile != null ? compSourceFile.SourceFile.FileType : SourceFileType.CSharp;
+			}
+		}
+
 		#endregion
 
-		public void AddUsing (UsingNamespace un)
+		public void AddUsing (UsingNamespace un, bool forceAppend = false)
 		{
-			if (DeclarationFound){
+			bool isPlayScript = compSourceFile != null &&
+				compSourceFile.SourceFile != null && 
+					compSourceFile.SourceFile.FileType == Mono.CSharpPs.SourceFileType.PlayScript;
+
+			if (DeclarationFound && !forceAppend && !isPlayScript){
 				Compiler.Report.Error (1529, un.Location, "A using clause must precede all other namespace elements except extern alias declarations");
 			}
 
@@ -1174,10 +1211,22 @@ namespace Mono.CSharp {
 				DoDefineNamespace ();
 			}
 
+			FullNamedExpression match = null;
+
+			//
+			// Check using types.
+			//
+			foreach (Tuple<TypeExpr,TypeSpec> using_type in type_using_table) {
+				var texpr = using_type.Item1;
+				var tspec = using_type.Item2;
+				if (tspec.Name == name && tspec.Arity == arity) {
+					match = texpr;
+				}
+			}
+			
 			//
 			// Check using entries.
 			//
-			FullNamedExpression match = null;
 			foreach (Namespace using_ns in namespace_using_table) {
 				//
 				// A using directive imports only types contained in the namespace, it
@@ -1233,9 +1282,12 @@ namespace Mono.CSharp {
 		void DoDefineNamespace ()
 		{
 			namespace_using_table = empty_namespaces;
+			type_using_table = empty_types; /* AS SUPPORT */
 
 			if (clauses != null) {
-				var list = new List<Namespace> (clauses.Count);
+				var ns_list = new List<Namespace> (clauses.Count);
+				var t_list = new List<Tuple<TypeExpr,TypeSpec>> (clauses.Count); /* AS SUPPORT */
+				
 				bool post_process_using_aliases = false;
 
 				for (int i = 0; i < clauses.Count; ++i) {
@@ -1273,22 +1325,44 @@ namespace Mono.CSharp {
 						continue;
 					}
 
+					var ut_entry = entry as UsingType;
+					if (ut_entry != null) { /* AS SUPPORT */
+						
+						TypeExpr using_te = ut_entry.ResolvedExpression as TypeExpr;
+						TypeSpec using_ts = ut_entry.ResolvedType as TypeSpec;
+						
+						if (using_te != null && using_ts != null) {
+							if (t_list.Find (t => t.Item1 == using_te) != null) {
+								// Ensure we don't report the warning multiple times in repl
+								clauses.RemoveAt (i--);
+		
+								Compiler.Report.Warning (105, 3, entry.Location,
+									"The using directive for `{0}' appeared previously in this namespace", using_te.GetSignatureForError ());
+							} else {
+								t_list.Add (new Tuple<TypeExpr, TypeSpec> (using_te, using_ts));
+							}
+						}
+							
+						continue;
+					}
+						
 					Namespace using_ns = entry.ResolvedExpression as Namespace;
 					if (using_ns == null)
 						continue;
 
-					if (list.Contains (using_ns)) {
+					if (ns_list.Contains (using_ns)) {
 						// Ensure we don't report the warning multiple times in repl
 						clauses.RemoveAt (i--);
 
 						Compiler.Report.Warning (105, 3, entry.Location,
 							"The using directive for `{0}' appeared previously in this namespace", using_ns.GetSignatureForError ());
 					} else {
-						list.Add (using_ns);
+						ns_list.Add (using_ns);
 					}
 				}
 
-				namespace_using_table = list.ToArray ();
+				namespace_using_table = ns_list.ToArray ();
+				type_using_table = t_list.ToArray (); /* AS SUPPORT */
 
 				if (post_process_using_aliases) {
 					for (int i = 0; i < clauses.Count; ++i) {
@@ -1437,13 +1511,30 @@ namespace Mono.CSharp {
 					Alias.Value);
 			}
 		}
+	}
+
+	public class UsingType : UsingNamespace
+	{
+		protected TypeSpec resolvedType;
+		
+		public UsingType (ATypeNameExpression expr, Location loc)
+			: base (expr, loc)
+		{
+		}
 		
-		public override void Accept (StructuralVisitor visitor)
+		public override void Define (NamespaceContainer ctx)
 		{
-			visitor.Visit (this);
+			resolved = NamespaceExpression.ResolveAsTypeOrNamespace (ctx);
+			if (resolved != null) {
+				resolvedType = resolved.ResolveAsType (ctx);
 		}
 	}
 
+		public TypeSpec ResolvedType {
+			get { return resolvedType; }
+		}
+	}		
+		
 	public class UsingAliasNamespace : UsingNamespace
 	{
 		readonly SimpleMemberName alias;
@@ -1543,6 +1634,10 @@ namespace Mono.CSharp {
 			{
 				return ns.LookupNamespaceAlias (name);
 			}
+
+			public SourceFileType FileType {
+				get { return ns.FileType; }
+			}
 		}
 
 		public UsingAliasNamespace (SimpleMemberName alias, ATypeNameExpression expr, Location loc)
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/nullable.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/nullable.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/nullable.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/nullable.cs	2013-04-23 21:04:54.000000000 -0700
@@ -20,7 +20,7 @@ using IKVM.Reflection.Emit;
 using System.Reflection.Emit;
 #endif
 	
-namespace Mono.CSharp.Nullable
+namespace Mono.CSharpPs.Nullable
 {
 	public class NullableType : TypeExpr
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/outline.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/outline.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/outline.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/outline.cs	2013-04-23 21:04:54.000000000 -0700
@@ -38,7 +38,7 @@ using System.CodeDom.Compiler;
 using System.IO;
 using System.Text;
 
-namespace Mono.CSharp {
+namespace Mono.CSharpPs {
 public class Outline {
 
 	bool declared_only;
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/parameter.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/parameter.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/parameter.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/parameter.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@ using System.Reflection;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp {
+namespace Mono.CSharpPs {
 
 	/// <summary>
 	///   Abstract Base class for parameters of a method.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/pending.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/pending.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/pending.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/pending.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@ using System.Reflection;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp {
+namespace Mono.CSharpPs {
 
 	struct TypeAndMethods {
 		public TypeSpec          type;
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/property.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/property.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/property.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/property.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,7 +29,7 @@ using System.Reflection;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	// It is used as a base class for all property based members
 	// This includes properties, indexers, and events
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/ps-lang.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/ps-lang.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/ps-lang.cs	1969-12-31 16:00:00.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/ps-lang.cs	2013-04-23 21:04:54.000000000 -0700
@@ -0,0 +1,1219 @@
+// Copyright 2013 Zynga Inc.
+//	
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//		
+//      Unless required by applicable law or agreed to in writing, software
+//      distributed under the License is distributed on an "AS IS" BASIS,
+//      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//      See the License for the specific language governing permissions and
+//      limitations under the License.
+
+using System;
+using System.Collections.Generic;
+//using Mono.CSharpPs.JavaScript;
+//using Mono.CSharpPs.Cpp;
+
+#if STATIC
+using IKVM.Reflection;
+using IKVM.Reflection.Emit;
+#else
+using System.Reflection;
+using System.Reflection.Emit;
+#endif
+
+namespace Mono.CSharpPs
+{
+	//
+	// Constants
+	//
+
+	public static class PsConsts 
+	{
+		//
+		// The namespace used for the root package.
+		//
+		public const string PsRootNamespace = "_root";
+	}
+
+	//
+	// Expressions
+	//
+
+	//
+	// ActionScript: Object initializers implement standard JSON style object
+	// initializer syntax in the form { ident : expr [ , ... ] } or { "literal" : expr [, ... ]}
+	// Like the array initializer, type is inferred from assignment type, parameter type, or
+	// field, var initializer type, or of no type can be inferred it is of type Dictionary<String,Object>.
+	//
+	public partial class AsObjectInitializer : Expression
+	{
+		List<Expression> elements;
+		BlockVariableDeclaration variable;
+		Assign assign;
+		TypeSpec inferredObjType;
+
+		public AsObjectInitializer (List<Expression> init, Location loc)
+		{
+			elements = init;
+			this.loc = loc;
+		}
+
+		public AsObjectInitializer (int count, Location loc)
+			: this (new List<Expression> (count), loc)
+		{
+		}
+
+		public AsObjectInitializer (Location loc)
+			: this (4, loc)
+		{
+		}
+
+		#region Properties
+
+		public int Count {
+			get { return elements.Count; }
+		}
+
+		public List<Expression> Elements {
+			get {
+				return elements;
+			}
+		}
+
+		public Expression this [int index] {
+			get {
+				return elements [index];
+			}
+		}
+
+		public BlockVariableDeclaration VariableDeclaration {
+			get {
+				return variable;
+			}
+			set {
+				variable = value;
+			}
+		}
+
+		public Assign Assign {
+			get {
+				return assign;
+			}
+			set {
+				assign = value;
+			}
+		}
+
+		#endregion
+
+		public void Add (Expression expr)
+		{
+			elements.Add (expr);
+		}
+
+		public override bool ContainsEmitWithAwait ()
+		{
+			throw new NotSupportedException ();
+		}
+
+		public override Expression CreateExpressionTree (ResolveContext ec)
+		{
+			throw new NotSupportedException ("ET");
+		}
+
+		protected override void CloneTo (CloneContext clonectx, Expression t)
+		{
+			var target = (AsObjectInitializer) t;
+
+			target.elements = new List<Expression> (elements.Count);
+			foreach (var element in elements)
+				target.elements.Add (element.Clone (clonectx));
+		}
+
+		protected override Expression DoResolve (ResolveContext rc)
+		{
+//			BEN: This won't work because the returned type won't pass Mono's type checkers.
+//			if (rc.Target == Target.JavaScript) {
+//				this.type = rc.BuiltinTypes.Dynamic;
+//				this.eclass = ExprClass.Value;
+//				foreach (ElementInitializer elem in Elements)
+//					elem.Resolve (rc);
+//				return this;
+//			}
+
+			TypeExpression type;
+			if (inferredObjType != null) {
+				type = new TypeExpression (inferredObjType, Location);
+			} else if (variable != null) {
+				if (variable.TypeExpression is VarExpr) {
+					type = new TypeExpression (rc.BuiltinTypes.Dynamic, Location);
+				} else {
+					type = new TypeExpression (variable.Variable.Type, variable.Variable.Location);
+				}
+			} else if (assign != null && assign.Target.Type != null) {
+				type = new TypeExpression (assign.Target.Type, assign.Target.Location);
+			} else {
+				type = new TypeExpression (rc.BuiltinTypes.Dynamic, Location);
+			}
+
+			return new NewInitialize (type, null, 
+				new CollectionOrObjectInitializers(elements, Location), Location).Resolve (rc);
+		}
+
+		public Expression InferredResolveWithObjectType(ResolveContext rc, TypeSpec objType) 
+		{
+			if (objType.Name == "ExpandoObject")
+				objType = rc.BuiltinTypes.Dynamic;
+			inferredObjType = objType;
+			return Resolve (rc);
+		}
+
+		public override void Emit (EmitContext ec)
+		{
+			throw new InternalErrorException ("Missing Resolve call");
+		}
+
+//		public override void EmitJs (JsEmitContext jec)
+//		{
+//			jec.Buf.Write ("{", Location);
+//
+//			bool first = true;
+//			foreach (ElementInitializer elem in Elements) {
+//				if (!first)
+//					jec.Buf.Write (", ");
+//				jec.Buf.Write ("\"", elem.Name, "\":");
+//				elem.Source.EmitJs (jec);
+//				first = false;
+//			}
+//
+//			jec.Buf.Write ("}");
+//		}
+
+		public override object Accept (StructuralVisitor visitor)
+		{
+			return visitor.Visit (this);
+		}
+	}
+
+	//
+	// ActionScript: Array initializer expression is a standard expression
+	// allowed anywhere an expression is valid.  The type is inferred from
+	// assignment type, parameter type, or field/variable initializer type.
+	// If no type is inferred, the type is Vector.<Object>.
+	//
+	public partial class AsArrayInitializer : ArrayInitializer
+	{
+		Assign assign;
+		TypeSpec inferredArrayType;
+		FullNamedExpression vectorType;
+
+		public AsArrayInitializer (List<Expression> init, Location loc)
+			: base(init, loc)
+		{
+		}
+
+		public AsArrayInitializer (int count, Location loc)
+			: this (new List<Expression> (count), loc)
+		{
+		}
+
+		public AsArrayInitializer (Location loc)
+			: this (4, loc)
+		{
+		}
+
+		#region Properties
+
+		public Assign Assign {
+			get {
+				return assign;
+			}
+			set {
+				assign = value;
+			}
+		}
+
+		public FullNamedExpression VectorType {
+			get {
+				return vectorType;
+			}
+			set {
+				vectorType = value;
+			}
+		}
+
+		#endregion
+
+		protected override Expression DoResolve (ResolveContext rc)
+		{
+//			BEN: This won't work because the returned type won't pass Mono's type checkers.
+//			if (rc.Target == Target.JavaScript) {
+//				this.type = rc.Module.PredefinedTypes.AsArray.Resolve();
+//				this.eclass = ExprClass.Value;
+//				foreach (var elem in Elements)
+//					elem.Resolve (rc);
+//				return this;
+//			}
+
+			TypeExpression type;
+			if (vectorType != null) {
+				var elemTypeSpec = vectorType.ResolveAsType(rc);
+				if (elemTypeSpec != null) {
+					type = new TypeExpression(
+						rc.Module.PredefinedTypes.AsVector.Resolve().MakeGenericType (rc, new [] { elemTypeSpec }), Location);
+				} else {
+					type = new TypeExpression (rc.Module.PredefinedTypes.AsArray.Resolve(), Location);
+				}
+			} else if (inferredArrayType != null) {
+				type = new TypeExpression (inferredArrayType, Location);
+			} else if (variable != null) {
+				if (variable.TypeExpression is VarExpr) {
+					type = new TypeExpression (rc.Module.PredefinedTypes.AsArray.Resolve(), Location);
+				} else if (variable.Variable.Type == rc.BuiltinTypes.Dynamic) {
+					type = new TypeExpression (rc.Module.PredefinedTypes.AsArray.Resolve(), Location);
+				} else {
+					type = new TypeExpression (variable.Variable.Type, variable.Variable.Location);
+				}
+			} else if (assign != null && assign.Target.Type != null) {
+				if (assign.Target.Type == rc.BuiltinTypes.Dynamic) {
+					type = new TypeExpression (rc.Module.PredefinedTypes.AsArray.Resolve(), Location);
+				} else {
+					type = new TypeExpression (assign.Target.Type, assign.Target.Location);
+				}
+			} else {
+				type = new TypeExpression (rc.Module.PredefinedTypes.AsArray.Resolve(), Location);
+			}
+
+			TypeSpec typeSpec = type.ResolveAsType(rc.MemberContext);
+			if (typeSpec.IsArray) {
+				ArrayCreation arrayCreate = (ArrayCreation)new ArrayCreation (type, this).Resolve (rc);
+				return arrayCreate;
+			} else {
+				var initElems = new List<Expression>();
+				foreach (var e in elements) {
+					initElems.Add (new CollectionElementInitializer(e));
+				}
+				return new NewInitialize (type, null, 
+					new CollectionOrObjectInitializers(initElems, Location), Location).Resolve (rc);
+			}
+		}
+
+		public Expression InferredResolveWithArrayType(ResolveContext rc, TypeSpec arrayType) 
+		{
+			inferredArrayType = arrayType;
+			return Resolve (rc);
+		}
+
+//		public override void EmitJs (JsEmitContext jec)
+//		{
+//			jec.Buf.Write ("[", Location);
+//			
+//			bool first = true;
+//			foreach (var elem in Elements) {
+//				if (!first)
+//					jec.Buf.Write (", ");
+//				elem.EmitJs (jec);
+//				first = false;
+//			}
+//			
+//			jec.Buf.Write ("]");
+//		}
+
+		public override object Accept (StructuralVisitor visitor)
+		{
+			return visitor.Visit (this);
+		}
+	}
+
+	//
+	// ActionScript: Implements the ActionScript delete expression.
+	// This expression is used to implement the delete expression as
+	// well as the delete statement.  Handles both the element access
+	// form or the member access form.
+	//
+	public partial class AsDelete : ExpressionStatement {
+
+		public Expression Expr;
+		private Invocation removeExpr;
+		
+		public AsDelete (Expression expr, Location l)
+		{
+			this.Expr = expr;
+			loc = l;
+		}
+
+		public override bool IsSideEffectFree {
+			get {
+				return removeExpr.IsSideEffectFree;
+			}
+		}
+
+		public override bool ContainsEmitWithAwait ()
+		{
+			return removeExpr.ContainsEmitWithAwait ();
+		}
+
+		protected override Expression DoResolve (ResolveContext ec)
+		{
+//			if (ec.Target == Target.JavaScript) {
+//				type = ec.BuiltinTypes.Dynamic;
+//				eclass = ExprClass.Value;
+//				return this;
+//			}
+
+			if (Expr is ElementAccess) {
+
+				var elem_access = Expr as ElementAccess;
+
+				if (elem_access.Arguments.Count != 1) {
+					ec.Report.Error (7021, loc, "delete statement must have only one index argument.");
+					return null;
+				}
+
+				var expr = elem_access.Expr.Resolve (ec);
+				if (expr.Type == null) {
+					return null;
+				}
+
+				if (expr.Type.IsArray) {
+					ec.Report.Error (7021, loc, "delete statement not allowed on arrays.");
+					return null;
+				}
+
+				if (ec.Target == Target.JavaScript) {
+					Expr = Expr.Resolve(ec);
+					return this;
+				}
+
+				removeExpr = new Invocation (new MemberAccess (expr, "Remove", loc), elem_access.Arguments);
+				return removeExpr.Resolve (ec);
+
+			} else if (Expr is MemberAccess) {
+
+				if (ec.Target == Target.JavaScript) {
+					Expr = Expr.Resolve(ec);
+					return this;
+				}
+
+				var memb_access = Expr as MemberAccess;
+
+				var expr = memb_access.LeftExpression.Resolve (ec);
+				if (expr.Type == null) {
+					return null;
+				}
+
+				var args = new Arguments(1);
+				args.Add (new Argument(new StringLiteral(ec.BuiltinTypes, memb_access.Name, loc)));
+				removeExpr = new Invocation (new MemberAccess (expr, "Remove", loc), args);
+				return removeExpr.Resolve (ec);
+
+			} else {
+				// Error is reported elsewhere.
+				return null;
+			}
+		}
+
+		protected override void CloneTo (CloneContext clonectx, Expression t)
+		{
+			var target = (AsDelete) t;
+
+			target.Expr = Expr.Clone (clonectx);
+		}
+
+		public override void Emit (EmitContext ec)
+		{
+			throw new System.NotImplementedException ();
+		}
+
+		public override void EmitStatement (EmitContext ec)
+		{
+			throw new System.NotImplementedException ();
+		}
+
+//		public override void EmitJs (JsEmitContext jec)
+//		{
+//			jec.Buf.Write ("delete ", Location);
+//			Expr.EmitJs (jec);
+//		}
+
+//		public override void EmitStatementJs (JsEmitContext jec)
+//		{
+//			jec.Buf.Write ("\t", Location);
+//			EmitJs (jec);
+//			jec.Buf.Write (";\n");
+//		}
+
+		public override Expression CreateExpressionTree (ResolveContext ec)
+		{
+			return removeExpr.CreateExpressionTree(ec);
+		}
+
+		public override object Accept (StructuralVisitor visitor)
+		{
+			return visitor.Visit (this);
+		}
+	}
+
+	//
+	// ActionScript: Implements the ActionScript new expression.
+	// This expression is used to implement the as new expression 
+	// which takes either a type expression, an AsArrayInitializer,
+	// or an invocation expression of some form.
+	//
+	public partial class AsNew : ExpressionStatement {
+		
+		public Expression Expr;
+		private Expression newExpr;
+
+		public AsNew (Expression expr, Location l)
+		{
+			this.Expr = expr;
+			loc = l;
+		}
+		
+		public override bool IsSideEffectFree {
+			get {
+				return newExpr.IsSideEffectFree;
+			}
+		}
+		
+		public override bool ContainsEmitWithAwait ()
+		{
+			return newExpr.ContainsEmitWithAwait ();
+		}
+		
+		protected override Expression DoResolve (ResolveContext ec)
+		{
+			if (ec.Target == Target.JavaScript) {
+				type = ec.BuiltinTypes.Dynamic;
+				eclass = ExprClass.Value;
+				return this;
+			}
+
+			if (Expr is AsArrayInitializer)
+				return Expr.Resolve (ec);
+
+			New newExpr = null;
+
+			if (Expr is Invocation) {
+				var inv = Expr as Invocation;
+				newExpr = new New(inv.Exp, inv.Arguments, loc);
+			} else if (Expr is ElementAccess) {
+				if (loc.SourceFile != null && !loc.SourceFile.PsExtended) {
+					ec.Report.Error (7103, loc, "Native arrays are only suppored in ASX.'");
+					return null;
+				}
+				var elemAcc = Expr as ElementAccess;
+				var exprList = new List<Expression>();
+				foreach (var arg in elemAcc.Arguments) {
+					exprList.Add (arg.Expr);
+				}
+				// TODO: Handle jagged arrays
+				var arrayCreate = new ArrayCreation ((FullNamedExpression) elemAcc.Expr, exprList, 
+				                new ComposedTypeSpecifier (exprList.Count, loc), null, loc);
+				return arrayCreate.Resolve (ec);
+			} else {
+				var resolveExpr = Expr.Resolve (ec);
+				if (resolveExpr == null)
+					return null;
+				newExpr = new New(resolveExpr, new Arguments (0), loc);
+			}
+
+			return newExpr.Resolve (ec);
+		}
+		
+		protected override void CloneTo (CloneContext clonectx, Expression t)
+		{
+			var target = (AsDelete) t;
+			
+			target.Expr = Expr.Clone (clonectx);
+		}
+		
+		public override void Emit (EmitContext ec)
+		{
+			throw new System.NotImplementedException ();
+		}
+		
+		public override void EmitStatement (EmitContext ec)
+		{
+			throw new System.NotImplementedException ();
+		}
+		
+//		public override void EmitJs (JsEmitContext jec)
+//		{
+//			jec.Buf.Write ("new ", Location);
+//			Expr.EmitJs (jec);
+//		}
+		
+//		public override void EmitStatementJs (JsEmitContext jec)
+//		{
+//			jec.Buf.Write ("\t", Location);
+//			EmitJs (jec);
+//			jec.Buf.Write (";\n");
+//		}
+		
+		public override Expression CreateExpressionTree (ResolveContext ec)
+		{
+			return newExpr.CreateExpressionTree(ec);
+		}
+		
+		public override object Accept (StructuralVisitor visitor)
+		{
+			return visitor.Visit (this);
+		}
+	}
+
+	//
+	// ActionScript: Implements the ActionScript typeof expression.
+	// This expression is for backwards compatibility with javascript
+	// and is not supported in ASX.
+	//
+	public partial class AsTypeOf : ExpressionStatement {
+		
+		public Expression Expr;
+		private Expression newExpr;
+		
+		public AsTypeOf (Expression expr, Location l)
+		{
+			this.Expr = expr;
+			loc = l;
+		}
+		
+		public override bool IsSideEffectFree {
+			get {
+				return newExpr.IsSideEffectFree;
+			}
+		}
+		
+		public override bool ContainsEmitWithAwait ()
+		{
+			return newExpr.ContainsEmitWithAwait ();
+		}
+		
+		protected override Expression DoResolve (ResolveContext ec)
+		{
+			if (ec.Target == Target.JavaScript) {
+				type = ec.BuiltinTypes.Dynamic;
+				eclass = ExprClass.Value;
+				return this;
+			}
+
+			if (loc.SourceFile != null && loc.SourceFile.PsExtended) {
+				ec.Report.Error (7101, loc, "'typeof' operator not supported in ASX.'");
+				return null;
+			}
+
+			var args = new Arguments(1);
+			args.Add (new Argument(Expr));
+
+			return new Invocation(new MemberAccess(new MemberAccess(
+				new SimpleName(PsConsts.PsRootNamespace, loc), "_typeof_fn", loc), "_typeof", loc), args).Resolve (ec);
+		}
+		
+		protected override void CloneTo (CloneContext clonectx, Expression t)
+		{
+			var target = (AsDelete) t;
+			
+			target.Expr = Expr.Clone (clonectx);
+		}
+		
+		public override void Emit (EmitContext ec)
+		{
+			throw new System.NotImplementedException ();
+		}
+		
+		public override void EmitStatement (EmitContext ec)
+		{
+			throw new System.NotImplementedException ();
+		}
+		
+//		public override void EmitJs (JsEmitContext jec)
+//		{
+//			jec.Buf.Write ("new ", Location);
+//			Expr.EmitJs (jec);
+//		}
+		
+//		public override void EmitStatementJs (JsEmitContext jec)
+//		{
+//			jec.Buf.Write ("\t", Location);
+//			EmitJs (jec);
+//			jec.Buf.Write (";\n");
+//		}
+		
+		public override Expression CreateExpressionTree (ResolveContext ec)
+		{
+			return newExpr.CreateExpressionTree(ec);
+		}
+		
+		public override object Accept (StructuralVisitor visitor)
+		{
+			return visitor.Visit (this);
+		}
+	}
+
+
+	public partial class RegexLiteral : Constant, ILiteralConstant
+	{
+		readonly public string Regex;
+		readonly public string Options;
+
+		public RegexLiteral (BuiltinTypes types, string regex, string options, Location loc)
+			: base (loc)
+		{
+			Regex = regex;
+			Options = options ?? "";
+		}
+
+		public override bool IsLiteral {
+			get { return true; }
+		}
+
+		public override object GetValue ()
+		{
+			return "/" + Regex + "/" + Options;
+		}
+		
+		public override string GetValueAsLiteral ()
+		{
+			return GetValue () as String;
+		}
+		
+		public override long GetValueAsLong ()
+		{
+			throw new NotSupportedException ();
+		}
+
+		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
+		{
+			throw new NotSupportedException ();
+		}
+		
+		public override bool IsDefaultValue {
+			get {
+				return Regex == null && Options == "";
+			}
+		}
+		
+		public override bool IsNegative {
+			get {
+				return false;
+			}
+		}
+		
+		public override bool IsNull {
+			get {
+				return IsDefaultValue;
+			}
+		}
+		
+		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
+		{
+			return null;
+		}
+
+		protected override Expression DoResolve (ResolveContext rc)
+		{
+			if (rc.Target == Target.JavaScript) {
+				type = rc.Module.PredefinedTypes.AsRegExp.Resolve();
+				eclass = ExprClass.Value;
+				return this;
+			}
+
+			var args = new Arguments(2);
+			args.Add (new Argument(new StringLiteral(rc.BuiltinTypes, Regex, this.Location)));
+			args.Add (new Argument(new StringLiteral(rc.BuiltinTypes, Options, this.Location)));
+
+			return new New(new TypeExpression(rc.Module.PredefinedTypes.AsRegExp.Resolve(), this.Location), 
+			               args, this.Location).Resolve (rc);
+		}
+
+		public override void Emit (EmitContext ec)
+		{
+			throw new NotSupportedException ();
+		}
+
+//		public override void EmitJs (JsEmitContext jec)
+//		{
+//			jec.Buf.Write (GetValue () as String, Location);
+//		}
+
+#if FULL_AST
+		public char[] ParsedValue { get; set; }
+#endif
+
+		public override object Accept (StructuralVisitor visitor)
+		{
+			return visitor.Visit (this);
+		}
+	}
+
+	public partial class XmlLiteral : Constant, ILiteralConstant
+	{
+		readonly public string Xml;
+
+		public XmlLiteral (BuiltinTypes types, string xml, Location loc)
+			: base (loc)
+		{
+			Xml = xml;
+		}
+		
+		public override bool IsLiteral {
+			get { return true; }
+		}
+		
+		public override object GetValue ()
+		{
+			return Xml;
+		}
+		
+		public override string GetValueAsLiteral ()
+		{
+			return GetValue () as String;
+		}
+		
+		public override long GetValueAsLong ()
+		{
+			throw new NotSupportedException ();
+		}
+		
+		public override void EncodeAttributeValue (IMemberContext rc, AttributeEncoder enc, TypeSpec targetType)
+		{
+			throw new NotSupportedException ();
+		}
+		
+		public override bool IsDefaultValue {
+			get {
+				return Xml == null;
+			}
+		}
+		
+		public override bool IsNegative {
+			get {
+				return false;
+			}
+		}
+		
+		public override bool IsNull {
+			get {
+				return IsDefaultValue;
+			}
+		}
+		
+		public override Constant ConvertExplicitly (bool in_checked_context, TypeSpec target_type)
+		{
+			return null;
+		}
+		
+		protected override Expression DoResolve (ResolveContext rc)
+		{
+			var args = new Arguments(1);
+			args.Add (new Argument(new StringLiteral(rc.BuiltinTypes, Xml, this.Location)));
+
+			return new New(new TypeExpression(rc.Module.PredefinedTypes.AsXml.Resolve(), this.Location), 
+			               args, this.Location).Resolve (rc);
+		}
+		
+		public override void Emit (EmitContext ec)
+		{
+			throw new NotSupportedException ();
+		}
+		
+//		public override void EmitJs (JsEmitContext jec)
+//		{
+//			jec.Buf.Write (GetValue () as String, Location);
+//		}
+		
+#if FULL_AST
+		public char[] ParsedValue { get; set; }
+#endif
+		
+		public override object Accept (StructuralVisitor visitor)
+		{
+			return visitor.Visit (this);
+		}
+	}
+
+	/// <summary>
+	///   Implementation of the ActionScript `in' operator.
+	/// </summary>
+	public partial class AsIn : Expression
+	{
+		protected Expression expr;
+		protected Expression objExpr;
+
+		public AsIn (Expression expr, Expression obj_expr, Location l)
+		{
+			this.expr = expr;
+			this.objExpr = obj_expr;
+			loc = l;
+		}
+
+		public Expression Expr {
+			get {
+				return expr;
+			}
+		}
+
+		public Expression ObjectExpression {
+			get {
+				return objExpr;
+			}
+		}
+
+		public override bool ContainsEmitWithAwait ()
+		{
+			throw new NotSupportedException ();
+		}
+
+		public override Expression CreateExpressionTree (ResolveContext ec)
+		{
+			throw new NotSupportedException ("ET");
+		}
+
+		protected override Expression DoResolve (ResolveContext ec)
+		{
+			if (ec.Target == Target.JavaScript) {
+				expr = Expr.Resolve (ec);
+				objExpr = objExpr.Resolve (ec);
+				type = ec.BuiltinTypes.Bool;
+				eclass = ExprClass.Value;
+				return this;
+			}
+
+			var objExpRes = objExpr.Resolve (ec);
+
+			var args = new Arguments (1);
+			args.Add (new Argument (expr));
+
+			if (objExpRes.Type == ec.BuiltinTypes.Dynamic) {
+				// If dynamic, cast to IDictionary<string,object> and call ContainsKey
+				var dictExpr = new TypeExpression(ec.Module.PredefinedTypes.IDictionaryGeneric.Resolve().MakeGenericType(ec, 
+				                      new [] { ec.BuiltinTypes.String, ec.BuiltinTypes.Object }), loc);
+				return new Invocation (new MemberAccess (new Cast(dictExpr, objExpr, loc), "ContainsKey", loc), args).Resolve (ec);
+			} else {
+				string containsMethodName = "Contains";
+	
+				if (objExpRes.Type != null && objExpRes.Type.ImplementsInterface (ec.Module.PredefinedTypes.IDictionary.Resolve(), true)) {
+					containsMethodName = "ContainsKey";
+				}
+
+				return new Invocation (new MemberAccess (objExpr, containsMethodName, loc), args).Resolve (ec);
+			}
+		}
+
+		protected override void CloneTo (CloneContext clonectx, Expression t)
+		{
+			AsIn target = (AsIn) t;
+
+			target.expr = expr.Clone (clonectx);
+			target.objExpr = objExpr.Clone (clonectx);
+		}
+
+		public override void Emit (EmitContext ec)
+		{
+			throw new InternalErrorException ("Missing Resolve call");
+		}
+
+//		public override void EmitJs (JsEmitContext jec)
+//		{
+//			Expr.EmitJs (jec);
+//			jec.Buf.Write (" in ");
+//			ObjectExpression.EmitJs (jec);
+//		}
+
+		public override object Accept (StructuralVisitor visitor)
+		{
+			return visitor.Visit (this);
+		}
+
+	}
+
+	/// <summary>
+	///   Implementation of the ActionScript `undefined' object constant.
+	/// </summary>
+	public partial class AsUndefinedLiteral : Expression
+	{
+		public AsUndefinedLiteral (Location l)
+		{
+			loc = l;
+		}
+
+		public override string ToString ()
+		{
+			return this.GetType ().Name + " (undefined)";
+		}
+
+		public override bool ContainsEmitWithAwait ()
+		{
+			throw new NotSupportedException ();
+		}
+
+		public override Expression CreateExpressionTree (ResolveContext ec)
+		{
+			throw new NotSupportedException ("ET");
+		}
+
+		protected override Expression DoResolve (ResolveContext ec)
+		{
+			if (ec.Target == Target.JavaScript) {
+				type = ec.BuiltinTypes.Dynamic;
+				eclass = ExprClass.Value;
+				return this;
+			}
+
+			return new MemberAccess(new TypeExpression(ec.Module.PredefinedTypes.AsUndefined.Resolve(), loc), 
+			                        "_undefined", loc).Resolve (ec);
+		}
+
+		protected override void CloneTo (CloneContext clonectx, Expression t)
+		{
+		}
+
+		public override void Emit (EmitContext ec)
+		{
+			throw new InternalErrorException ("Missing Resolve call");
+		}
+
+//		public override void EmitJs (JsEmitContext jec)
+//		{
+//			jec.Buf.Write ("undefined", Location);
+//		}
+
+		public override object Accept (StructuralVisitor visitor)
+		{
+			return visitor.Visit (this);
+		}
+
+	}
+
+	//
+	// ActionScript: Implements the ActionScript delete expression.
+	// This expression is used to implement the delete expression as
+	// well as the delete statement.  Handles both the element access
+	// form or the member access form.
+	//
+	public partial class AsLocalFunction : Statement {
+		
+		public string Name;
+		public AnonymousMethodExpression MethodExpr;
+		public BlockVariableDeclaration VarDecl;
+
+		public AsLocalFunction (Location loc, string name, AnonymousMethodExpression methodExpr, BlockVariableDeclaration varDecl)
+		{
+			this.loc = loc;
+			this.Name = name;
+			this.MethodExpr = methodExpr;
+			this.VarDecl = varDecl;
+		}
+
+		public override bool Resolve (BlockContext bc)
+		{
+			return true;
+		}
+
+		protected override void CloneTo (CloneContext clonectx, Statement t)
+		{
+			var target = (AsLocalFunction) t;
+
+			target.Name = Name;
+			target.MethodExpr = MethodExpr.Clone (clonectx) as AnonymousMethodExpression;
+			target.VarDecl = VarDecl.Clone (clonectx) as BlockVariableDeclaration;
+		}
+
+		protected override void DoEmit (EmitContext ec)
+		{
+		}
+
+//		public override void EmitJs (JsEmitContext jec)
+//		{
+//			jec.Buf.Write ("delete ", Location);
+//			Expr.EmitJs (jec);
+//		}
+//		
+//		public override void EmitStatementJs (JsEmitContext jec)
+//		{
+//			jec.Buf.Write ("\t", Location);
+//			EmitJs (jec);
+//			jec.Buf.Write (";\n");
+//		}
+		
+		public override Expression CreateExpressionTree (ResolveContext ec)
+		{
+			throw new System.NotSupportedException ();
+		}
+		
+		public override object Accept (StructuralVisitor visitor)
+		{
+			return visitor.Visit (this);
+		}
+	}
+
+	// Use namespace statement
+	public partial class AsUseNamespaceStatement : Statement {
+
+		public string NS;
+
+		public AsUseNamespaceStatement(string ns, Location loc)
+		{
+			this.loc = loc;
+			NS = ns;
+		}
+
+		public override bool Resolve (BlockContext ec)
+		{
+			return true;
+		}
+		
+		public override bool ResolveUnreachable (BlockContext ec, bool warn)
+		{
+			return true;
+		}
+		
+		public override void Emit (EmitContext ec)
+		{
+		}
+		
+//		public override void EmitJs (JsEmitContext jec)
+//		{
+//		}
+
+		protected override void DoEmit (EmitContext ec)
+		{
+			throw new NotSupportedException ();
+		}
+		
+		protected override void CloneTo (CloneContext clonectx, Statement target)
+		{
+			// nothing needed.
+		}
+		
+		public override object Accept (StructuralVisitor visitor)
+		{
+			return visitor.Visit (this);
+		}
+
+	}
+
+	public partial class AsNonAssignStatementExpression : Statement
+	{
+		public Expression expr;
+		
+		public AsNonAssignStatementExpression (Expression expr)
+		{
+			this.expr = expr;
+		}
+		
+		public Expression Expr {
+			get {
+				return expr;
+			}
+		}
+
+		public override bool Resolve (BlockContext bc)
+		{
+			if (!base.Resolve (bc))
+				return false;
+
+			expr = expr.Resolve (bc);
+
+			return expr != null;
+		}
+
+		protected override void DoEmit (EmitContext ec)
+		{
+			if (!expr.IsSideEffectFree) {
+				expr.EmitSideEffect (ec);
+			}
+		}
+
+//		protected override void DoEmitJs (JsEmitContext jec) 
+//		{
+//			expr.EmitJs (jec);
+//		}
+		
+//		public override void EmitJs (JsEmitContext jec)
+//		{
+//			DoEmitJs (jec);
+//		}
+
+		protected override void CloneTo (CloneContext clonectx, Statement target)
+		{
+			var t = target as AsNonAssignStatementExpression;
+			t.expr = expr.Clone (clonectx);
+		}
+		
+		public override object Accept (StructuralVisitor visitor)
+		{
+			return visitor.Visit (this);
+		}
+	}
+
+	/// <summary>
+	///   Implementation of the ActionScript E4X xml query.
+	/// </summary>
+	public partial class AsXmlQueryExpression : Expression
+	{
+		protected Expression expr;
+		protected Expression query;
+		
+		public AsXmlQueryExpression (Expression expr, Expression query, Location l)
+		{
+			this.expr = expr;
+			this.query = query;
+			loc = l;
+		}
+		
+		public Expression Expr {
+			get {
+				return expr;
+			}
+		}
+
+		public Expression Query {
+			get {
+				return query;
+			}
+		}
+
+		public override bool ContainsEmitWithAwait ()
+		{
+			throw new NotSupportedException ();
+		}
+		
+		public override Expression CreateExpressionTree (ResolveContext ec)
+		{
+			throw new NotSupportedException ("ET");
+		}
+		
+		protected override Expression DoResolve (ResolveContext ec)
+		{
+			// TODO: Implement XML query expression.
+			return null;
+		}
+		
+		protected override void CloneTo (CloneContext clonectx, Expression t)
+		{
+			AsXmlQueryExpression target = (AsXmlQueryExpression) t;
+			
+			target.expr = expr.Clone (clonectx);
+			target.query = query.Clone (clonectx);
+		}
+		
+		public override void Emit (EmitContext ec)
+		{
+			throw new InternalErrorException ("Missing Resolve call");
+		}
+
+		public override object Accept (StructuralVisitor visitor)
+		{
+			return visitor.Visit (this);
+		}
+		
+	}
+
+
+}
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/ps-parser.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/ps-parser.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/ps-parser.cs	1969-12-31 16:00:00.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/ps-parser.cs	2013-04-23 21:04:54.000000000 -0700
@@ -0,0 +1,15944 @@
+// created by jay 0.7 (c) 1998 Axel.Schreiner@informatik.uni-osnabrueck.de
+
+#line 2 "ps-parser.jay"
+//
+// ps-parser.jay: The Parser for the PlayScript language
+// Authors: Miguel de Icaza (miguel@gnome.org)
+//          Ravi Pratap     (ravi@ximian.com)
+//          Marek Safar	    (marek.safar@gmail.com)
+//          Ben Cooley	    (bcooley@zynga.com)
+// Dual Licensed under the terms of the GNU GPL and the MIT X11 license
+//
+// (C) 2001 Ximian, Inc (http://www.ximian.com)
+// (C) 2004-2011 Novell, Inc
+// Copyright 2011-2012 Xamarin Inc.
+//
+
+using System.Text;
+using System.IO;
+using System;
+using System.Collections.Generic;
+using Mono.CSharpPs;
+using Linq = Mono.CSharpPs.Linq;
+using Enum = Mono.CSharpPs.Enum;
+using Attribute = Mono.CSharpPs.Attribute;
+using Delegate = Mono.CSharpPs.Delegate;
+using Nullable = Mono.CSharpPs.Nullable;
+
+namespace Mono.PlayScript
+{
+	/// <summary>
+	///    The PlayScript Parser
+	/// </summary>
+	public class PlayScriptParser
+	{
+		[Flags]
+		enum ParameterModifierType
+		{
+			Ref		= 1 << 1,
+			Out		= 1 << 2,
+			This	= 1 << 3,
+			Params	= 1 << 4,
+			Arglist	= 1 << 5,
+			DefaultValue = 1 << 6,
+			
+			All = Ref | Out | This | Params | Arglist | DefaultValue
+		}
+		
+		public bool parsing_playscript = false;
+		
+		static readonly object ModifierNone = 0;
+	
+		const string RootNs = PsConsts.PsRootNamespace;
+	
+		NamespaceContainer current_namespace;
+		NamespaceContainer prev_namespace;
+		NamespaceContainer private_namespace;
+		TypeContainer current_container;
+		TypeDefinition current_type;
+		PropertyBase current_property;
+		EventProperty current_event;
+		EventField current_event_field;
+		FieldBase current_field;
+		Constructor current_constructor;
+		
+		// Set by config params to enable/disable inclusion of methods, fields, consts, classes, structs, etc.
+		bool is_config_enabled = true;
+		
+		bool is_package_function = false;
+	
+		/// <summary>
+		///   Current block is used to add statements as we find
+		///   them.  
+		/// </summary>
+		Block      current_block;
+		
+		BlockVariableDeclaration current_variable;
+
+		Delegate   current_delegate;
+		
+		AnonymousMethodExpression current_anonymous_method;
+
+		/// <summary>
+		///   This is used by the unary_expression code to resolve
+		///   a name against a parameter.  
+		/// </summary>
+		
+		// FIXME: This is very ugly and it's very hard to reset it correctly
+		// on all places, especially when some parameters are autogenerated.
+		ParametersCompiled current_local_parameters;
+
+		bool parsing_anonymous_method;
+		
+		bool async_block;
+
+		///
+		/// An out-of-band stack.
+		///
+		Stack<object> oob_stack;
+
+		///
+		/// Controls the verbosity of the errors produced by the parser
+		///
+		int yacc_verbose_flag;
+
+		/// 
+		/// Used by the interactive shell, flags whether EOF was reached
+		/// and an error was produced
+		///
+		public bool UnexpectedEOF;
+
+		///
+		/// The current file.
+		///
+		readonly CompilationSourceFile file;
+
+		///
+		/// Temporary Xml documentation cache.
+		/// For enum types, we need one more temporary store.
+		///
+		string tmpComment;
+		string enumTypeComment;
+	       		
+		/// Current attribute target
+		string current_attr_target;
+		
+		ParameterModifierType valid_param_mod;
+		
+		bool default_parameter_used;
+
+		/// When using the interactive parser, this holds the
+		/// resulting expression
+		public Class InteractiveResult;
+
+		// Current modifier namespace identifier
+		public string ns_modifier;
+
+		//
+		// Keeps track of global data changes to undo on parser error
+		//
+		public Undo undo;
+		
+		Stack<Linq.QueryBlock> linq_clause_blocks;
+
+		ModuleContainer module;
+		
+		readonly CompilerContext compiler;
+		readonly LanguageVersion lang_version;
+		readonly bool doc_support;
+		readonly CompilerSettings settings;
+		readonly Report report;
+		
+		//
+		// Instead of allocating carrier array everytime we
+		// share the bucket for very common constructs which can never
+		// be recursive
+		//
+		List<Parameter> parameters_bucket;
+		
+		//
+		// Full AST support members
+		//
+		LocationsBag lbag;
+		List<Tuple<Modifiers, Location>> mod_locations;
+		Location parameterModifierLocation, savedLocation, savedOpenLocation, savedCloseLocation, savedEventAssignLocation;
+		Location savedAttrParenOpenLocation, savedAttrParenCloseLocation, savedOperatorLocation;
+		Stack<List<Location>> locationListStack = new Stack<List<Location>> (); // used for type parameters
+		Stack<Location> opt_intoStack = new Stack<Location> ();
+
+		bool HadAttributeParens;
+		List<Location> attributeCommas = new List<Location> ();
+		List<Location> attributeArgumentCommas = new List<Location> ();
+		List<Location> parameterListCommas = new List<Location> ();
+#line default
+
+  /** error output stream.
+      It should be changeable.
+    */
+  public System.IO.TextWriter ErrorOutput = System.Console.Out;
+
+  /** simplified error message.
+      @see <a href="#yyerror(java.lang.String, java.lang.String[])">yyerror</a>
+    */
+  public void yyerror (string message) {
+    yyerror(message, null);
+  }
+#pragma warning disable 649
+  /* An EOF token */
+  public int eof_token;
+#pragma warning restore 649
+  /** (syntax) error message.
+      Can be overwritten to control message format.
+      @param message text to be displayed.
+      @param expected vector of acceptable tokens, if available.
+    */
+  public void yyerror (string message, string[] expected) {
+    if ((yacc_verbose_flag > 0) && (expected != null) && (expected.Length  > 0)) {
+      ErrorOutput.Write (message+", expecting");
+      for (int n = 0; n < expected.Length; ++ n)
+        ErrorOutput.Write (" "+expected[n]);
+        ErrorOutput.WriteLine ();
+    } else
+      ErrorOutput.WriteLine (message);
+  }
+
+  /** debugging support, requires the package jay.yydebug.
+      Set to null to suppress debugging messages.
+    */
+//t  internal yydebug.yyDebug debug;
+
+  protected const int yyFinal = 7;
+//t // Put this array into a separate class so it is only initialized if debugging is actually used
+//t // Use MarshalByRefObject to disable inlining
+//t class YYRules : MarshalByRefObject {
+//t  public static readonly string [] yyRule = {
+//t    "$accept : compilation_unit",
+//t    "compilation_unit : outer_declaration opt_EOF",
+//t    "$$1 :",
+//t    "compilation_unit : interactive_parsing $$1 opt_EOF",
+//t    "compilation_unit : documentation_parsing",
+//t    "outer_declaration : opt_extern_alias_directives opt_package_directives",
+//t    "outer_declaration : opt_extern_alias_directives opt_package_directives package_declaration opt_attributes",
+//t    "outer_declaration : opt_extern_alias_directives opt_package_directives attribute_sections",
+//t    "outer_declaration : error",
+//t    "opt_EOF :",
+//t    "opt_EOF : EOF",
+//t    "extern_alias_directives : extern_alias_directive",
+//t    "extern_alias_directives : extern_alias_directives extern_alias_directive",
+//t    "extern_alias_directive : EXTERN IDENTIFIER IDENTIFIER SEMICOLON",
+//t    "extern_alias_directive : EXTERN error",
+//t    "no_config_package_directive : import_directive",
+//t    "no_config_package_directive : use_namespace_directive",
+//t    "package_directive : no_config_package_directive",
+//t    "package_directive : config_package_directive",
+//t    "$$2 :",
+//t    "config_package_directive : IDENTIFIER_CONFIG $$2 no_config_package_directive",
+//t    "$$3 :",
+//t    "config_package_directive : IDENTIFIER_CONFIG $$3 OPEN_BRACE opt_package_directives CLOSE_BRACE",
+//t    "package_directives : package_directive",
+//t    "package_directives : package_directives package_directive",
+//t    "use_namespace_directive : use_namespace",
+//t    "use_namespace : USE NAMESPACE IDENTIFIER SEMICOLON",
+//t    "import_directive : import_package",
+//t    "$$4 :",
+//t    "import_package : IMPORT namespace_or_type_expr $$4 DOT_STAR SEMICOLON",
+//t    "import_package : IMPORT typeof_type_expression SEMICOLON",
+//t    "import_package : IMPORT IDENTIFIER ASSIGN namespace_or_type_expr SEMICOLON",
+//t    "import_package : IMPORT error",
+//t    "$$5 :",
+//t    "$$6 :",
+//t    "$$7 :",
+//t    "$$8 :",
+//t    "package_declaration : opt_attributes PACKAGE $$5 opt_package_name $$6 OPEN_BRACE $$7 opt_package_statements_or_blocks CLOSE_BRACE $$8 opt_package_statements_or_blocks",
+//t    "opt_package_name :",
+//t    "opt_package_name : package_name",
+//t    "package_name : IDENTIFIER",
+//t    "package_name : package_name DOT IDENTIFIER",
+//t    "package_name : error",
+//t    "opt_semicolon :",
+//t    "opt_semicolon : SEMICOLON",
+//t    "opt_comma :",
+//t    "opt_comma : COMMA",
+//t    "opt_package_statements_or_blocks : opt_extern_alias_directives opt_package_statements",
+//t    "opt_package_statements_or_blocks : OPEN_BRACE opt_package_statements_or_blocks CLOSE_BRACE",
+//t    "opt_package_directives :",
+//t    "opt_package_directives : package_directives",
+//t    "opt_extern_alias_directives :",
+//t    "opt_extern_alias_directives : extern_alias_directives",
+//t    "opt_package_statements :",
+//t    "opt_package_statements : package_statements",
+//t    "package_statements : package_statement",
+//t    "package_statements : package_statements package_statement",
+//t    "package_statement : no_config_package_statement",
+//t    "package_statement : config_package_statement",
+//t    "package_statement : attribute_sections CLOSE_BRACE",
+//t    "no_config_package_statement : type_declaration",
+//t    "no_config_package_statement : method_declaration",
+//t    "no_config_package_statement : no_config_package_directive",
+//t    "$$9 :",
+//t    "config_package_statement : IDENTIFIER_CONFIG $$9 no_config_package_statement",
+//t    "$$10 :",
+//t    "config_package_statement : IDENTIFIER_CONFIG $$10 OPEN_BRACE opt_package_statements CLOSE_BRACE",
+//t    "type_declaration : class_declaration",
+//t    "type_declaration : struct_declaration",
+//t    "type_declaration : interface_declaration",
+//t    "type_declaration : enum_declaration",
+//t    "type_declaration : delegate_declaration",
+//t    "type_declaration : namespace_declaration",
+//t    "opt_attributes :",
+//t    "opt_attributes : attribute_sections",
+//t    "attribute_sections : attribute_section",
+//t    "attribute_sections : attribute_sections attribute_section",
+//t    "$$11 :",
+//t    "attribute_section : OPEN_BRACKET $$11 attribute_section_cont",
+//t    "$$12 :",
+//t    "attribute_section_cont : attribute_target COLON $$12 attribute_list opt_comma CLOSE_BRACKET",
+//t    "attribute_section_cont : attribute_list opt_comma CLOSE_BRACKET",
+//t    "attribute_target : IDENTIFIER",
+//t    "attribute_target : EVENT",
+//t    "attribute_target : RETURN",
+//t    "attribute_target : error",
+//t    "attribute_list : attribute",
+//t    "attribute_list : attribute_list COMMA attribute",
+//t    "$$13 :",
+//t    "attribute : attribute_name $$13 opt_attribute_arguments",
+//t    "attribute_name : namespace_or_type_expr",
+//t    "opt_attribute_arguments :",
+//t    "opt_attribute_arguments : OPEN_PARENS attribute_arguments CLOSE_PARENS",
+//t    "attribute_arguments :",
+//t    "attribute_arguments : positional_or_named_argument",
+//t    "attribute_arguments : named_attribute_argument",
+//t    "attribute_arguments : attribute_arguments COMMA positional_or_named_argument",
+//t    "attribute_arguments : attribute_arguments COMMA named_attribute_argument",
+//t    "positional_or_named_argument : expression",
+//t    "positional_or_named_argument : named_argument",
+//t    "$$14 :",
+//t    "named_attribute_argument : IDENTIFIER ASSIGN $$14 expression",
+//t    "named_argument : identifier_inside_body COLON opt_named_modifier expression",
+//t    "opt_named_modifier :",
+//t    "opt_named_modifier : REF",
+//t    "opt_named_modifier : OUT",
+//t    "opt_class_member_declarations :",
+//t    "opt_class_member_declarations : class_member_declarations",
+//t    "class_member_declarations : class_member_declaration",
+//t    "class_member_declarations : class_member_declarations class_member_declaration",
+//t    "class_member_declaration : constant_declaration",
+//t    "class_member_declaration : field_declaration",
+//t    "class_member_declaration : method_declaration",
+//t    "class_member_declaration : property_declaration",
+//t    "class_member_declaration : event_declaration",
+//t    "class_member_declaration : indexer_declaration",
+//t    "class_member_declaration : operator_declaration",
+//t    "class_member_declaration : destructor_declaration",
+//t    "class_member_declaration : type_declaration",
+//t    "class_member_declaration : member_config_block",
+//t    "class_member_declaration : config_member_declaration",
+//t    "class_member_declaration : attributes_without_members",
+//t    "class_member_declaration : use_namespace_class_directive",
+//t    "class_member_declaration : import_class_directive",
+//t    "class_member_declaration : error",
+//t    "use_namespace_class_directive : opt_attributes opt_modifiers use_namespace_directive",
+//t    "import_class_directive : opt_attributes opt_modifiers import_directive",
+//t    "$$15 :",
+//t    "config_member_declaration : IDENTIFIER_CONFIG $$15 class_member_declaration",
+//t    "$$16 :",
+//t    "member_config_block : IDENTIFIER_CONFIG $$16 OPEN_BRACE opt_class_member_declarations CLOSE_BRACE",
+//t    "$$17 :",
+//t    "$$18 :",
+//t    "$$19 :",
+//t    "$$20 :",
+//t    "$$21 :",
+//t    "struct_declaration : opt_attributes opt_modifiers opt_partial STRUCT $$17 type_declaration_name $$18 opt_class_extends opt_class_implements opt_type_parameter_constraints_clauses $$19 OPEN_BRACE $$20 opt_class_member_declarations CLOSE_BRACE $$21 opt_semicolon",
+//t    "struct_declaration : opt_attributes opt_modifiers opt_partial STRUCT error",
+//t    "$$22 :",
+//t    "constant_declaration : opt_attributes opt_modifiers CONST IDENTIFIER COLON type $$22 opt_constant_initializer opt_constant_declarators SEMICOLON",
+//t    "opt_constant_declarators :",
+//t    "opt_constant_declarators : constant_declarators",
+//t    "constant_declarators : constant_declarator",
+//t    "constant_declarators : constant_declarators constant_declarator",
+//t    "constant_declarator : COMMA IDENTIFIER COLON member_type opt_constant_initializer",
+//t    "opt_constant_initializer :",
+//t    "opt_constant_initializer : constant_initializer",
+//t    "$$23 :",
+//t    "constant_initializer : ASSIGN $$23 constant_initializer_expr",
+//t    "constant_initializer : error",
+//t    "constant_initializer_expr : constant_expression",
+//t    "$$24 :",
+//t    "field_declaration : opt_attributes opt_modifiers VAR IDENTIFIER COLON member_type $$24 opt_field_initializer opt_field_declarators SEMICOLON",
+//t    "$$25 :",
+//t    "field_declaration : opt_attributes opt_modifiers FIXED IDENTIFIER COLON simple_type $$25 fixed_field_size opt_fixed_field_declarators SEMICOLON",
+//t    "field_declaration : opt_attributes opt_modifiers FIXED IDENTIFIER COLON simple_type error SEMICOLON",
+//t    "opt_field_initializer :",
+//t    "$$26 :",
+//t    "opt_field_initializer : ASSIGN $$26 variable_initializer",
+//t    "opt_field_declarators :",
+//t    "opt_field_declarators : field_declarators",
+//t    "field_declarators : field_declarator",
+//t    "field_declarators : field_declarators field_declarator",
+//t    "field_declarator : COMMA IDENTIFIER COLON member_type",
+//t    "$$27 :",
+//t    "field_declarator : COMMA IDENTIFIER COLON member_type ASSIGN $$27 variable_initializer",
+//t    "opt_fixed_field_declarators :",
+//t    "opt_fixed_field_declarators : fixed_field_declarators",
+//t    "fixed_field_declarators : fixed_field_declarator",
+//t    "fixed_field_declarators : fixed_field_declarators fixed_field_declarator",
+//t    "fixed_field_declarator : COMMA IDENTIFIER fixed_field_size COLON member_type",
+//t    "$$28 :",
+//t    "fixed_field_size : OPEN_BRACKET $$28 expression CLOSE_BRACKET",
+//t    "fixed_field_size : OPEN_BRACKET error",
+//t    "variable_initializer : expression",
+//t    "variable_initializer : error",
+//t    "$$29 :",
+//t    "method_declaration : method_header $$29 method_body",
+//t    "$$30 :",
+//t    "$$31 :",
+//t    "method_header : opt_attributes opt_modifiers FUNCTION method_declaration_name OPEN_PARENS $$30 opt_formal_parameter_list CLOSE_PARENS opt_method_return_type $$31 opt_type_parameter_constraints_clauses",
+//t    "$$32 :",
+//t    "method_header : opt_attributes opt_modifiers FUNCTION_GET method_declaration_name OPEN_PARENS $$32 opt_formal_parameter_list CLOSE_PARENS method_colon member_type",
+//t    "$$33 :",
+//t    "method_header : opt_attributes opt_modifiers FUNCTION_SET method_declaration_name OPEN_PARENS $$33 opt_formal_parameter_list CLOSE_PARENS method_colon member_type",
+//t    "$$34 :",
+//t    "$$35 :",
+//t    "$$36 :",
+//t    "method_header : opt_attributes opt_modifiers PARTIAL FUNCTION $$34 method_declaration_name OPEN_PARENS $$35 opt_formal_parameter_list CLOSE_PARENS COLON VOID $$36 opt_type_parameter_constraints_clauses",
+//t    "method_header : opt_attributes opt_modifiers FUNCTION modifiers method_declaration_name OPEN_PARENS opt_formal_parameter_list CLOSE_PARENS method_colon member_type",
+//t    "method_header : opt_attributes opt_modifiers FUNCTION method_declaration_name error",
+//t    "opt_method_return_type :",
+//t    "opt_method_return_type : method_colon member_type",
+//t    "method_colon : COLON",
+//t    "method_body : block",
+//t    "method_body : SEMICOLON",
+//t    "opt_formal_parameter_list :",
+//t    "opt_formal_parameter_list : formal_parameter_list",
+//t    "formal_parameter_list : fixed_parameters",
+//t    "formal_parameter_list : fixed_parameters COMMA parameter_array",
+//t    "formal_parameter_list : parameter_array COMMA error",
+//t    "formal_parameter_list : fixed_parameters COMMA parameter_array COMMA error",
+//t    "formal_parameter_list : parameter_array",
+//t    "formal_parameter_list : error",
+//t    "fixed_parameters : fixed_parameter",
+//t    "fixed_parameters : fixed_parameters COMMA fixed_parameter",
+//t    "fixed_parameter : opt_attributes opt_parameter_modifier IDENTIFIER COLON parameter_type",
+//t    "fixed_parameter : attribute_sections error",
+//t    "fixed_parameter : opt_attributes opt_parameter_modifier IDENTIFIER COLON error",
+//t    "$$37 :",
+//t    "fixed_parameter : opt_attributes opt_parameter_modifier IDENTIFIER COLON parameter_type ASSIGN $$37 constant_expression",
+//t    "opt_parameter_modifier :",
+//t    "opt_parameter_modifier : parameter_modifiers",
+//t    "parameter_modifiers : parameter_modifier",
+//t    "parameter_modifiers : parameter_modifiers parameter_modifier",
+//t    "parameter_modifier : REF",
+//t    "parameter_modifier : OUT",
+//t    "parameter_modifier : THIS",
+//t    "parameter_array : opt_attributes DOTDOTDOT IDENTIFIER",
+//t    "parameter_array : opt_attributes DOTDOTDOT IDENTIFIER ASSIGN constant_expression",
+//t    "parameter_array : opt_attributes DOTDOTDOT error",
+//t    "$$38 :",
+//t    "$$39 :",
+//t    "$$40 :",
+//t    "property_declaration : opt_attributes opt_modifiers PROPERTY member_declaration_name COLON member_type $$38 OPEN_BRACE $$39 accessor_declarations $$40 CLOSE_BRACE",
+//t    "$$41 :",
+//t    "$$42 :",
+//t    "$$43 :",
+//t    "indexer_declaration : opt_attributes opt_modifiers INDEXER indexer_declaration_name OPEN_PARENS $$41 opt_formal_parameter_list CLOSE_PARENS COLON member_type OPEN_BRACE $$42 accessor_declarations $$43 CLOSE_BRACE",
+//t    "accessor_declarations : get_accessor_declaration",
+//t    "accessor_declarations : get_accessor_declaration accessor_declarations",
+//t    "accessor_declarations : set_accessor_declaration",
+//t    "accessor_declarations : set_accessor_declaration accessor_declarations",
+//t    "accessor_declarations : error",
+//t    "$$44 :",
+//t    "get_accessor_declaration : opt_attributes opt_modifiers GET $$44 accessor_body",
+//t    "$$45 :",
+//t    "set_accessor_declaration : opt_attributes opt_modifiers SET $$45 accessor_body",
+//t    "accessor_body : block",
+//t    "accessor_body : SEMICOLON",
+//t    "accessor_body : error",
+//t    "$$46 :",
+//t    "$$47 :",
+//t    "$$48 :",
+//t    "$$49 :",
+//t    "$$50 :",
+//t    "interface_declaration : opt_attributes opt_modifiers opt_partial INTERFACE $$46 type_declaration_name $$47 opt_class_extends opt_class_implements opt_type_parameter_constraints_clauses $$48 OPEN_BRACE $$49 opt_interface_member_declarations CLOSE_BRACE $$50 opt_semicolon",
+//t    "interface_declaration : opt_attributes opt_modifiers opt_partial INTERFACE error",
+//t    "opt_interface_member_declarations :",
+//t    "opt_interface_member_declarations : interface_member_declarations",
+//t    "interface_member_declarations : interface_member_declaration",
+//t    "interface_member_declarations : interface_member_declarations interface_member_declaration",
+//t    "interface_member_declaration : constant_declaration",
+//t    "interface_member_declaration : field_declaration",
+//t    "interface_member_declaration : method_declaration",
+//t    "interface_member_declaration : property_declaration",
+//t    "interface_member_declaration : event_declaration",
+//t    "interface_member_declaration : indexer_declaration",
+//t    "interface_member_declaration : operator_declaration",
+//t    "interface_member_declaration : type_declaration",
+//t    "$$51 :",
+//t    "operator_declaration : opt_attributes opt_modifiers operator_declarator $$51 operator_body",
+//t    "operator_body : block",
+//t    "operator_body : SEMICOLON",
+//t    "operator_type : type_expression_or_array",
+//t    "operator_type : VOID",
+//t    "$$52 :",
+//t    "operator_declarator : OPERATOR overloadable_operator OPEN_PARENS $$52 opt_formal_parameter_list CLOSE_PARENS COLON operator_type",
+//t    "operator_declarator : conversion_operator_declarator",
+//t    "overloadable_operator : BANG",
+//t    "overloadable_operator : TILDE",
+//t    "overloadable_operator : OP_INC",
+//t    "overloadable_operator : OP_DEC",
+//t    "overloadable_operator : TRUE",
+//t    "overloadable_operator : FALSE",
+//t    "overloadable_operator : PLUS",
+//t    "overloadable_operator : MINUS",
+//t    "overloadable_operator : STAR",
+//t    "overloadable_operator : DIV",
+//t    "overloadable_operator : PERCENT",
+//t    "overloadable_operator : BITWISE_AND",
+//t    "overloadable_operator : BITWISE_OR",
+//t    "overloadable_operator : CARRET",
+//t    "overloadable_operator : OP_SHIFT_LEFT",
+//t    "overloadable_operator : OP_SHIFT_RIGHT",
+//t    "overloadable_operator : OP_USHIFT_RIGHT",
+//t    "overloadable_operator : OP_EQ",
+//t    "overloadable_operator : OP_NE",
+//t    "overloadable_operator : OP_GT",
+//t    "overloadable_operator : OP_LT",
+//t    "overloadable_operator : OP_GE",
+//t    "overloadable_operator : OP_LE",
+//t    "overloadable_operator : OP_IN",
+//t    "$$53 :",
+//t    "conversion_operator_declarator : IMPLICIT OPERATOR type OPEN_PARENS $$53 opt_formal_parameter_list CLOSE_PARENS",
+//t    "$$54 :",
+//t    "conversion_operator_declarator : EXPLICIT OPERATOR type OPEN_PARENS $$54 opt_formal_parameter_list CLOSE_PARENS",
+//t    "conversion_operator_declarator : IMPLICIT error",
+//t    "conversion_operator_declarator : EXPLICIT error",
+//t    "$$55 :",
+//t    "destructor_declaration : opt_attributes opt_modifiers FUNCTION TILDE $$55 IDENTIFIER OPEN_PARENS CLOSE_PARENS method_body",
+//t    "$$56 :",
+//t    "event_declaration : opt_attributes opt_modifiers EVENT member_declaration_name COLON type $$56 opt_event_initializer opt_event_declarators SEMICOLON",
+//t    "$$57 :",
+//t    "$$58 :",
+//t    "event_declaration : opt_attributes opt_modifiers EVENT member_declaration_name COLON type OPEN_BRACE $$57 event_accessor_declarations $$58 CLOSE_BRACE",
+//t    "opt_event_initializer :",
+//t    "$$59 :",
+//t    "opt_event_initializer : ASSIGN $$59 event_variable_initializer",
+//t    "opt_event_declarators :",
+//t    "opt_event_declarators : event_declarators",
+//t    "event_declarators : event_declarator",
+//t    "event_declarators : event_declarators event_declarator",
+//t    "event_declarator : COMMA IDENTIFIER COLON member_type",
+//t    "$$60 :",
+//t    "event_declarator : COMMA IDENTIFIER COLON member_type ASSIGN $$60 event_variable_initializer",
+//t    "$$61 :",
+//t    "event_variable_initializer : $$61 variable_initializer",
+//t    "event_accessor_declarations : add_accessor_declaration remove_accessor_declaration",
+//t    "event_accessor_declarations : remove_accessor_declaration add_accessor_declaration",
+//t    "event_accessor_declarations : add_accessor_declaration",
+//t    "event_accessor_declarations : remove_accessor_declaration",
+//t    "event_accessor_declarations : error",
+//t    "$$62 :",
+//t    "add_accessor_declaration : opt_attributes opt_modifiers ADD $$62 event_accessor_block",
+//t    "$$63 :",
+//t    "remove_accessor_declaration : opt_attributes opt_modifiers REMOVE $$63 event_accessor_block",
+//t    "event_accessor_block : opt_semicolon",
+//t    "event_accessor_block : block",
+//t    "attributes_without_members : attribute_sections CLOSE_BRACE",
+//t    "$$64 :",
+//t    "$$65 :",
+//t    "$$66 :",
+//t    "enum_declaration : opt_attributes opt_modifiers ENUM type_declaration_name opt_enum_base $$64 OPEN_BRACE $$65 opt_enum_member_declarations $$66 CLOSE_BRACE opt_semicolon",
+//t    "opt_enum_base :",
+//t    "opt_enum_base : COLON type",
+//t    "opt_enum_base : COLON error",
+//t    "opt_enum_member_declarations :",
+//t    "opt_enum_member_declarations : enum_member_declarations",
+//t    "opt_enum_member_declarations : enum_member_declarations COMMA",
+//t    "enum_member_declarations : enum_member_declaration",
+//t    "enum_member_declarations : enum_member_declarations COMMA enum_member_declaration",
+//t    "enum_member_declaration : opt_attributes IDENTIFIER",
+//t    "$$67 :",
+//t    "enum_member_declaration : opt_attributes IDENTIFIER $$67 ASSIGN constant_expression",
+//t    "enum_member_declaration : opt_attributes IDENTIFIER error",
+//t    "enum_member_declaration : attributes_without_members",
+//t    "$$68 :",
+//t    "$$69 :",
+//t    "$$70 :",
+//t    "delegate_declaration : opt_attributes opt_modifiers DELEGATE type_declaration_name OPEN_PARENS $$68 opt_formal_parameter_list CLOSE_PARENS COLON member_type $$69 opt_type_parameter_constraints_clauses $$70 SEMICOLON",
+//t    "namespace_declaration : opt_attributes opt_modifiers NAMESPACE IDENTIFIER opt_namespace_url SEMICOLON",
+//t    "opt_namespace_url :",
+//t    "opt_namespace_url : namespace_url",
+//t    "namespace_url : ASSIGN LITERAL",
+//t    "opt_nullable :",
+//t    "opt_nullable : INTERR_NULLABLE",
+//t    "namespace_or_type_expr : member_name",
+//t    "member_name : simple_name_expr",
+//t    "member_name : namespace_or_type_expr DOT IDENTIFIER opt_type_argument_list",
+//t    "simple_name_expr : IDENTIFIER opt_type_argument_list",
+//t    "opt_type_argument_list :",
+//t    "opt_type_argument_list : OP_GENERICS_LT type_arguments OP_GENERICS_GT",
+//t    "opt_type_argument_list : OP_GENERICS_LT error",
+//t    "type_arguments : type",
+//t    "type_arguments : type_arguments COMMA type",
+//t    "$$71 :",
+//t    "type_declaration_name : IDENTIFIER $$71 opt_type_parameter_list",
+//t    "member_declaration_name : method_declaration_name",
+//t    "method_declaration_name : type_declaration_name",
+//t    "method_declaration_name : explicit_interface IDENTIFIER opt_type_parameter_list",
+//t    "indexer_declaration_name : THIS",
+//t    "indexer_declaration_name : explicit_interface THIS",
+//t    "explicit_interface : IDENTIFIER opt_type_argument_list DOT",
+//t    "explicit_interface : explicit_interface IDENTIFIER opt_type_argument_list DOT",
+//t    "opt_type_parameter_list :",
+//t    "opt_type_parameter_list : OP_GENERICS_LT type_parameters OP_GENERICS_GT",
+//t    "type_parameters : type_parameter",
+//t    "type_parameters : type_parameters COMMA type_parameter",
+//t    "type_parameter : opt_attributes opt_type_parameter_variance IDENTIFIER",
+//t    "type_parameter : error",
+//t    "type_and_void : type_expression_or_array",
+//t    "type_and_void : VOID",
+//t    "member_type : type_and_void",
+//t    "type : type_expression_or_array",
+//t    "type : VOID",
+//t    "simple_type : type_expression",
+//t    "simple_type : VOID",
+//t    "parameter_type : type_expression_or_array",
+//t    "parameter_type : VOID",
+//t    "type_expression_or_array : type_expression",
+//t    "type_expression_or_array : type_expression rank_specifiers",
+//t    "type_expression : namespace_or_type_expr opt_nullable",
+//t    "type_expression : STAR",
+//t    "type_expression : builtin_types opt_nullable",
+//t    "type_list : base_type_name",
+//t    "type_list : type_list COMMA base_type_name",
+//t    "base_type_name : type",
+//t    "builtin_types : DECIMAL",
+//t    "builtin_types : FLOAT",
+//t    "builtin_types : DOUBLE",
+//t    "builtin_types : integral_type",
+//t    "integral_type : SBYTE",
+//t    "integral_type : BYTE",
+//t    "integral_type : SHORT",
+//t    "integral_type : USHORT",
+//t    "integral_type : INT",
+//t    "integral_type : UINT",
+//t    "integral_type : LONG",
+//t    "integral_type : ULONG",
+//t    "integral_type : CHAR",
+//t    "primary_expression : primary_expression_or_type",
+//t    "primary_expression : literal",
+//t    "primary_expression : parenthesized_expression",
+//t    "primary_expression : default_value_expression",
+//t    "primary_expression : invocation_expression",
+//t    "primary_expression : element_access",
+//t    "primary_expression : this_access",
+//t    "primary_expression : base_access",
+//t    "primary_expression : post_increment_expression",
+//t    "primary_expression : post_decrement_expression",
+//t    "primary_expression : sizeof_expression",
+//t    "primary_expression : checked_expression",
+//t    "primary_expression : unchecked_expression",
+//t    "primary_expression : new_expression",
+//t    "primary_expression : anonymous_method_expression",
+//t    "primary_expression : array_initializer",
+//t    "primary_expression : object_or_collection_initializer",
+//t    "primary_expression_or_type : IDENTIFIER opt_type_argument_list",
+//t    "primary_expression_or_type : IDENTIFIER GENERATE_COMPLETION",
+//t    "primary_expression_or_type : member_access",
+//t    "literal : boolean_literal",
+//t    "literal : LITERAL",
+//t    "literal : UNDEFINED",
+//t    "literal : NULL",
+//t    "boolean_literal : TRUE",
+//t    "boolean_literal : FALSE",
+//t    "open_parens_any : OPEN_PARENS",
+//t    "open_parens_any : OPEN_PARENS_CAST",
+//t    "close_parens : CLOSE_PARENS",
+//t    "close_parens : COMPLETE_COMPLETION",
+//t    "parenthesized_expression : OPEN_PARENS expression CLOSE_PARENS",
+//t    "parenthesized_expression : OPEN_PARENS expression COMPLETE_COMPLETION",
+//t    "member_access : primary_expression DOT IDENTIFIER opt_type_argument_list",
+//t    "member_access : primary_expression DOT_AT IDENTIFIER",
+//t    "member_access : primary_expression DOT_STAR",
+//t    "member_access : primary_expression DOTDOT IDENTIFIER",
+//t    "member_access : primary_expression DOTDOT_STAR",
+//t    "member_access : primary_expression DOUBLE_COLON IDENTIFIER",
+//t    "member_access : primary_expression DOUBLE_COLON OPEN_BRACKET_EXPR expression_list_arguments CLOSE_BRACKET",
+//t    "member_access : primary_expression DOT_AT OPEN_BRACKET_EXPR expression_list_arguments CLOSE_BRACKET",
+//t    "member_access : primary_expression DOT OPEN_PARENS expression CLOSE_PARENS",
+//t    "member_access : builtin_types DOT IDENTIFIER opt_type_argument_list",
+//t    "member_access : SUPER DOT IDENTIFIER opt_type_argument_list",
+//t    "member_access : primary_expression DOT GENERATE_COMPLETION",
+//t    "member_access : primary_expression DOT IDENTIFIER GENERATE_COMPLETION",
+//t    "member_access : builtin_types DOT GENERATE_COMPLETION",
+//t    "member_access : builtin_types DOT IDENTIFIER GENERATE_COMPLETION",
+//t    "invocation_expression : SUPER open_parens_any opt_argument_list close_parens",
+//t    "invocation_expression : builtin_types open_parens_any opt_argument_list close_parens",
+//t    "invocation_expression : primary_expression open_parens_any opt_argument_list close_parens",
+//t    "invocation_expression : primary_expression open_parens_any argument_list error",
+//t    "object_or_collection_initializer : init_open_brace opt_member_initializer_list init_close_brace_or_complete_completion",
+//t    "object_or_collection_initializer : init_open_brace member_initializer_list COMMA init_close_brace",
+//t    "init_open_brace : OPEN_BRACE_INIT",
+//t    "init_close_brace : CLOSE_BRACE",
+//t    "init_close_brace_or_complete_completion : CLOSE_BRACE",
+//t    "init_close_brace_or_complete_completion : COMPLETE_COMPLETION",
+//t    "opt_member_initializer_list :",
+//t    "opt_member_initializer_list : member_initializer_list",
+//t    "member_initializer_list : member_initializer",
+//t    "member_initializer_list : member_initializer_list COMMA member_initializer",
+//t    "member_initializer_list : member_initializer_list error",
+//t    "member_initializer : IDENTIFIER COLON initializer_value",
+//t    "member_initializer : AWAIT ASSIGN initializer_value",
+//t    "member_initializer : LITERAL COLON initializer_value",
+//t    "member_initializer : GENERATE_COMPLETION",
+//t    "initializer_value : expression",
+//t    "opt_argument_list :",
+//t    "opt_argument_list : argument_list",
+//t    "argument_list : argument_or_named_argument",
+//t    "argument_list : argument_list COMMA argument",
+//t    "argument_list : argument_list COMMA named_argument",
+//t    "argument_list : argument_list COMMA error",
+//t    "argument_list : COMMA error",
+//t    "argument : expression",
+//t    "argument : non_simple_argument",
+//t    "argument_or_named_argument : argument",
+//t    "argument_or_named_argument : named_argument",
+//t    "non_simple_argument : REF variable_reference",
+//t    "non_simple_argument : OUT variable_reference",
+//t    "variable_reference : expression",
+//t    "element_access : primary_expression OPEN_BRACKET_EXPR expression_list_arguments CLOSE_BRACKET",
+//t    "element_access : primary_expression OPEN_BRACKET_EXPR expression_list_arguments error",
+//t    "element_access : primary_expression OPEN_BRACKET_EXPR error",
+//t    "element_access : builtin_types OPEN_BRACKET_EXPR expression_list_arguments CLOSE_BRACKET",
+//t    "element_access : builtin_types OPEN_BRACKET_EXPR expression_list_arguments error",
+//t    "element_access : builtin_types OPEN_BRACKET_EXPR error",
+//t    "expression_list : expression",
+//t    "expression_list : expression_list COMMA expression",
+//t    "expression_list : expression_list error",
+//t    "expression_list_arguments : expression_list_argument",
+//t    "expression_list_arguments : expression_list_arguments COMMA expression_list_argument",
+//t    "expression_list_argument : expression",
+//t    "expression_list_argument : named_argument",
+//t    "this_access : THIS",
+//t    "base_access : SUPER OPEN_BRACKET_EXPR expression_list_arguments CLOSE_BRACKET",
+//t    "base_access : SUPER OPEN_BRACKET error",
+//t    "post_increment_expression : primary_expression OP_INC",
+//t    "post_decrement_expression : primary_expression OP_DEC",
+//t    "new_expression : NEW namespace_or_type_expr",
+//t    "new_expression : NEW builtin_types",
+//t    "new_expression : NEW OPEN_PARENS expression CLOSE_PARENS",
+//t    "new_expression : NEW OP_LT type_expression OP_GT array_initializer",
+//t    "rank_specifiers : rank_specifier",
+//t    "rank_specifiers : rank_specifier rank_specifiers",
+//t    "rank_specifier : OPEN_BRACKET CLOSE_BRACKET",
+//t    "rank_specifier : OPEN_BRACKET dim_separators CLOSE_BRACKET",
+//t    "dim_separators : COMMA",
+//t    "dim_separators : dim_separators COMMA",
+//t    "array_initializer : init_open_bracket init_close_bracket",
+//t    "array_initializer : init_open_bracket_expr variable_initializer_list opt_comma init_close_bracket",
+//t    "init_open_bracket : OPEN_BRACKET",
+//t    "init_open_bracket_expr : OPEN_BRACKET_EXPR",
+//t    "init_close_bracket : CLOSE_BRACKET",
+//t    "variable_initializer_list : variable_initializer",
+//t    "variable_initializer_list : variable_initializer_list COMMA variable_initializer",
+//t    "typeof_type_expression : type_and_void",
+//t    "typeof_type_expression : unbound_type_name",
+//t    "typeof_type_expression : error",
+//t    "unbound_type_name : identifier_inside_body generic_dimension",
+//t    "unbound_type_name : unbound_type_name DOT identifier_inside_body",
+//t    "unbound_type_name : unbound_type_name DOT identifier_inside_body generic_dimension",
+//t    "unbound_type_name : namespace_or_type_expr DOT identifier_inside_body generic_dimension",
+//t    "generic_dimension : GENERIC_DIMENSION",
+//t    "sizeof_expression : SIZEOF open_parens_any type CLOSE_PARENS",
+//t    "sizeof_expression : SIZEOF open_parens_any type error",
+//t    "checked_expression : CHECKED open_parens_any expression CLOSE_PARENS",
+//t    "checked_expression : CHECKED error",
+//t    "unchecked_expression : UNCHECKED open_parens_any expression CLOSE_PARENS",
+//t    "unchecked_expression : UNCHECKED error",
+//t    "$$72 :",
+//t    "$$73 :",
+//t    "anonymous_method_expression : FUNCTION OPEN_PARENS $$72 opt_formal_parameter_list CLOSE_PARENS COLON member_type $$73 block",
+//t    "$$74 :",
+//t    "$$75 :",
+//t    "anonymous_method_expression : ASYNC FUNCTION OPEN_PARENS $$74 opt_formal_parameter_list CLOSE_PARENS COLON member_type $$75 block",
+//t    "$$76 :",
+//t    "$$77 :",
+//t    "local_function_statement : FUNCTION IDENTIFIER OPEN_PARENS $$76 opt_formal_parameter_list CLOSE_PARENS COLON member_type $$77 block",
+//t    "$$78 :",
+//t    "$$79 :",
+//t    "local_function_statement : ASYNC FUNCTION IDENTIFIER OPEN_PARENS $$78 opt_formal_parameter_list CLOSE_PARENS COLON member_type $$79 block",
+//t    "default_value_expression : DEFAULT open_parens_any type CLOSE_PARENS",
+//t    "unary_expression : primary_expression",
+//t    "unary_expression : BANG prefixed_unary_expression",
+//t    "unary_expression : TILDE prefixed_unary_expression",
+//t    "unary_expression : AWAIT prefixed_unary_expression",
+//t    "unary_expression : OP_AT prefixed_unary_expression",
+//t    "unary_expression : TYPEOF prefixed_unary_expression",
+//t    "unary_expression : DELETE prefixed_unary_expression",
+//t    "unary_expression : BANG error",
+//t    "unary_expression : TILDE error",
+//t    "unary_expression : AWAIT error",
+//t    "unary_expression : OP_AT error",
+//t    "unary_expression : TYPEOF error",
+//t    "unary_expression : DELETE error",
+//t    "prefixed_unary_expression : unary_expression",
+//t    "prefixed_unary_expression : PLUS prefixed_unary_expression",
+//t    "prefixed_unary_expression : MINUS prefixed_unary_expression",
+//t    "prefixed_unary_expression : OP_INC prefixed_unary_expression",
+//t    "prefixed_unary_expression : OP_DEC prefixed_unary_expression",
+//t    "prefixed_unary_expression : BITWISE_AND prefixed_unary_expression",
+//t    "prefixed_unary_expression : PLUS error",
+//t    "prefixed_unary_expression : MINUS error",
+//t    "prefixed_unary_expression : OP_INC error",
+//t    "prefixed_unary_expression : OP_DEC error",
+//t    "prefixed_unary_expression : BITWISE_AND error",
+//t    "multiplicative_expression : prefixed_unary_expression",
+//t    "multiplicative_expression : multiplicative_expression STAR prefixed_unary_expression",
+//t    "multiplicative_expression : multiplicative_expression DIV prefixed_unary_expression",
+//t    "multiplicative_expression : multiplicative_expression PERCENT prefixed_unary_expression",
+//t    "multiplicative_expression : multiplicative_expression STAR error",
+//t    "multiplicative_expression : multiplicative_expression DIV error",
+//t    "multiplicative_expression : multiplicative_expression PERCENT error",
+//t    "additive_expression : multiplicative_expression",
+//t    "additive_expression : additive_expression PLUS multiplicative_expression",
+//t    "additive_expression : additive_expression MINUS multiplicative_expression",
+//t    "additive_expression : additive_expression OP_IN multiplicative_expression",
+//t    "additive_expression : additive_expression AS type",
+//t    "additive_expression : additive_expression IS type",
+//t    "additive_expression : additive_expression PLUS error",
+//t    "additive_expression : additive_expression MINUS error",
+//t    "additive_expression : additive_expression OP_IN error",
+//t    "additive_expression : additive_expression AS error",
+//t    "additive_expression : additive_expression IS error",
+//t    "shift_expression : additive_expression",
+//t    "shift_expression : shift_expression OP_SHIFT_LEFT additive_expression",
+//t    "shift_expression : shift_expression OP_SHIFT_RIGHT additive_expression",
+//t    "shift_expression : shift_expression OP_USHIFT_RIGHT additive_expression",
+//t    "shift_expression : shift_expression OP_SHIFT_LEFT error",
+//t    "shift_expression : shift_expression OP_SHIFT_RIGHT error",
+//t    "shift_expression : shift_expression OP_USHIFT_RIGHT error",
+//t    "relational_expression : shift_expression",
+//t    "relational_expression : relational_expression OP_LT shift_expression",
+//t    "relational_expression : relational_expression OP_GT shift_expression",
+//t    "relational_expression : relational_expression OP_LE shift_expression",
+//t    "relational_expression : relational_expression OP_GE shift_expression",
+//t    "relational_expression : relational_expression OP_LT error",
+//t    "relational_expression : relational_expression OP_GT error",
+//t    "relational_expression : relational_expression OP_LE error",
+//t    "relational_expression : relational_expression OP_GE error",
+//t    "equality_expression : relational_expression",
+//t    "equality_expression : equality_expression OP_EQ relational_expression",
+//t    "equality_expression : equality_expression OP_NE relational_expression",
+//t    "equality_expression : equality_expression OP_REF_EQ relational_expression",
+//t    "equality_expression : equality_expression OP_REF_NE relational_expression",
+//t    "and_expression : equality_expression",
+//t    "and_expression : and_expression BITWISE_AND equality_expression",
+//t    "and_expression : and_expression BITWISE_AND error",
+//t    "exclusive_or_expression : and_expression",
+//t    "exclusive_or_expression : exclusive_or_expression CARRET and_expression",
+//t    "exclusive_or_expression : exclusive_or_expression CARRET error",
+//t    "inclusive_or_expression : exclusive_or_expression",
+//t    "inclusive_or_expression : inclusive_or_expression BITWISE_OR exclusive_or_expression",
+//t    "inclusive_or_expression : inclusive_or_expression BITWISE_OR error",
+//t    "conditional_and_expression : inclusive_or_expression",
+//t    "conditional_and_expression : conditional_and_expression OP_AND inclusive_or_expression",
+//t    "conditional_and_expression : conditional_and_expression OP_AND error",
+//t    "conditional_or_expression : conditional_and_expression",
+//t    "conditional_or_expression : conditional_or_expression OP_OR conditional_and_expression",
+//t    "conditional_or_expression : conditional_or_expression OP_OR error",
+//t    "null_coalescing_expression : conditional_or_expression",
+//t    "null_coalescing_expression : conditional_or_expression OP_COALESCING null_coalescing_expression",
+//t    "conditional_expression : null_coalescing_expression",
+//t    "conditional_expression : null_coalescing_expression INTERR expression COLON expression",
+//t    "conditional_expression : null_coalescing_expression INTERR expression error",
+//t    "conditional_expression : null_coalescing_expression INTERR expression COLON error",
+//t    "assignment_expression : prefixed_unary_expression ASSIGN expression",
+//t    "assignment_expression : prefixed_unary_expression OP_MULT_ASSIGN expression",
+//t    "assignment_expression : prefixed_unary_expression OP_DIV_ASSIGN expression",
+//t    "assignment_expression : prefixed_unary_expression OP_MOD_ASSIGN expression",
+//t    "assignment_expression : prefixed_unary_expression OP_ADD_ASSIGN expression",
+//t    "assignment_expression : prefixed_unary_expression OP_SUB_ASSIGN expression",
+//t    "assignment_expression : prefixed_unary_expression OP_SHIFT_LEFT_ASSIGN expression",
+//t    "assignment_expression : prefixed_unary_expression OP_SHIFT_RIGHT_ASSIGN expression",
+//t    "assignment_expression : prefixed_unary_expression OP_USHIFT_RIGHT_ASSIGN expression",
+//t    "assignment_expression : prefixed_unary_expression OP_AND_ASSIGN expression",
+//t    "assignment_expression : prefixed_unary_expression LOGICAL_AND_ASSIGN expression",
+//t    "assignment_expression : prefixed_unary_expression OP_OR_ASSIGN expression",
+//t    "assignment_expression : prefixed_unary_expression LOGICAL_OR_ASSIGN expression",
+//t    "assignment_expression : prefixed_unary_expression OP_XOR_ASSIGN expression",
+//t    "lambda_parameter_list : lambda_parameter",
+//t    "lambda_parameter_list : lambda_parameter_list COMMA lambda_parameter",
+//t    "lambda_parameter : parameter_modifier parameter_type identifier_inside_body",
+//t    "lambda_parameter : parameter_type identifier_inside_body",
+//t    "lambda_parameter : IDENTIFIER",
+//t    "lambda_parameter : AWAIT",
+//t    "opt_lambda_parameter_list :",
+//t    "opt_lambda_parameter_list : lambda_parameter_list",
+//t    "$$80 :",
+//t    "lambda_expression_body : $$80 expression",
+//t    "lambda_expression_body : block",
+//t    "lambda_expression_body : error",
+//t    "expression_or_error : expression",
+//t    "expression_or_error : error",
+//t    "$$81 :",
+//t    "lambda_expression : IDENTIFIER ARROW $$81 lambda_expression_body",
+//t    "$$82 :",
+//t    "lambda_expression : AWAIT ARROW $$82 lambda_expression_body",
+//t    "$$83 :",
+//t    "lambda_expression : ASYNC identifier_inside_body ARROW $$83 lambda_expression_body",
+//t    "$$84 :",
+//t    "$$85 :",
+//t    "lambda_expression : OPEN_PARENS_LAMBDA $$84 opt_lambda_parameter_list CLOSE_PARENS ARROW $$85 lambda_expression_body",
+//t    "$$86 :",
+//t    "$$87 :",
+//t    "lambda_expression : ASYNC OPEN_PARENS_LAMBDA $$86 opt_lambda_parameter_list CLOSE_PARENS ARROW $$87 lambda_expression_body",
+//t    "expression : assignment_expression",
+//t    "expression : non_assignment_expression",
+//t    "non_assignment_expression : conditional_expression",
+//t    "non_assignment_expression : lambda_expression",
+//t    "non_assignment_expression : query_expression",
+//t    "constant_expression : expression",
+//t    "boolean_expression : expression",
+//t    "$$88 :",
+//t    "$$89 :",
+//t    "$$90 :",
+//t    "$$91 :",
+//t    "$$92 :",
+//t    "class_declaration : opt_attributes opt_modifiers opt_partial CLASS $$88 type_declaration_name $$89 opt_class_extends opt_class_implements opt_type_parameter_constraints_clauses $$90 OPEN_BRACE $$91 opt_class_member_declarations CLOSE_BRACE $$92 opt_semicolon",
+//t    "opt_partial :",
+//t    "opt_partial : PARTIAL",
+//t    "opt_modifiers :",
+//t    "opt_modifiers : modifiers",
+//t    "modifiers : modifier",
+//t    "modifiers : modifiers modifier",
+//t    "modifier : NEW",
+//t    "modifier : PUBLIC",
+//t    "modifier : PROTECTED",
+//t    "modifier : INTERNAL",
+//t    "modifier : PRIVATE",
+//t    "modifier : ABSTRACT",
+//t    "modifier : FINAL",
+//t    "modifier : STATIC",
+//t    "modifier : READONLY",
+//t    "modifier : VIRTUAL",
+//t    "modifier : OVERRIDE",
+//t    "modifier : NATIVE",
+//t    "modifier : VOLATILE",
+//t    "modifier : UNSAFE",
+//t    "modifier : ASYNC",
+//t    "modifier : DYNAMIC",
+//t    "modifier : IDENTIFIER_MODIFIER",
+//t    "opt_class_extends :",
+//t    "opt_class_extends : EXTENDS base_type_name",
+//t    "opt_class_extends : EXTENDS base_type_name error",
+//t    "opt_class_implements :",
+//t    "opt_class_implements : IMPLEMENTS type_list",
+//t    "opt_class_implements : IMPLEMENTS type_list error",
+//t    "opt_type_parameter_constraints_clauses :",
+//t    "opt_type_parameter_constraints_clauses : type_parameter_constraints_clauses",
+//t    "type_parameter_constraints_clauses : type_parameter_constraints_clause",
+//t    "type_parameter_constraints_clauses : type_parameter_constraints_clauses type_parameter_constraints_clause",
+//t    "type_parameter_constraints_clause : WHERE IDENTIFIER COLON type_parameter_constraints",
+//t    "type_parameter_constraints_clause : WHERE IDENTIFIER error",
+//t    "type_parameter_constraints : type_parameter_constraint",
+//t    "type_parameter_constraints : type_parameter_constraints COMMA type_parameter_constraint",
+//t    "type_parameter_constraint : type",
+//t    "type_parameter_constraint : NEW OPEN_PARENS CLOSE_PARENS",
+//t    "type_parameter_constraint : CLASS",
+//t    "type_parameter_constraint : STRUCT",
+//t    "opt_type_parameter_variance :",
+//t    "opt_type_parameter_variance : type_parameter_variance",
+//t    "type_parameter_variance : OUT",
+//t    "type_parameter_variance : IN",
+//t    "$$93 :",
+//t    "block : OPEN_BRACE $$93 opt_statement_list block_end",
+//t    "$$94 :",
+//t    "config_block : opt_block_config OPEN_BRACE $$94 opt_statement_list block_end",
+//t    "opt_block_config :",
+//t    "opt_block_config : IDENTIFIER DOUBLE_COLON IDENTIFIER",
+//t    "block_end : CLOSE_BRACE",
+//t    "block_end : COMPLETE_COMPLETION",
+//t    "$$95 :",
+//t    "block_prepared : OPEN_BRACE $$95 opt_statement_list CLOSE_BRACE",
+//t    "opt_statement_list :",
+//t    "opt_statement_list : statement_list",
+//t    "statement_list : statement",
+//t    "statement_list : statement_list statement",
+//t    "statement : block_variable_declaration",
+//t    "statement : valid_declaration_statement",
+//t    "statement : labeled_statement",
+//t    "statement : error",
+//t    "interactive_statement_list : interactive_statement",
+//t    "interactive_statement_list : interactive_statement_list interactive_statement",
+//t    "interactive_statement : block_variable_declaration",
+//t    "interactive_statement : interactive_valid_declaration_statement",
+//t    "interactive_statement : labeled_statement",
+//t    "valid_declaration_statement : config_block",
+//t    "valid_declaration_statement : empty_statement",
+//t    "valid_declaration_statement : expression_statement",
+//t    "valid_declaration_statement : selection_statement",
+//t    "valid_declaration_statement : iteration_statement",
+//t    "valid_declaration_statement : jump_statement",
+//t    "valid_declaration_statement : try_statement",
+//t    "valid_declaration_statement : checked_statement",
+//t    "valid_declaration_statement : unchecked_statement",
+//t    "valid_declaration_statement : lock_statement",
+//t    "valid_declaration_statement : using_statement",
+//t    "valid_declaration_statement : unsafe_statement",
+//t    "valid_declaration_statement : fixed_statement",
+//t    "valid_declaration_statement : local_function_statement",
+//t    "interactive_valid_declaration_statement : config_block",
+//t    "interactive_valid_declaration_statement : empty_statement",
+//t    "interactive_valid_declaration_statement : interactive_expression_statement",
+//t    "interactive_valid_declaration_statement : selection_statement",
+//t    "interactive_valid_declaration_statement : iteration_statement",
+//t    "interactive_valid_declaration_statement : jump_statement",
+//t    "interactive_valid_declaration_statement : try_statement",
+//t    "interactive_valid_declaration_statement : checked_statement",
+//t    "interactive_valid_declaration_statement : unchecked_statement",
+//t    "interactive_valid_declaration_statement : lock_statement",
+//t    "interactive_valid_declaration_statement : using_statement",
+//t    "interactive_valid_declaration_statement : unsafe_statement",
+//t    "interactive_valid_declaration_statement : fixed_statement",
+//t    "interactive_valid_declaration_statement : local_function_statement",
+//t    "embedded_statement : valid_declaration_statement",
+//t    "embedded_statement : block_variable_declaration",
+//t    "embedded_statement : labeled_statement",
+//t    "embedded_statement : error",
+//t    "empty_statement : SEMICOLON",
+//t    "$$96 :",
+//t    "labeled_statement : identifier_inside_body COLON $$96 statement",
+//t    "use_namespace_statement : USE NAMESPACE IDENTIFIER stmnt_end_semicolon",
+//t    "variable_type : variable_type_simple",
+//t    "variable_type : variable_type_simple rank_specifiers",
+//t    "variable_type_simple : primary_expression_or_type opt_nullable",
+//t    "variable_type_simple : builtin_types opt_nullable",
+//t    "variable_type_simple : VOID",
+//t    "identifier_inside_body : IDENTIFIER",
+//t    "identifier_inside_body : AWAIT",
+//t    "stmnt_end_semicolon : SEMICOLON",
+//t    "$$97 :",
+//t    "block_variable_declaration : VAR identifier_inside_body COLON type $$97 opt_local_variable_initializer opt_variable_declarators stmnt_end_semicolon",
+//t    "$$98 :",
+//t    "block_variable_declaration : VAR identifier_inside_body $$98 opt_local_variable_initializer opt_variable_declarators stmnt_end_semicolon",
+//t    "$$99 :",
+//t    "block_variable_declaration : CONST identifier_inside_body COLON type $$99 const_variable_initializer opt_const_declarators stmnt_end_semicolon",
+//t    "opt_local_variable_initializer :",
+//t    "opt_local_variable_initializer : ASSIGN block_variable_initializer",
+//t    "opt_local_variable_initializer : error",
+//t    "opt_variable_declarators :",
+//t    "opt_variable_declarators : variable_declarators",
+//t    "opt_using_or_fixed_variable_declarators :",
+//t    "opt_using_or_fixed_variable_declarators : variable_declarators",
+//t    "variable_declarators : variable_declarator",
+//t    "variable_declarators : variable_declarators variable_declarator",
+//t    "variable_declarator : COMMA identifier_inside_body",
+//t    "variable_declarator : COMMA identifier_inside_body ASSIGN block_variable_initializer",
+//t    "variable_declarator : COMMA identifier_inside_body COLON type",
+//t    "variable_declarator : COMMA identifier_inside_body COLON type ASSIGN block_variable_initializer",
+//t    "const_variable_initializer :",
+//t    "const_variable_initializer : ASSIGN constant_initializer_expr",
+//t    "opt_const_declarators :",
+//t    "opt_const_declarators : const_declarators",
+//t    "const_declarators : const_declarator",
+//t    "const_declarators : const_declarators const_declarator",
+//t    "const_declarator : COMMA identifier_inside_body ASSIGN constant_initializer_expr",
+//t    "block_variable_initializer : variable_initializer",
+//t    "expression_statement : statement_expression stmnt_end_semicolon",
+//t    "expression_statement : statement_expression COMPLETE_COMPLETION",
+//t    "expression_statement : statement_expression CLOSE_BRACE",
+//t    "interactive_expression_statement : interactive_statement_expression SEMICOLON",
+//t    "interactive_expression_statement : interactive_statement_expression COMPLETE_COMPLETION",
+//t    "statement_expression : expression",
+//t    "interactive_statement_expression : expression",
+//t    "interactive_statement_expression : error",
+//t    "selection_statement : if_statement",
+//t    "selection_statement : switch_statement",
+//t    "stmnt_close_parens : CLOSE_PARENS",
+//t    "stmnt_else : ELSE",
+//t    "if_statement : IF open_parens_any boolean_expression stmnt_close_parens embedded_statement",
+//t    "if_statement : IF open_parens_any boolean_expression stmnt_close_parens embedded_statement stmnt_else embedded_statement",
+//t    "if_statement : IF open_parens_any boolean_expression error",
+//t    "$$100 :",
+//t    "switch_statement : SWITCH open_parens_any expression CLOSE_PARENS OPEN_BRACE $$100 opt_switch_sections CLOSE_BRACE",
+//t    "switch_statement : SWITCH open_parens_any expression error",
+//t    "opt_switch_sections :",
+//t    "opt_switch_sections : switch_sections",
+//t    "switch_sections : switch_section",
+//t    "switch_sections : switch_sections switch_section",
+//t    "switch_sections : error",
+//t    "$$101 :",
+//t    "switch_section : switch_labels $$101 statement_list",
+//t    "switch_labels : switch_label",
+//t    "switch_labels : switch_labels switch_label",
+//t    "switch_label : CASE constant_expression COLON",
+//t    "switch_label : CASE constant_expression error",
+//t    "switch_label : DEFAULT_COLON",
+//t    "iteration_statement : while_statement",
+//t    "iteration_statement : do_statement",
+//t    "iteration_statement : for_statement",
+//t    "iteration_statement : foreach_statement",
+//t    "while_statement : WHILE open_parens_any boolean_expression stmnt_close_parens embedded_statement",
+//t    "while_statement : WHILE open_parens_any boolean_expression error",
+//t    "stmnt_do : DO",
+//t    "do_while_stmnt_close_parens : CLOSE_PARENS",
+//t    "do_statement : stmnt_do embedded_statement WHILE open_parens_any boolean_expression do_while_stmnt_close_parens stmnt_end_semicolon",
+//t    "do_statement : stmnt_do embedded_statement error",
+//t    "do_statement : stmnt_do embedded_statement WHILE open_parens_any boolean_expression error",
+//t    "$$102 :",
+//t    "for_statement : FOR open_parens_any $$102 for_statement_cont",
+//t    "$$103 :",
+//t    "for_statement_cont : for_initializer IN $$103 expression stmnt_close_parens embedded_statement",
+//t    "$$104 :",
+//t    "for_statement_cont : opt_for_initializer SEMICOLON $$104 for_condition_and_iterator_part embedded_statement",
+//t    "for_statement_cont : error",
+//t    "$$105 :",
+//t    "for_condition_and_iterator_part : opt_for_condition SEMICOLON $$105 for_iterator_part",
+//t    "for_condition_and_iterator_part : opt_for_condition close_parens_close_brace",
+//t    "for_iterator_part : opt_for_iterator stmnt_close_parens",
+//t    "for_iterator_part : opt_for_iterator CLOSE_BRACE",
+//t    "close_parens_close_brace : CLOSE_PARENS",
+//t    "close_parens_close_brace : CLOSE_BRACE",
+//t    "opt_for_initializer :",
+//t    "opt_for_initializer : for_initializer",
+//t    "$$106 :",
+//t    "for_initializer : VAR identifier_inside_body COLON type $$106 opt_local_variable_initializer opt_variable_declarators",
+//t    "for_initializer : expression_list",
+//t    "opt_for_condition :",
+//t    "opt_for_condition : boolean_expression",
+//t    "opt_for_iterator :",
+//t    "opt_for_iterator : for_iterator",
+//t    "for_iterator : statement_expression_list",
+//t    "statement_expression_list : statement_expression",
+//t    "statement_expression_list : statement_expression_list COMMA statement_expression",
+//t    "$$107 :",
+//t    "$$108 :",
+//t    "$$109 :",
+//t    "foreach_statement : FOR_EACH $$107 open_parens_any for_initializer IN $$108 expression stmnt_close_parens $$109 embedded_statement",
+//t    "jump_statement : break_statement",
+//t    "jump_statement : continue_statement",
+//t    "jump_statement : goto_statement",
+//t    "jump_statement : return_statement",
+//t    "jump_statement : throw_statement",
+//t    "jump_statement : yield_statement",
+//t    "jump_statement : use_namespace_statement",
+//t    "break_statement : BREAK stmnt_end_semicolon",
+//t    "continue_statement : CONTINUE stmnt_end_semicolon",
+//t    "continue_statement : CONTINUE error",
+//t    "goto_statement : GOTO identifier_inside_body stmnt_end_semicolon",
+//t    "goto_statement : GOTO CASE constant_expression stmnt_end_semicolon",
+//t    "goto_statement : GOTO DEFAULT stmnt_end_semicolon",
+//t    "return_statement : RETURN opt_expression stmnt_end_semicolon",
+//t    "return_statement : RETURN expression error",
+//t    "return_statement : RETURN error",
+//t    "throw_statement : THROW opt_expression stmnt_end_semicolon",
+//t    "throw_statement : THROW error",
+//t    "yield_statement : identifier_inside_body RETURN opt_expression stmnt_end_semicolon",
+//t    "yield_statement : identifier_inside_body RETURN expression error",
+//t    "yield_statement : identifier_inside_body BREAK stmnt_end_semicolon",
+//t    "opt_expression :",
+//t    "opt_expression : expression",
+//t    "try_statement : TRY block catch_clauses",
+//t    "try_statement : TRY block FINALLY block",
+//t    "try_statement : TRY block catch_clauses FINALLY block",
+//t    "try_statement : TRY block error",
+//t    "catch_clauses : catch_clause",
+//t    "catch_clauses : catch_clauses catch_clause",
+//t    "opt_identifier :",
+//t    "opt_identifier : identifier_inside_body",
+//t    "catch_clause : CATCH block",
+//t    "$$110 :",
+//t    "catch_clause : CATCH open_parens_any IDENTIFIER COLON type CLOSE_PARENS $$110 block_prepared",
+//t    "catch_clause : CATCH open_parens_any error",
+//t    "catch_clause : CATCH open_parens_any type opt_identifier CLOSE_PARENS error",
+//t    "checked_statement : CHECKED block",
+//t    "unchecked_statement : UNCHECKED block",
+//t    "$$111 :",
+//t    "unsafe_statement : UNSAFE $$111 block",
+//t    "lock_statement : LOCK open_parens_any expression CLOSE_PARENS embedded_statement",
+//t    "lock_statement : LOCK open_parens_any expression error",
+//t    "$$112 :",
+//t    "$$113 :",
+//t    "fixed_statement : FIXED open_parens_any type identifier_inside_body $$112 using_or_fixed_variable_initializer opt_using_or_fixed_variable_declarators CLOSE_PARENS $$113 embedded_statement",
+//t    "$$114 :",
+//t    "$$115 :",
+//t    "using_statement : USING open_parens_any variable_type identifier_inside_body $$114 using_initialization CLOSE_PARENS $$115 embedded_statement",
+//t    "using_statement : USING open_parens_any expression CLOSE_PARENS embedded_statement",
+//t    "using_statement : USING open_parens_any expression error",
+//t    "using_initialization : using_or_fixed_variable_initializer opt_using_or_fixed_variable_declarators",
+//t    "using_initialization : error",
+//t    "using_or_fixed_variable_initializer :",
+//t    "using_or_fixed_variable_initializer : ASSIGN variable_initializer",
+//t    "query_expression : first_from_clause query_body",
+//t    "query_expression : nested_from_clause query_body",
+//t    "query_expression : first_from_clause COMPLETE_COMPLETION",
+//t    "query_expression : nested_from_clause COMPLETE_COMPLETION",
+//t    "first_from_clause : FROM_FIRST identifier_inside_body IN expression",
+//t    "first_from_clause : FROM_FIRST type identifier_inside_body IN expression",
+//t    "nested_from_clause : FROM identifier_inside_body IN expression",
+//t    "nested_from_clause : FROM type identifier_inside_body IN expression",
+//t    "$$116 :",
+//t    "from_clause : FROM identifier_inside_body IN $$116 expression_or_error",
+//t    "$$117 :",
+//t    "from_clause : FROM type identifier_inside_body IN $$117 expression_or_error",
+//t    "query_body : query_body_clauses select_or_group_clause opt_query_continuation",
+//t    "query_body : select_or_group_clause opt_query_continuation",
+//t    "query_body : query_body_clauses COMPLETE_COMPLETION",
+//t    "query_body : query_body_clauses error",
+//t    "query_body : error",
+//t    "$$118 :",
+//t    "select_or_group_clause : SELECT $$118 expression_or_error",
+//t    "$$119 :",
+//t    "$$120 :",
+//t    "select_or_group_clause : GROUP $$119 expression_or_error $$120 BY expression_or_error",
+//t    "query_body_clauses : query_body_clause",
+//t    "query_body_clauses : query_body_clauses query_body_clause",
+//t    "query_body_clause : from_clause",
+//t    "query_body_clause : let_clause",
+//t    "query_body_clause : where_clause",
+//t    "query_body_clause : join_clause",
+//t    "query_body_clause : orderby_clause",
+//t    "$$121 :",
+//t    "let_clause : LET identifier_inside_body ASSIGN $$121 expression_or_error",
+//t    "$$122 :",
+//t    "where_clause : WHERE $$122 expression_or_error",
+//t    "$$123 :",
+//t    "$$124 :",
+//t    "$$125 :",
+//t    "join_clause : JOIN identifier_inside_body IN $$123 expression_or_error ON $$124 expression_or_error EQUALS $$125 expression_or_error opt_join_into",
+//t    "$$126 :",
+//t    "$$127 :",
+//t    "$$128 :",
+//t    "join_clause : JOIN type identifier_inside_body IN $$126 expression_or_error ON $$127 expression_or_error EQUALS $$128 expression_or_error opt_join_into",
+//t    "opt_join_into :",
+//t    "opt_join_into : INTO identifier_inside_body",
+//t    "$$129 :",
+//t    "orderby_clause : ORDERBY $$129 orderings",
+//t    "orderings : order_by",
+//t    "$$130 :",
+//t    "orderings : order_by COMMA $$130 orderings_then_by",
+//t    "orderings_then_by : then_by",
+//t    "$$131 :",
+//t    "orderings_then_by : orderings_then_by COMMA $$131 then_by",
+//t    "order_by : expression",
+//t    "order_by : expression ASCENDING",
+//t    "order_by : expression DESCENDING",
+//t    "then_by : expression",
+//t    "then_by : expression ASCENDING",
+//t    "then_by : expression DESCENDING",
+//t    "opt_query_continuation :",
+//t    "$$132 :",
+//t    "opt_query_continuation : INTO identifier_inside_body $$132 query_body",
+//t    "interactive_parsing : EVAL_STATEMENT_PARSER EOF",
+//t    "interactive_parsing : EVAL_USING_DECLARATIONS_UNIT_PARSER package_directives opt_COMPLETE_COMPLETION",
+//t    "$$133 :",
+//t    "interactive_parsing : EVAL_STATEMENT_PARSER $$133 interactive_statement_list opt_COMPLETE_COMPLETION",
+//t    "interactive_parsing : EVAL_COMPILATION_UNIT_PARSER interactive_compilation_unit",
+//t    "interactive_compilation_unit : opt_extern_alias_directives opt_package_directives",
+//t    "interactive_compilation_unit : opt_extern_alias_directives opt_package_directives package_declaration",
+//t    "opt_COMPLETE_COMPLETION :",
+//t    "opt_COMPLETE_COMPLETION : COMPLETE_COMPLETION",
+//t    "documentation_parsing : DOC_SEE doc_cref",
+//t    "doc_cref : doc_type_declaration_name opt_doc_method_sig",
+//t    "doc_cref : builtin_types opt_doc_method_sig",
+//t    "doc_cref : builtin_types DOT IDENTIFIER opt_doc_method_sig",
+//t    "doc_cref : doc_type_declaration_name DOT THIS",
+//t    "$$134 :",
+//t    "doc_cref : doc_type_declaration_name DOT THIS OPEN_BRACKET $$134 opt_doc_parameters CLOSE_BRACKET",
+//t    "doc_cref : EXPLICIT OPERATOR type opt_doc_method_sig",
+//t    "doc_cref : IMPLICIT OPERATOR type opt_doc_method_sig",
+//t    "doc_cref : OPERATOR overloadable_operator opt_doc_method_sig",
+//t    "doc_type_declaration_name : type_declaration_name",
+//t    "doc_type_declaration_name : doc_type_declaration_name DOT type_declaration_name",
+//t    "opt_doc_method_sig :",
+//t    "$$135 :",
+//t    "opt_doc_method_sig : OPEN_PARENS $$135 opt_doc_parameters CLOSE_PARENS",
+//t    "opt_doc_parameters :",
+//t    "opt_doc_parameters : doc_parameters",
+//t    "doc_parameters : doc_parameter",
+//t    "doc_parameters : doc_parameters COMMA doc_parameter",
+//t    "doc_parameter : opt_parameter_modifier parameter_type",
+//t  };
+//t public static string getRule (int index) {
+//t    return yyRule [index];
+//t }
+//t}
+  protected static readonly string [] yyNames = {    
+    "end-of-file",null,null,null,null,null,null,null,null,null,null,null,
+    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
+    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
+    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
+    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
+    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
+    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
+    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
+    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
+    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
+    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
+    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
+    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
+    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
+    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
+    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
+    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
+    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
+    null,null,null,null,null,null,null,"EOF","NONE","ERROR",
+    "FIRST_KEYWORD","ABSTRACT","AS","ADD","SUPER","BOOL","BOOLEAN",
+    "BREAK","BYTE","CASE","CATCH","CHAR","CHECKED","CLASS","CONST",
+    "CONTINUE","DECIMAL","DEFAULT","DELEGATE","DELETE","DO","DOUBLE",
+    "DOUBLE2","DOUBLE3","DOUBLE4","DYNAMIC","EACH","ELSE","ENUM","EVENT",
+    "EXPLICIT","EXTENDS","FALSE","FINAL","FINALLY","FIXED","FLOAT",
+    "FLOAT2","FLOAT3","FLOAT4","FOR","FOR_EACH","FUNCTION","FUNCTION_GET",
+    "FUNCTION_SET","GOTO","IF","IMPLICIT","IMPLEMENTS","IMPORT","IN",
+    "INDEXER","INSTANCEOF","INT","INTERFACE","INTERNAL","IS","LOCK",
+    "LONG","NAMESPACE","NATIVE","NEW","NULL","OBJECT","OPERATOR","OUT",
+    "OVERRIDE","OVERLOAD","PACKAGE","PARAMS","PRIVATE","PROPERTY",
+    "PROTECTED","PUBLIC","READONLY","REF","RETURN","REMOVE","SBYTE",
+    "SHORT","SIZEOF","STACKALLOC","STATIC","STRING","STRUCT","SWITCH",
+    "THIS","THROW","TRUE","TRY","TYPEOF","UINT","ULONG","UNCHECKED",
+    "UNDEFINED","UNSAFE","USE","USHORT","USING","VAR","VIRTUAL","VOID",
+    "VOLATILE","WHERE","WHILE","PARTIAL","ARROW","FROM","FROM_FIRST",
+    "JOIN","ON","EQUALS","SELECT","GROUP","BY","LET","ORDERBY",
+    "ASCENDING","DESCENDING","INTO","INTERR_NULLABLE","EXTERN","ASYNC",
+    "AWAIT","GET","SET","LAST_KEYWORD","OPEN_BRACE","CLOSE_BRACE",
+    "OPEN_BRACKET","CLOSE_BRACKET","OPEN_PARENS","CLOSE_PARENS","DOT",
+    "DOT_AT","DOT_STAR","DOTDOT","DOTDOT_AT","DOTDOT_STAR","DOTDOTDOT",
+    "DOT_OPEN_PARENS","CLOSE_PARENS_DOT","COMMA","COLON","SEMICOLON",
+    "TILDE","PLUS","MINUS","BANG","ASSIGN","OP_LT","OP_GT","BITWISE_AND",
+    "BITWISE_OR","LOGICAL_AND_ASSIGN","LOGICAL_OR_ASSIGN","STAR",
+    "PERCENT","DIV","CARRET","INTERR","DOUBLE_COLON","OP_INC","OP_DEC",
+    "OP_SHIFT_LEFT","OP_SHIFT_RIGHT","OP_USHIFT_RIGHT","OP_LE","OP_GE",
+    "OP_EQ","OP_REF_EQ","OP_NE","OP_REF_NE","OP_AND","OP_OR",
+    "OP_MULT_ASSIGN","OP_DIV_ASSIGN","OP_MOD_ASSIGN","OP_ADD_ASSIGN",
+    "OP_SUB_ASSIGN","OP_SHIFT_LEFT_ASSIGN","OP_SHIFT_RIGHT_ASSIGN",
+    "OP_USHIFT_RIGHT_ASSIGN","OP_AND_ASSIGN","OP_XOR_ASSIGN",
+    "OP_OR_ASSIGN","OP_PTR","OP_COALESCING","OP_IN","OP_AT",
+    "OP_GENERICS_LT","OP_GENERICS_LT_DECL","OP_GENERICS_GT","LITERAL",
+    "IDENTIFIER","IDENTIFIER_MODIFIER","IDENTIFIER_CONFIG",
+    "OPEN_PARENS_LAMBDA","OPEN_PARENS_CAST","GENERIC_DIMENSION",
+    "DEFAULT_COLON","OPEN_BRACKET_EXPR","OPEN_BRACE_INIT",
+    "EVAL_STATEMENT_PARSER","EVAL_COMPILATION_UNIT_PARSER",
+    "EVAL_USING_DECLARATIONS_UNIT_PARSER","DOC_SEE","GENERATE_COMPLETION",
+    "COMPLETE_COMPLETION","UMINUS",
+  };
+
+  /** index-checked interface to yyNames[].
+      @param token single character or %token value.
+      @return token name or [illegal] or [unknown].
+    */
+//t  public static string yyname (int token) {
+//t    if ((token < 0) || (token > yyNames.Length)) return "[illegal]";
+//t    string name;
+//t    if ((name = yyNames[token]) != null) return name;
+//t    return "[unknown]";
+//t  }
+
+#pragma warning disable 414
+  int yyExpectingState;
+#pragma warning restore 414
+  /** computes list of expected tokens on error by tracing the tables.
+      @param state for which to compute the list.
+      @return list of token names.
+    */
+  protected int [] yyExpectingTokens (int state){
+    int token, n, len = 0;
+    bool[] ok = new bool[yyNames.Length];
+    if ((n = yySindex[state]) != 0)
+      for (token = n < 0 ? -n : 0;
+           (token < yyNames.Length) && (n+token < yyTable.Length); ++ token)
+        if (yyCheck[n+token] == token && !ok[token] && yyNames[token] != null) {
+          ++ len;
+          ok[token] = true;
+        }
+    if ((n = yyRindex[state]) != 0)
+      for (token = n < 0 ? -n : 0;
+           (token < yyNames.Length) && (n+token < yyTable.Length); ++ token)
+        if (yyCheck[n+token] == token && !ok[token] && yyNames[token] != null) {
+          ++ len;
+          ok[token] = true;
+        }
+    int [] result = new int [len];
+    for (n = token = 0; n < len;  ++ token)
+      if (ok[token]) result[n++] = token;
+    return result;
+  }
+  protected string[] yyExpecting (int state) {
+    int [] tokens = yyExpectingTokens (state);
+    string [] result = new string[tokens.Length];
+    for (int n = 0; n < tokens.Length;  n++)
+      result[n++] = yyNames[tokens [n]];
+    return result;
+  }
+
+  /** the generated parser, with debugging messages.
+      Maintains a state and a value stack, currently with fixed maximum size.
+      @param yyLex scanner.
+      @param yydebug debug message writer implementing yyDebug, or null.
+      @return result of the last reduction, if any.
+      @throws yyException on irrecoverable parse error.
+    */
+  internal Object yyparse (yyParser.yyInput yyLex, Object yyd)
+				 {
+//t    this.debug = (yydebug.yyDebug)yyd;
+    return yyparse(yyLex);
+  }
+
+  /** initial size and increment of the state/value stack [default 256].
+      This is not final so that it can be overwritten outside of invocations
+      of yyparse().
+    */
+  protected int yyMax;
+
+  /** executed at the beginning of a reduce action.
+      Used as $$ = yyDefault($1), prior to the user-specified action, if any.
+      Can be overwritten to provide deep copy, etc.
+      @param first value for $1, or null.
+      @return first.
+    */
+  protected Object yyDefault (Object first) {
+    return first;
+  }
+
+	static int[] global_yyStates;
+	static object[] global_yyVals;
+#pragma warning disable 649
+	protected bool use_global_stacks;
+#pragma warning restore 649
+	object[] yyVals;					// value stack
+	object yyVal;						// value stack ptr
+	int yyToken;						// current input
+	int yyTop;
+
+  /** the generated parser.
+      Maintains a state and a value stack, currently with fixed maximum size.
+      @param yyLex scanner.
+      @return result of the last reduction, if any.
+      @throws yyException on irrecoverable parse error.
+    */
+  internal Object yyparse (yyParser.yyInput yyLex)
+  {
+    if (yyMax <= 0) yyMax = 256;		// initial size
+    int yyState = 0;                   // state stack ptr
+    int [] yyStates;               	// state stack 
+    yyVal = null;
+    yyToken = -1;
+    int yyErrorFlag = 0;				// #tks to shift
+	if (use_global_stacks && global_yyStates != null) {
+		yyVals = global_yyVals;
+		yyStates = global_yyStates;
+   } else {
+		yyVals = new object [yyMax];
+		yyStates = new int [yyMax];
+		if (use_global_stacks) {
+			global_yyVals = yyVals;
+			global_yyStates = yyStates;
+		}
+	}
+
+    /*yyLoop:*/ for (yyTop = 0;; ++ yyTop) {
+      if (yyTop >= yyStates.Length) {			// dynamically increase
+        global::System.Array.Resize (ref yyStates, yyStates.Length+yyMax);
+        global::System.Array.Resize (ref yyVals, yyVals.Length+yyMax);
+      }
+      yyStates[yyTop] = yyState;
+      yyVals[yyTop] = yyVal;
+//t      if (debug != null) debug.push(yyState, yyVal);
+
+      /*yyDiscarded:*/ while (true) {	// discarding a token does not change stack
+        int yyN;
+        if ((yyN = yyDefRed[yyState]) == 0) {	// else [default] reduce (yyN)
+          if (yyToken < 0) {
+            yyToken = yyLex.advance() ? yyLex.token() : 0;
+//t            if (debug != null)
+//t              debug.lex(yyState, yyToken, yyname(yyToken), yyLex.value());
+          }
+          if ((yyN = yySindex[yyState]) != 0 && ((yyN += yyToken) >= 0)
+              && (yyN < yyTable.Length) && (yyCheck[yyN] == yyToken)) {
+//t            if (debug != null)
+//t              debug.shift(yyState, yyTable[yyN], yyErrorFlag-1);
+            yyState = yyTable[yyN];		// shift to yyN
+            yyVal = yyLex.value();
+            yyToken = -1;
+            if (yyErrorFlag > 0) -- yyErrorFlag;
+            goto continue_yyLoop;
+          }
+          if ((yyN = yyRindex[yyState]) != 0 && (yyN += yyToken) >= 0
+              && yyN < yyTable.Length && yyCheck[yyN] == yyToken)
+            yyN = yyTable[yyN];			// reduce (yyN)
+          else
+            switch (yyErrorFlag) {
+  
+            case 0:
+              yyExpectingState = yyState;
+              // yyerror(String.Format ("syntax error, got token `{0}'", yyname (yyToken)), yyExpecting(yyState));
+//t              if (debug != null) debug.error("syntax error");
+              if (yyToken == 0 /*eof*/ || yyToken == eof_token) throw new yyParser.yyUnexpectedEof ();
+              goto case 1;
+            case 1: case 2:
+              yyErrorFlag = 3;
+              do {
+                if ((yyN = yySindex[yyStates[yyTop]]) != 0
+                    && (yyN += Token.yyErrorCode) >= 0 && yyN < yyTable.Length
+                    && yyCheck[yyN] == Token.yyErrorCode) {
+//t                  if (debug != null)
+//t                    debug.shift(yyStates[yyTop], yyTable[yyN], 3);
+                  yyState = yyTable[yyN];
+                  yyVal = yyLex.value();
+                  goto continue_yyLoop;
+                }
+//t                if (debug != null) debug.pop(yyStates[yyTop]);
+              } while (-- yyTop >= 0);
+//t              if (debug != null) debug.reject();
+              throw new yyParser.yyException("irrecoverable syntax error");
+  
+            case 3:
+              if (yyToken == 0) {
+//t                if (debug != null) debug.reject();
+                throw new yyParser.yyException("irrecoverable syntax error at end-of-file");
+              }
+//t              if (debug != null)
+//t                debug.discard(yyState, yyToken, yyname(yyToken),
+//t  							yyLex.value());
+              yyToken = -1;
+              goto continue_yyDiscarded;		// leave stack alone
+            }
+        }
+        int yyV = yyTop + 1-yyLen[yyN];
+//t        if (debug != null)
+//t          debug.reduce(yyState, yyStates[yyV-1], yyN, YYRules.getRule (yyN), yyLen[yyN]);
+        yyVal = yyV > yyTop ? null : yyVals[yyV]; // yyVal = yyDefault(yyV > yyTop ? null : yyVals[yyV]);
+        switch (yyN) {
+case 1:
+#line 445 "ps-parser.jay"
+  {
+		Lexer.check_incorrect_doc_comment ();
+	  }
+  break;
+case 2:
+#line 446 "ps-parser.jay"
+  { Lexer.CompleteOnEOF = false; }
+  break;
+case 6:
+  case_6();
+  break;
+case 7:
+#line 465 "ps-parser.jay"
+  {
+		module.AddAttributes ((Attributes) yyVals[0+yyTop], current_namespace);
+	  }
+  break;
+case 8:
+  case_8();
+  break;
+case 13:
+  case_13();
+  break;
+case 14:
+#line 510 "ps-parser.jay"
+  {
+		Error_SyntaxError (yyToken);
+	  }
+  break;
+case 19:
+  case_19();
+  break;
+case 20:
+  case_20();
+  break;
+case 21:
+  case_21();
+  break;
+case 22:
+  case_22();
+  break;
+case 25:
+  case_25();
+  break;
+case 27:
+  case_27();
+  break;
+case 28:
+#line 575 "ps-parser.jay"
+  {
+	    Lexer.AllowAutoSemiAfterToken(Token.DOT_STAR, true);
+	  }
+  break;
+case 29:
+  case_29();
+  break;
+case 30:
+  case_30();
+  break;
+case 31:
+  case_31();
+  break;
+case 32:
+  case_32();
+  break;
+case 33:
+#line 627 "ps-parser.jay"
+  {
+	  	Lexer.AutoSemiInsertion = false;
+	  }
+  break;
+case 34:
+  case_34();
+  break;
+case 35:
+  case_35();
+  break;
+case 36:
+  case_36();
+  break;
+case 37:
+  case_37();
+  break;
+case 40:
+  case_40();
+  break;
+case 41:
+  case_41();
+  break;
+case 42:
+  case_42();
+  break;
+case 59:
+  case_59();
+  break;
+case 60:
+  case_60();
+  break;
+case 61:
+  case_61();
+  break;
+case 63:
+  case_63();
+  break;
+case 64:
+  case_64();
+  break;
+case 65:
+  case_65();
+  break;
+case 66:
+  case_66();
+  break;
+case 75:
+  case_75();
+  break;
+case 76:
+  case_76();
+  break;
+case 77:
+#line 888 "ps-parser.jay"
+  {
+		lexer.parsing_attribute_section = true;
+	  }
+  break;
+case 78:
+  case_78();
+  break;
+case 79:
+  case_79();
+  break;
+case 80:
+  case_80();
+  break;
+case 81:
+  case_81();
+  break;
+case 82:
+  case_82();
+  break;
+case 83:
+#line 929 "ps-parser.jay"
+  { yyVal = "event"; }
+  break;
+case 84:
+#line 930 "ps-parser.jay"
+  { yyVal = "return"; }
+  break;
+case 85:
+  case_85();
+  break;
+case 86:
+#line 947 "ps-parser.jay"
+  {
+		yyVal = new List<Attribute> (4) { (Attribute) yyVals[0+yyTop] };
+	  }
+  break;
+case 87:
+  case_87();
+  break;
+case 88:
+#line 961 "ps-parser.jay"
+  {
+		++lexer.parsing_block;
+	  }
+  break;
+case 89:
+  case_89();
+  break;
+case 91:
+#line 980 "ps-parser.jay"
+  { yyVal = null; }
+  break;
+case 92:
+  case_92();
+  break;
+case 93:
+#line 990 "ps-parser.jay"
+  { yyVal = null; }
+  break;
+case 94:
+  case_94();
+  break;
+case 95:
+  case_95();
+  break;
+case 96:
+  case_96();
+  break;
+case 97:
+  case_97();
+  break;
+case 98:
+#line 1032 "ps-parser.jay"
+  {
+	  	yyVal = new Argument ((Expression) yyVals[0+yyTop]);
+	  }
+  break;
+case 100:
+#line 1040 "ps-parser.jay"
+  {
+		++lexer.parsing_block;
+	  }
+  break;
+case 101:
+  case_101();
+  break;
+case 102:
+  case_102();
+  break;
+case 103:
+#line 1066 "ps-parser.jay"
+  { yyVal = null; }
+  break;
+case 104:
+  case_104();
+  break;
+case 105:
+  case_105();
+  break;
+case 108:
+#line 1088 "ps-parser.jay"
+  {
+		lexer.parsing_modifiers = true;
+	  }
+  break;
+case 109:
+#line 1092 "ps-parser.jay"
+  {
+		lexer.parsing_modifiers = true;
+	  }
+  break;
+case 124:
+  case_124();
+  break;
+case 125:
+  case_125();
+  break;
+case 126:
+  case_126();
+  break;
+case 127:
+  case_127();
+  break;
+case 128:
+  case_128();
+  break;
+case 129:
+  case_129();
+  break;
+case 130:
+  case_130();
+  break;
+case 131:
+#line 1176 "ps-parser.jay"
+  {
+		lexer.AutoSemiInsertion = false;
+	  }
+  break;
+case 132:
+  case_132();
+  break;
+case 133:
+  case_133();
+  break;
+case 134:
+  case_134();
+  break;
+case 135:
+  case_135();
+  break;
+case 136:
+  case_136();
+  break;
+case 137:
+#line 1225 "ps-parser.jay"
+  {
+		Error_SyntaxError (yyToken);
+	  }
+  break;
+case 138:
+  case_138();
+  break;
+case 139:
+  case_139();
+  break;
+case 142:
+#line 1266 "ps-parser.jay"
+  {
+		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
+	  }
+  break;
+case 143:
+#line 1270 "ps-parser.jay"
+  {
+		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
+	  }
+  break;
+case 144:
+  case_144();
+  break;
+case 145:
+#line 1283 "ps-parser.jay"
+  { yyVal = null; }
+  break;
+case 147:
+#line 1291 "ps-parser.jay"
+  {
+		++lexer.parsing_block;
+	  }
+  break;
+case 148:
+  case_148();
+  break;
+case 149:
+  case_149();
+  break;
+case 151:
+  case_151();
+  break;
+case 152:
+  case_152();
+  break;
+case 153:
+  case_153();
+  break;
+case 154:
+  case_154();
+  break;
+case 155:
+#line 1374 "ps-parser.jay"
+  {
+		report.Error (1641, GetLocation (yyVals[0+yyTop]), "A fixed size buffer field must have the array size specifier after the field name");
+	  }
+  break;
+case 157:
+  case_157();
+  break;
+case 158:
+  case_158();
+  break;
+case 161:
+#line 1403 "ps-parser.jay"
+  {
+		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
+	  }
+  break;
+case 162:
+#line 1407 "ps-parser.jay"
+  {
+		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
+	  }
+  break;
+case 163:
+  case_163();
+  break;
+case 164:
+#line 1420 "ps-parser.jay"
+  {
+		++lexer.parsing_block;
+	  }
+  break;
+case 165:
+  case_165();
+  break;
+case 168:
+#line 1439 "ps-parser.jay"
+  {
+		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
+	  }
+  break;
+case 169:
+#line 1443 "ps-parser.jay"
+  {
+		current_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
+	  }
+  break;
+case 170:
+  case_170();
+  break;
+case 171:
+#line 1459 "ps-parser.jay"
+  {
+		++lexer.parsing_block;
+	  }
+  break;
+case 172:
+  case_172();
+  break;
+case 173:
+  case_173();
+  break;
+case 175:
+  case_175();
+  break;
+case 176:
+  case_176();
+  break;
+case 177:
+  case_177();
+  break;
+case 178:
+  case_178();
+  break;
+case 179:
+#line 1603 "ps-parser.jay"
+  {
+		lexer.ConstraintsParsing = true;
+	  }
+  break;
+case 180:
+  case_180();
+  break;
+case 181:
+#line 1672 "ps-parser.jay"
+  {
+		valid_param_mod = ParameterModifierType.All;
+	  }
+  break;
+case 182:
+  case_182();
+  break;
+case 183:
+#line 1733 "ps-parser.jay"
+  {
+		valid_param_mod = ParameterModifierType.All;
+	  }
+  break;
+case 184:
+  case_184();
+  break;
+case 185:
+#line 1801 "ps-parser.jay"
+  {
+		lexer.parsing_generic_declaration = true;
+	  }
+  break;
+case 186:
+  case_186();
+  break;
+case 187:
+#line 1811 "ps-parser.jay"
+  {
+		lexer.ConstraintsParsing = true;
+	  }
+  break;
+case 188:
+  case_188();
+  break;
+case 189:
+  case_189();
+  break;
+case 190:
+  case_190();
+  break;
+case 192:
+#line 1882 "ps-parser.jay"
+  {
+		yyVal = yyVals[0+yyTop];
+	  }
+  break;
+case 193:
+  case_193();
+  break;
+case 195:
+  case_195();
+  break;
+case 196:
+#line 1904 "ps-parser.jay"
+  { yyVal = ParametersCompiled.EmptyReadOnlyParameters; }
+  break;
+case 198:
+  case_198();
+  break;
+case 199:
+  case_199();
+  break;
+case 200:
+  case_200();
+  break;
+case 201:
+  case_201();
+  break;
+case 202:
+#line 1976 "ps-parser.jay"
+  {
+		yyVal = new ParametersCompiled (new Parameter[] { (Parameter) yyVals[0+yyTop] } );
+	  }
+  break;
+case 203:
+  case_203();
+  break;
+case 204:
+  case_204();
+  break;
+case 205:
+  case_205();
+  break;
+case 206:
+  case_206();
+  break;
+case 207:
+  case_207();
+  break;
+case 208:
+  case_208();
+  break;
+case 209:
+#line 2055 "ps-parser.jay"
+  {
+	  	++lexer.parsing_block;
+	  }
+  break;
+case 210:
+  case_210();
+  break;
+case 211:
+#line 2096 "ps-parser.jay"
+  { yyVal = Parameter.Modifier.NONE; }
+  break;
+case 213:
+#line 2104 "ps-parser.jay"
+  {
+		yyVal = yyVals[0+yyTop];
+	  }
+  break;
+case 214:
+  case_214();
+  break;
+case 215:
+  case_215();
+  break;
+case 216:
+  case_216();
+  break;
+case 217:
+  case_217();
+  break;
+case 218:
+  case_218();
+  break;
+case 219:
+  case_219();
+  break;
+case 220:
+  case_220();
+  break;
+case 221:
+  case_221();
+  break;
+case 222:
+  case_222();
+  break;
+case 223:
+  case_223();
+  break;
+case 224:
+  case_224();
+  break;
+case 225:
+#line 2270 "ps-parser.jay"
+  {
+	  	valid_param_mod = ParameterModifierType.Params | ParameterModifierType.DefaultValue;
+	  }
+  break;
+case 226:
+  case_226();
+  break;
+case 227:
+#line 2311 "ps-parser.jay"
+  {
+		lexer.PropertyParsing = false;
+	  }
+  break;
+case 228:
+  case_228();
+  break;
+case 233:
+  case_233();
+  break;
+case 234:
+  case_234();
+  break;
+case 235:
+  case_235();
+  break;
+case 236:
+  case_236();
+  break;
+case 237:
+  case_237();
+  break;
+case 239:
+  case_239();
+  break;
+case 240:
+  case_240();
+  break;
+case 241:
+#line 2463 "ps-parser.jay"
+  {
+	    Lexer.AutoSemiInsertion = false;
+	  }
+  break;
+case 242:
+  case_242();
+  break;
+case 243:
+  case_243();
+  break;
+case 244:
+#line 2490 "ps-parser.jay"
+  {
+	    Lexer.AutoSemiInsertion = true;
+	  }
+  break;
+case 245:
+  case_245();
+  break;
+case 246:
+  case_246();
+  break;
+case 247:
+#line 2505 "ps-parser.jay"
+  {
+		Error_SyntaxError (yyToken);	  
+	  }
+  break;
+case 250:
+#line 2517 "ps-parser.jay"
+  {
+		lexer.parsing_modifiers = true;
+	  }
+  break;
+case 251:
+#line 2521 "ps-parser.jay"
+  {
+		lexer.parsing_modifiers = true;
+	  }
+  break;
+case 252:
+#line 2528 "ps-parser.jay"
+  {
+		report.Error (525, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain fields or constants");
+	  }
+  break;
+case 253:
+#line 2532 "ps-parser.jay"
+  {
+		report.Error (525, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain fields or constants");
+	  }
+  break;
+case 258:
+#line 2540 "ps-parser.jay"
+  {
+	  	report.Error (567, GetLocation (yyVals[0+yyTop]), "Interfaces cannot contain operators");
+	  }
+  break;
+case 259:
+#line 2548 "ps-parser.jay"
+  {
+	  	report.Error (524, GetLocation (yyVals[0+yyTop]), "Interfaces cannot declare classes, structs, interfaces, delegates, or enumerations");
+	  }
+  break;
+case 260:
+#line 2554 "ps-parser.jay"
+  {
+	  }
+  break;
+case 261:
+  case_261();
+  break;
+case 263:
+#line 2603 "ps-parser.jay"
+  { savedLocation = GetLocation (yyVals[0+yyTop]); yyVal = null; }
+  break;
+case 265:
+  case_265();
+  break;
+case 266:
+#line 2619 "ps-parser.jay"
+  {
+		valid_param_mod = ParameterModifierType.DefaultValue;
+	  }
+  break;
+case 267:
+  case_267();
+  break;
+case 269:
+#line 2667 "ps-parser.jay"
+  { yyVal = Operator.OpType.LogicalNot; }
+  break;
+case 270:
+#line 2668 "ps-parser.jay"
+  { yyVal = Operator.OpType.OnesComplement; }
+  break;
+case 271:
+#line 2669 "ps-parser.jay"
+  { yyVal = Operator.OpType.Increment; }
+  break;
+case 272:
+#line 2670 "ps-parser.jay"
+  { yyVal = Operator.OpType.Decrement; }
+  break;
+case 273:
+#line 2671 "ps-parser.jay"
+  { yyVal = Operator.OpType.True; }
+  break;
+case 274:
+#line 2672 "ps-parser.jay"
+  { yyVal = Operator.OpType.False; }
+  break;
+case 275:
+#line 2674 "ps-parser.jay"
+  { yyVal = Operator.OpType.Addition; }
+  break;
+case 276:
+#line 2675 "ps-parser.jay"
+  { yyVal = Operator.OpType.Subtraction; }
+  break;
+case 277:
+#line 2677 "ps-parser.jay"
+  { yyVal = Operator.OpType.Multiply; }
+  break;
+case 278:
+#line 2678 "ps-parser.jay"
+  {  yyVal = Operator.OpType.Division; }
+  break;
+case 279:
+#line 2679 "ps-parser.jay"
+  { yyVal = Operator.OpType.Modulus; }
+  break;
+case 280:
+#line 2680 "ps-parser.jay"
+  { yyVal = Operator.OpType.BitwiseAnd; }
+  break;
+case 281:
+#line 2681 "ps-parser.jay"
+  { yyVal = Operator.OpType.BitwiseOr; }
+  break;
+case 282:
+#line 2682 "ps-parser.jay"
+  { yyVal = Operator.OpType.ExclusiveOr; }
+  break;
+case 283:
+#line 2683 "ps-parser.jay"
+  { yyVal = Operator.OpType.LeftShift; }
+  break;
+case 284:
+#line 2684 "ps-parser.jay"
+  { yyVal = Operator.OpType.RightShift; }
+  break;
+case 285:
+#line 2685 "ps-parser.jay"
+  { yyVal = Operator.OpType.AsURightShift; }
+  break;
+case 286:
+#line 2686 "ps-parser.jay"
+  { yyVal = Operator.OpType.Equality; }
+  break;
+case 287:
+#line 2687 "ps-parser.jay"
+  { yyVal = Operator.OpType.Inequality; }
+  break;
+case 288:
+#line 2688 "ps-parser.jay"
+  { yyVal = Operator.OpType.GreaterThan; }
+  break;
+case 289:
+#line 2689 "ps-parser.jay"
+  { yyVal = Operator.OpType.LessThan; }
+  break;
+case 290:
+#line 2690 "ps-parser.jay"
+  { yyVal = Operator.OpType.GreaterThanOrEqual; }
+  break;
+case 291:
+#line 2691 "ps-parser.jay"
+  { yyVal = Operator.OpType.LessThanOrEqual; }
+  break;
+case 292:
+#line 2692 "ps-parser.jay"
+  { yyVal = Operator.OpType.AsIn; }
+  break;
+case 293:
+#line 2699 "ps-parser.jay"
+  {
+		valid_param_mod = ParameterModifierType.DefaultValue;
+	  }
+  break;
+case 294:
+  case_294();
+  break;
+case 295:
+#line 2718 "ps-parser.jay"
+  {
+		valid_param_mod = ParameterModifierType.DefaultValue;
+	  }
+  break;
+case 296:
+  case_296();
+  break;
+case 297:
+  case_297();
+  break;
+case 298:
+  case_298();
+  break;
+case 299:
+  case_299();
+  break;
+case 300:
+  case_300();
+  break;
+case 301:
+  case_301();
+  break;
+case 302:
+  case_302();
+  break;
+case 303:
+  case_303();
+  break;
+case 304:
+  case_304();
+  break;
+case 305:
+  case_305();
+  break;
+case 307:
+#line 2985 "ps-parser.jay"
+  {
+	  	++lexer.parsing_block;
+	  }
+  break;
+case 308:
+  case_308();
+  break;
+case 311:
+#line 3002 "ps-parser.jay"
+  {
+		current_event_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
+	  }
+  break;
+case 312:
+#line 3006 "ps-parser.jay"
+  {
+		current_event_field.AddDeclarator ((FieldDeclarator) yyVals[0+yyTop]);
+	  }
+  break;
+case 313:
+  case_313();
+  break;
+case 314:
+#line 3019 "ps-parser.jay"
+  {
+		++lexer.parsing_block;
+	  }
+  break;
+case 315:
+  case_315();
+  break;
+case 316:
+  case_316();
+  break;
+case 317:
+#line 3044 "ps-parser.jay"
+  {
+		yyVal = yyVals[0+yyTop];
+	  }
+  break;
+case 320:
+  case_320();
+  break;
+case 321:
+  case_321();
+  break;
+case 322:
+  case_322();
+  break;
+case 323:
+  case_323();
+  break;
+case 324:
+  case_324();
+  break;
+case 325:
+  case_325();
+  break;
+case 326:
+  case_326();
+  break;
+case 327:
+  case_327();
+  break;
+case 329:
+  case_329();
+  break;
+case 330:
+  case_330();
+  break;
+case 331:
+  case_331();
+  break;
+case 332:
+  case_332();
+  break;
+case 333:
+  case_333();
+  break;
+case 335:
+  case_335();
+  break;
+case 336:
+  case_336();
+  break;
+case 339:
+#line 3208 "ps-parser.jay"
+  {
+	  	lbag.AddLocation (yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
+	  }
+  break;
+case 341:
+  case_341();
+  break;
+case 342:
+  case_342();
+  break;
+case 343:
+  case_343();
+  break;
+case 344:
+  case_344();
+  break;
+case 345:
+  case_345();
+  break;
+case 347:
+#line 3282 "ps-parser.jay"
+  {
+		valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out | ParameterModifierType.Params | ParameterModifierType.DefaultValue;
+	  }
+  break;
+case 348:
+  case_348();
+  break;
+case 349:
+#line 3301 "ps-parser.jay"
+  {
+		lexer.ConstraintsParsing = false;
+	  }
+  break;
+case 350:
+  case_350();
+  break;
+case 351:
+  case_351();
+  break;
+case 354:
+  case_354();
+  break;
+case 356:
+  case_356();
+  break;
+case 359:
+  case_359();
+  break;
+case 360:
+  case_360();
+  break;
+case 362:
+  case_362();
+  break;
+case 363:
+  case_363();
+  break;
+case 364:
+  case_364();
+  break;
+case 365:
+  case_365();
+  break;
+case 366:
+#line 3437 "ps-parser.jay"
+  {
+		lexer.parsing_generic_declaration = true;
+	  }
+  break;
+case 367:
+  case_367();
+  break;
+case 368:
+  case_368();
+  break;
+case 370:
+  case_370();
+  break;
+case 371:
+  case_371();
+  break;
+case 372:
+  case_372();
+  break;
+case 373:
+  case_373();
+  break;
+case 374:
+  case_374();
+  break;
+case 376:
+  case_376();
+  break;
+case 377:
+  case_377();
+  break;
+case 378:
+  case_378();
+  break;
+case 379:
+  case_379();
+  break;
+case 380:
+  case_380();
+  break;
+case 382:
+#line 3555 "ps-parser.jay"
+  {
+		yyVal = new TypeExpression (compiler.BuiltinTypes.Void, GetLocation (yyVals[0+yyTop]));
+	  }
+  break;
+case 383:
+#line 3562 "ps-parser.jay"
+  {
+		lexer.parsing_generic_declaration = true;
+	  }
+  break;
+case 385:
+  case_385();
+  break;
+case 387:
+  case_387();
+  break;
+case 389:
+  case_389();
+  break;
+case 391:
+  case_391();
+  break;
+case 392:
+  case_392();
+  break;
+case 393:
+#line 3620 "ps-parser.jay"
+  {
+	  	yyVal = new TypeExpression (compiler.BuiltinTypes.Dynamic, GetLocation (yyVals[0+yyTop]));
+	  }
+  break;
+case 394:
+  case_394();
+  break;
+case 395:
+  case_395();
+  break;
+case 396:
+  case_396();
+  break;
+case 397:
+  case_397();
+  break;
+case 398:
+#line 3673 "ps-parser.jay"
+  { CheckIsPlayScript("decimal", GetLocation(yyVals[0+yyTop])); yyVal = new TypeExpression (compiler.BuiltinTypes.Decimal, GetLocation (yyVals[0+yyTop])); }
+  break;
+case 399:
+#line 3674 "ps-parser.jay"
+  { CheckIsPlayScript("float", GetLocation(yyVals[0+yyTop])); yyVal = new TypeExpression (compiler.BuiltinTypes.Float, GetLocation (yyVals[0+yyTop])); }
+  break;
+case 400:
+#line 3678 "ps-parser.jay"
+  { CheckIsPlayScript("double", GetLocation(yyVals[0+yyTop])); yyVal = new TypeExpression (compiler.BuiltinTypes.Double, GetLocation (yyVals[0+yyTop])); }
+  break;
+case 402:
+#line 3686 "ps-parser.jay"
+  { CheckIsPlayScript("sbyte", GetLocation(yyVals[0+yyTop])); yyVal = new TypeExpression (compiler.BuiltinTypes.SByte, GetLocation (yyVals[0+yyTop])); }
+  break;
+case 403:
+#line 3687 "ps-parser.jay"
+  { CheckIsPlayScript("byte", GetLocation(yyVals[0+yyTop])); yyVal = new TypeExpression (compiler.BuiltinTypes.Byte, GetLocation (yyVals[0+yyTop])); }
+  break;
+case 404:
+#line 3688 "ps-parser.jay"
+  { CheckIsPlayScript("short", GetLocation(yyVals[0+yyTop])); yyVal = new TypeExpression (compiler.BuiltinTypes.Short, GetLocation (yyVals[0+yyTop])); }
+  break;
+case 405:
+#line 3689 "ps-parser.jay"
+  { CheckIsPlayScript("ushort", GetLocation(yyVals[0+yyTop])); yyVal = new TypeExpression (compiler.BuiltinTypes.UShort, GetLocation (yyVals[0+yyTop])); }
+  break;
+case 406:
+#line 3690 "ps-parser.jay"
+  { yyVal = new TypeExpression (compiler.BuiltinTypes.Int, GetLocation (yyVals[0+yyTop])); }
+  break;
+case 407:
+#line 3691 "ps-parser.jay"
+  { yyVal = new TypeExpression (compiler.BuiltinTypes.UInt, GetLocation (yyVals[0+yyTop])); }
+  break;
+case 408:
+#line 3692 "ps-parser.jay"
+  { CheckIsPlayScript("long", GetLocation(yyVals[0+yyTop])); yyVal = new TypeExpression (compiler.BuiltinTypes.Long, GetLocation (yyVals[0+yyTop])); }
+  break;
+case 409:
+#line 3693 "ps-parser.jay"
+  { CheckIsPlayScript("ulong", GetLocation(yyVals[0+yyTop])); yyVal = new TypeExpression (compiler.BuiltinTypes.ULong, GetLocation (yyVals[0+yyTop])); }
+  break;
+case 410:
+#line 3694 "ps-parser.jay"
+  { CheckIsPlayScript("char", GetLocation(yyVals[0+yyTop])); yyVal = new TypeExpression (compiler.BuiltinTypes.Char, GetLocation (yyVals[0+yyTop])); }
+  break;
+case 428:
+  case_428();
+  break;
+case 429:
+  case_429();
+  break;
+case 433:
+#line 3745 "ps-parser.jay"
+  { yyVal = new AsUndefinedLiteral (GetLocation (yyVals[0+yyTop])); }
+  break;
+case 434:
+#line 3746 "ps-parser.jay"
+  { yyVal = new NullLiteral (GetLocation (yyVals[0+yyTop])); }
+  break;
+case 435:
+#line 3750 "ps-parser.jay"
+  { yyVal = new BoolLiteral (compiler.BuiltinTypes, true, GetLocation (yyVals[0+yyTop])); }
+  break;
+case 436:
+#line 3751 "ps-parser.jay"
+  { yyVal = new BoolLiteral (compiler.BuiltinTypes, false, GetLocation (yyVals[0+yyTop])); }
+  break;
+case 441:
+  case_441();
+  break;
+case 442:
+#line 3784 "ps-parser.jay"
+  {
+		yyVal = new ParenthesizedExpression ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
+	  }
+  break;
+case 443:
+  case_443();
+  break;
+case 444:
+  case_444();
+  break;
+case 445:
+  case_445();
+  break;
+case 446:
+  case_446();
+  break;
+case 447:
+  case_447();
+  break;
+case 448:
+  case_448();
+  break;
+case 449:
+  case_449();
+  break;
+case 450:
+  case_450();
+  break;
+case 451:
+  case_451();
+  break;
+case 452:
+  case_452();
+  break;
+case 453:
+  case_453();
+  break;
+case 454:
+#line 3877 "ps-parser.jay"
+  {
+		yyVal = new CompletionMemberAccess ((Expression) yyVals[-2+yyTop], null,GetLocation (yyVals[0+yyTop]));
+	  }
+  break;
+case 455:
+  case_455();
+  break;
+case 456:
+#line 3885 "ps-parser.jay"
+  {
+		yyVal = new CompletionMemberAccess ((Expression) yyVals[-2+yyTop], null, lexer.Location);
+	  }
+  break;
+case 457:
+  case_457();
+  break;
+case 458:
+  case_458();
+  break;
+case 459:
+  case_459();
+  break;
+case 460:
+  case_460();
+  break;
+case 461:
+  case_461();
+  break;
+case 462:
+  case_462();
+  break;
+case 463:
+  case_463();
+  break;
+case 464:
+  case_464();
+  break;
+case 465:
+  case_465();
+  break;
+case 466:
+  case_466();
+  break;
+case 468:
+#line 3984 "ps-parser.jay"
+  { yyVal = null; }
+  break;
+case 469:
+#line 3988 "ps-parser.jay"
+  {
+		yyVal = yyVals[0+yyTop];
+	  }
+  break;
+case 470:
+  case_470();
+  break;
+case 471:
+  case_471();
+  break;
+case 472:
+  case_472();
+  break;
+case 473:
+  case_473();
+  break;
+case 474:
+  case_474();
+  break;
+case 475:
+  case_475();
+  break;
+case 476:
+#line 4044 "ps-parser.jay"
+  {
+		yyVal = new CompletionElementInitializer (null, GetLocation (yyVals[0+yyTop]));
+	  }
+  break;
+case 478:
+#line 4071 "ps-parser.jay"
+  { yyVal = null; }
+  break;
+case 480:
+  case_480();
+  break;
+case 481:
+  case_481();
+  break;
+case 482:
+  case_482();
+  break;
+case 483:
+  case_483();
+  break;
+case 484:
+  case_484();
+  break;
+case 485:
+#line 4122 "ps-parser.jay"
+  {
+		yyVal = new Argument ((Expression) yyVals[0+yyTop]);
+	  }
+  break;
+case 489:
+  case_489();
+  break;
+case 490:
+  case_490();
+  break;
+case 492:
+  case_492();
+  break;
+case 493:
+  case_493();
+  break;
+case 494:
+  case_494();
+  break;
+case 495:
+  case_495();
+  break;
+case 496:
+  case_496();
+  break;
+case 497:
+  case_497();
+  break;
+case 498:
+  case_498();
+  break;
+case 499:
+  case_499();
+  break;
+case 500:
+  case_500();
+  break;
+case 501:
+  case_501();
+  break;
+case 502:
+  case_502();
+  break;
+case 503:
+#line 4240 "ps-parser.jay"
+  {
+	  	yyVal = new Argument ((Expression) yyVals[0+yyTop]);
+	  }
+  break;
+case 505:
+#line 4248 "ps-parser.jay"
+  {
+		yyVal = new This (GetLocation (yyVals[0+yyTop]));
+	  }
+  break;
+case 506:
+  case_506();
+  break;
+case 507:
+  case_507();
+  break;
+case 508:
+#line 4268 "ps-parser.jay"
+  {
+		yyVal = new UnaryMutator (UnaryMutator.Mode.PostIncrement, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
+	  }
+  break;
+case 509:
+#line 4275 "ps-parser.jay"
+  {
+		yyVal = new UnaryMutator (UnaryMutator.Mode.PostDecrement, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
+	  }
+  break;
+case 510:
+#line 4339 "ps-parser.jay"
+  {
+		yyVal = new AsNew ((Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
+	  }
+  break;
+case 511:
+#line 4343 "ps-parser.jay"
+  {
+		yyVal = new AsNew ((Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
+	  }
+  break;
+case 512:
+#line 4347 "ps-parser.jay"
+  {
+		yyVal = new AsNew ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
+	  }
+  break;
+case 513:
+  case_513();
+  break;
+case 515:
+  case_515();
+  break;
+case 516:
+  case_516();
+  break;
+case 517:
+  case_517();
+  break;
+case 518:
+#line 4451 "ps-parser.jay"
+  {
+		yyVal = 2;
+	  }
+  break;
+case 519:
+#line 4455 "ps-parser.jay"
+  {
+		yyVal = ((int) yyVals[-1+yyTop]) + 1;
+	  }
+  break;
+case 520:
+  case_520();
+  break;
+case 521:
+  case_521();
+  break;
+case 522:
+  case_522();
+  break;
+case 523:
+  case_523();
+  break;
+case 524:
+#line 4514 "ps-parser.jay"
+  {
+      	Lexer.AutoSemiInsertion = (bool) oob_stack.Pop ();
+ 	  }
+  break;
+case 525:
+  case_525();
+  break;
+case 526:
+  case_526();
+  break;
+case 529:
+  case_529();
+  break;
+case 530:
+  case_530();
+  break;
+case 531:
+  case_531();
+  break;
+case 532:
+  case_532();
+  break;
+case 533:
+  case_533();
+  break;
+case 534:
+  case_534();
+  break;
+case 535:
+  case_535();
+  break;
+case 536:
+  case_536();
+  break;
+case 537:
+  case_537();
+  break;
+case 538:
+  case_538();
+  break;
+case 539:
+  case_539();
+  break;
+case 540:
+  case_540();
+  break;
+case 541:
+#line 4673 "ps-parser.jay"
+  {
+	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
+	  }
+  break;
+case 542:
+  case_542();
+  break;
+case 543:
+#line 4682 "ps-parser.jay"
+  {
+		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
+	  }
+  break;
+case 544:
+#line 4686 "ps-parser.jay"
+  {
+	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
+	  }
+  break;
+case 545:
+  case_545();
+  break;
+case 546:
+#line 4695 "ps-parser.jay"
+  {
+		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
+	  }
+  break;
+case 547:
+#line 4702 "ps-parser.jay"
+  {
+	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
+	  }
+  break;
+case 548:
+  case_548();
+  break;
+case 549:
+  case_549();
+  break;
+case 550:
+#line 4723 "ps-parser.jay"
+  {
+	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
+	  }
+  break;
+case 551:
+  case_551();
+  break;
+case 552:
+  case_552();
+  break;
+case 553:
+  case_553();
+  break;
+case 555:
+#line 4773 "ps-parser.jay"
+  {
+		yyVal = new Unary (Unary.Operator.LogicalNot, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
+	  }
+  break;
+case 556:
+#line 4777 "ps-parser.jay"
+  {
+		yyVal = new Unary (Unary.Operator.OnesComplement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
+	  }
+  break;
+case 557:
+  case_557();
+  break;
+case 558:
+#line 4807 "ps-parser.jay"
+  {
+		yyVal = new Unary (Unary.Operator.AsE4xAttribute, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
+	  }
+  break;
+case 559:
+#line 4811 "ps-parser.jay"
+  {
+	  	yyVal = new AsTypeOf ((Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
+	  }
+  break;
+case 560:
+  case_560();
+  break;
+case 561:
+  case_561();
+  break;
+case 562:
+  case_562();
+  break;
+case 563:
+  case_563();
+  break;
+case 564:
+  case_564();
+  break;
+case 565:
+  case_565();
+  break;
+case 566:
+  case_566();
+  break;
+case 568:
+#line 4875 "ps-parser.jay"
+  { 
+	  	yyVal = new Unary (Unary.Operator.UnaryPlus, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
+	  }
+  break;
+case 569:
+#line 4879 "ps-parser.jay"
+  { 
+		yyVal = new Unary (Unary.Operator.UnaryNegation, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
+	  }
+  break;
+case 570:
+#line 4883 "ps-parser.jay"
+  {
+		yyVal = new UnaryMutator (UnaryMutator.Mode.PreIncrement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
+	  }
+  break;
+case 571:
+#line 4887 "ps-parser.jay"
+  {
+		yyVal = new UnaryMutator (UnaryMutator.Mode.PreDecrement, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
+	  }
+  break;
+case 572:
+#line 4895 "ps-parser.jay"
+  {
+		yyVal = new Unary (Unary.Operator.AddressOf, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
+	  }
+  break;
+case 573:
+  case_573();
+  break;
+case 574:
+  case_574();
+  break;
+case 575:
+  case_575();
+  break;
+case 576:
+  case_576();
+  break;
+case 577:
+  case_577();
+  break;
+case 579:
+  case_579();
+  break;
+case 580:
+  case_580();
+  break;
+case 581:
+  case_581();
+  break;
+case 582:
+  case_582();
+  break;
+case 583:
+  case_583();
+  break;
+case 584:
+  case_584();
+  break;
+case 586:
+  case_586();
+  break;
+case 587:
+  case_587();
+  break;
+case 588:
+#line 4989 "ps-parser.jay"
+  {
+		yyVal = new AsIn ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
+	  }
+  break;
+case 589:
+#line 4993 "ps-parser.jay"
+  {
+		yyVal = new As ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
+	  }
+  break;
+case 590:
+#line 4997 "ps-parser.jay"
+  {
+		yyVal = new Is ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
+	  }
+  break;
+case 591:
+  case_591();
+  break;
+case 592:
+  case_592();
+  break;
+case 593:
+  case_593();
+  break;
+case 594:
+  case_594();
+  break;
+case 595:
+  case_595();
+  break;
+case 597:
+  case_597();
+  break;
+case 598:
+  case_598();
+  break;
+case 599:
+  case_599();
+  break;
+case 600:
+  case_600();
+  break;
+case 601:
+  case_601();
+  break;
+case 602:
+  case_602();
+  break;
+case 604:
+  case_604();
+  break;
+case 605:
+  case_605();
+  break;
+case 606:
+  case_606();
+  break;
+case 607:
+  case_607();
+  break;
+case 608:
+  case_608();
+  break;
+case 609:
+  case_609();
+  break;
+case 610:
+  case_610();
+  break;
+case 611:
+  case_611();
+  break;
+case 613:
+  case_613();
+  break;
+case 614:
+  case_614();
+  break;
+case 615:
+  case_615();
+  break;
+case 616:
+  case_616();
+  break;
+case 618:
+  case_618();
+  break;
+case 619:
+  case_619();
+  break;
+case 621:
+  case_621();
+  break;
+case 622:
+  case_622();
+  break;
+case 624:
+  case_624();
+  break;
+case 625:
+  case_625();
+  break;
+case 627:
+  case_627();
+  break;
+case 628:
+  case_628();
+  break;
+case 630:
+  case_630();
+  break;
+case 631:
+  case_631();
+  break;
+case 633:
+  case_633();
+  break;
+case 635:
+  case_635();
+  break;
+case 636:
+  case_636();
+  break;
+case 637:
+  case_637();
+  break;
+case 638:
+  case_638();
+  break;
+case 639:
+  case_639();
+  break;
+case 640:
+  case_640();
+  break;
+case 641:
+  case_641();
+  break;
+case 642:
+  case_642();
+  break;
+case 643:
+  case_643();
+  break;
+case 644:
+  case_644();
+  break;
+case 645:
+  case_645();
+  break;
+case 646:
+  case_646();
+  break;
+case 647:
+  case_647();
+  break;
+case 648:
+  case_648();
+  break;
+case 649:
+  case_649();
+  break;
+case 650:
+  case_650();
+  break;
+case 651:
+  case_651();
+  break;
+case 652:
+  case_652();
+  break;
+case 653:
+  case_653();
+  break;
+case 654:
+  case_654();
+  break;
+case 655:
+  case_655();
+  break;
+case 656:
+  case_656();
+  break;
+case 657:
+  case_657();
+  break;
+case 658:
+#line 5397 "ps-parser.jay"
+  { yyVal = ParametersCompiled.EmptyReadOnlyParameters; }
+  break;
+case 659:
+  case_659();
+  break;
+case 660:
+#line 5408 "ps-parser.jay"
+  {
+		start_block (Location.Null);
+	  }
+  break;
+case 661:
+  case_661();
+  break;
+case 663:
+  case_663();
+  break;
+case 665:
+  case_665();
+  break;
+case 666:
+  case_666();
+  break;
+case 667:
+  case_667();
+  break;
+case 668:
+  case_668();
+  break;
+case 669:
+  case_669();
+  break;
+case 670:
+  case_670();
+  break;
+case 671:
+  case_671();
+  break;
+case 672:
+#line 5478 "ps-parser.jay"
+  {
+	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
+	  }
+  break;
+case 673:
+  case_673();
+  break;
+case 674:
+  case_674();
+  break;
+case 675:
+#line 5493 "ps-parser.jay"
+  {
+	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;	  
+	  }
+  break;
+case 676:
+  case_676();
+  break;
+case 677:
+  case_677();
+  break;
+case 684:
+#line 5548 "ps-parser.jay"
+  {
+		yyVal = new BooleanExpression ((Expression) yyVals[0+yyTop]);
+	  }
+  break;
+case 685:
+#line 5561 "ps-parser.jay"
+  {
+		lexer.AutoSemiInsertion = false;
+	  }
+  break;
+case 686:
+  case_686();
+  break;
+case 687:
+  case_687();
+  break;
+case 688:
+#line 5596 "ps-parser.jay"
+  {
+		lexer.AutoSemiInsertion = true;		
+	  }
+  break;
+case 689:
+  case_689();
+  break;
+case 690:
+  case_690();
+  break;
+case 691:
+#line 5617 "ps-parser.jay"
+  { yyVal = null; }
+  break;
+case 692:
+#line 5619 "ps-parser.jay"
+  { yyVal = yyVals[0+yyTop]; StoreModifierLocation (Modifiers.PARTIAL, GetLocation (yyVals[0+yyTop])); }
+  break;
+case 693:
+  case_693();
+  break;
+case 694:
+#line 5632 "ps-parser.jay"
+  {
+		lexer.parsing_modifiers = false;		
+	  }
+  break;
+case 696:
+  case_696();
+  break;
+case 697:
+  case_697();
+  break;
+case 698:
+  case_698();
+  break;
+case 699:
+  case_699();
+  break;
+case 700:
+  case_700();
+  break;
+case 701:
+  case_701();
+  break;
+case 702:
+  case_702();
+  break;
+case 703:
+  case_703();
+  break;
+case 704:
+  case_704();
+  break;
+case 705:
+  case_705();
+  break;
+case 706:
+  case_706();
+  break;
+case 707:
+  case_707();
+  break;
+case 708:
+  case_708();
+  break;
+case 709:
+  case_709();
+  break;
+case 710:
+  case_710();
+  break;
+case 711:
+  case_711();
+  break;
+case 712:
+  case_712();
+  break;
+case 713:
+  case_713();
+  break;
+case 715:
+#line 5753 "ps-parser.jay"
+  {
+		current_type.AddBaseForPart ((FullNamedExpression) yyVals[0+yyTop]);
+	 }
+  break;
+case 716:
+  case_716();
+  break;
+case 718:
+#line 5767 "ps-parser.jay"
+  {
+		current_type.AddBasesForPart ((List<FullNamedExpression>) yyVals[0+yyTop]);
+	 }
+  break;
+case 719:
+  case_719();
+  break;
+case 721:
+#line 5781 "ps-parser.jay"
+  {
+		yyVal = yyVals[0+yyTop];
+	  }
+  break;
+case 722:
+  case_722();
+  break;
+case 723:
+  case_723();
+  break;
+case 724:
+  case_724();
+  break;
+case 725:
+  case_725();
+  break;
+case 726:
+  case_726();
+  break;
+case 727:
+  case_727();
+  break;
+case 728:
+  case_728();
+  break;
+case 729:
+  case_729();
+  break;
+case 730:
+#line 5873 "ps-parser.jay"
+  {
+		yyVal = new SpecialContraintExpr (SpecialConstraint.Class, GetLocation (yyVals[0+yyTop]));
+	  }
+  break;
+case 731:
+#line 5877 "ps-parser.jay"
+  {
+		yyVal = new SpecialContraintExpr (SpecialConstraint.Struct, GetLocation (yyVals[0+yyTop]));
+	  }
+  break;
+case 732:
+#line 5884 "ps-parser.jay"
+  {
+		yyVal = Variance.None;
+	  }
+  break;
+case 733:
+  case_733();
+  break;
+case 734:
+#line 5898 "ps-parser.jay"
+  {
+		yyVal = Variance.Covariant;
+	  }
+  break;
+case 735:
+#line 5902 "ps-parser.jay"
+  {
+		yyVal = Variance.Contravariant;
+	  }
+  break;
+case 736:
+  case_736();
+  break;
+case 737:
+#line 5928 "ps-parser.jay"
+  {
+  		yyVal = yyVals[0+yyTop];
+	  }
+  break;
+case 738:
+  case_738();
+  break;
+case 739:
+  case_739();
+  break;
+case 741:
+  case_741();
+  break;
+case 742:
+  case_742();
+  break;
+case 743:
+  case_743();
+  break;
+case 744:
+  case_744();
+  break;
+case 745:
+  case_745();
+  break;
+case 750:
+#line 6008 "ps-parser.jay"
+  {
+		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
+	  }
+  break;
+case 751:
+#line 6012 "ps-parser.jay"
+  {
+		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
+	  }
+  break;
+case 753:
+  case_753();
+  break;
+case 756:
+#line 6036 "ps-parser.jay"
+  {
+		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
+	  }
+  break;
+case 757:
+#line 6040 "ps-parser.jay"
+  {
+		current_block.AddStatement ((Statement) yyVals[0+yyTop]);
+	  }
+  break;
+case 788:
+  case_788();
+  break;
+case 789:
+  case_789();
+  break;
+case 790:
+  case_790();
+  break;
+case 791:
+  case_791();
+  break;
+case 792:
+  case_792();
+  break;
+case 794:
+  case_794();
+  break;
+case 796:
+  case_796();
+  break;
+case 797:
+  case_797();
+  break;
+case 798:
+  case_798();
+  break;
+case 799:
+  case_799();
+  break;
+case 801:
+  case_801();
+  break;
+case 802:
+#line 6246 "ps-parser.jay"
+  {
+	  	Lexer.AutoSemiInsertion = true;
+	  }
+  break;
+case 803:
+  case_803();
+  break;
+case 804:
+  case_804();
+  break;
+case 805:
+  case_805();
+  break;
+case 806:
+  case_806();
+  break;
+case 807:
+  case_807();
+  break;
+case 808:
+  case_808();
+  break;
+case 810:
+  case_810();
+  break;
+case 811:
+  case_811();
+  break;
+case 815:
+  case_815();
+  break;
+case 818:
+  case_818();
+  break;
+case 819:
+  case_819();
+  break;
+case 820:
+  case_820();
+  break;
+case 821:
+  case_821();
+  break;
+case 822:
+#line 6372 "ps-parser.jay"
+  {
+		report.Error (145, lexer.Location, "A const field requires a value to be provided");
+	  }
+  break;
+case 823:
+#line 6376 "ps-parser.jay"
+  {
+		current_variable.Initializer = (Expression) yyVals[0+yyTop];
+	  }
+  break;
+case 828:
+  case_828();
+  break;
+case 830:
+  case_830();
+  break;
+case 831:
+#line 6421 "ps-parser.jay"
+  { yyVal = yyVals[-1+yyTop]; }
+  break;
+case 832:
+  case_832();
+  break;
+case 833:
+#line 6431 "ps-parser.jay"
+  { yyVal = yyVals[-1+yyTop]; }
+  break;
+case 834:
+#line 6432 "ps-parser.jay"
+  { yyVal = yyVals[-1+yyTop]; }
+  break;
+case 835:
+#line 6443 "ps-parser.jay"
+  {
+		yyVal = ConvertExpressionToStatement((Expression)yyVals[0+yyTop]);
+	  }
+  break;
+case 836:
+  case_836();
+  break;
+case 837:
+  case_837();
+  break;
+case 840:
+#line 6471 "ps-parser.jay"
+  {
+	  	Lexer.AutoSemiInsertionAfter = 1;
+	  }
+  break;
+case 841:
+#line 6478 "ps-parser.jay"
+  {
+	  	Lexer.AutoSemiInsertionAfter = 1;
+	  }
+  break;
+case 842:
+  case_842();
+  break;
+case 843:
+  case_843();
+  break;
+case 844:
+  case_844();
+  break;
+case 845:
+  case_845();
+  break;
+case 846:
+  case_846();
+  break;
+case 847:
+  case_847();
+  break;
+case 848:
+  case_848();
+  break;
+case 850:
+  case_850();
+  break;
+case 851:
+  case_851();
+  break;
+case 852:
+  case_852();
+  break;
+case 853:
+#line 6567 "ps-parser.jay"
+  {
+		current_block = current_block.CreateSwitchBlock (lexer.Location);
+	  }
+  break;
+case 854:
+#line 6571 "ps-parser.jay"
+  {
+		yyVal = new SwitchSection ((List<SwitchLabel>) yyVals[-2+yyTop], current_block);
+	  }
+  break;
+case 855:
+  case_855();
+  break;
+case 856:
+  case_856();
+  break;
+case 857:
+  case_857();
+  break;
+case 858:
+  case_858();
+  break;
+case 859:
+  case_859();
+  break;
+case 864:
+  case_864();
+  break;
+case 865:
+  case_865();
+  break;
+case 866:
+#line 6639 "ps-parser.jay"
+  {
+	    Lexer.AutoSemiInsertionAfter = 1;
+	  }
+  break;
+case 867:
+#line 6646 "ps-parser.jay"
+  {
+	    Lexer.AutoSemiInsertion = true;
+	  }
+  break;
+case 868:
+  case_868();
+  break;
+case 869:
+  case_869();
+  break;
+case 870:
+  case_870();
+  break;
+case 871:
+  case_871();
+  break;
+case 872:
+  case_872();
+  break;
+case 873:
+#line 6695 "ps-parser.jay"
+  {
+	    lexer.ForInParsing = false;
+	  }
+  break;
+case 874:
+  case_874();
+  break;
+case 875:
+  case_875();
+  break;
+case 876:
+  case_876();
+  break;
+case 877:
+  case_877();
+  break;
+case 878:
+  case_878();
+  break;
+case 879:
+#line 6782 "ps-parser.jay"
+  {
+		yyVal = new Tuple<Location,Location> (GetLocation (yyVals[-2+yyTop]), (Location) yyVals[0+yyTop]);
+	  }
+  break;
+case 880:
+  case_880();
+  break;
+case 881:
+  case_881();
+  break;
+case 882:
+  case_882();
+  break;
+case 884:
+#line 6812 "ps-parser.jay"
+  { lexer.putback ('}'); }
+  break;
+case 885:
+#line 6816 "ps-parser.jay"
+  { yyVal = new EmptyStatement (lexer.Location); }
+  break;
+case 887:
+  case_887();
+  break;
+case 888:
+  case_888();
+  break;
+case 889:
+#line 6836 "ps-parser.jay"
+  {
+		
+	  }
+  break;
+case 890:
+#line 6840 "ps-parser.jay"
+  { yyVal = null; }
+  break;
+case 892:
+#line 6845 "ps-parser.jay"
+  { yyVal = new EmptyStatement (lexer.Location); }
+  break;
+case 896:
+  case_896();
+  break;
+case 897:
+#line 6874 "ps-parser.jay"
+  {
+		lexer.ForInParsing = true;
+	  }
+  break;
+case 898:
+#line 6878 "ps-parser.jay"
+  {
+	  	lexer.ForInParsing = false;
+	  }
+  break;
+case 899:
+  case_899();
+  break;
+case 900:
+  case_900();
+  break;
+case 908:
+  case_908();
+  break;
+case 909:
+  case_909();
+  break;
+case 910:
+  case_910();
+  break;
+case 911:
+  case_911();
+  break;
+case 912:
+  case_912();
+  break;
+case 913:
+  case_913();
+  break;
+case 914:
+  case_914();
+  break;
+case 915:
+  case_915();
+  break;
+case 916:
+  case_916();
+  break;
+case 917:
+  case_917();
+  break;
+case 918:
+  case_918();
+  break;
+case 919:
+  case_919();
+  break;
+case 920:
+  case_920();
+  break;
+case 921:
+  case_921();
+  break;
+case 924:
+#line 7064 "ps-parser.jay"
+  {
+		yyVal = new TryCatch ((Block) yyVals[-1+yyTop], (List<Catch>) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]), false);
+	  }
+  break;
+case 925:
+  case_925();
+  break;
+case 926:
+  case_926();
+  break;
+case 927:
+  case_927();
+  break;
+case 928:
+  case_928();
+  break;
+case 929:
+  case_929();
+  break;
+case 932:
+#line 7113 "ps-parser.jay"
+  {
+		yyVal = new Catch ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
+	  }
+  break;
+case 933:
+  case_933();
+  break;
+case 934:
+#line 7131 "ps-parser.jay"
+  {
+		yyVal = yyVals[-1+yyTop];
+	  }
+  break;
+case 935:
+  case_935();
+  break;
+case 936:
+  case_936();
+  break;
+case 937:
+#line 7167 "ps-parser.jay"
+  {
+		yyVal = new Checked ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
+	  }
+  break;
+case 938:
+#line 7174 "ps-parser.jay"
+  {
+		yyVal = new Unchecked ((Block) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
+	  }
+  break;
+case 939:
+  case_939();
+  break;
+case 940:
+#line 7184 "ps-parser.jay"
+  {
+		yyVal = new Unsafe ((Block) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
+	  }
+  break;
+case 941:
+  case_941();
+  break;
+case 942:
+  case_942();
+  break;
+case 943:
+  case_943();
+  break;
+case 944:
+  case_944();
+  break;
+case 945:
+  case_945();
+  break;
+case 946:
+  case_946();
+  break;
+case 947:
+  case_947();
+  break;
+case 948:
+  case_948();
+  break;
+case 949:
+  case_949();
+  break;
+case 950:
+  case_950();
+  break;
+case 952:
+  case_952();
+  break;
+case 953:
+#line 7295 "ps-parser.jay"
+  {
+		Error_MissingInitializer (lexer.Location);
+	  }
+  break;
+case 954:
+  case_954();
+  break;
+case 955:
+  case_955();
+  break;
+case 956:
+  case_956();
+  break;
+case 957:
+  case_957();
+  break;
+case 958:
+  case_958();
+  break;
+case 959:
+  case_959();
+  break;
+case 960:
+  case_960();
+  break;
+case 961:
+  case_961();
+  break;
+case 962:
+  case_962();
+  break;
+case 963:
+#line 7408 "ps-parser.jay"
+  {
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  }
+  break;
+case 964:
+  case_964();
+  break;
+case 965:
+#line 7423 "ps-parser.jay"
+  {
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  }
+  break;
+case 966:
+  case_966();
+  break;
+case 967:
+  case_967();
+  break;
+case 968:
+  case_968();
+  break;
+case 970:
+  case_970();
+  break;
+case 971:
+  case_971();
+  break;
+case 972:
+#line 7485 "ps-parser.jay"
+  {
+	  	current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  }
+  break;
+case 973:
+  case_973();
+  break;
+case 974:
+  case_974();
+  break;
+case 975:
+  case_975();
+  break;
+case 976:
+  case_976();
+  break;
+case 978:
+  case_978();
+  break;
+case 984:
+#line 7539 "ps-parser.jay"
+  {
+	  	current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  }
+  break;
+case 985:
+  case_985();
+  break;
+case 986:
+#line 7558 "ps-parser.jay"
+  {
+	  	current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  }
+  break;
+case 987:
+  case_987();
+  break;
+case 988:
+  case_988();
+  break;
+case 989:
+  case_989();
+  break;
+case 990:
+  case_990();
+  break;
+case 991:
+  case_991();
+  break;
+case 992:
+  case_992();
+  break;
+case 993:
+  case_993();
+  break;
+case 994:
+  case_994();
+  break;
+case 995:
+  case_995();
+  break;
+case 997:
+#line 7702 "ps-parser.jay"
+  {
+		yyVal = yyVals[0+yyTop];
+	  }
+  break;
+case 998:
+#line 7709 "ps-parser.jay"
+  {
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  }
+  break;
+case 999:
+  case_999();
+  break;
+case 1001:
+  case_1001();
+  break;
+case 1002:
+  case_1002();
+  break;
+case 1004:
+  case_1004();
+  break;
+case 1005:
+  case_1005();
+  break;
+case 1006:
+#line 7755 "ps-parser.jay"
+  {
+		yyVal = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[0+yyTop]);	
+	  }
+  break;
+case 1007:
+  case_1007();
+  break;
+case 1008:
+  case_1008();
+  break;
+case 1009:
+#line 7772 "ps-parser.jay"
+  {
+		yyVal = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[0+yyTop]);	
+	  }
+  break;
+case 1010:
+  case_1010();
+  break;
+case 1011:
+  case_1011();
+  break;
+case 1013:
+  case_1013();
+  break;
+case 1014:
+  case_1014();
+  break;
+case 1017:
+  case_1017();
+  break;
+case 1018:
+  case_1018();
+  break;
+case 1024:
+#line 7897 "ps-parser.jay"
+  {
+		module.DocumentationBuilder.ParsedName = (MemberName) yyVals[0+yyTop];
+	  }
+  break;
+case 1025:
+#line 7904 "ps-parser.jay"
+  {
+		module.DocumentationBuilder.ParsedParameters = (List<DocumentationParameter>)yyVals[0+yyTop];
+	  }
+  break;
+case 1026:
+  case_1026();
+  break;
+case 1027:
+  case_1027();
+  break;
+case 1028:
+#line 7921 "ps-parser.jay"
+  {
+		yyVal = new MemberName ((MemberName) yyVals[-2+yyTop], MemberCache.IndexerNameAlias, Location.Null);
+	  }
+  break;
+case 1029:
+#line 7925 "ps-parser.jay"
+  {
+		valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
+	  }
+  break;
+case 1030:
+  case_1030();
+  break;
+case 1031:
+  case_1031();
+  break;
+case 1032:
+  case_1032();
+  break;
+case 1033:
+  case_1033();
+  break;
+case 1035:
+#line 7961 "ps-parser.jay"
+  {
+		yyVal = new MemberName (((MemberName) yyVals[-2+yyTop]), (MemberName) yyVals[0+yyTop]);
+	  }
+  break;
+case 1037:
+#line 7969 "ps-parser.jay"
+  {
+		valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
+	  }
+  break;
+case 1038:
+#line 7973 "ps-parser.jay"
+  {
+		yyVal = yyVals[-1+yyTop];
+	  }
+  break;
+case 1039:
+#line 7980 "ps-parser.jay"
+  {
+		yyVal = new List<DocumentationParameter> (0);
+	  }
+  break;
+case 1041:
+  case_1041();
+  break;
+case 1042:
+  case_1042();
+  break;
+case 1043:
+  case_1043();
+  break;
+#line default
+        }
+        yyTop -= yyLen[yyN];
+        yyState = yyStates[yyTop];
+        int yyM = yyLhs[yyN];
+        if (yyState == 0 && yyM == 0) {
+//t          if (debug != null) debug.shift(0, yyFinal);
+          yyState = yyFinal;
+          if (yyToken < 0) {
+            yyToken = yyLex.advance() ? yyLex.token() : 0;
+//t            if (debug != null)
+//t               debug.lex(yyState, yyToken,yyname(yyToken), yyLex.value());
+          }
+          if (yyToken == 0) {
+//t            if (debug != null) debug.accept(yyVal);
+            return yyVal;
+          }
+          goto continue_yyLoop;
+        }
+        if (((yyN = yyGindex[yyM]) != 0) && ((yyN += yyState) >= 0)
+            && (yyN < yyTable.Length) && (yyCheck[yyN] == yyState))
+          yyState = yyTable[yyN];
+        else
+          yyState = yyDgoto[yyM];
+//t        if (debug != null) debug.shift(yyStates[yyTop], yyState);
+	 goto continue_yyLoop;
+      continue_yyDiscarded: ;	// implements the named-loop continue: 'continue yyDiscarded'
+      }
+    continue_yyLoop: ;		// implements the named-loop continue: 'continue yyLoop'
+    }
+  }
+
+/*
+ All more than 3 lines long rules are wrapped into a method
+*/
+void case_6()
+#line 453 "ps-parser.jay"
+{
+		if (yyVals[0+yyTop] != null) {
+			Attributes attrs = (Attributes) yyVals[0+yyTop];
+			report.Error (1730, attrs.Attrs [0].Location,
+				"Assembly and module attributes must precede all other elements except using clauses and extern alias declarations");
+
+			current_namespace.UnattachedAttributes = attrs;
+		}
+	  }
+
+void case_8()
+#line 467 "ps-parser.jay"
+{
+		if (yyToken == Token.EXTERN)
+			report.Error (439, lexer.Location, "An extern alias declaration must precede all other elements");
+		else
+			Error_SyntaxError (yyToken);
+	  }
+
+void case_13()
+#line 487 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+		string s = lt.Value;
+		if (s != "alias") {
+			syntax_error (lt.Location, "`alias' expected");
+		} else {
+			if (lang_version == LanguageVersion.ISO_1)
+				FeatureIsNotAvailable (lt.Location, "external alias");
+
+			lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
+			if (lt.Value == QualifiedAliasMember.GlobalAlias) {
+				RootNamespace.Error_GlobalNamespaceRedefined (report, lt.Location);
+			}
+			
+			var na = new UsingExternAlias (new SimpleMemberName (lt.Value, lt.Location), GetLocation (yyVals[-3+yyTop]));
+			current_namespace.AddUsing (na);
+			
+			lbag.AddLocation (na, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
+		}
+	  }
+
+void case_19()
+#line 525 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
+	    is_config_enabled = file.IsConditionalDefined (lt.Value.Replace("::","_"));	  
+	  }
+
+void case_20()
+#line 530 "ps-parser.jay"
+{
+	  	is_config_enabled = true;
+	  	yyVal = yyVals[0+yyTop];
+	  }
+
+void case_21()
+#line 535 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
+	    is_config_enabled = file.IsConditionalDefined (lt.Value.Replace("::","_"));	  
+	  }
+
+void case_22()
+#line 540 "ps-parser.jay"
+{
+	  	is_config_enabled = true;
+	  	yyVal = yyVals[-1+yyTop];
+	  }
+
+void case_25()
+#line 553 "ps-parser.jay"
+{
+		if (doc_support)
+			Lexer.doc_state = XmlCommentState.Allowed;
+	  }
+
+void case_27()
+#line 565 "ps-parser.jay"
+{
+		if (doc_support)
+			Lexer.doc_state = XmlCommentState.Allowed;
+	  }
+
+void case_29()
+#line 577 "ps-parser.jay"
+{
+	    if (is_config_enabled) {
+			var un = new UsingNamespace ((ATypeNameExpression) yyVals[-3+yyTop], GetLocation (yyVals[-4+yyTop]));
+		  	current_namespace.AddUsing (un);
+		
+			lbag.AddLocation (un, GetLocation (yyVals[0+yyTop]));
+			
+		    Lexer.AllowAutoSemiAfterToken(Token.DOT_STAR, false);
+		}
+	  }
+
+void case_30()
+#line 588 "ps-parser.jay"
+{
+	    if (is_config_enabled) {
+			var ut = new UsingType ((ATypeNameExpression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
+			current_namespace.AddUsing (ut);
+		
+			lbag.AddLocation (ut, GetLocation (yyVals[0+yyTop]));
+		}
+	  }
+
+void case_31()
+#line 597 "ps-parser.jay"
+{
+	    if (is_config_enabled) {
+			var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
+			if (lang_version != LanguageVersion.ISO_1 && lt.Value == "global") {
+				report.Warning (440, 2, lt.Location,
+				 "An alias named `global' will not be used when resolving `global::'. The global namespace will be used instead");
+			}
+
+			var un = new UsingAliasNamespace (new SimpleMemberName (lt.Value, lt.Location), (ATypeNameExpression) yyVals[-1+yyTop], GetLocation (yyVals[-4+yyTop]));
+			current_namespace.AddUsing (un);
+		
+			lbag.AddLocation (un, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
+		}
+	  }
+
+void case_32()
+#line 612 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+		yyVal = null;
+	  }
+
+void case_34()
+#line 629 "ps-parser.jay"
+{
+		Attributes attrs = (Attributes) yyVals[-3+yyTop];
+		var name = yyVals[0+yyTop] as MemberName;
+		if (name == null) {
+			name = new MemberName(RootNs);
+		}
+		if (attrs != null) {
+			bool valid_global_attrs = true;
+			if ((current_namespace.DeclarationFound || current_namespace != file)) {
+				valid_global_attrs = false;
+			} else {
+				foreach (var a in attrs.Attrs) {
+					if (a.ExplicitTarget == "assembly" || a.ExplicitTarget == "module")
+						continue;
+						
+					valid_global_attrs = false;
+					break;
+				}
+			}
+			
+			if (!valid_global_attrs)
+				report.Error (1671, name.Location, "A namespace declaration cannot have modifiers or attributes");
+		}
+	
+		module.AddAttributes (attrs, current_namespace);
+		
+	    /* Close the private package namespace (if it's active)*/
+	  	if (current_namespace == private_namespace) {
+	  		if (private_namespace.Containers.Count > 0) {
+		  		prev_namespace.AddTypeContainer(private_namespace);
+				var priv_un = new UsingNamespace (
+					private_namespace.NS.MakeTypeNameExpression(GetLocation(yyVals[-3+yyTop])), GetLocation (yyVals[-3+yyTop]));
+				prev_namespace.AddUsing(priv_un, true);
+			}
+			current_container = current_namespace = prev_namespace.Parent;
+			prev_namespace = private_namespace = null; 
+	  	}
+		
+		var ns = new NamespaceContainer (name, current_namespace);
+		current_namespace.AddTypeContainer (ns);
+		current_container = current_namespace = ns;
+		var un = new UsingNamespace (new SimpleName (RootNs, GetLocation (yyVals[-3+yyTop])), GetLocation (yyVals[-3+yyTop]));
+		current_namespace.AddUsing(un, true);
+	  }
+
+void case_35()
+#line 674 "ps-parser.jay"
+{
+		if (doc_support)
+			Lexer.doc_state = XmlCommentState.Allowed;
+			
+		Lexer.AutoSemiInsertion = true;
+	  }
+
+void case_36()
+#line 681 "ps-parser.jay"
+{
+	  	lbag.AddLocation (current_container, GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
+	  
+	  	if (current_namespace.Parent != null && current_namespace.Parent.Parent == null) { /* Is this the top level package?*/
+			var ns = new NamespaceContainer (new MemberName("__" + file.FileName.Replace(".","_")), current_namespace);
+			prev_namespace = current_namespace;
+			current_container = private_namespace = current_namespace = ns;
+	    } else {
+			current_container = current_namespace = current_namespace.Parent;
+		}
+		
+		lexer.parsing_modifiers = false;
+	  }
+
+void case_37()
+#line 695 "ps-parser.jay"
+{
+	    /* Close the private package namespace (if it's active)*/
+	  	if (current_namespace == private_namespace) {
+	  		if (private_namespace.Containers.Count > 0) {
+		  		prev_namespace.AddTypeContainer(private_namespace);
+				var priv_un = new UsingNamespace (
+					private_namespace.NS.MakeTypeNameExpression(GetLocation(yyVals[-10+yyTop])), GetLocation (yyVals[-10+yyTop]));
+				prev_namespace.AddUsing(priv_un, true);
+			}
+			current_container = current_namespace = prev_namespace.Parent;
+			prev_namespace = private_namespace = null; 
+	  	}
+	  
+/*	  	lbag.AddLocation (current_container, GetLocation ($2), GetLocation ($6), GetLocation ($11));*/
+	  }
+
+void case_40()
+#line 719 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
+		yyVal = new MemberName (lt.Value, lt.Location);
+	  }
+
+void case_41()
+#line 724 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
+		yyVal = new MemberName ((MemberName) yyVals[-2+yyTop], lt.Value, lt.Location);		
+	  }
+
+void case_42()
+#line 729 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+		yyVal = new MemberName ("<invalid>", lexer.Location);
+	  }
+
+void case_59()
+#line 773 "ps-parser.jay"
+{
+		current_namespace.UnattachedAttributes = (Attributes) yyVals[-1+yyTop];
+		report.Error (1518, lexer.Location, "Attributes must be attached to class, delegate, enum, interface or struct");
+		lexer.putback ('}');
+		is_config_enabled = true;		
+	  }
+
+void case_60()
+#line 783 "ps-parser.jay"
+{
+	    if (is_config_enabled) {
+			if (yyVals[0+yyTop] != null) {
+				TypeContainer ds = (TypeContainer)yyVals[0+yyTop];
+
+				if ((ds.ModFlags & (Modifiers.PRIVATE | Modifiers.PROTECTED)) != 0){
+					report.Error (1527, ds.Location, 
+					"Namespace elements cannot be explicitly declared as private, protected or protected internal");
+				}
+
+				/* Here is a trick, for explicit attributes we don't know where they belong to until*/
+				/* we parse succeeding declaration hence we parse them as normal and re-attach them*/
+				/* when we know whether they are global (assembly:, module:) or local (type:).*/
+				if (ds.OptAttributes != null) {
+					ds.OptAttributes.ConvertGlobalAttributes (ds, current_namespace, !current_namespace.DeclarationFound && current_namespace == file);
+				}
+			}
+			current_namespace.DeclarationFound = true;
+		}
+	  }
+
+void case_61()
+#line 804 "ps-parser.jay"
+{
+	  	if (is_config_enabled) {
+			current_namespace.DeclarationFound = true;
+		}
+	  }
+
+void case_63()
+#line 814 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
+	    is_config_enabled = file.IsConditionalDefined (lt.Value.Replace("::","_"));	 	  
+	  }
+
+void case_64()
+#line 819 "ps-parser.jay"
+{
+	    is_config_enabled = true;
+	    yyVal = yyVals[0+yyTop];
+	  }
+
+void case_65()
+#line 824 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
+	    is_config_enabled = file.IsConditionalDefined (lt.Value.Replace("::","_"));	  
+	  }
+
+void case_66()
+#line 829 "ps-parser.jay"
+{
+	  	is_config_enabled = true;
+	  	yyVal = yyVals[-1+yyTop];
+	  }
+
+void case_75()
+#line 864 "ps-parser.jay"
+{
+		var sect = yyVals[0+yyTop] as List<Attribute>;
+		if (sect != null) {
+			yyVal = new Attributes (sect);
+		}
+	  }
+
+void case_76()
+#line 871 "ps-parser.jay"
+{
+		Attributes attrs = yyVals[-1+yyTop] as Attributes;
+		var sect = yyVals[0+yyTop] as List<Attribute>;
+		if (sect != null) {
+			if (attrs == null)
+				attrs = new Attributes (sect);
+			else
+				attrs.AddAttributes (sect);
+		}
+		yyVal = attrs;
+	  }
+
+void case_78()
+#line 890 "ps-parser.jay"
+{
+		lexer.parsing_attribute_section = false;
+		yyVal = yyVals[0+yyTop];
+	  }
+
+void case_79()
+#line 898 "ps-parser.jay"
+{
+		current_attr_target = (string) yyVals[-1+yyTop];
+		if (current_attr_target == "assembly" || current_attr_target == "module") {
+			Lexer.check_incorrect_doc_comment ();
+		}
+	  }
+
+void case_80()
+#line 905 "ps-parser.jay"
+{
+		/* when attribute target is invalid*/
+		if (current_attr_target == string.Empty)
+			yyVal = new List<Attribute> (0);
+		else
+			yyVal = yyVals[-2+yyTop];
+	  
+		current_attr_target = null;
+		lexer.parsing_attribute_section = false;
+		lexer.AutoSemiInsertionAfter = 1;
+ 	  }
+
+void case_81()
+#line 917 "ps-parser.jay"
+{
+		lexer.AutoSemiInsertionAfter = 1;
+		yyVal = yyVals[-2+yyTop];
+	  }
+
+void case_82()
+#line 925 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
+		yyVal = CheckAttributeTarget (lt.Value, lt.Location);
+	  }
+
+void case_85()
+#line 932 "ps-parser.jay"
+{
+		if (yyToken == Token.IDENTIFIER) {
+			Error_SyntaxError (yyToken);
+			yyVal = null;
+		} else {
+			string name = GetTokenName (yyToken);
+			yyVal = CheckAttributeTarget (name, GetLocation (yyVals[0+yyTop]));
+		}
+	  }
+
+void case_87()
+#line 949 "ps-parser.jay"
+{
+		var attrs = (List<Attribute>) yyVals[-2+yyTop];
+		attrs.Add ((Attribute) yyVals[0+yyTop]);
+
+		yyVal = attrs;
+	  }
+
+void case_89()
+#line 963 "ps-parser.jay"
+{
+		--lexer.parsing_block;
+		
+		var tne = (ATypeNameExpression) yyVals[-2+yyTop];
+		if (tne.HasTypeArguments) {
+			report.Error (404, tne.Location, "Attributes cannot be generic");
+		}
+
+		yyVal = new Attribute (current_attr_target, tne, (Arguments[]) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]), lexer.IsEscapedIdentifier (tne));
+	  }
+
+void case_92()
+#line 982 "ps-parser.jay"
+{
+	    lexer.AutoSemiInsertionAfter = 1;
+		yyVal = yyVals[-1+yyTop];
+	  }
+
+void case_94()
+#line 992 "ps-parser.jay"
+{
+	  	Arguments a = new Arguments (4);
+		a.Add ((Argument) yyVals[0+yyTop]);
+		yyVal = new Arguments [] { a, null };
+	  }
+
+void case_95()
+#line 998 "ps-parser.jay"
+{
+	  	Arguments a = new Arguments (4);
+		a.Add ((Argument) yyVals[0+yyTop]);  
+		yyVal = new Arguments [] { null, a };
+	  }
+
+void case_96()
+#line 1004 "ps-parser.jay"
+{
+		Arguments[] o = (Arguments[]) yyVals[-2+yyTop];
+		if (o [1] != null) {
+			report.Error (1016, ((Argument) yyVals[0+yyTop]).Expr.Location, "Named attribute arguments must appear after the positional arguments");
+			o [0] = new Arguments (4);
+		}
+		
+		Arguments args = ((Arguments) o [0]);
+		if (args.Count > 0 && !(yyVals[0+yyTop] is NamedArgument) && args [args.Count - 1] is NamedArgument)
+			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
+		
+		args.Add ((Argument) yyVals[0+yyTop]);
+	  }
+
+void case_97()
+#line 1018 "ps-parser.jay"
+{
+		Arguments[] o = (Arguments[]) yyVals[-2+yyTop];
+		if (o [1] == null) {
+			o [1] = new Arguments (4);
+		}
+
+		((Arguments) o [1]).Add ((Argument) yyVals[0+yyTop]);
+	  }
+
+void case_101()
+#line 1042 "ps-parser.jay"
+{
+	  	--lexer.parsing_block;
+	  	var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
+		yyVal = new NamedArgument (lt.Value, lt.Location, (Expression) yyVals[0+yyTop]);	  
+		lbag.AddLocation (yyVal, GetLocation(yyVals[-2+yyTop]));
+	  }
+
+void case_102()
+#line 1052 "ps-parser.jay"
+{
+		if (lang_version <= LanguageVersion.V_3)
+			FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "named argument");
+			
+		/* Avoid boxing in common case (no modifier)*/
+		var arg_mod = yyVals[-1+yyTop] == null ? Argument.AType.None : (Argument.AType) yyVals[-1+yyTop];
+			
+		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
+		yyVal = new NamedArgument (lt.Value, lt.Location, (Expression) yyVals[0+yyTop], arg_mod);
+		lbag.AddLocation (yyVal, GetLocation(yyVals[-2+yyTop]));
+	  }
+
+void case_104()
+#line 1068 "ps-parser.jay"
+{ 
+	  	CheckIsPlayScript("ref parameters", GetLocation(yyVals[0+yyTop]));
+		yyVal = Argument.AType.Ref;
+	  }
+
+void case_105()
+#line 1073 "ps-parser.jay"
+{ 
+	  	CheckIsPlayScript("out parameters", GetLocation(yyVals[0+yyTop]));
+		yyVal = Argument.AType.Out;
+	  }
+
+void case_124()
+#line 1112 "ps-parser.jay"
+{
+		report.Error (1519, lexer.Location, "Unexpected symbol `{0}' in class, struct, or interface member declaration",
+			GetSymbolName (yyToken));
+		yyVal = null;
+		lexer.parsing_generic_declaration = false;
+	  }
+
+void case_125()
+#line 1124 "ps-parser.jay"
+{
+	  	if (yyVals[-2+yyTop] != null || (Modifiers) yyVals[-1+yyTop] != 0) {
+			report.Error (7058, GetLocation(yyVals[-2+yyTop] ?? yyVals[-1+yyTop]), "Modifiers and attributes not allowed");
+	  	}
+	  }
+
+void case_126()
+#line 1135 "ps-parser.jay"
+{
+	  	if (yyVals[-2+yyTop] != null || (Modifiers) yyVals[-1+yyTop] != 0) {
+			report.Error (7058, GetLocation(yyVals[-2+yyTop] ?? yyVals[-1+yyTop]), "Modifiers and attributes not allowed");
+	  	}
+	  }
+
+void case_127()
+#line 1144 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
+	    is_config_enabled = file.IsConditionalDefined (lt.Value.Replace("::","_"));	  
+	  }
+
+void case_128()
+#line 1149 "ps-parser.jay"
+{
+	    is_config_enabled = true;
+	    yyVal = yyVals[0+yyTop];
+	  }
+
+void case_129()
+#line 1158 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
+	    is_config_enabled = file.IsConditionalDefined (lt.Value.Replace("::","_"));	  
+	  }
+
+void case_130()
+#line 1163 "ps-parser.jay"
+{
+	  	is_config_enabled = true;
+	  	yyVal = yyVals[-1+yyTop];
+	  }
+
+void case_132()
+#line 1178 "ps-parser.jay"
+{
+		lexer.ConstraintsParsing = true;	  
+	  	bool is_partial = IsPartial(yyVals[-5+yyTop]) || yyVals[-3+yyTop] != null;
+		push_current_container (new Struct (current_container, (MemberName) yyVals[0+yyTop], (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), is_partial);
+		lbag.AddMember (current_container, GetModifierLocations (), GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_133()
+#line 1187 "ps-parser.jay"
+{
+		lexer.ConstraintsParsing = false;
+
+		if (yyVals[0+yyTop] != null)
+			current_container.SetConstraints ((List<Constraints>) yyVals[0+yyTop]);
+
+		if (doc_support)
+			current_container.PartialContainer.DocComment = Lexer.consume_doc_comment ();
+
+		
+		lexer.parsing_modifiers = true;
+		lexer.AutoSemiInsertion = true;
+	  }
+
+void case_134()
+#line 1201 "ps-parser.jay"
+{
+		if (doc_support)
+			Lexer.doc_state = XmlCommentState.Allowed;
+		lexer.DynamicParsing = false;
+	  }
+
+void case_135()
+#line 1207 "ps-parser.jay"
+{
+		lexer.DynamicParsing = true;
+		--lexer.parsing_declaration;
+		if (doc_support)
+			Lexer.doc_state = XmlCommentState.Allowed;
+	  }
+
+void case_136()
+#line 1214 "ps-parser.jay"
+{
+		if (yyVals[0+yyTop] == null) {
+			lbag.AppendToMember (current_container, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]));
+		} else {
+			lbag.AppendToMember (current_container, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
+		}
+		yyVal = pop_current_class ();
+	  }
+
+void case_138()
+#line 1232 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+		var mod = (Modifiers) yyVals[-4+yyTop];
+		mod &= ~Modifiers.STATIC;
+		current_field = new Const (current_type, (FullNamedExpression) yyVals[0+yyTop], mod, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-5+yyTop]);
+		if (is_config_enabled) {
+			current_type.AddMember (current_field);
+		}
+		is_config_enabled = true;
+				
+		yyVal = current_field;
+	  }
+
+void case_139()
+#line 1245 "ps-parser.jay"
+{
+		if (doc_support) {
+			current_field.DocComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.Allowed;
+		}
+		
+		current_field.Initializer = (ConstInitializer) yyVals[-2+yyTop];
+		lbag.AddMember (current_field, GetModifierLocations (), GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[0+yyTop]));
+		current_field = null;
+	  }
+
+void case_144()
+#line 1275 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
+	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) yyVals[0+yyTop], (FullNamedExpression) yyVals[-1+yyTop]);
+	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]));
+	  }
+
+void case_148()
+#line 1293 "ps-parser.jay"
+{
+		--lexer.parsing_block;
+		yyVal = new ConstInitializer (current_field, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_149()
+#line 1298 "ps-parser.jay"
+{
+		report.Error (145, lexer.Location, "A const field requires a value to be provided");
+		yyVal = null;
+	  }
+
+void case_151()
+#line 1312 "ps-parser.jay"
+{
+	  	lexer.parsing_generic_declaration = false;
+
+		FullNamedExpression type = (FullNamedExpression) yyVals[0+yyTop];
+		if (type.Type != null && type.Type.Kind == MemberKind.Void)
+			report.Error (670, GetLocation (yyVals[0+yyTop]), "Fields cannot have void type");
+			
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+		current_field = new Field (current_type, type, (Modifiers) yyVals[-4+yyTop], new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-5+yyTop]);
+		if (is_config_enabled) {
+			current_type.AddField (current_field);
+		}
+		is_config_enabled = true;
+		yyVal = current_field;
+	  }
+
+void case_152()
+#line 1330 "ps-parser.jay"
+{ 
+		if (doc_support) {
+			current_field.DocComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.Allowed;
+		}
+			
+		lbag.AddMember (current_field, GetModifierLocations (), GetLocation (yyVals[0+yyTop]));
+		yyVal = current_field;
+		current_field = null;
+	  }
+
+void case_153()
+#line 1343 "ps-parser.jay"
+{ 
+		if (lang_version < LanguageVersion.ISO_2)
+			FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "fixed size buffers");
+
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+		current_field = new FixedField (current_type, (FullNamedExpression) yyVals[0+yyTop], (Modifiers) yyVals[-4+yyTop],
+			new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-5+yyTop]);
+			
+		if (is_config_enabled) {
+			current_type.AddField (current_field);
+		}
+		is_config_enabled = true;
+	  }
+
+void case_154()
+#line 1357 "ps-parser.jay"
+{
+		if (doc_support) {
+			current_field.DocComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.Allowed;
+	    }
+
+		current_field.Initializer = (ConstInitializer) yyVals[-2+yyTop];	    
+		lbag.AddMember (current_field, GetModifierLocations (), GetLocation (yyVals[0+yyTop]));
+		yyVal = current_field;
+	    current_field = null;
+	  }
+
+void case_157()
+#line 1380 "ps-parser.jay"
+{
+	  	++lexer.parsing_block;
+		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
+	  	start_block (GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_158()
+#line 1386 "ps-parser.jay"
+{
+	  	--lexer.parsing_block;
+		current_field.Initializer = (Expression) yyVals[0+yyTop];
+		end_block (lexer.Location);
+		current_local_parameters = null;
+	  }
+
+void case_163()
+#line 1412 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null, (FullNamedExpression) yyVals[0+yyTop]);
+	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-3+yyTop]));
+	  }
+
+void case_165()
+#line 1422 "ps-parser.jay"
+{
+		--lexer.parsing_block;
+		var lt = (Tokenizer.LocatedToken) yyVals[-5+yyTop];	  
+	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) yyVals[0+yyTop], (FullNamedExpression) yyVals[-3+yyTop]);
+	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_170()
+#line 1448 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];	  
+		yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) yyVals[-2+yyTop], (FullNamedExpression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]));
+	  }
+
+void case_172()
+#line 1461 "ps-parser.jay"
+{
+		--lexer.parsing_block;
+		yyVal = new ConstInitializer (current_field, (Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
+		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_173()
+#line 1467 "ps-parser.jay"
+{
+		report.Error (443, lexer.Location, "Value or constant expected");
+		yyVal = null;
+	  }
+
+void case_175()
+#line 1476 "ps-parser.jay"
+{
+		/* It has to be here for the parent to safely restore artificial block*/
+	  	Error_SyntaxError (yyToken);
+	  	yyVal = null;
+	  }
+
+void case_176()
+#line 1485 "ps-parser.jay"
+{
+		if (doc_support)
+			Lexer.doc_state = XmlCommentState.NotAllowed;
+
+		/* Add it early in the case of body being eof for full ast*/
+		Method m = yyVals[0+yyTop] as Method;
+		if (m != null) {
+			async_block = (m.ModFlags & Modifiers.ASYNC) != 0;
+			if (is_config_enabled) {
+				current_type.AddMember (m);
+			}
+			is_config_enabled = true;
+		}
+		
+		Constructor c = yyVals[0+yyTop] as Constructor;
+		if (c != null) {
+			if (is_config_enabled) {
+				current_type.AddConstructor (c);
+			}
+			is_config_enabled = true;
+			current_constructor = c;
+		}
+		
+		if (is_package_function)
+			lexer.DynamicParsing = false;
+			
+	  }
+
+void case_177()
+#line 1513 "ps-parser.jay"
+{
+		if (is_package_function)
+			lexer.DynamicParsing = true;
+	  
+	 	async_block = false;
+
+		if (yyVals[-2+yyTop] is Method) {
+		
+			Method method = yyVals[-2+yyTop] as Method;
+			
+			if (yyVals[0+yyTop] == null) {
+				lbag.AppendToMember (method, savedLocation); /* semicolon			*/
+				method.ParameterInfo.CheckParameters (method);
+	
+				if ((method.ModFlags & Modifiers.ASYNC) != 0) {
+					report.Error (1994, method.Location, "`{0}': The async modifier can only be used with methods that have a body",
+						method.GetSignatureForError ());
+				}
+			} else {
+				method.Block = (ToplevelBlock) yyVals[0+yyTop];
+				
+				if (current_container.Kind == MemberKind.Interface) {
+					report.Error (531, method.Location, "`{0}': interface members cannot have a definition",
+						method.GetSignatureForError ());
+				}
+			}
+			
+		} else if (yyVals[-2+yyTop] is Constructor) {
+		
+			Constructor c = yyVals[-2+yyTop] as Constructor;
+			
+			if (yyVals[0+yyTop] != null) {		
+				c.Block = (ToplevelBlock) yyVals[0+yyTop];
+			}
+			
+			if (doc_support)
+				c.DocComment = ConsumeStoredComment ();
+		
+		} else {
+		
+			Property.PropertyMethod propMethod = yyVals[-2+yyTop] as Property.PropertyMethod;
+			
+			if (yyVals[0+yyTop] != null) {
+		  		propMethod.Block = (ToplevelBlock) yyVals[0+yyTop];			
+		  	
+				if (current_container.Kind == MemberKind.Interface) {
+					report.Error (531, propMethod.Block.StartLocation,
+						"`{0}': interface members cannot have a definition", propMethod.GetSignatureForError ());
+				}
+			}
+			
+		}
+
+		current_local_parameters = null;
+		current_property = null;
+		current_constructor = null;
+		
+		/* If this was a package function, pop the container xxxxx_fn class.*/
+		if (is_package_function) {
+			pop_current_class();
+			is_package_function = false;
+		}
+	
+		if (doc_support)
+			Lexer.doc_state = XmlCommentState.Allowed;
+	  }
+
+void case_178()
+#line 1586 "ps-parser.jay"
+{
+		valid_param_mod = ParameterModifierType.All;
+		
+		/* If package level function, create a new package function class with */
+		/* the name of the function plus "_fn".*/
+		if (current_container is NamespaceContainer) {
+			MemberName methodName = (MemberName) yyVals[-1+yyTop];
+			MemberName className = new MemberName(methodName.Name + "_fn", GetLocation(yyVals[-1+yyTop]));
+			var fnClassModifiers = (Modifiers) yyVals[-3+yyTop] | Modifiers.PARTIAL | Modifiers.STATIC; /* Allows overloads..*/
+			push_current_container(new Class (current_container, className, fnClassModifiers, (Attributes) yyVals[-4+yyTop]), GetLocation(yyVals[-2+yyTop]));
+			is_package_function = true;
+		}
+		
+	  }
+
+void case_180()
+#line 1605 "ps-parser.jay"
+{
+		lexer.ConstraintsParsing = false;
+		valid_param_mod = 0;
+		MemberName name = (MemberName) yyVals[-7+yyTop];
+		current_local_parameters = (ParametersCompiled) yyVals[-4+yyTop];
+
+		var modifiers = (Modifiers) yyVals[-9+yyTop];
+		if (is_package_function) {
+			modifiers |= Modifiers.STATIC;
+		}
+		
+		if (current_type != null && name.Name == current_type.MemberName.Name) {
+
+			var c = new Constructor (current_type, name.Name, modifiers, (Attributes) yyVals[-10+yyTop], current_local_parameters, name.Location);
+
+			if (yyVals[0+yyTop] != null) {
+					report.Error (7011, c.Location,
+						"`{0}': constructor can not have type constraints.",
+						c.GetSignatureForError ());
+			}
+
+			if ((modifiers & Modifiers.STATIC) != 0) {
+				if ((modifiers & Modifiers.AccessibilityMask) != 0){
+					report.Error (515, c.Location,
+						"`{0}': static constructor cannot have an access modifier",
+						c.GetSignatureForError ());
+				}
+			}
+
+			if (doc_support)
+				c.DocComment = Lexer.consume_doc_comment ();
+				
+			lbag.AddMember (c, GetModifierLocations (), GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-3+yyTop]));
+			yyVal = c;
+		
+		} else {
+
+			if (current_container.Kind == MemberKind.Class && name.ExplicitInterface == null &&
+				(modifiers & (Modifiers.NEW | Modifiers.SEALED | Modifiers.STATIC | Modifiers.PRIVATE | Modifiers.VIRTUAL | Modifiers.OVERRIDE)) == 0)
+					modifiers |= Modifiers.VIRTUAL;
+
+			var ret_type = yyVals[-2+yyTop] as FullNamedExpression;
+			
+			if (ret_type == null) {
+				report.Error (7012, GetLocation(yyVals[-3+yyTop]), "Method must specify a return type.");
+				ret_type = new TypeExpression (compiler.BuiltinTypes.Void, GetLocation (yyVals[-3+yyTop]));
+			}
+
+			var method = Method.Create (current_type, ret_type, modifiers,
+					     name, current_local_parameters, (Attributes) yyVals[-10+yyTop]);
+
+			if (yyVals[0+yyTop] != null)
+				method.SetConstraints ((List<Constraints>) yyVals[0+yyTop]);
+					     
+			if (doc_support)
+				method.DocComment = Lexer.consume_doc_comment ();
+
+			lbag.AddMember (method, GetModifierLocations (), GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-3+yyTop]));
+			yyVal = method;
+			
+		}
+	  }
+
+void case_182()
+#line 1674 "ps-parser.jay"
+{
+		var type = (FullNamedExpression) yyVals[0+yyTop];
+		var name = (MemberName) yyVals[-6+yyTop];
+		var modifiers = (Modifiers) yyVals[-8+yyTop];
+		var parameters = (ParametersCompiled) yyVals[-3+yyTop];		
+		
+		if (current_container.Kind == MemberKind.Class && name.ExplicitInterface == null &&
+			(modifiers & (Modifiers.NEW | Modifiers.SEALED | Modifiers.STATIC | Modifiers.PRIVATE | Modifiers.VIRTUAL | Modifiers.OVERRIDE)) == 0)
+				modifiers |= Modifiers.VIRTUAL;
+
+		if (parameters != null && parameters.Count > 0)
+			report.Error (7016, GetLocation (yyVals[0+yyTop]), "Property getter functions may not have parameters");
+
+		current_property = null;		
+						
+		MemberCore member;
+		if (current_type.DefinedNames.TryGetValue(name.Name, out member)) {
+			current_property = member as Property;
+		}
+		
+		if (current_property == null) {
+			current_property = new Property (current_type, type, modifiers, name, (Attributes) yyVals[-9+yyTop]);
+			if (is_config_enabled) {
+				current_type.AddMember (current_property);
+			}
+			is_config_enabled = true;
+			modifiers = (Modifiers) 0;
+		} else {
+/*			if (!type.Equals(current_property.TypeExpression)) {*/
+/*				report.Error (7002, GetLocation ($10), "Type of property getter and setter must match", current_property.GetSignatureForError ());*/
+/*			}*/
+			if (current_property.Set != null && ModifiersExtensions.IsRestrictedModifier (current_property.ModFlags & Modifiers.AccessibilityMask, modifiers & Modifiers.AccessibilityMask)) {
+				current_property.Set.ModFlags |= current_property.ModFlags & Modifiers.AccessibilityMask;
+				current_property.ModFlags = (current_property.ModFlags & ~Modifiers.AccessibilityMask) | (modifiers & Modifiers.AccessibilityMask);
+				modifiers = (Modifiers) 0;
+			} else if ((modifiers & Modifiers.AccessibilityMask) == (current_property.ModFlags & Modifiers.AccessibilityMask)) {
+				modifiers = (Modifiers) 0;
+			}
+		}
+		
+		if (type.Type != null && type.Type.Kind == MemberKind.Void)
+			report.Error (547, GetLocation (yyVals[0+yyTop]), "`{0}': property or indexer cannot have void type", current_property.GetSignatureForError ());					
+			
+		if (current_property.Get != null) {
+			report.Error (1007, GetLocation (yyVals[-7+yyTop]), "Property accessor already defined");
+		}
+		
+		current_property.Get = new Property.GetMethod (current_property,
+			modifiers & Modifiers.AccessibilityMask, (Attributes) yyVals[-9+yyTop], GetLocation (yyVals[-7+yyTop]));
+	  
+		lbag.AddMember (current_property, GetModifierLocations (), GetLocation (yyVals[0+yyTop]));
+		current_local_parameters = current_property.Get.ParameterInfo;
+		yyVal = current_property.Get;
+	  }
+
+void case_184()
+#line 1735 "ps-parser.jay"
+{
+		var void_type = (FullNamedExpression) yyVals[0+yyTop];
+		var name = (MemberName) yyVals[-6+yyTop];
+		var modifiers = (Modifiers) yyVals[-8+yyTop];
+		var parameters = (ParametersCompiled) yyVals[-3+yyTop];
+		
+		if (current_container.Kind == MemberKind.Class && name.ExplicitInterface == null &&
+			(modifiers & (Modifiers.NEW | Modifiers.SEALED | Modifiers.STATIC | Modifiers.PRIVATE | Modifiers.VIRTUAL | Modifiers.OVERRIDE)) == 0)
+				modifiers |= Modifiers.VIRTUAL;
+		
+		if (void_type.Type != null && void_type.Type.Kind != MemberKind.Void)
+			report.Error (7003, GetLocation (yyVals[0+yyTop]), "Property setter function must not be of type void");					
+
+		current_property = null;
+						
+		MemberCore member;
+		if (current_type.DefinedNames.TryGetValue(name.Name, out member)) {
+			current_property = member as Property;
+		}
+
+		FullNamedExpression type; 
+		
+		if (parameters == null || parameters.Count != 1 || parameters.FixedParameters.Length != parameters.Count) {
+			report.Error (7001, GetLocation (yyVals[-3+yyTop]), "Property setter must have a single parameter");
+			type = new TypeExpression (compiler.BuiltinTypes.Int, GetLocation (yyVals[-3+yyTop]));
+		} else {
+			type = ((Parameter)parameters.FixedParameters[0]).TypeExpression;	
+		}
+				
+		if (current_property == null) {
+			current_property = new Property (current_type, type, modifiers, name, (Attributes) yyVals[-9+yyTop]);
+			if (is_config_enabled) {
+				current_type.AddMember (current_property);
+			}
+			is_config_enabled = true;
+			modifiers = (Modifiers) 0;			
+		} else {
+/*			if (!type.Equals(current_property.TypeExpression)) {*/
+/*				report.Error (7002, GetLocation ($10), "Type of property getter and setter must match", current_property.GetSignatureForError ());*/
+/*			}*/
+			if (current_property.Get != null && ModifiersExtensions.IsRestrictedModifier (current_property.ModFlags & Modifiers.AccessibilityMask, modifiers & Modifiers.AccessibilityMask)) {
+				current_property.Get.ModFlags |= current_property.ModFlags & Modifiers.AccessibilityMask;
+				current_property.ModFlags = (current_property.ModFlags & ~Modifiers.AccessibilityMask) | (modifiers & Modifiers.AccessibilityMask);
+				modifiers = (Modifiers) 0;
+			} else if ((modifiers & Modifiers.AccessibilityMask) == (current_property.ModFlags & Modifiers.AccessibilityMask)) {
+				modifiers = (Modifiers) 0;
+			}
+		}
+		
+		if (current_property.Set != null) {
+			report.Error (1007, GetLocation (yyVals[-7+yyTop]), "Property accessor already defined");
+		}
+		
+		current_property.Set = new Property.SetMethod (current_property, 
+			modifiers & Modifiers.AccessibilityMask, (ParametersCompiled) yyVals[-3+yyTop], (Attributes) yyVals[-9+yyTop], GetLocation (yyVals[-7+yyTop]));
+	  
+		lbag.AddMember (current_property, GetModifierLocations (), GetLocation (yyVals[0+yyTop]));
+		current_local_parameters = parameters;
+		yyVal = current_property.Set;
+	  }
+
+void case_186()
+#line 1804 "ps-parser.jay"
+{
+		lexer.parsing_generic_declaration = false;
+	  	valid_param_mod = ParameterModifierType.All;
+	  }
+
+void case_188()
+#line 1813 "ps-parser.jay"
+{
+		lexer.ConstraintsParsing = false;
+		valid_param_mod = 0;
+
+		MemberName name = (MemberName) yyVals[-8+yyTop];
+		current_local_parameters = (ParametersCompiled) yyVals[-5+yyTop];
+
+		var modifiers = (Modifiers) yyVals[-12+yyTop];
+		modifiers |= Modifiers.PARTIAL;
+
+		if (name.ExplicitInterface == null && (modifiers & (Modifiers.NEW | Modifiers.SEALED | Modifiers.STATIC | Modifiers.PRIVATE | Modifiers.VIRTUAL | Modifiers.OVERRIDE)) == 0)
+			modifiers |= Modifiers.VIRTUAL;
+			
+		var method = Method.Create (current_type, new TypeExpression (compiler.BuiltinTypes.Void, GetLocation (yyVals[-2+yyTop])),
+				     modifiers, name, current_local_parameters, (Attributes) yyVals[-13+yyTop]);
+
+		if (yyVals[0+yyTop] != null)
+			method.SetConstraints ((List<Constraints>) yyVals[0+yyTop]);
+
+		if (doc_support)
+			method.DocComment = Lexer.consume_doc_comment ();
+
+		StoreModifierLocation (Modifiers.PARTIAL, GetLocation (yyVals[-11+yyTop]));
+		lbag.AddMember (method, GetModifierLocations (), GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-4+yyTop]));
+		yyVal = method;
+	  }
+
+void case_189()
+#line 1843 "ps-parser.jay"
+{
+		MemberName name = (MemberName) yyVals[-5+yyTop];
+		report.Error (1585, name.Location, 
+			"Member modifier `{0}' must precede the member type and name", ModifiersExtensions.Name ((Modifiers) yyVals[-6+yyTop]));
+
+		var method = Method.Create (current_type, (FullNamedExpression) yyVals[-9+yyTop],
+					    0, name, (ParametersCompiled) yyVals[-3+yyTop], (Attributes) yyVals[-9+yyTop]);
+
+		current_local_parameters = (ParametersCompiled) yyVals[-3+yyTop];
+
+		if (doc_support)
+			method.DocComment = Lexer.consume_doc_comment ();
+
+		yyVal = method;
+	  }
+
+void case_190()
+#line 1862 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+		current_local_parameters = ParametersCompiled.Undefined;
+
+		MemberName name = (MemberName) yyVals[-1+yyTop];
+		var method = Method.Create (current_type, new TypeExpression (compiler.BuiltinTypes.Void, GetLocation (yyVals[-1+yyTop])), (Modifiers) yyVals[-3+yyTop],
+									name, current_local_parameters, (Attributes) yyVals[-4+yyTop]);
+
+		if (doc_support)
+			method.DocComment = Lexer.consume_doc_comment ();
+
+		yyVal = method;
+	  }
+
+void case_193()
+#line 1887 "ps-parser.jay"
+{
+		if (current_container.Kind == MemberKind.Interface) 
+			Lexer.AutoSemiInsertion = true;	  
+	  }
+
+void case_195()
+#line 1896 "ps-parser.jay"
+{ 
+	  	/* method body.*/
+	   	savedLocation = GetLocation (yyVals[0+yyTop]);
+	   	yyVal = null; 
+	  }
+
+void case_198()
+#line 1910 "ps-parser.jay"
+{
+		var pars_list = (List<Parameter>) yyVals[0+yyTop];
+	  	yyVal = new ParametersCompiled (pars_list.ToArray ());
+	  	lbag.AddLocation (yyVal, parameterListCommas);
+	  }
+
+void case_199()
+#line 1916 "ps-parser.jay"
+{
+		var pars_list = (List<Parameter>) yyVals[-2+yyTop];
+		pars_list.Add ((Parameter) yyVals[0+yyTop]);
+		parameterListCommas.Add (GetLocation (yyVals[-1+yyTop]));
+
+		yyVal = new ParametersCompiled (pars_list.ToArray ()); 
+	  	lbag.AddLocation (yyVal, parameterListCommas);		
+	  }
+
+void case_200()
+#line 1934 "ps-parser.jay"
+{
+		if (yyVals[-2+yyTop] != null)
+			report.Error (231, ((Parameter) yyVals[-2+yyTop]).Location, "A params parameter must be the last parameter in a formal parameter list");
+
+		yyVal = new ParametersCompiled (new Parameter[] { (Parameter) yyVals[-2+yyTop] } );			
+	  	lbag.AddLocation (yyVal, parameterListCommas);
+	  }
+
+void case_201()
+#line 1942 "ps-parser.jay"
+{
+		if (yyVals[-2+yyTop] != null)
+			report.Error (231, ((Parameter) yyVals[-2+yyTop]).Location, "A params parameter must be the last parameter in a formal parameter list");
+
+		var pars_list = (List<Parameter>) yyVals[-4+yyTop];
+		pars_list.Add (new ArglistParameter (GetLocation (yyVals[-2+yyTop])));
+		parameterListCommas.Add (GetLocation (yyVals[-3+yyTop]));
+		parameterListCommas.Add (GetLocation (yyVals[-1+yyTop]));
+
+		yyVal = new ParametersCompiled (pars_list.ToArray (), true);
+	  	lbag.AddLocation (yyVal, parameterListCommas);		
+	  }
+
+void case_203()
+#line 1982 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+		yyVal = ParametersCompiled.EmptyReadOnlyParameters;
+	  }
+
+void case_204()
+#line 1990 "ps-parser.jay"
+{
+		parameters_bucket.Clear ();
+		Parameter p = (Parameter) yyVals[0+yyTop];
+		parameters_bucket.Add (p);
+		parameterListCommas.Clear ();
+		default_parameter_used = p.HasDefaultValue;
+		yyVal = parameters_bucket;
+	  }
+
+void case_205()
+#line 1999 "ps-parser.jay"
+{
+		var pars = (List<Parameter>) yyVals[-2+yyTop];
+		Parameter p = (Parameter) yyVals[0+yyTop];
+		if (p != null) {
+			if (p.HasExtensionMethodModifier)
+				report.Error (1100, p.Location, "The parameter modifier `this' can only be used on the first parameter");
+			else if (!p.HasDefaultValue && default_parameter_used)
+				report.Error (1737, p.Location, "Optional parameter cannot precede required parameters");
+
+			default_parameter_used |= p.HasDefaultValue;
+			pars.Add (p);
+			
+			parameterListCommas.Add (GetLocation (yyVals[-1+yyTop]));
+		}
+		
+		yyVal = yyVals[-2+yyTop];
+	  }
+
+void case_206()
+#line 2024 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+		yyVal = new Parameter ((FullNamedExpression) yyVals[0+yyTop], lt.Value, (Parameter.Modifier) yyVals[-3+yyTop], (Attributes) yyVals[-4+yyTop], lt.Location);
+		lbag.AddLocation (yyVal, parameterModifierLocation);
+	  }
+
+void case_207()
+#line 2030 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+	  	Location l = GetLocation (yyVals[0+yyTop]);
+		yyVal = new Parameter (null, null, Parameter.Modifier.NONE, (Attributes) yyVals[-1+yyTop], l);
+	  }
+
+void case_208()
+#line 2040 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+	  	Location l = GetLocation (yyVals[0+yyTop]);
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+		yyVal = new Parameter (new TypeExpression (compiler.BuiltinTypes.Object, GetLocation (yyVals[0+yyTop])), lt.Value, (Parameter.Modifier) yyVals[-3+yyTop], (Attributes) yyVals[-4+yyTop], l);
+		lbag.AddLocation (yyVal, parameterModifierLocation);
+	  }
+
+void case_210()
+#line 2057 "ps-parser.jay"
+{
+	  	--lexer.parsing_block;
+		if (lang_version <= LanguageVersion.V_3) {
+			FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "optional parameter");
+		}
+		
+		Parameter.Modifier mod = (Parameter.Modifier) yyVals[-6+yyTop];
+		if (mod != Parameter.Modifier.NONE) {
+			switch (mod) {
+			case Parameter.Modifier.REF:
+			case Parameter.Modifier.OUT:
+				report.Error (1741, GetLocation (yyVals[-6+yyTop]), "Cannot specify a default value for the `{0}' parameter",
+					Parameter.GetModifierSignature (mod));
+				break;
+				
+			case Parameter.Modifier.This:
+				report.Error (1743, GetLocation (yyVals[-6+yyTop]), "Cannot specify a default value for the `{0}' parameter",
+					Parameter.GetModifierSignature (mod));
+				break;
+			default:
+				throw new NotImplementedException (mod.ToString ());
+			}
+				
+			mod = Parameter.Modifier.NONE;
+		}
+		
+		if ((valid_param_mod & ParameterModifierType.DefaultValue) == 0)
+			report.Error (1065, GetLocation (yyVals[-2+yyTop]), "Optional parameter is not valid in this context");
+		
+		var lt = (Tokenizer.LocatedToken) yyVals[-5+yyTop];
+		yyVal = new Parameter ((FullNamedExpression) yyVals[-3+yyTop], lt.Value, mod, (Attributes) yyVals[-7+yyTop], lt.Location);
+		lbag.AddLocation (yyVal, parameterModifierLocation, GetLocation (yyVals[-2+yyTop])); /* parameterModifierLocation should be ignored when mod == NONE*/
+		
+		if (yyVals[0+yyTop] != null)
+			((Parameter) yyVal).DefaultValue = new DefaultParameterValueExpression ((Expression) yyVals[0+yyTop]);
+	  }
+
+void case_214()
+#line 2106 "ps-parser.jay"
+{
+		Parameter.Modifier p2 = (Parameter.Modifier)yyVals[0+yyTop];
+  		Parameter.Modifier mod = (Parameter.Modifier)yyVals[-1+yyTop] | p2;
+  		if (((Parameter.Modifier)yyVals[-1+yyTop] & p2) == p2) {
+  			Error_DuplicateParameterModifier (lexer.Location, p2);
+  		} else {
+	  		switch (mod & ~Parameter.Modifier.This) {
+  				case Parameter.Modifier.REF:
+					report.Error (1101, lexer.Location, "The parameter modifiers `this' and `ref' cannot be used altogether");
+  					break;
+   				case Parameter.Modifier.OUT:
+					report.Error (1102, lexer.Location, "The parameter modifiers `this' and `out' cannot be used altogether");
+  					break;
+  				default:
+ 					report.Error (1108, lexer.Location, "A parameter cannot have specified more than one modifier");
+ 					break;
+ 			}
+  		}
+  		yyVal = mod;
+	  }
+
+void case_215()
+#line 2130 "ps-parser.jay"
+{
+	  	if ((valid_param_mod & ParameterModifierType.Ref) == 0)
+	  		Error_ParameterModifierNotValid ("ref", GetLocation (yyVals[0+yyTop]));
+	  		
+	  	yyVal = Parameter.Modifier.REF;
+	  }
+
+void case_216()
+#line 2137 "ps-parser.jay"
+{
+	  	if ((valid_param_mod & ParameterModifierType.Out) == 0)
+	  		Error_ParameterModifierNotValid ("out", GetLocation (yyVals[0+yyTop]));
+	  
+	  	yyVal = Parameter.Modifier.OUT;
+	  }
+
+void case_217()
+#line 2144 "ps-parser.jay"
+{
+		if ((valid_param_mod & ParameterModifierType.This) == 0)
+	  		Error_ParameterModifierNotValid ("this", GetLocation (yyVals[0+yyTop]));
+
+	  	if (lang_version <= LanguageVersion.ISO_2)
+	  		FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "extension methods");
+	  			
+		yyVal = Parameter.Modifier.This;
+	  }
+
+void case_218()
+#line 2157 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
+		var type = new ComposedCast (
+			new TypeExpression(compiler.BuiltinTypes.Object, GetLocation(yyVals[0+yyTop])),  
+			ComposedTypeSpecifier.CreateArrayDimension (1, GetLocation (yyVals[0+yyTop])));
+		yyVal = new ParamsParameter (type, lt.Value, (Attributes) yyVals[-2+yyTop], lt.Location);
+		lbag.AddLocation (yyVal, savedLocation);
+	  }
+
+void case_219()
+#line 2166 "ps-parser.jay"
+{
+		report.Error (1751, GetLocation (yyVals[-3+yyTop]), "Cannot specify a default value for a variable argument array");
+		
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+		var type = new ComposedCast (
+			new TypeExpression(compiler.BuiltinTypes.Object, GetLocation(yyVals[-2+yyTop])),  
+			ComposedTypeSpecifier.CreateArrayDimension (1, GetLocation (yyVals[-2+yyTop])));
+		yyVal = new ParamsParameter (type, lt.Value, (Attributes) yyVals[-4+yyTop], lt.Location);
+		lbag.AddLocation (yyVal, savedLocation);
+	  }
+
+void case_220()
+#line 2177 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+		
+		yyVal = new ParamsParameter ((FullNamedExpression) yyVals[0+yyTop], null, (Attributes) yyVals[-2+yyTop], Location.Null);
+	  }
+
+void case_221()
+#line 2219 "ps-parser.jay"
+{
+		if (doc_support)
+			tmpComment = Lexer.consume_doc_comment ();
+	  }
+
+void case_222()
+#line 2224 "ps-parser.jay"
+{
+		var type = (FullNamedExpression) yyVals[-2+yyTop];
+	
+		var modifiers = (Modifiers) yyVals[-6+yyTop];
+	
+		var name = (MemberName) yyVals[-4+yyTop];
+		
+		if (current_container.Kind == MemberKind.Class && name.ExplicitInterface == null && 
+			(modifiers & (Modifiers.NEW | Modifiers.SEALED | Modifiers.STATIC | Modifiers.PRIVATE | Modifiers.VIRTUAL | Modifiers.OVERRIDE)) == 0)
+				modifiers |= Modifiers.VIRTUAL;
+		
+		current_property = new Property (current_type, type, modifiers,
+			name, (Attributes) yyVals[-7+yyTop]);
+			
+		if (type.Type != null && type.Type.Kind == MemberKind.Void)
+			report.Error (547, GetLocation (yyVals[-5+yyTop]), "`{0}': property or indexer cannot have void type", current_property.GetSignatureForError ());					
+			
+		if (is_config_enabled) {
+			current_type.AddMember (current_property);
+		}
+		is_config_enabled = true;
+		lbag.AddMember (current_property, GetModifierLocations (), GetLocation (yyVals[0+yyTop]));
+		
+		lexer.PropertyParsing = true;
+	  }
+
+void case_223()
+#line 2250 "ps-parser.jay"
+{
+		lexer.PropertyParsing = false;
+		
+		if (doc_support)
+			current_property.DocComment = ConsumeStoredComment ();				
+	  }
+
+void case_224()
+#line 2257 "ps-parser.jay"
+{
+  		CheckIsPlayScript("property", GetLocation(yyVals[-9+yyTop])); 	
+  		  
+		lbag.AppendToMember (current_property, GetLocation (yyVals[0+yyTop]));
+		current_property = null;
+	  }
+
+void case_226()
+#line 2272 "ps-parser.jay"
+{
+		valid_param_mod = 0;
+		var type = (FullNamedExpression) yyVals[-1+yyTop];
+
+		var modifiers = (Modifiers) yyVals[-9+yyTop];
+		
+		var name = (MemberName) yyVals[-7+yyTop];
+
+		if (current_container.Kind == MemberKind.Class && name.ExplicitInterface == null && 
+			(modifiers & (Modifiers.NEW | Modifiers.SEALED | Modifiers.STATIC | Modifiers.PRIVATE | Modifiers.VIRTUAL | Modifiers.OVERRIDE)) == 0)
+				modifiers |= Modifiers.VIRTUAL;
+		
+		Indexer indexer = new Indexer (current_type, type, name, modifiers, (ParametersCompiled) yyVals[-4+yyTop], (Attributes) yyVals[-10+yyTop]);
+			
+		current_property = indexer;
+
+		if (is_config_enabled) {
+	  		current_type.AddIndexer (indexer);
+	  	}
+	  	is_config_enabled = true;
+		lbag.AddMember (current_property, GetModifierLocations (), GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-3+yyTop]));
+  		
+		if (type.Type != null && type.Type.Kind == MemberKind.Void)
+			report.Error (620, GetLocation (yyVals[-8+yyTop]), "`{0}': indexer return type cannot be `void'", indexer.GetSignatureForError ());  		
+
+		if (indexer.ParameterInfo.IsEmpty) {
+			report.Error (1551, GetLocation (yyVals[-6+yyTop]), "Indexers must have at least one parameter");
+		}
+
+		if (doc_support) {
+			tmpComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.Allowed;
+		}
+
+		lexer.PropertyParsing = true;
+	  }
+
+void case_228()
+#line 2313 "ps-parser.jay"
+{
+  		CheckIsPlayScript("indexer", GetLocation(yyVals[-12+yyTop])); 	
+	  
+		if (current_property.AccessorFirst != null && current_property.AccessorFirst.Block == null)
+			((Indexer) current_property).ParameterInfo.CheckParameters (current_property);
+	  
+		if (doc_support)
+			current_property.DocComment = ConsumeStoredComment ();
+			
+		lbag.AppendToMember (current_property, GetLocation (yyVals[-3+yyTop]));
+		current_property = null;		
+	  }
+
+void case_233()
+#line 2334 "ps-parser.jay"
+{
+	  	if (yyToken == Token.CLOSE_BRACE) {
+	  		report.Error (548, lexer.Location, "`{0}': property or indexer must have at least one accessor", current_property.GetSignatureForError ());
+		} else {
+			if (yyToken == Token.SEMICOLON)
+				report.Error (1597, lexer.Location, "Semicolon after method or accessor block is not valid");
+			else
+				report.Error (1014, GetLocation (yyVals[0+yyTop]), "A get or set accessor expected");
+		}
+	  }
+
+void case_234()
+#line 2348 "ps-parser.jay"
+{
+		if (yyVals[-1+yyTop] != ModifierNone && lang_version == LanguageVersion.ISO_1) {
+			FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "access modifiers on properties");
+		}
+	  
+		if (current_property.Get != null) {
+			report.Error (1007, GetLocation (yyVals[0+yyTop]), "Property accessor already defined");
+		}
+		
+		if (current_property is Indexer) {
+			current_property.Get = new Indexer.GetIndexerMethod (current_property, (Modifiers) yyVals[-1+yyTop], ((Indexer)current_property).ParameterInfo.Clone (),
+				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
+		} else {
+			current_property.Get = new Property.GetMethod (current_property,
+				(Modifiers) yyVals[-1+yyTop], (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
+		}	
+	  
+		current_local_parameters = current_property.Get.ParameterInfo;	  
+		lbag.AddMember (current_property.Get, GetModifierLocations ());
+		lexer.PropertyParsing = false;
+	  }
+
+void case_235()
+#line 2370 "ps-parser.jay"
+{
+	  	if (yyVals[0+yyTop] != null) {
+	  		current_property.Get.Block = (ToplevelBlock) yyVals[0+yyTop];			
+	  	
+			if (current_container.Kind == MemberKind.Interface) {
+				report.Error (531, current_property.Get.Block.StartLocation,
+					"`{0}': interface members cannot have a definition", current_property.Get.GetSignatureForError ());
+			}
+			lbag.AddMember (current_property.Get, GetModifierLocations ());
+		} else {
+			lbag.AddMember (current_property.Get, GetModifierLocations (), savedLocation);
+		}
+	  
+		current_local_parameters = null;
+		lexer.PropertyParsing = true;
+
+		if (doc_support)
+			if (Lexer.doc_state == XmlCommentState.Error)
+				Lexer.doc_state = XmlCommentState.NotAllowed;
+	  }
+
+void case_236()
+#line 2394 "ps-parser.jay"
+{
+		if (yyVals[-1+yyTop] != ModifierNone && lang_version == LanguageVersion.ISO_1) {
+			FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "access modifiers on properties");
+		}
+		
+		if (current_property.Set != null) {
+			report.Error (1007, GetLocation (yyVals[0+yyTop]), "Property accessor already defined");
+		}
+	  
+		if (current_property is Indexer) {
+			current_property.Set = new Indexer.SetIndexerMethod (current_property, (Modifiers) yyVals[-1+yyTop],
+				ParametersCompiled.MergeGenerated (compiler,
+				((Indexer)current_property).ParameterInfo, true, new Parameter (
+					current_property.TypeExpression, "value", Parameter.Modifier.NONE, null, GetLocation (yyVals[0+yyTop])),
+					null),
+				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
+		} else {
+			current_property.Set = new Property.SetMethod (current_property, (Modifiers) yyVals[-1+yyTop], 
+				ParametersCompiled.CreateImplicitParameter (current_property.TypeExpression, GetLocation (yyVals[0+yyTop])),
+				(Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
+		}
+		
+		current_local_parameters = current_property.Set.ParameterInfo;	
+		lexer.PropertyParsing = false;
+	  }
+
+void case_237()
+#line 2420 "ps-parser.jay"
+{
+		if (yyVals[0+yyTop] != null) {		
+			current_property.Set.Block = (ToplevelBlock) yyVals[0+yyTop];
+		
+			if (current_container.Kind == MemberKind.Interface) {
+				report.Error (531, current_property.Set.Block.StartLocation,
+					"`{0}': interface members cannot have a definition", current_property.Set.GetSignatureForError ());
+			}
+			lbag.AddMember (current_property.Set, GetModifierLocations ());
+		} else {
+			lbag.AddMember (current_property.Set, GetModifierLocations (), savedLocation);
+		}
+		
+		current_local_parameters = null;
+		lexer.PropertyParsing = true;
+
+		if (doc_support
+			&& Lexer.doc_state == XmlCommentState.Error)
+			Lexer.doc_state = XmlCommentState.NotAllowed;
+	  }
+
+void case_239()
+#line 2445 "ps-parser.jay"
+{
+		savedLocation = GetLocation (yyVals[0+yyTop]);
+	  	yyVal = null;
+	  }
+
+void case_240()
+#line 2450 "ps-parser.jay"
+{
+	  	Error_SyntaxError (1043, yyToken, "Invalid accessor body");
+	  	yyVal = null;
+	  }
+
+void case_242()
+#line 2465 "ps-parser.jay"
+{
+		lexer.ConstraintsParsing = true;	  
+	    bool is_partial = IsPartial(yyVals[-5+yyTop]) || yyVals[-3+yyTop] != null;
+		push_current_container (new Interface (current_container, (MemberName) yyVals[0+yyTop], (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), is_partial);
+		lbag.AddMember (current_container, GetModifierLocations (), GetLocation (yyVals[-2+yyTop]));		
+	  }
+
+void case_243()
+#line 2474 "ps-parser.jay"
+{
+		lexer.ConstraintsParsing = false;
+
+		if (yyVals[0+yyTop] != null)
+			current_container.SetConstraints ((List<Constraints>) yyVals[0+yyTop]);
+
+		if (doc_support) {
+			current_container.PartialContainer.DocComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.Allowed;
+		}
+		
+		lexer.parsing_modifiers = true;
+	  }
+
+void case_245()
+#line 2492 "ps-parser.jay"
+{
+		--lexer.parsing_declaration;	  
+		if (doc_support)
+			Lexer.doc_state = XmlCommentState.Allowed;
+	  }
+
+void case_246()
+#line 2498 "ps-parser.jay"
+{
+	    lbag.AppendToMember (current_container, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]));
+		yyVal = pop_current_class ();
+	  }
+
+void case_261()
+#line 2556 "ps-parser.jay"
+{
+		OperatorDeclaration decl = (OperatorDeclaration) yyVals[-2+yyTop];
+		if (decl != null) {
+			var modifiers = (Modifiers) yyVals[-3+yyTop];
+			
+/*			if (current_container.Kind == MemberKind.Class && */
+/*				(modifiers & (Modifiers.NEW | Modifiers.SEALED | Modifiers.STATIC | Modifiers.PRIVATE | Modifiers.VIRTUAL | Modifiers.OVERRIDE)) == 0)*/
+/*					modifiers |= Modifiers.VIRTUAL;			*/
+		
+			if (current_local_parameters.Count < 1) {
+			
+				report.Error (7037, GetLocation (yyVals[-4+yyTop]), "Invalid number of parameters for operator.");			
+			
+			} else {
+			
+				Operator op = new Operator (
+					current_type, decl.optype, decl.ret_type, modifiers, 
+					current_local_parameters,
+					(ToplevelBlock) yyVals[0+yyTop], (Attributes) yyVals[-4+yyTop], decl.location);
+				
+				if (op.Block == null)
+					op.ParameterInfo.CheckParameters (op);
+
+				if (doc_support) {
+					op.DocComment = tmpComment;
+					Lexer.doc_state = XmlCommentState.Allowed;
+				}
+
+				/* Note again, checking is done in semantic analysis*/
+				if (is_config_enabled) {
+					current_type.AddOperator (op);
+				}
+				is_config_enabled = true;
+
+				lbag.AddMember (op, GetModifierLocations (), lbag.GetLocations (decl));
+				if (yyVals[0+yyTop] == null) { /* Semicolon*/
+					lbag.AppendTo (op, savedLocation);
+				}
+			}
+		}
+		
+		current_local_parameters = null;
+	  }
+
+void case_265()
+#line 2609 "ps-parser.jay"
+{
+		report.Error (590, GetLocation (yyVals[0+yyTop]), "User-defined operators cannot return void");
+		yyVal = new TypeExpression (compiler.BuiltinTypes.Void, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_267()
+#line 2621 "ps-parser.jay"
+{
+		CheckIsPlayScript("operator", GetLocation(yyVals[-7+yyTop])); 	  
+	  
+		valid_param_mod = 0;
+
+		Location loc = GetLocation (yyVals[-7+yyTop]);
+		Operator.OpType op = (Operator.OpType) yyVals[0+yyTop];
+		current_local_parameters = (ParametersCompiled)yyVals[-3+yyTop];
+		
+		int p_count = current_local_parameters.Count;
+		if (p_count == 1) {
+			if (op == Operator.OpType.Addition)
+				op = Operator.OpType.UnaryPlus;
+			else if (op == Operator.OpType.Subtraction)
+				op = Operator.OpType.UnaryNegation;
+		}
+		
+		if (IsUnaryOperator (op)) {
+			if (p_count == 2) {
+				report.Error (1020, loc, "Overloadable binary operator expected");
+			} else if (p_count != 1) {
+				report.Error (1535, loc, "Overloaded unary operator `{0}' takes one parameter",
+					Operator.GetName (op));
+			}
+		} else {
+			if (p_count > 2) {
+				report.Error (1534, loc, "Overloaded binary operator `{0}' takes two parameters",
+					Operator.GetName (op));
+			} else if (p_count != 2) {
+				report.Error (1019, loc, "Overloadable unary operator expected");
+			}
+		}
+		
+		if (doc_support) {
+			tmpComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.NotAllowed;
+		}
+
+		yyVal = new OperatorDeclaration (op, (FullNamedExpression) yyVals[0+yyTop], loc);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_294()
+#line 2701 "ps-parser.jay"
+{
+		valid_param_mod = 0;
+
+		Location loc = GetLocation (yyVals[-5+yyTop]);
+		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];  
+		  
+		if (doc_support) {
+			tmpComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.NotAllowed;
+		}
+
+		yyVal = new OperatorDeclaration (Operator.OpType.Implicit, (FullNamedExpression) yyVals[-4+yyTop], loc);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_296()
+#line 2720 "ps-parser.jay"
+{
+		valid_param_mod = 0;
+		
+		Location loc = GetLocation (yyVals[-5+yyTop]);
+		current_local_parameters = (ParametersCompiled)yyVals[-1+yyTop];  
+		  
+		if (doc_support) {
+			tmpComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.NotAllowed;
+		}
+
+		yyVal = new OperatorDeclaration (Operator.OpType.Explicit, (FullNamedExpression) yyVals[-4+yyTop], loc);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_297()
+#line 2735 "ps-parser.jay"
+{
+	  	Error_SyntaxError (yyToken);
+		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
+		yyVal = new OperatorDeclaration (Operator.OpType.Implicit, null, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_298()
+#line 2741 "ps-parser.jay"
+{
+	  	Error_SyntaxError (yyToken);
+		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
+	  	yyVal = new OperatorDeclaration (Operator.OpType.Explicit, null, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_299()
+#line 2880 "ps-parser.jay"
+{
+		if (doc_support) {
+			tmpComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.NotAllowed;
+		}
+		
+		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
+	  }
+
+void case_300()
+#line 2889 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
+		if (lt.Value != current_container.MemberName.Name){
+			report.Error (574, lt.Location, "Name of destructor must match name of class");
+		} else if (current_container.Kind != MemberKind.Class){
+			report.Error (575, lt.Location, "Only class types can contain destructor");
+		}
+		
+		Destructor d = new Destructor (current_type, (Modifiers) yyVals[-7+yyTop],
+			ParametersCompiled.EmptyReadOnlyParameters, (Attributes) yyVals[-8+yyTop], lt.Location);
+		if (doc_support)
+			d.DocComment = ConsumeStoredComment ();
+		  
+		d.Block = (ToplevelBlock) yyVals[0+yyTop];
+		if (is_config_enabled) {
+			current_type.AddMember (d);
+		}
+		is_config_enabled = true;
+		lbag.AddMember (d, GetModifierLocations (), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[-1+yyTop]));
+
+		current_local_parameters = null;
+	  }
+
+void case_301()
+#line 2917 "ps-parser.jay"
+{
+		current_event_field = new EventField (current_type, (FullNamedExpression) yyVals[0+yyTop], (Modifiers) yyVals[-4+yyTop], (MemberName) yyVals[-2+yyTop], (Attributes) yyVals[-5+yyTop]);
+		if (is_config_enabled) {
+			current_type.AddMember (current_event_field);
+		}
+		is_config_enabled = true;
+		
+		if (current_event_field.MemberName.ExplicitInterface != null) {
+			report.Error (71, current_event_field.Location, "`{0}': An explicit interface implementation of an event must use property syntax",
+			current_event_field.GetSignatureForError ());
+		}
+		
+		yyVal = current_event_field;
+	  }
+
+void case_302()
+#line 2934 "ps-parser.jay"
+{
+		if (doc_support) {
+			current_event_field.DocComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.Allowed;
+		}
+		if (current_event_field.Initializer != null) {
+			lbag.AddMember (current_event_field, GetModifierLocations (), GetLocation (yyVals[-7+yyTop]), savedEventAssignLocation, GetLocation (yyVals[0+yyTop]));
+		} else {
+			lbag.AddMember (current_event_field, GetModifierLocations (), GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[0+yyTop]));
+		}
+		current_event_field = null;
+	  }
+
+void case_303()
+#line 2950 "ps-parser.jay"
+{
+		current_event = new EventProperty (current_type, (FullNamedExpression) yyVals[-1+yyTop], (Modifiers) yyVals[-5+yyTop], (MemberName) yyVals[-3+yyTop], (Attributes) yyVals[-6+yyTop]);
+		if (is_config_enabled) {
+			current_type.AddMember (current_event);
+		}
+		is_config_enabled = true;
+		lbag.AddMember (current_event, GetModifierLocations (), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[0+yyTop]));
+		
+		lexer.EventParsing = true;
+	  }
+
+void case_304()
+#line 2961 "ps-parser.jay"
+{
+		if (current_container.Kind == MemberKind.Interface)
+			report.Error (69, GetLocation (yyVals[-2+yyTop]), "Event in interface cannot have add or remove accessors");
+	  
+		lexer.EventParsing = false;
+	  }
+
+void case_305()
+#line 2968 "ps-parser.jay"
+{
+		if (doc_support) {
+			current_event.DocComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.Allowed;
+		}
+		
+		lbag.AppendToMember (current_event, GetLocation (yyVals[-1+yyTop]));
+	  	current_event = null;	
+		current_local_parameters = null;
+	  }
+
+void case_308()
+#line 2987 "ps-parser.jay"
+{
+	  	--lexer.parsing_block;
+		current_event_field.Initializer = (Expression) yyVals[0+yyTop];
+	  }
+
+void case_313()
+#line 3011 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null, (FullNamedExpression) yyVals[0+yyTop]);
+	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-3+yyTop]));
+	  }
+
+void case_315()
+#line 3021 "ps-parser.jay"
+{
+		--lexer.parsing_block;
+		var lt = (Tokenizer.LocatedToken) yyVals[-5+yyTop];	  
+	  	yyVal = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) yyVals[0+yyTop], (FullNamedExpression) yyVals[-3+yyTop]);
+	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_316()
+#line 3030 "ps-parser.jay"
+{
+		if (current_container.Kind == MemberKind.Interface) {
+			report.Error (68, lexer.Location, "`{0}': event in interface cannot have an initializer",
+				current_event_field.GetSignatureForError ());
+		}
+		
+	  	if ((current_event_field.ModFlags & Modifiers.ABSTRACT) != 0) {
+			report.Error (74, lexer.Location, "`{0}': abstract event cannot have an initializer",
+				current_event_field.GetSignatureForError ());
+	  	}		
+	  }
+
+void case_320()
+#line 3051 "ps-parser.jay"
+{
+		report.Error (65, lexer.Location, "`{0}': event property must have both add and remove accessors",
+			current_event.GetSignatureForError ());
+	  }
+
+void case_321()
+#line 3056 "ps-parser.jay"
+{
+		report.Error (65, lexer.Location, "`{0}': event property must have both add and remove accessors",
+			current_event.GetSignatureForError ());
+	  }
+
+void case_322()
+#line 3061 "ps-parser.jay"
+{ 
+		report.Error (1055, GetLocation (yyVals[0+yyTop]), "An add or remove accessor expected");
+		yyVal = null;
+	  }
+
+void case_323()
+#line 3069 "ps-parser.jay"
+{
+	  	if (yyVals[-1+yyTop] != ModifierNone) {
+			report.Error (1609, GetLocation (yyVals[-1+yyTop]), "Modifiers cannot be placed on event accessor declarations");
+	  	}
+	  	
+	  	current_event.Add = new EventProperty.AddDelegateMethod (current_event, (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
+		current_local_parameters = current_event.Add.ParameterInfo;
+		
+		lbag.AddMember (current_event.Add, GetModifierLocations ());
+		lexer.EventParsing = false;		
+	  }
+
+void case_324()
+#line 3081 "ps-parser.jay"
+{
+		lexer.EventParsing = true;
+	  
+	  	current_event.Add.Block = (ToplevelBlock) yyVals[0+yyTop];
+		
+		if (current_container.Kind == MemberKind.Interface) {
+			report.Error (531, current_event.Add.Block.StartLocation,
+				"`{0}': interface members cannot have a definition", current_event.Add.GetSignatureForError ());
+		}
+		
+		current_local_parameters = null;
+	  }
+
+void case_325()
+#line 3097 "ps-parser.jay"
+{
+	  	if (yyVals[-1+yyTop] != ModifierNone) {
+			report.Error (1609, GetLocation (yyVals[-1+yyTop]), "Modifiers cannot be placed on event accessor declarations");
+	  	}
+	  	
+	  	current_event.Remove = new EventProperty.RemoveDelegateMethod (current_event, (Attributes) yyVals[-2+yyTop], GetLocation (yyVals[0+yyTop]));
+		current_local_parameters = current_event.Remove.ParameterInfo;
+
+		lbag.AddMember (current_event.Remove, GetModifierLocations ());
+		lexer.EventParsing = false;		
+	  }
+
+void case_326()
+#line 3109 "ps-parser.jay"
+{
+		lexer.EventParsing = true;
+	  
+	  	current_event.Remove.Block = (ToplevelBlock) yyVals[0+yyTop];
+		
+		if (current_container.Kind == MemberKind.Interface) {
+			report.Error (531, current_event.Remove.Block.StartLocation,
+				"`{0}': interface members cannot have a definition", current_event.Remove.GetSignatureForError ());
+		}
+		
+		current_local_parameters = null;
+	  }
+
+void case_327()
+#line 3125 "ps-parser.jay"
+{
+		report.Error (73, lexer.Location, "An add or remove accessor must have a body");
+		yyVal = null;
+	  }
+
+void case_329()
+#line 3134 "ps-parser.jay"
+{
+		current_type.UnattachedAttributes = (Attributes) yyVals[-1+yyTop];
+		report.Error (1519, GetLocation (yyVals[-1+yyTop]), "An attribute is missing member declaration");
+		lexer.putback ('}');
+	  }
+
+void case_330()
+#line 3146 "ps-parser.jay"
+{
+		if (doc_support)
+			enumTypeComment = Lexer.consume_doc_comment ();
+	  }
+
+void case_331()
+#line 3151 "ps-parser.jay"
+{
+		if (doc_support)
+			Lexer.doc_state = XmlCommentState.Allowed;
+
+		MemberName name = (MemberName) yyVals[-3+yyTop];
+		if (name.IsGeneric) {
+			report.Error (1675, name.Location, "Enums cannot have type parameters");
+		}
+		
+		push_current_container (new Enum (current_container, (FullNamedExpression) yyVals[-2+yyTop], (Modifiers) yyVals[-5+yyTop], name, (Attributes) yyVals[-6+yyTop]), null);
+	  }
+
+void case_332()
+#line 3163 "ps-parser.jay"
+{
+	  	/* here will be evaluated after CLOSE_BLACE is consumed.*/
+		if (doc_support)
+			Lexer.doc_state = XmlCommentState.Allowed;
+	  }
+
+void case_333()
+#line 3169 "ps-parser.jay"
+{
+	  	CheckIsPlayScript("enum", GetLocation(yyVals[-9+yyTop]));
+	  
+		if (doc_support)
+			current_container.DocComment = enumTypeComment;
+			
+		--lexer.parsing_declaration;
+
+/*			if (doc_support)*/
+/*				em.DocComment = ev.DocComment;*/
+
+		lbag.AddMember (current_container, GetModifierLocations (), GetLocation (yyVals[-9+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-1+yyTop]));
+		yyVal = pop_current_class ();
+	  }
+
+void case_335()
+#line 3188 "ps-parser.jay"
+{
+	 	var te = yyVals[0+yyTop] as TypeExpression;
+		if (te == null || !EnumSpec.IsValidUnderlyingType (te.Type)) {
+			Enum.Error_1008 (GetLocation (yyVals[0+yyTop]), report);
+		}
+		yyVal = yyVals[0+yyTop];
+	 }
+
+void case_336()
+#line 3196 "ps-parser.jay"
+{
+	 	Error_TypeExpected (GetLocation (yyVals[-1+yyTop]));
+		yyVal = null;
+	 }
+
+void case_341()
+#line 3214 "ps-parser.jay"
+{
+	  	lbag.AddLocation (yyVals[-2+yyTop], GetLocation (yyVals[-1+yyTop]));
+	  	yyVal = yyVals[0+yyTop];
+	  }
+
+void case_342()
+#line 3222 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
+	  	var em = new EnumMember ((Enum) current_type, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-1+yyTop]);
+	  	((Enum) current_type).AddEnumMember (em);
+
+		if (doc_support) {
+			em.DocComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.Allowed;
+		}
+
+		yyVal = em;
+	  }
+
+void case_343()
+#line 3235 "ps-parser.jay"
+{
+	  	++lexer.parsing_block;
+		if (doc_support) {
+			tmpComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.NotAllowed;
+		}
+	  }
+
+void case_344()
+#line 3243 "ps-parser.jay"
+{ 
+		--lexer.parsing_block;
+		
+		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
+	  	var em = new EnumMember ((Enum) current_type, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-4+yyTop]);
+	  	em.Initializer = new ConstInitializer (em, (Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
+	  	((Enum) current_type).AddEnumMember (em);
+		
+		if (doc_support)
+			em.DocComment = ConsumeStoredComment ();
+
+		yyVal = em;
+	  }
+
+void case_345()
+#line 3257 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+	  
+		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
+	  	var em = new EnumMember ((Enum) current_type, new MemberName (lt.Value, lt.Location), (Attributes) yyVals[-2+yyTop]);
+	  	((Enum) current_type).AddEnumMember (em);
+
+		if (doc_support) {
+			em.DocComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.Allowed;
+		}
+
+		yyVal = em;
+	  }
+
+void case_348()
+#line 3284 "ps-parser.jay"
+{
+		valid_param_mod = 0;
+
+		ParametersCompiled p = (ParametersCompiled) yyVals[-3+yyTop];
+
+		Delegate del = new Delegate (current_container, (FullNamedExpression) yyVals[0+yyTop], (Modifiers) yyVals[-8+yyTop], (MemberName) yyVals[-6+yyTop], p, (Attributes) yyVals[-9+yyTop]);
+
+		p.CheckParameters (del);
+
+		current_container.AddTypeContainer (del);
+
+		current_delegate = del;
+		lexer.ConstraintsParsing = true;
+	  }
+
+void case_350()
+#line 3303 "ps-parser.jay"
+{
+	  	CheckIsPlayScript("delegate", GetLocation(yyVals[-11+yyTop]));
+	  	
+		if (doc_support) {
+			current_delegate.DocComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.Allowed;
+		}
+	  
+		if (yyVals[-2+yyTop] != null)
+			current_delegate.SetConstraints ((List<Constraints>) yyVals[-2+yyTop]);
+		lbag.AddMember (current_delegate, GetModifierLocations (), GetLocation (yyVals[-11+yyTop]), GetLocation (yyVals[-9+yyTop]), GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[0+yyTop]));
+
+		yyVal = current_delegate;
+
+		current_delegate = null;
+	  }
+
+void case_351()
+#line 3326 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];	  
+		MemberName className = new MemberName(lt.Value + "_ns", GetLocation(yyVals[-2+yyTop]));
+		push_current_container(new Class (current_container, className, (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]), GetLocation(yyVals[-3+yyTop]));	  
+		pop_current_class();
+			  
+	  	if (doc_support) {
+			current_delegate.DocComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.Allowed;
+		}
+	  }
+
+void case_354()
+#line 3346 "ps-parser.jay"
+{
+	  	if (!(yyVals[0+yyTop] is StringLiteral))
+	  		syntax_error (GetLocation(yyVals[0+yyTop]), "string literal expected");
+	  	yyVal = yyVals[0+yyTop];
+	  }
+
+void case_356()
+#line 3356 "ps-parser.jay"
+{
+		if (lang_version < LanguageVersion.ISO_2)
+			FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "nullable types");
+	  
+	  	yyVal = ComposedTypeSpecifier.CreateNullable (GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_359()
+#line 3379 "ps-parser.jay"
+{
+	    /* member_name*/
+		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
+		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_360()
+#line 3389 "ps-parser.jay"
+{
+	    /* simple_name_expr*/
+		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
+		yyVal = new SimpleName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);
+	  }
+
+void case_362()
+#line 3402 "ps-parser.jay"
+{
+		if (lang_version < LanguageVersion.ISO_2)
+			FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "generics");	  
+	  
+		yyVal = yyVals[-1+yyTop];
+	  }
+
+void case_363()
+#line 3409 "ps-parser.jay"
+{
+		Error_TypeExpected (lexer.Location);
+		yyVal = new TypeArguments ();
+	  }
+
+void case_364()
+#line 3417 "ps-parser.jay"
+{
+		TypeArguments type_args = new TypeArguments ();
+		type_args.Add ((FullNamedExpression) yyVals[0+yyTop]);
+		yyVal = type_args;
+	  }
+
+void case_365()
+#line 3423 "ps-parser.jay"
+{
+		TypeArguments type_args = (TypeArguments) yyVals[-2+yyTop];
+		type_args.Add ((FullNamedExpression) yyVals[0+yyTop]);
+		yyVal = type_args;
+	  }
+
+void case_367()
+#line 3439 "ps-parser.jay"
+{
+		lexer.parsing_generic_declaration = false;
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+		yyVal = new MemberName (lt.Value, (TypeParameters)yyVals[0+yyTop], lt.Location);
+	  }
+
+void case_368()
+#line 3448 "ps-parser.jay"
+{
+	  	MemberName mn = (MemberName)yyVals[0+yyTop];
+	  	if (mn.TypeParameters != null)
+	  		syntax_error (mn.Location, string.Format ("Member `{0}' cannot declare type arguments",
+	  			mn.GetSignatureForError ()));
+	  }
+
+void case_370()
+#line 3459 "ps-parser.jay"
+{
+		lexer.parsing_generic_declaration = false;	  
+		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
+		yyVal = new MemberName (lt.Value, (TypeParameters) yyVals[0+yyTop], (ATypeNameExpression) yyVals[-2+yyTop], lt.Location);
+	  }
+
+void case_371()
+#line 3468 "ps-parser.jay"
+{
+		lexer.parsing_generic_declaration = false;	  
+		yyVal = new MemberName (TypeDefinition.DefaultIndexerName, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_372()
+#line 3473 "ps-parser.jay"
+{
+		lexer.parsing_generic_declaration = false;
+		yyVal = new MemberName (TypeDefinition.DefaultIndexerName, null, (ATypeNameExpression) yyVals[-1+yyTop], GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_373()
+#line 3481 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+		yyVal = new SimpleName (lt.Value, (TypeArguments) yyVals[-1+yyTop], lt.Location);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_374()
+#line 3495 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+		yyVal = new MemberAccess ((ATypeNameExpression) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[-1+yyTop], lt.Location);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_376()
+#line 3505 "ps-parser.jay"
+{
+		if (lang_version < LanguageVersion.ISO_2)
+			FeatureIsNotAvailable (GetLocation (yyVals[-2+yyTop]), "generics");
+	  
+		yyVal = yyVals[-1+yyTop];
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_377()
+#line 3516 "ps-parser.jay"
+{
+		var tparams = new TypeParameters ();
+		tparams.Add ((TypeParameter)yyVals[0+yyTop]);
+		yyVal = tparams;
+	  }
+
+void case_378()
+#line 3522 "ps-parser.jay"
+{
+		var tparams = (TypeParameters) yyVals[-2+yyTop];
+		tparams.Add ((TypeParameter)yyVals[0+yyTop]);
+		yyVal = tparams;
+		lbag.AddLocation (yyVals[0+yyTop], GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_379()
+#line 3532 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken)yyVals[0+yyTop];
+		yyVal = new TypeParameter (new MemberName (lt.Value, lt.Location), (Attributes)yyVals[-2+yyTop], (Variance) yyVals[-1+yyTop]);
+  	  }
+
+void case_380()
+#line 3537 "ps-parser.jay"
+{
+  	  	if (GetTokenName (yyToken) == "type")
+			report.Error (81, GetLocation (yyVals[0+yyTop]), "Type parameter declaration must be an identifier not a type");
+		else
+			Error_SyntaxError (yyToken);
+			
+  	  	yyVal = new TypeParameter (MemberName.Null, null, Variance.None);
+  	  }
+
+void case_385()
+#line 3571 "ps-parser.jay"
+{
+	  	Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), report);
+		yyVal = new TypeExpression (compiler.BuiltinTypes.Void, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_387()
+#line 3580 "ps-parser.jay"
+{
+	  	Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), report);
+		yyVal = new TypeExpression (compiler.BuiltinTypes.Void, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_389()
+#line 3589 "ps-parser.jay"
+{
+	  	report.Error (1536, GetLocation (yyVals[0+yyTop]), "Invalid parameter type `void'");
+		yyVal = new TypeExpression (compiler.BuiltinTypes.Void, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_391()
+#line 3598 "ps-parser.jay"
+{
+	  	CheckIsPlayScript("arrays", GetLocation(yyVals[0+yyTop]));
+		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
+	  }
+
+void case_392()
+#line 3606 "ps-parser.jay"
+{
+		if (yyVals[0+yyTop] != null) {
+			yyVal = new ComposedCast ((ATypeNameExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
+		} else {
+			var sn = yyVals[-1+yyTop] as SimpleName;
+			if (sn != null)
+				yyVal = ConvertAsType(sn, yyVals[-1+yyTop]);
+			else
+				yyVal = yyVals[-1+yyTop];
+		}
+	  }
+
+void case_394()
+#line 3626 "ps-parser.jay"
+{
+		if (yyVals[0+yyTop] != null)
+			yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
+	  }
+
+void case_395()
+#line 3642 "ps-parser.jay"
+{
+		var types = new List<FullNamedExpression> (2);
+		types.Add ((FullNamedExpression) yyVals[0+yyTop]);
+		yyVal = types;
+	  }
+
+void case_396()
+#line 3648 "ps-parser.jay"
+{
+		var types = (List<FullNamedExpression>) yyVals[-2+yyTop];
+		types.Add ((FullNamedExpression) yyVals[0+yyTop]);
+		yyVal = types;
+	  }
+
+void case_397()
+#line 3657 "ps-parser.jay"
+{
+		if (yyVals[0+yyTop] is ComposedCast) {
+			report.Error (1521, GetLocation (yyVals[0+yyTop]), "Invalid base type `{0}'", ((ComposedCast)yyVals[0+yyTop]).GetSignatureForError ());
+		}
+		yyVal = yyVals[0+yyTop];
+	  }
+
+void case_428()
+#line 3730 "ps-parser.jay"
+{
+	    /* primary_expression_or_type*/
+		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
+		yyVal = new SimpleName (lt.Value, (TypeArguments)yyVals[0+yyTop], lt.Location);	  
+	  }
+
+void case_429()
+#line 3735 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
+	       yyVal = new CompletionSimpleName (MemberName.MakeName (lt.Value, null), lt.Location);
+	  }
+
+void case_441()
+#line 3777 "ps-parser.jay"
+{
+		yyVal = new ParenthesizedExpression ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_443()
+#line 3789 "ps-parser.jay"
+{
+	    /* member_access*/
+		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
+		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_444()
+#line 3797 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
+		var ma = new MemberAccess ((Expression) yyVals[-2+yyTop], lt.Value, null, lt.Location);
+		ma.AccessorType = MemberAccess.Accessor.AsE4xChildAttribute;
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+		yyVal = ma;
+	  }
+
+void case_445()
+#line 3805 "ps-parser.jay"
+{
+		var ma = new MemberAccess ((Expression) yyVals[-1+yyTop], "any", null, GetLocation(yyVals[0+yyTop]));
+		ma.AccessorType = MemberAccess.Accessor.AsE4xChildAll;
+		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+		yyVal = ma;
+	  }
+
+void case_446()
+#line 3812 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
+		var ma = new MemberAccess ((Expression) yyVals[-2+yyTop], lt.Value, null, lt.Location);
+		ma.AccessorType = MemberAccess.Accessor.AsE4xDescendant;
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+		yyVal = ma;
+	  }
+
+void case_447()
+#line 3820 "ps-parser.jay"
+{
+		var ma = new MemberAccess ((Expression) yyVals[-1+yyTop], "any", null, GetLocation(yyVals[0+yyTop]));
+		ma.AccessorType = MemberAccess.Accessor.AsE4xDescendantAll;
+		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+		yyVal = ma;
+	  }
+
+void case_448()
+#line 3827 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
+		var ma = new MemberAccess ((Expression) yyVals[-2+yyTop], lt.Value, null, lt.Location);
+		ma.AccessorType = MemberAccess.Accessor.AsE4xNamespace;
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+		yyVal = ma;
+	  }
+
+void case_449()
+#line 3835 "ps-parser.jay"
+{
+		var ea = new ElementAccess ((Expression) yyVals[-4+yyTop], (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
+		ea.AccessorType = ElementAccess.Accessor.AsE4xNamespaceAccess;
+		lbag.AddLocation (GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
+		yyVal = ea;
+	  }
+
+void case_450()
+#line 3842 "ps-parser.jay"
+{
+		var ea = new ElementAccess ((Expression) yyVals[-4+yyTop], (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
+		ea.AccessorType = ElementAccess.Accessor.AsE4xAttributeAccess;
+		lbag.AddLocation (GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
+		yyVal = ea;
+	  }
+
+void case_451()
+#line 3849 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+		var ma = new AsXmlQueryExpression ((Expression) yyVals[-4+yyTop], (Expression) yyVals[-1+yyTop], lt.Location);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-3+yyTop]));
+		yyVal = ma;
+	  }
+
+void case_452()
+#line 3856 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
+		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_453()
+#line 3862 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
+		yyVal = new MemberAccess (new BaseThis (GetLocation (yyVals[-3+yyTop])), lt.Value, (TypeArguments) yyVals[0+yyTop], lt.Location);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_455()
+#line 3878 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
+		yyVal = new CompletionMemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, lt.Location);
+	  }
+
+void case_457()
+#line 3886 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
+		yyVal = new CompletionMemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, lt.Location);
+ 	  }
+
+void case_458()
+#line 3894 "ps-parser.jay"
+{
+		if (current_constructor == null)
+ 			report.Error (7014, GetLocation (yyVals[-3+yyTop]), "Base constructor initializer may only be called in constructor");
+ 		var initializer = new ConstructorBaseInitializer ((Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
+ 		initializer.IsAsExplicitSuperCall = true;
+ 		current_constructor.Initializer = initializer;
+ 		yyVal = initializer;
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_459()
+#line 3904 "ps-parser.jay"
+{
+		yyVal = new Invocation ((Expression) yyVals[-3+yyTop], (Arguments) yyVals[-1+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_460()
+#line 3909 "ps-parser.jay"
+{
+	    var newExpr = yyVals[-3+yyTop] as AsNew;
+	    if (newExpr != null) {
+		    /* Convert Invocation(AsNew()) into AsNew(Invocation())*/
+			var invExpr = new Invocation(newExpr.Expr, (Arguments) yyVals[-1+yyTop]);
+			newExpr.Expr = invExpr;
+			yyVal = newExpr;
+	    } else {
+	    	/* Just a normal invocation*/
+			yyVal = new Invocation ((Expression) yyVals[-3+yyTop], (Arguments) yyVals[-1+yyTop]);
+	    }
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_461()
+#line 3923 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Invocation ((Expression) yyVals[-3+yyTop], (Arguments) yyVals[-1+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_462()
+#line 3933 "ps-parser.jay"
+{
+	    var expList = yyVals[-1+yyTop] as List<Expression>;
+	    if (expList == null) {
+	    	expList = new List<Expression>();
+	    }
+  		var oi = new AsObjectInitializer (expList, GetLocation (yyVals[-2+yyTop]));
+		if (current_variable != null) {
+			oi.VariableDeclaration = current_variable;
+		}
+		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+  		yyVal = oi;
+	  }
+
+void case_463()
+#line 3946 "ps-parser.jay"
+{
+	  	var oi = new AsObjectInitializer ((List<Expression>) yyVals[-2+yyTop], GetLocation (yyVals[-3+yyTop]));
+		if (current_variable != null) {
+			oi.VariableDeclaration = current_variable;
+		}
+	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
+	  	yyVal = oi;
+	  }
+
+void case_464()
+#line 3958 "ps-parser.jay"
+{
+      	oob_stack.Push (Lexer.AutoSemiInsertion);
+        Lexer.AutoSemiInsertion = false;
+	  }
+
+void case_465()
+#line 3966 "ps-parser.jay"
+{
+      	Lexer.AutoSemiInsertion = (bool) oob_stack.Pop ();
+      	if (Lexer.AutoSemiInsertion)
+	 	  	Lexer.AllowAutoSemiAfterToken(Token.CLOSE_BRACE, true);
+ 	  }
+
+void case_466()
+#line 3975 "ps-parser.jay"
+{
+      	Lexer.AutoSemiInsertion = (bool) oob_stack.Pop ();
+      	if (Lexer.AutoSemiInsertion)
+	 	  	Lexer.AllowAutoSemiAfterToken(Token.CLOSE_BRACE, true);
+ 	  }
+
+void case_470()
+#line 3993 "ps-parser.jay"
+{
+	  	var a = new List<Expression> ();
+	  	a.Add ((Expression) yyVals[0+yyTop]);
+	  	yyVal = a;
+	  }
+
+void case_471()
+#line 3999 "ps-parser.jay"
+{
+	  	var a = (List<Expression>)yyVals[-2+yyTop];
+	  	a.Add ((Expression) yyVals[0+yyTop]);
+	  	yyVal = a;
+	  }
+
+void case_472()
+#line 4004 "ps-parser.jay"
+{
+	  	Error_SyntaxError (yyToken);
+		yyVal = yyVals[-1+yyTop];
+	  }
+
+void case_473()
+#line 4012 "ps-parser.jay"
+{
+	  	var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+	  	yyVal = new ElementInitializer (lt.Value, (Expression)yyVals[0+yyTop], lt.Location);
+	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_474()
+#line 4018 "ps-parser.jay"
+{
+	  	var lt = (Tokenizer.LocatedToken) Error_AwaitAsIdentifier (yyVals[-2+yyTop]);
+	  	yyVal = new ElementInitializer (lt.Value, (Expression)yyVals[0+yyTop], lt.Location);
+	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_475()
+#line 4024 "ps-parser.jay"
+{
+	  	ILiteralConstant lit = yyVals[-2+yyTop] as ILiteralConstant;
+		string nm;	  	
+	  	if (lit is StringLiteral) {
+			nm = ((StringLiteral)lit).Value;
+		} else {
+	  		if (parsing_playscript || !(lit is IntLiteral || lit is DoubleLiteral || lit is BoolLiteral)) {
+			  	report.Error (7019, GetLocation (yyVals[-2+yyTop]), "Must be identifier or string literal");
+			  	nm = "err";
+			 } else {
+				nm = ((Constant)yyVals[-2+yyTop]).GetValueAsLiteral();			 
+			 }
+		}
+	  
+	  	yyVal = new ElementInitializer (nm, (Expression)yyVals[0+yyTop], GetLocation(yyVals[-2+yyTop]));
+	  	lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_480()
+#line 4077 "ps-parser.jay"
+{ 
+		Arguments list = new Arguments (4);
+		list.Add ((Argument) yyVals[0+yyTop]);
+		yyVal = list;
+	  }
+
+void case_481()
+#line 4083 "ps-parser.jay"
+{
+		Arguments list = (Arguments) yyVals[-2+yyTop];
+		if (list [list.Count - 1] is NamedArgument)
+			Error_NamedArgumentExpected ((NamedArgument) list [list.Count - 1]);
+		
+		list.Add ((Argument) yyVals[0+yyTop]);
+		yyVal = list;
+	  }
+
+void case_482()
+#line 4092 "ps-parser.jay"
+{
+		Arguments list = (Arguments) yyVals[-2+yyTop];
+		NamedArgument a = (NamedArgument) yyVals[0+yyTop];
+		for (int i = 0; i < list.Count; ++i) {
+			NamedArgument na = list [i] as NamedArgument;
+			if (na != null && na.Name == a.Name)
+				report.Error (1740, na.Location, "Named argument `{0}' specified multiple times",
+					na.Name);
+		}
+		
+		list.Add (a);
+		yyVal = list;
+	  }
+
+void case_483()
+#line 4106 "ps-parser.jay"
+{
+	  	lexer.putback (')'); /* TODO: Wrong but what can I do*/
+		Error_SyntaxError (yyToken);
+		yyVal = yyVals[-2+yyTop];
+	  }
+
+void case_484()
+#line 4112 "ps-parser.jay"
+{
+	  	report.Error (839, GetLocation (yyVals[-1+yyTop]), "An argument is missing");
+	  	yyVal = null;
+	  }
+
+void case_489()
+#line 4133 "ps-parser.jay"
+{ 
+		yyVal = new Argument ((Expression) yyVals[0+yyTop], Argument.AType.Ref);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_490()
+#line 4138 "ps-parser.jay"
+{ 
+		yyVal = new Argument ((Expression) yyVals[0+yyTop], Argument.AType.Out);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_492()
+#line 4160 "ps-parser.jay"
+{
+	    var newExpr = yyVals[-3+yyTop] as AsNew;
+	    if (newExpr != null) {
+		    /* Convert ElementAccess(AsNew()) into AsNew(ElementAccess())*/
+			var elemAccessExpr = new ElementAccess(newExpr.Expr, (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
+			newExpr.Expr = elemAccessExpr;
+			yyVal = newExpr;
+	    } else {
+			yyVal = new ElementAccess ((Expression) yyVals[-3+yyTop], (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
+		}
+		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_493()
+#line 4173 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+		yyVal = new ElementAccess ((Expression) yyVals[-3+yyTop], (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_494()
+#line 4178 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+		yyVal = new ElementAccess ((Expression) yyVals[-2+yyTop], null, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_495()
+#line 4183 "ps-parser.jay"
+{
+		yyVal = new ElementAccess ((Expression) yyVals[-3+yyTop], (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
+		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_496()
+#line 4188 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+		yyVal = new ElementAccess ((Expression) yyVals[-3+yyTop], (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_497()
+#line 4193 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+		yyVal = new ElementAccess ((Expression) yyVals[-2+yyTop], null, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_498()
+#line 4201 "ps-parser.jay"
+{
+		var list = new List<Expression> (4);
+		list.Add ((Expression) yyVals[0+yyTop]);
+		yyVal = list;
+	  }
+
+void case_499()
+#line 4207 "ps-parser.jay"
+{
+		var list = (List<Expression>) yyVals[-2+yyTop];
+		list.Add ((Expression) yyVals[0+yyTop]);
+		yyVal = list;
+	  }
+
+void case_500()
+#line 4212 "ps-parser.jay"
+{
+	  	Error_SyntaxError (yyToken);
+		yyVal = yyVals[-1+yyTop];
+	  }
+
+void case_501()
+#line 4220 "ps-parser.jay"
+{
+		Arguments args = new Arguments (4);
+		args.Add ((Argument) yyVals[0+yyTop]);
+		yyVal = args;
+	  }
+
+void case_502()
+#line 4226 "ps-parser.jay"
+{
+		Arguments args = (Arguments) yyVals[-2+yyTop];
+		if (args [args.Count - 1] is NamedArgument && !(yyVals[0+yyTop] is NamedArgument))
+			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
+	  
+		args.Add ((Argument) yyVals[0+yyTop]);
+		yyVal = args;	  
+	  }
+
+void case_506()
+#line 4253 "ps-parser.jay"
+{
+	  	yyVal = new ElementAccess (new BaseThis (GetLocation (yyVals[-3+yyTop])), (Arguments) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
+		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_507()
+#line 4258 "ps-parser.jay"
+{
+	  	Error_SyntaxError (yyToken);
+		yyVal = new ElementAccess (null, null, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_513()
+#line 4349 "ps-parser.jay"
+{
+	    var arrayInit = (AsArrayInitializer) yyVals[0+yyTop];
+	    arrayInit.VectorType = (FullNamedExpression) yyVals[-2+yyTop];
+	    yyVal = arrayInit;
+	  }
+
+void case_515()
+#line 4428 "ps-parser.jay"
+{
+	  	((ComposedTypeSpecifier) yyVals[-1+yyTop]).Next = (ComposedTypeSpecifier) yyVals[0+yyTop];
+	  	yyVal = yyVals[-1+yyTop];
+	  }
+
+void case_516()
+#line 4436 "ps-parser.jay"
+{
+		yyVal = ComposedTypeSpecifier.CreateArrayDimension (1, GetLocation (yyVals[-1+yyTop]));
+		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_517()
+#line 4441 "ps-parser.jay"
+{
+		yyVal = ComposedTypeSpecifier.CreateArrayDimension ((int)yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
+		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_520()
+#line 4471 "ps-parser.jay"
+{
+		var ai = new AsArrayInitializer (0, GetLocation (yyVals[-1+yyTop]));
+		if (current_variable != null) {
+			ai.VariableDeclaration = current_variable;
+		}
+		lbag.AddLocation (ai, GetLocation (yyVals[0+yyTop]));
+		yyVal = ai;
+	  }
+
+void case_521()
+#line 4480 "ps-parser.jay"
+{
+		var ai = new AsArrayInitializer ((List<Expression>) yyVals[-2+yyTop], GetLocation (yyVals[-3+yyTop]));
+		if (current_variable != null) {
+			ai.VariableDeclaration = current_variable;
+		}
+		if (yyVals[-1+yyTop] != null) {
+			lbag.AddLocation (ai, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
+		} else {
+			lbag.AddLocation (ai, GetLocation (yyVals[0+yyTop]));
+		}
+		yyVal = ai;
+	  }
+
+void case_522()
+#line 4496 "ps-parser.jay"
+{
+      	oob_stack.Push (Lexer.AutoSemiInsertion);
+        Lexer.AutoSemiInsertion = false;
+	  }
+
+void case_523()
+#line 4504 "ps-parser.jay"
+{
+      	oob_stack.Push (Lexer.AutoSemiInsertion);
+        Lexer.AutoSemiInsertion = false;
+	  }
+
+void case_525()
+#line 4519 "ps-parser.jay"
+{
+		var list = new List<Expression> (4);
+		list.Add ((Expression) yyVals[0+yyTop]);
+		yyVal = list;
+	  }
+
+void case_526()
+#line 4525 "ps-parser.jay"
+{
+		var list = (List<Expression>) yyVals[-2+yyTop];
+		list.Add ((Expression) yyVals[0+yyTop]);
+		yyVal = list;
+	  }
+
+void case_529()
+#line 4550 "ps-parser.jay"
+{
+	 	Error_TypeExpected (lexer.Location);
+	 	yyVal = null;
+	 }
+
+void case_530()
+#line 4558 "ps-parser.jay"
+{  
+		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
+
+		yyVal = new SimpleName (lt.Value, (int) yyVals[0+yyTop], lt.Location);
+	  }
+
+void case_531()
+#line 4572 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
+		
+		yyVal = new MemberAccess ((Expression) yyVals[-2+yyTop], lt.Value, lt.Location);		
+	  }
+
+void case_532()
+#line 4578 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
+		
+		yyVal = new MemberAccess ((Expression) yyVals[-3+yyTop], lt.Value, (int) yyVals[0+yyTop], lt.Location);		
+	  }
+
+void case_533()
+#line 4584 "ps-parser.jay"
+{
+		var tne = (ATypeNameExpression) yyVals[-3+yyTop];
+		if (tne.HasTypeArguments)
+			Error_TypeExpected (GetLocation (yyVals[0+yyTop]));
+
+		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
+		yyVal = new MemberAccess (tne, lt.Value, (int) yyVals[0+yyTop], lt.Location);		
+	  }
+
+void case_534()
+#line 4596 "ps-parser.jay"
+{
+		if (lang_version < LanguageVersion.ISO_2)
+			FeatureIsNotAvailable (GetLocation (yyVals[0+yyTop]), "generics");
+
+		yyVal = yyVals[0+yyTop];
+	  }
+
+void case_535()
+#line 4617 "ps-parser.jay"
+{ 
+		CheckIsPlayScript("sizeof", GetLocation(yyVals[-3+yyTop])); 	  
+		yyVal = new SizeOf ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_536()
+#line 4623 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new SizeOf ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_537()
+#line 4633 "ps-parser.jay"
+{
+		CheckIsPlayScript("checked", GetLocation(yyVals[-3+yyTop])); 	  
+		yyVal = new CheckedExpr ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_538()
+#line 4639 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new CheckedExpr (null, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_539()
+#line 4648 "ps-parser.jay"
+{
+		CheckIsPlayScript("unchecked", GetLocation(yyVals[-3+yyTop])); 	  
+		yyVal = new UnCheckedExpr ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_540()
+#line 4654 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new UnCheckedExpr (null, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_542()
+#line 4675 "ps-parser.jay"
+{
+		valid_param_mod = 0;
+		start_anonymous (false, (ParametersCompiled) yyVals[-3+yyTop], (TypeExpr) yyVals[0+yyTop], false, GetLocation (yyVals[-6+yyTop]));
+	  }
+
+void case_545()
+#line 4688 "ps-parser.jay"
+{
+		valid_param_mod = 0;
+		start_anonymous (false, (ParametersCompiled) yyVals[-3+yyTop], (FullNamedExpression) yyVals[0+yyTop], true, GetLocation (yyVals[-7+yyTop]));
+	  }
+
+void case_548()
+#line 4704 "ps-parser.jay"
+{
+		valid_param_mod = 0;
+		start_anonymous (false, (ParametersCompiled) yyVals[-3+yyTop], (FullNamedExpression) yyVals[0+yyTop], false, GetLocation (yyVals[-7+yyTop]));
+	  }
+
+void case_549()
+#line 4709 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-8+yyTop];
+		var anonMethod = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
+		var li = new LocalVariable (current_block.ParametersBlock.TopBlock, lt.Value, lt.Location);
+		var type = Delegate.CreateDelegateTypeExpression(compiler.BuiltinTypes, anonMethod.AsParameters, anonMethod.AsReturnType, GetLocation(yyVals[-9+yyTop]));
+		var decl = new BlockVariableDeclaration(type, li);
+		decl.Initializer = anonMethod;
+		current_block.AddLocalName (li);
+		current_block.ParametersBlock.TopBlock.AddScopeStatement (decl);	
+		yyVal = new AsLocalFunction(GetLocation(yyVals[-9+yyTop]), lt.Value, anonMethod, decl);
+	  }
+
+void case_551()
+#line 4725 "ps-parser.jay"
+{
+		valid_param_mod = 0;
+		start_anonymous (false, (ParametersCompiled) yyVals[-3+yyTop], (FullNamedExpression) yyVals[0+yyTop], true, GetLocation (yyVals[-8+yyTop]));
+	  }
+
+void case_552()
+#line 4730 "ps-parser.jay"
+{
+	    var lt = (Tokenizer.LocatedToken) yyVals[-8+yyTop];
+		var anonMethod = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
+		var li = new LocalVariable (current_block.ParametersBlock.TopBlock, lt.Value, lt.Location);
+		var type = Delegate.CreateDelegateTypeExpression(compiler.BuiltinTypes, anonMethod.AsParameters, anonMethod.AsReturnType, GetLocation(yyVals[-10+yyTop]));
+		var decl = new BlockVariableDeclaration(type, li);
+		decl.Initializer = anonMethod;
+		current_block.AddLocalName (li);
+		current_block.ParametersBlock.TopBlock.AddScopeStatement (decl);	
+		yyVal = new AsLocalFunction(GetLocation(yyVals[-10+yyTop]), lt.Value, anonMethod, decl);
+	  }
+
+void case_553()
+#line 4757 "ps-parser.jay"
+{
+	  	CheckIsPlayScript("default values", GetLocation(yyVals[-3+yyTop]));
+	  
+		if (lang_version < LanguageVersion.ISO_2)
+			FeatureIsNotAvailable (GetLocation (yyVals[-3+yyTop]), "default value expression");
+
+		yyVal = new DefaultValueExpression ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_557()
+#line 4784 "ps-parser.jay"
+{
+	  	CheckIsPlayScript("await", GetLocation(yyVals[-1+yyTop]));
+	  	
+		if (!async_block) {
+			 if (current_anonymous_method is LambdaExpression) {
+				report.Error (4034, GetLocation (yyVals[-1+yyTop]),
+					"The `await' operator can only be used when its containing lambda expression is marked with the `async' modifier");
+			} else if (current_anonymous_method is AnonymousMethodExpression) {
+				report.Error (4035, GetLocation (yyVals[-1+yyTop]),
+					"The `await' operator can only be used when its containing anonymous method is marked with the `async' modifier");
+			} else {
+				report.Error (4033, GetLocation (yyVals[-1+yyTop]),
+					"The `await' operator can only be used when its containing method is marked with the `async' modifier");
+			}
+		} else {
+			current_block.Explicit.RegisterAsyncAwait ();
+		}
+		
+		yyVal = new Await ((Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_560()
+#line 4813 "ps-parser.jay"
+{
+	  	var expr = yyVals[0+yyTop] as Expression;
+	  	if (!(expr is ElementAccess || expr is MemberAccess)) {
+			report.Error (7022, GetLocation (yyVals[-1+yyTop]),
+				"delete operator may only be used with element access or member access expressions");
+	  	}
+		yyVal = new AsDelete ((Expression) yyVals[0+yyTop], GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_561()
+#line 4822 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Unary (Unary.Operator.LogicalNot, null, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_562()
+#line 4828 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Unary (Unary.Operator.OnesComplement, null, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_563()
+#line 4841 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Await (null, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_564()
+#line 4847 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Unary (Unary.Operator.AsE4xAttribute, null, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_565()
+#line 4853 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new AsTypeOf (null, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_566()
+#line 4859 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+		
+		yyVal = new AsDelete (null, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_573()
+#line 4897 "ps-parser.jay"
+{ 
+		Error_SyntaxError (yyToken);
+
+	  	yyVal = new Unary (Unary.Operator.UnaryPlus, null, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_574()
+#line 4903 "ps-parser.jay"
+{ 
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Unary (Unary.Operator.UnaryNegation, null, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_575()
+#line 4909 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new UnaryMutator (UnaryMutator.Mode.PreIncrement, null, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_576()
+#line 4915 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new UnaryMutator (UnaryMutator.Mode.PreDecrement, null, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_577()
+#line 4927 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Unary (Unary.Operator.AddressOf, null, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_579()
+#line 4937 "ps-parser.jay"
+{
+		yyVal = new Binary (Binary.Operator.Multiply, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_580()
+#line 4942 "ps-parser.jay"
+{
+		yyVal = new Binary (Binary.Operator.Division, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_581()
+#line 4947 "ps-parser.jay"
+{
+		yyVal = new Binary (Binary.Operator.Modulus, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_582()
+#line 4952 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Binary (Binary.Operator.Multiply, (Expression) yyVals[-2+yyTop], null);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_583()
+#line 4959 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Binary (Binary.Operator.Division, (Expression) yyVals[-2+yyTop], null);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_584()
+#line 4966 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Binary (Binary.Operator.Modulus, (Expression) yyVals[-2+yyTop], null);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_586()
+#line 4977 "ps-parser.jay"
+{
+		yyVal = new Binary (Binary.Operator.Addition, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_587()
+#line 4982 "ps-parser.jay"
+{
+		yyVal = new Binary (Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+  	  }
+
+void case_591()
+#line 4999 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Binary (Binary.Operator.Addition, (Expression) yyVals[-2+yyTop], null);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_592()
+#line 5006 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Binary (Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], null);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_593()
+#line 5013 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new AsIn ((Expression) yyVals[-2+yyTop], null, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_594()
+#line 5019 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new As ((Expression) yyVals[-2+yyTop], null, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_595()
+#line 5025 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Is ((Expression) yyVals[-2+yyTop], null, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_597()
+#line 5035 "ps-parser.jay"
+{
+		yyVal = new Binary (Binary.Operator.LeftShift, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_598()
+#line 5040 "ps-parser.jay"
+{
+		yyVal = new Binary (Binary.Operator.RightShift, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_599()
+#line 5045 "ps-parser.jay"
+{
+		yyVal = new Binary (Binary.Operator.AsURightShift, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_600()
+#line 5050 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Binary (Binary.Operator.LeftShift, (Expression) yyVals[-2+yyTop], null);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_601()
+#line 5057 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Binary (Binary.Operator.RightShift, (Expression) yyVals[-2+yyTop], null);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_602()
+#line 5064 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Binary (Binary.Operator.AsURightShift, (Expression) yyVals[-2+yyTop], null);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_604()
+#line 5075 "ps-parser.jay"
+{
+		yyVal = new Binary (Binary.Operator.LessThan, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_605()
+#line 5080 "ps-parser.jay"
+{
+		yyVal = new Binary (Binary.Operator.GreaterThan, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_606()
+#line 5085 "ps-parser.jay"
+{
+		yyVal = new Binary (Binary.Operator.LessThanOrEqual, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_607()
+#line 5090 "ps-parser.jay"
+{
+		yyVal = new Binary (Binary.Operator.GreaterThanOrEqual, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_608()
+#line 5095 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Binary (Binary.Operator.LessThan, (Expression) yyVals[-2+yyTop], null);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_609()
+#line 5102 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Binary (Binary.Operator.GreaterThan, (Expression) yyVals[-2+yyTop], null);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_610()
+#line 5109 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Binary (Binary.Operator.LessThanOrEqual, (Expression) yyVals[-2+yyTop], null);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_611()
+#line 5116 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Binary (Binary.Operator.GreaterThanOrEqual, (Expression) yyVals[-2+yyTop], null);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_613()
+#line 5127 "ps-parser.jay"
+{
+		yyVal = new Binary (Binary.Operator.Equality, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_614()
+#line 5132 "ps-parser.jay"
+{
+		yyVal = new Binary (Binary.Operator.Inequality, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_615()
+#line 5137 "ps-parser.jay"
+{
+		yyVal = new Binary (Binary.Operator.AsRefEquality, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_616()
+#line 5142 "ps-parser.jay"
+{
+		yyVal = new Binary (Binary.Operator.AsRefInequality, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_618()
+#line 5151 "ps-parser.jay"
+{
+		yyVal = new Binary (Binary.Operator.BitwiseAnd, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_619()
+#line 5156 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Binary (Binary.Operator.BitwiseAnd, (Expression) yyVals[-2+yyTop], null);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_621()
+#line 5167 "ps-parser.jay"
+{
+		yyVal = new Binary (Binary.Operator.ExclusiveOr, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_622()
+#line 5172 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Binary (Binary.Operator.ExclusiveOr, (Expression) yyVals[-2+yyTop], null);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_624()
+#line 5183 "ps-parser.jay"
+{
+		yyVal = new Binary (Binary.Operator.BitwiseOr, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_625()
+#line 5188 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Binary (Binary.Operator.BitwiseOr, (Expression) yyVals[-2+yyTop], null);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_627()
+#line 5199 "ps-parser.jay"
+{
+		yyVal = new Binary (Binary.Operator.LogicalAnd, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_628()
+#line 5204 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Binary (Binary.Operator.LogicalAnd, (Expression) yyVals[-2+yyTop], null);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_630()
+#line 5215 "ps-parser.jay"
+{
+		yyVal = new Binary (Binary.Operator.LogicalOr, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_631()
+#line 5220 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Binary (Binary.Operator.LogicalOr, (Expression) yyVals[-2+yyTop], null);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_633()
+#line 5231 "ps-parser.jay"
+{
+	  	CheckIsPlayScript("?? operator", GetLocation(yyVals[-1+yyTop]));
+	  
+		if (lang_version < LanguageVersion.ISO_2)
+			FeatureIsNotAvailable (GetLocation (yyVals[-1+yyTop]), "null coalescing operator");
+			
+		yyVal = new Nullable.NullCoalescingOperator ((Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_635()
+#line 5245 "ps-parser.jay"
+{
+		yyVal = new Conditional (new BooleanExpression ((Expression) yyVals[-4+yyTop]), (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_636()
+#line 5250 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Conditional (new BooleanExpression ((Expression) yyVals[-3+yyTop]), (Expression) yyVals[-1+yyTop], null, GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_637()
+#line 5256 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Conditional (new BooleanExpression ((Expression) yyVals[-4+yyTop]), (Expression) yyVals[-2+yyTop], null, GetLocation (yyVals[-3+yyTop]));
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_638()
+#line 5266 "ps-parser.jay"
+{
+	  	Expression target = (Expression) yyVals[-2+yyTop];
+	  	Expression source = (Expression) yyVals[0+yyTop];
+
+		var assign = new SimpleAssign (target, source);
+		lbag.AddLocation (assign, GetLocation (yyVals[-1+yyTop]));
+	  	
+	  	if (source is AsArrayInitializer) {
+	  		(source as AsArrayInitializer).Assign = assign;
+	  	} else if (source is AsObjectInitializer) {
+	  		(source as AsObjectInitializer).Assign = assign;
+	  	}
+	  	
+	  	yyVal = assign;
+	  }
+
+void case_639()
+#line 5282 "ps-parser.jay"
+{
+		yyVal = new CompoundAssign (Binary.Operator.Multiply, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_640()
+#line 5287 "ps-parser.jay"
+{
+		yyVal = new CompoundAssign (Binary.Operator.Division, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_641()
+#line 5292 "ps-parser.jay"
+{
+		yyVal = new CompoundAssign (Binary.Operator.Modulus, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_642()
+#line 5297 "ps-parser.jay"
+{
+		yyVal = new CompoundAssign (Binary.Operator.Addition, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_643()
+#line 5302 "ps-parser.jay"
+{
+		yyVal = new CompoundAssign (Binary.Operator.Subtraction, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_644()
+#line 5307 "ps-parser.jay"
+{
+		yyVal = new CompoundAssign (Binary.Operator.LeftShift, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_645()
+#line 5312 "ps-parser.jay"
+{
+		yyVal = new CompoundAssign (Binary.Operator.RightShift, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_646()
+#line 5317 "ps-parser.jay"
+{
+		yyVal = new CompoundAssign (Binary.Operator.AsURightShift, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_647()
+#line 5322 "ps-parser.jay"
+{
+		yyVal = new CompoundAssign (Binary.Operator.BitwiseAnd, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_648()
+#line 5327 "ps-parser.jay"
+{
+		yyVal = new CompoundAssign (Binary.Operator.LogicalAnd, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_649()
+#line 5332 "ps-parser.jay"
+{
+		yyVal = new CompoundAssign (Binary.Operator.BitwiseOr, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_650()
+#line 5337 "ps-parser.jay"
+{
+		yyVal = new CompoundAssign (Binary.Operator.LogicalOr, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_651()
+#line 5342 "ps-parser.jay"
+{
+		yyVal = new CompoundAssign (Binary.Operator.ExclusiveOr, (Expression) yyVals[-2+yyTop], (Expression) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_652()
+#line 5350 "ps-parser.jay"
+{
+		var pars = new List<Parameter> (4);
+		pars.Add ((Parameter) yyVals[0+yyTop]);
+		parameterListCommas.Clear ();
+		yyVal = pars;
+	  }
+
+void case_653()
+#line 5357 "ps-parser.jay"
+{
+		var pars = (List<Parameter>) yyVals[-2+yyTop];
+		Parameter p = (Parameter)yyVals[0+yyTop];
+		if (pars[0].GetType () != p.GetType ()) {
+			report.Error (748, p.Location, "All lambda parameters must be typed either explicitly or implicitly");
+		}
+		
+		pars.Add (p);
+		parameterListCommas.Add (GetLocation (yyVals[-1+yyTop]));
+
+		yyVal = pars;
+	  }
+
+void case_654()
+#line 5373 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
+
+		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, (Parameter.Modifier) yyVals[-2+yyTop], null, lt.Location);
+	  }
+
+void case_655()
+#line 5379 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
+
+		yyVal = new Parameter ((FullNamedExpression) yyVals[-1+yyTop], lt.Value, Parameter.Modifier.NONE, null, lt.Location);
+	  }
+
+void case_656()
+#line 5385 "ps-parser.jay"
+{
+	  	var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
+		yyVal = new ImplicitLambdaParameter (lt.Value, lt.Location);
+	  }
+
+void case_657()
+#line 5390 "ps-parser.jay"
+{
+	  	var lt = (Tokenizer.LocatedToken) Error_AwaitAsIdentifier (yyVals[0+yyTop]);
+		yyVal = new ImplicitLambdaParameter (lt.Value, lt.Location);
+	  }
+
+void case_659()
+#line 5398 "ps-parser.jay"
+{ 
+		var pars_list = (List<Parameter>) yyVals[0+yyTop];
+		yyVal = new ParametersCompiled (pars_list.ToArray ());
+		lbag.AddLocation (yyVal, parameterListCommas);
+	  }
+
+void case_661()
+#line 5410 "ps-parser.jay"
+{
+		Block b = end_block (Location.Null);
+		b.IsCompilerGenerated = true;
+		b.AddStatement (new ContextualReturn ((Expression) yyVals[0+yyTop]));
+		yyVal = b;
+	  }
+
+void case_663()
+#line 5418 "ps-parser.jay"
+{
+	  	/* Handles only cases like foo = x.FirstOrDefault (l => );*/
+	  	/* where we must restore current_variable*/
+		Block b = end_block (Location.Null);
+		b.IsCompilerGenerated = true;
+
+		Error_SyntaxError (yyToken);
+		yyVal = null;
+	  }
+
+void case_665()
+#line 5432 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+		yyVal = null;
+	  }
+
+void case_666()
+#line 5440 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];	
+		Parameter p = new ImplicitLambdaParameter (lt.Value, lt.Location);
+		start_anonymous (true, new ParametersCompiled (p), null, false, lt.Location);
+	  }
+
+void case_667()
+#line 5446 "ps-parser.jay"
+{
+		CheckIsPlayScript("lambda", GetLocation(yyVals[-3+yyTop])); 	  
+		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_668()
+#line 5452 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) Error_AwaitAsIdentifier (yyVals[-1+yyTop]);
+		Parameter p = new ImplicitLambdaParameter (lt.Value, lt.Location);
+		start_anonymous (true, new ParametersCompiled (p), null, false, lt.Location);
+	  }
+
+void case_669()
+#line 5458 "ps-parser.jay"
+{
+		CheckIsPlayScript("lambda", GetLocation(yyVals[-3+yyTop])); 	  
+		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_670()
+#line 5464 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
+		Parameter p = new ImplicitLambdaParameter (lt.Value, lt.Location);
+		start_anonymous (true, new ParametersCompiled (p), null, true, lt.Location);
+	  }
+
+void case_671()
+#line 5470 "ps-parser.jay"
+{
+		CheckIsPlayScript("lambda", GetLocation(yyVals[-4+yyTop])); 	  
+		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_673()
+#line 5480 "ps-parser.jay"
+{
+	  	valid_param_mod = 0;
+		start_anonymous (true, (ParametersCompiled) yyVals[-2+yyTop], null, false, GetLocation (yyVals[-4+yyTop]));
+	  }
+
+void case_674()
+#line 5485 "ps-parser.jay"
+{
+		CheckIsPlayScript("lambda", GetLocation(yyVals[-6+yyTop])); 	  
+		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_676()
+#line 5495 "ps-parser.jay"
+{
+	  	valid_param_mod = 0;
+		start_anonymous (true, (ParametersCompiled) yyVals[-2+yyTop], null, true, GetLocation (yyVals[-5+yyTop]));
+	  }
+
+void case_677()
+#line 5500 "ps-parser.jay"
+{
+		CheckIsPlayScript("lambda", GetLocation(yyVals[-7+yyTop])); 	  
+		yyVal = end_anonymous ((ParametersBlock) yyVals[0+yyTop]);
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_686()
+#line 5563 "ps-parser.jay"
+{
+		lexer.ConstraintsParsing = true;
+		
+		Class c = new Class (current_container, (MemberName) yyVals[0+yyTop], (Modifiers) yyVals[-4+yyTop], (Attributes) yyVals[-5+yyTop]);
+		if (((c.ModFlags & Modifiers.STATIC) != 0) && lang_version == LanguageVersion.ISO_1) {
+			FeatureIsNotAvailable (c.Location, "static classes");
+		}
+			
+	    bool is_partial = IsPartial(yyVals[-5+yyTop]) || yyVals[-3+yyTop] != null;
+		push_current_container (c, is_partial);
+		lbag.AddMember (current_container, GetModifierLocations (), GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_687()
+#line 5578 "ps-parser.jay"
+{
+		lexer.ConstraintsParsing = false;
+
+		if (yyVals[0+yyTop] != null)
+			current_container.SetConstraints ((List<Constraints>) yyVals[0+yyTop]);
+		lbag.AddMember (current_container, GetModifierLocations (), GetLocation (yyVals[-6+yyTop]));
+
+		if (doc_support) {
+			current_container.PartialContainer.DocComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.Allowed;
+		}
+		
+		lexer.parsing_modifiers = true;
+		lexer.DynamicParsing = false;
+	  }
+
+void case_689()
+#line 5598 "ps-parser.jay"
+{
+		lexer.DynamicParsing = true;	  
+		--lexer.parsing_declaration;
+		if (doc_support)
+			Lexer.doc_state = XmlCommentState.Allowed;
+	  }
+
+void case_690()
+#line 5605 "ps-parser.jay"
+{
+		if (yyVals[0+yyTop] == null) {
+			lbag.AppendToMember (current_container, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]));
+		} else {
+			lbag.AppendToMember (current_container, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
+		}
+		yyVal = pop_current_class ();
+	  }
+
+void case_693()
+#line 5624 "ps-parser.jay"
+{
+	    mod_locations = null;
+		yyVal = ModifierNone;
+		lexer.parsing_modifiers = false;
+	  }
+
+void case_696()
+#line 5638 "ps-parser.jay"
+{ 
+		var m1 = (Modifiers) yyVals[-1+yyTop];
+		var m2 = (Modifiers) yyVals[0+yyTop];
+
+		if ((m1 & m2) != 0) {
+			report.Error (1004, lexer.Location - ModifiersExtensions.Name (m2).Length,
+				"Duplicate `{0}' modifier", ModifiersExtensions.Name (m2));
+		} else if ((m2 & Modifiers.AccessibilityMask) != 0 && (m1 & Modifiers.AccessibilityMask) != 0 &&
+			((m2 | m1 & Modifiers.AccessibilityMask) != (Modifiers.PROTECTED | Modifiers.INTERNAL))) {
+			report.Error (107, lexer.Location - ModifiersExtensions.Name (m2).Length,
+				"More than one protection modifier specified");
+		}
+		
+		yyVal = m1 | m2;
+	  }
+
+void case_697()
+#line 5657 "ps-parser.jay"
+{
+		yyVal = Modifiers.NEW;
+		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+		
+		if (current_container.Kind == MemberKind.Namespace)
+			report.Error (1530, GetLocation (yyVals[0+yyTop]), "Keyword `new' is not allowed on namespace elements");
+	  }
+
+void case_698()
+#line 5665 "ps-parser.jay"
+{
+		yyVal = Modifiers.PUBLIC;
+		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_699()
+#line 5670 "ps-parser.jay"
+{
+		yyVal = Modifiers.PROTECTED;
+		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_700()
+#line 5675 "ps-parser.jay"
+{
+		yyVal = Modifiers.INTERNAL;
+		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_701()
+#line 5680 "ps-parser.jay"
+{
+		yyVal = Modifiers.PRIVATE;
+		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_702()
+#line 5685 "ps-parser.jay"
+{
+		yyVal = Modifiers.ABSTRACT;
+		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_703()
+#line 5690 "ps-parser.jay"
+{
+		yyVal = (Modifiers)0; /* Modifiers.SEALED;  // The semantics for SEALED and FINAL don't quite match.  Ignore FINAL for right now. (BEN)*/
+		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_704()
+#line 5695 "ps-parser.jay"
+{
+		yyVal = Modifiers.STATIC;
+		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_705()
+#line 5700 "ps-parser.jay"
+{
+		yyVal = Modifiers.READONLY;
+		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_706()
+#line 5705 "ps-parser.jay"
+{
+		yyVal = Modifiers.VIRTUAL;
+		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_707()
+#line 5710 "ps-parser.jay"
+{
+		yyVal = Modifiers.OVERRIDE;
+		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_708()
+#line 5715 "ps-parser.jay"
+{
+		yyVal = Modifiers.EXTERN;
+		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_709()
+#line 5720 "ps-parser.jay"
+{
+		yyVal = Modifiers.VOLATILE;
+		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_710()
+#line 5725 "ps-parser.jay"
+{
+		yyVal = Modifiers.UNSAFE;
+		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+		if (!settings.Unsafe)
+			Error_UnsafeCodeNotAllowed (GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_711()
+#line 5732 "ps-parser.jay"
+{
+		yyVal = Modifiers.ASYNC;
+		StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_712()
+#line 5737 "ps-parser.jay"
+{
+	    yyVal = Modifiers.AS_DYNAMIC;
+	    StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_713()
+#line 5742 "ps-parser.jay"
+{
+	    yyVal = Modifiers.INTERNAL;
+	    StoreModifierLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_716()
+#line 5755 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		current_type.AddBaseForPart ((FullNamedExpression) yyVals[-1+yyTop]);
+	  }
+
+void case_719()
+#line 5769 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		current_type.AddBasesForPart ((List<FullNamedExpression>) yyVals[-1+yyTop]);
+	  }
+
+void case_722()
+#line 5786 "ps-parser.jay"
+{
+		var constraints = new List<Constraints> (1);
+		constraints.Add ((Constraints) yyVals[0+yyTop]);
+		yyVal = constraints;
+	  }
+
+void case_723()
+#line 5792 "ps-parser.jay"
+{
+		var constraints = (List<Constraints>) yyVals[-1+yyTop];
+		Constraints new_constraint = (Constraints)yyVals[0+yyTop];
+
+		foreach (Constraints c in constraints) {
+			if (new_constraint.TypeParameter.Value == c.TypeParameter.Value) {
+				report.Error (409, new_constraint.Location,
+					"A constraint clause has already been specified for type parameter `{0}'",
+					new_constraint.TypeParameter.Value);
+			}
+		}
+
+		constraints.Add (new_constraint);
+		yyVal = constraints;
+	  }
+
+void case_724()
+#line 5811 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+		yyVal = new Constraints (new SimpleMemberName (lt.Value, lt.Location), (List<FullNamedExpression>) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_725()
+#line 5817 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+	  
+		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
+		yyVal = new Constraints (new SimpleMemberName (lt.Value, lt.Location), null, GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_726()
+#line 5827 "ps-parser.jay"
+{
+		var constraints = new List<FullNamedExpression> (1);
+		constraints.Add ((FullNamedExpression) yyVals[0+yyTop]);
+		yyVal = constraints;
+	  }
+
+void case_727()
+#line 5833 "ps-parser.jay"
+{
+		var constraints = (List<FullNamedExpression>) yyVals[-2+yyTop];
+		var prev = constraints [constraints.Count - 1] as SpecialContraintExpr;
+		if (prev != null && (prev.Constraint & SpecialConstraint.Constructor) != 0) {			
+			report.Error (401, GetLocation (yyVals[-1+yyTop]), "The `new()' constraint must be the last constraint specified");
+		}
+		
+		prev = yyVals[0+yyTop] as SpecialContraintExpr;
+		if (prev != null) {
+			if ((prev.Constraint & (SpecialConstraint.Class | SpecialConstraint.Struct)) != 0) {
+				report.Error (449, prev.Location, "The `class' or `struct' constraint must be the first constraint specified");			
+			} else {
+			 	prev = constraints [0] as SpecialContraintExpr;
+			 	if (prev != null && (prev.Constraint & SpecialConstraint.Struct) != 0) {			
+					report.Error (451, GetLocation (yyVals[0+yyTop]), "The `new()' constraint cannot be used with the `struct' constraint");
+				}
+			}
+		}
+
+		constraints.Add ((FullNamedExpression) yyVals[0+yyTop]);
+		yyVal = constraints;
+	  }
+
+void case_728()
+#line 5859 "ps-parser.jay"
+{
+		if (yyVals[0+yyTop] is ComposedCast)
+			report.Error (706, GetLocation (yyVals[0+yyTop]), "Invalid constraint type `{0}'", ((ComposedCast)yyVals[0+yyTop]).GetSignatureForError ());
+	  
+	  	yyVal = yyVals[0+yyTop];
+	  }
+
+void case_729()
+#line 5866 "ps-parser.jay"
+{
+		yyVal = new SpecialContraintExpr (SpecialConstraint.Constructor, GetLocation (yyVals[-2+yyTop]));
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_733()
+#line 5886 "ps-parser.jay"
+{
+		if (lang_version <= LanguageVersion.V_3)
+			FeatureIsNotAvailable (lexer.Location, "generic type variance");
+		
+		yyVal = yyVals[0+yyTop];
+	  }
+
+void case_736()
+#line 5920 "ps-parser.jay"
+{
+		++lexer.parsing_block;
+		lexer.AutoSemiInsertion = true;
+		start_block (GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_738()
+#line 5937 "ps-parser.jay"
+{
+		++lexer.parsing_block;
+		start_block (GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_739()
+#line 5942 "ps-parser.jay"
+{
+	    if (is_config_enabled) {
+	      /* This block should be included*/
+  		  yyVal = yyVals[0+yyTop];
+  		} else {
+  		  /* This block should not be included.. create an empty block*/
+  		  start_block (GetLocation (yyVals[-3+yyTop]));
+  		  yyVal = end_block (GetLocation (yyVals[0+yyTop]));
+  		}
+	  }
+
+void case_741()
+#line 5957 "ps-parser.jay"
+{
+	    var lt1 = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+	    var lt2 = (Tokenizer.LocatedToken) yyVals[0+yyTop];
+        is_config_enabled = file.IsConditionalDefined (lt1.Value + "_" + lt2.Value);
+	  }
+
+void case_742()
+#line 5966 "ps-parser.jay"
+{
+	  	Lexer.AutoSemiInsertion = true;
+	 	--lexer.parsing_block;
+		yyVal = end_block (GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_743()
+#line 5972 "ps-parser.jay"
+{
+	  	Lexer.AutoSemiInsertion = true;
+	 	--lexer.parsing_block;
+		yyVal = end_block (lexer.Location);
+	  }
+
+void case_744()
+#line 5982 "ps-parser.jay"
+{
+		++lexer.parsing_block;
+		current_block.StartLocation = GetLocation (yyVals[0+yyTop]);
+	  }
+
+void case_745()
+#line 5987 "ps-parser.jay"
+{
+	  	Lexer.AutoSemiInsertion = true;
+		--lexer.parsing_block;
+		yyVal = end_block (GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_753()
+#line 6015 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+		yyVal = null;
+	  }
+
+void case_788()
+#line 6083 "ps-parser.jay"
+{
+	  	  if (parsing_playscript) {
+			  report.Error (1023, GetLocation (yyVals[0+yyTop]), "An embedded statement may not be a declaration or labeled statement");
+			  yyVal = null;
+		  } else {
+		  	  /* NOTE: This is actually allowed in PlayScript.  We'll turn it off in ASX though as it's error prone.*/
+		  	  yyVal = yyVals[0+yyTop];
+		  }
+	  }
+
+void case_789()
+#line 6093 "ps-parser.jay"
+{
+		  report.Error (1023, GetLocation (yyVals[0+yyTop]), "An embedded statement may not be a declaration or labeled statement");
+		  yyVal = null;
+	  }
+
+void case_790()
+#line 6098 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+		yyVal = new EmptyStatement (GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_791()
+#line 6106 "ps-parser.jay"
+{
+	    Lexer.AutoSemiInsertion = true;
+		/* Uses lexer.Location because semicolon location is not kept in quick mode*/
+		yyVal = new EmptyStatement (lexer.Location);
+	  }
+
+void case_792()
+#line 6115 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
+		LabeledStatement labeled = new LabeledStatement (lt.Value, current_block, lt.Location);
+		lbag.AddLocation (labeled, GetLocation (yyVals[0+yyTop]));
+		current_block.AddLabel (labeled);
+		current_block.AddStatement (labeled);
+	  }
+
+void case_794()
+#line 6127 "ps-parser.jay"
+{
+		Lexer.NamespaceParsing = false;
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];		
+		yyVal = new AsUseNamespaceStatement (lt.Value, GetLocation (yyVals[-3+yyTop]));		
+	  }
+
+void case_796()
+#line 6137 "ps-parser.jay"
+{
+		if (yyVals[-1+yyTop] is VarExpr)
+			yyVals[-1+yyTop] = new SimpleName ("var", ((VarExpr) yyVals[-1+yyTop]).Location);
+	  
+		yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
+	  }
+
+void case_797()
+#line 6153 "ps-parser.jay"
+{ 
+		/* Ok, the above "primary_expression" is there to get rid of*/
+		/* both reduce/reduce and shift/reduces in the grammar, it should*/
+		/* really just be "type_name".  If you use type_name, a reduce/reduce*/
+		/* creeps up.  If you use namespace_or_type_name (which is all we need*/
+		/* really) two shift/reduces appear.*/
+		/* */
+
+		/* So the super-trick is that primary_expression*/
+		/* can only be either a SimpleName or a MemberAccess. */
+		/* The MemberAccess case arises when you have a fully qualified type-name like :*/
+		/* Foo.Bar.Blah i;*/
+		/* SimpleName is when you have*/
+		/* Blah i;*/
+		
+		Expression expr = (Expression) yyVals[-1+yyTop];
+		if (yyVals[0+yyTop] == null) {
+			SimpleName sn = expr as SimpleName;
+			if (sn != null)
+				yyVal = ConvertAsType(sn, yyVals[-1+yyTop]);
+			else
+				yyVal = yyVals[-1+yyTop];
+		} else if (expr is ATypeNameExpression) {
+			yyVal = new ComposedCast ((ATypeNameExpression)expr, (ComposedTypeSpecifier) yyVals[0+yyTop]);
+		} else {
+			Error_ExpectingTypeName (expr);
+			yyVal = null;
+		}
+	  }
+
+void case_798()
+#line 6194 "ps-parser.jay"
+{
+		if (yyVals[0+yyTop] == null)
+			yyVal = yyVals[-1+yyTop];
+		else
+			yyVal = new ComposedCast ((FullNamedExpression) yyVals[-1+yyTop], (ComposedTypeSpecifier) yyVals[0+yyTop]);
+	  }
+
+void case_799()
+#line 6209 "ps-parser.jay"
+{
+		Expression.Error_VoidInvalidInTheContext (GetLocation (yyVals[0+yyTop]), report);
+		yyVal = new TypeExpression (compiler.BuiltinTypes.Void, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_801()
+#line 6234 "ps-parser.jay"
+{
+		if (async_block) {
+			report.Error (4003, GetLocation (yyVals[0+yyTop]), "`await' cannot be used as an identifier within an async method or lambda expression");
+			yyVal = new Tokenizer.LocatedToken ("await", GetLocation (yyVals[0+yyTop]));
+		}
+	  }
+
+void case_803()
+#line 6251 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+		var li = GetOrCreateLocalVariable (current_block, lt.Value, 0, (FullNamedExpression) yyVals[0+yyTop], lt.Location);
+		current_variable = new BlockVariableDeclaration ((FullNamedExpression) yyVals[0+yyTop], li);
+	  }
+
+void case_804()
+#line 6257 "ps-parser.jay"
+{
+		yyVal = current_variable;
+		current_variable = null;
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_805()
+#line 6263 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
+		var li = GetOrCreateLocalVariable (current_block, lt.Value, 0, null, lt.Location);
+		current_variable = new BlockVariableDeclaration (new VarExpr (GetLocation(yyVals[-1+yyTop])), li);
+	  }
+
+void case_806()
+#line 6269 "ps-parser.jay"
+{
+		yyVal = current_variable;
+		current_variable = null;
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_807()
+#line 6275 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+		var li = GetOrCreateLocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, null, lt.Location);
+		current_variable = new BlockConstantDeclaration ((FullNamedExpression) yyVals[0+yyTop], li);
+	  }
+
+void case_808()
+#line 6281 "ps-parser.jay"
+{
+		yyVal = current_variable;
+		current_variable = null;
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_810()
+#line 6291 "ps-parser.jay"
+{
+		current_variable.Initializer = (Expression) yyVals[0+yyTop];
+		/* TODO: lbag*/
+	  }
+
+void case_811()
+#line 6296 "ps-parser.jay"
+{
+	  	if (yyToken == Token.OPEN_BRACKET_EXPR) {
+			report.Error (650, lexer.Location,
+				"Syntax error, bad array declarator. To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type");
+		} else {
+			Error_SyntaxError (yyToken);
+		}
+	  }
+
+void case_815()
+#line 6314 "ps-parser.jay"
+{
+		foreach (var d in current_variable.Declarators) {
+			if (d.Initializer == null)
+				Error_MissingInitializer (d.Variable.Location);
+		}
+	  }
+
+void case_818()
+#line 6329 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];	  
+		var li = GetOrCreateLocalVariable (current_variable.Variable.Block, lt.Value, 
+			current_variable.Variable.DeclFlags, current_variable.TypeExpression, lt.Location);
+		var d = new BlockVariableDeclaration.Declarator (li, null);
+		current_variable.AddDeclarator (d);
+	  	lbag.AddLocation (d, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_819()
+#line 6338 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];	  
+		var li = GetOrCreateLocalVariable (current_variable.Variable.Block, lt.Value, 
+			current_variable.Variable.DeclFlags, current_variable.TypeExpression, lt.Location);
+		var d = new BlockVariableDeclaration.Declarator (li, (Expression) yyVals[0+yyTop]);
+		current_variable.AddDeclarator (d);
+	  	lbag.AddLocation (d, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_820()
+#line 6347 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];	  
+		var li = GetOrCreateLocalVariable (current_variable.Variable.Block, lt.Value, 
+			current_variable.Variable.DeclFlags, (FullNamedExpression) yyVals[0+yyTop], lt.Location);
+		var d = new BlockVariableDeclaration.Declarator (li, null, (FullNamedExpression) yyVals[0+yyTop]);
+		d.Location = GetLocation(yyVals[-2+yyTop]);
+		current_variable.AddDeclarator (d);
+	  	lbag.AddLocation (d, GetLocation (yyVals[-3+yyTop]));
+	  }
+
+void case_821()
+#line 6357 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-4+yyTop];	  
+		var li = GetOrCreateLocalVariable (current_variable.Variable.Block, lt.Value, 
+			current_variable.Variable.DeclFlags, (FullNamedExpression) yyVals[-2+yyTop], lt.Location);
+		var d = new BlockVariableDeclaration.Declarator (li, (Expression) yyVals[0+yyTop], (FullNamedExpression) yyVals[-2+yyTop]);
+		d.Location = GetLocation(yyVals[-4+yyTop]);
+		current_variable.AddDeclarator (d);
+	  	lbag.AddLocation (d, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_828()
+#line 6391 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];	  
+		var li = GetOrCreateLocalVariable (current_block, lt.Value, 
+			LocalVariable.Flags.Constant, current_variable.TypeExpression, lt.Location);
+		var d = new BlockVariableDeclaration.Declarator (li, (Expression) yyVals[0+yyTop]);
+		current_variable.AddDeclarator (d);
+	  	lbag.AddLocation (d, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_830()
+#line 6417 "ps-parser.jay"
+{
+		yyVal = yyVals[-1+yyTop];
+		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_832()
+#line 6423 "ps-parser.jay"
+{
+		yyVal = yyVals[-1+yyTop];
+		report.Error (1002, GetLocation (yyVals[0+yyTop]), "; expected");
+		lexer.putback ('}');
+	  }
+
+void case_836()
+#line 6448 "ps-parser.jay"
+{
+		Expression expr = (Expression) yyVals[0+yyTop];
+		ExpressionStatement s;
+
+	        s = new OptionalAssign (new SimpleName ("$retval", lexer.Location), expr, lexer.Location);
+		yyVal = new StatementExpression (s);
+	  }
+
+void case_837()
+#line 6456 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+		yyVal = new EmptyStatement (GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_842()
+#line 6484 "ps-parser.jay"
+{ 
+		if (yyVals[0+yyTop] is EmptyStatement)
+			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
+		
+		yyVal = new If ((BooleanExpression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
+		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_843()
+#line 6493 "ps-parser.jay"
+{
+		yyVal = new If ((BooleanExpression) yyVals[-4+yyTop], (Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-6+yyTop]));
+		lbag.AddStatement (yyVal, GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
+		
+		if (yyVals[-2+yyTop] is EmptyStatement)
+			Warning_EmptyStatement (GetLocation (yyVals[-2+yyTop]));
+		if (yyVals[0+yyTop] is EmptyStatement)
+			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_844()
+#line 6503 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+		
+		yyVal = new If ((BooleanExpression) yyVals[-1+yyTop], null, GetLocation (yyVals[-3+yyTop]));
+		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_845()
+#line 6513 "ps-parser.jay"
+{
+	    Lexer.AutoSemiInsertion = true;
+		start_block (GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_846()
+#line 6518 "ps-parser.jay"
+{
+		yyVal = new Switch ((Expression) yyVals[-5+yyTop], (ExplicitBlock) current_block.Explicit, (List<SwitchSection>) yyVals[-1+yyTop], GetLocation (yyVals[-7+yyTop]));	
+		end_block (GetLocation (yyVals[0+yyTop]));
+		lbag.AddStatement (yyVal, GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_847()
+#line 6524 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+	  
+		yyVal = new Switch ((Expression) yyVals[-1+yyTop], null, null, GetLocation (yyVals[-3+yyTop]));	
+		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_848()
+#line 6534 "ps-parser.jay"
+{
+		report.Warning (1522, 1, current_block.StartLocation, "Empty switch block"); 
+		yyVal = new List<SwitchSection> ();
+	  }
+
+void case_850()
+#line 6543 "ps-parser.jay"
+{
+		var sections = new List<SwitchSection> (4);
+
+		sections.Add ((SwitchSection) yyVals[0+yyTop]);
+		yyVal = sections;
+	  }
+
+void case_851()
+#line 6550 "ps-parser.jay"
+{
+		var sections = (List<SwitchSection>) yyVals[-1+yyTop];
+
+		sections.Add ((SwitchSection) yyVals[0+yyTop]);
+		yyVal = sections;
+	  }
+
+void case_852()
+#line 6557 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+		yyVal = new List<SwitchSection> ();
+	  }
+
+void case_855()
+#line 6576 "ps-parser.jay"
+{
+		var labels = new List<SwitchLabel> (2);
+
+		labels.Add ((SwitchLabel) yyVals[0+yyTop]);
+		yyVal = labels;
+	  }
+
+void case_856()
+#line 6583 "ps-parser.jay"
+{
+		var labels = (List<SwitchLabel>) (yyVals[-1+yyTop]);
+		labels.Add ((SwitchLabel) yyVals[0+yyTop]);
+
+		yyVal = labels;
+	  }
+
+void case_857()
+#line 6593 "ps-parser.jay"
+{
+	 	yyVal = new SwitchLabel ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
+	 	lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  	Lexer.AutoSemiInsertionAfter = 1;	 	
+	 }
+
+void case_858()
+#line 6599 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+		yyVal = new SwitchLabel ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_859()
+#line 6604 "ps-parser.jay"
+{
+		yyVal = new SwitchLabel (null, GetLocation (yyVals[0+yyTop]));
+	  	Lexer.AutoSemiInsertionAfter = 1;		
+	  }
+
+void case_864()
+#line 6619 "ps-parser.jay"
+{
+		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
+			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
+	  
+		yyVal = new While ((BooleanExpression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
+		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_865()
+#line 6627 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+		
+		yyVal = new While ((BooleanExpression) yyVals[-1+yyTop], null, GetLocation (yyVals[-3+yyTop]));
+		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_868()
+#line 6651 "ps-parser.jay"
+{
+	    Lexer.AutoSemiInsertion = true;
+	    
+		yyVal = new Do ((Statement) yyVals[-5+yyTop], (BooleanExpression) yyVals[-2+yyTop], GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-4+yyTop]));
+		lbag.AddStatement (yyVal, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_869()
+#line 6658 "ps-parser.jay"
+{
+	    Lexer.AutoSemiInsertion = true;
+	    
+		Error_SyntaxError (yyToken);
+		yyVal = new Do ((Statement) yyVals[-1+yyTop], null, GetLocation (yyVals[-2+yyTop]), Location.Null);
+	  }
+
+void case_870()
+#line 6665 "ps-parser.jay"
+{
+	    Lexer.AutoSemiInsertion = true;
+
+		Error_SyntaxError (yyToken);
+	  
+		yyVal = new Do ((Statement) yyVals[-4+yyTop], (BooleanExpression) yyVals[-1+yyTop], GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-3+yyTop]));
+		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_871()
+#line 6677 "ps-parser.jay"
+{
+		start_block (GetLocation (yyVals[0+yyTop]));
+		current_block.IsCompilerGenerated = true;
+		lexer.ForInParsing = true;
+		yyVal = new Tuple<Location,Location>(GetLocation(yyVals[-2+yyTop]), GetLocation(yyVals[-1+yyTop]));
+	  }
+
+void case_872()
+#line 6684 "ps-parser.jay"
+{
+		lexer.ForInParsing = false;	  
+		yyVal = yyVals[0+yyTop];
+	  }
+
+void case_874()
+#line 6697 "ps-parser.jay"
+{
+		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
+			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
+
+		var blockVar = yyVals[-5+yyTop] as BlockVariableDeclaration;
+		if (blockVar != null) {
+			if (blockVar == null || blockVar.Initializer != null || blockVar.Declarators != null) {
+				report.Error (7036, GetLocation (yyVals[-2+yyTop]), "Invalid for each initializer");	
+				yyVal = end_block (current_block.StartLocation);
+			} else {
+				var locations = (Tuple<Location,Location>) yyVals[-6+yyTop];
+				
+				Foreach f = new Foreach (blockVar.TypeExpression, blockVar.Variable, (Expression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], current_block, AsForEachType.ForEachKey, locations.Item1);
+				lbag.AddStatement (f, locations.Item2, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-1+yyTop]));
+				
+				end_block (GetLocation (yyVals[-1+yyTop]));
+				yyVal = f;
+			}
+		} else {
+			var expList = yyVals[-5+yyTop] as List<Expression>;
+			var varRef = (yyVals[-5+yyTop] as FullNamedExpression) ?? ((expList != null && expList.Count == 1) ? (expList[0] as FullNamedExpression) : null);
+			if (varRef == null) {
+				report.Error (7041, GetLocation (yyVals[-5+yyTop]), "Invalid iterator initializer");		
+				yyVal = end_block (current_block.StartLocation);
+			} else {
+				var locations = (Tuple<Location,Location>) yyVals[-6+yyTop];
+				
+				Foreach f = new Foreach (varRef, (Expression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], current_block, AsForEachType.ForEachKey, locations.Item1);
+				lbag.AddStatement (f, locations.Item2, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-1+yyTop]));
+				
+				end_block (GetLocation (yyVals[-1+yyTop]));
+				yyVal = f;
+			}
+		}
+	  }
+
+void case_875()
+#line 6733 "ps-parser.jay"
+{
+	    lexer.ForInParsing = false;
+	  
+		var locations = (Tuple<Location,Location>) yyVals[-2+yyTop];
+
+		For f = new For (locations.Item1);
+		current_block.AddStatement (f);
+		
+		var expList = yyVals[-1+yyTop] as List<Expression>;
+		if (expList != null) 
+			f.Initializer = ExpressionListToStatementList (expList);
+		else
+			f.Initializer = (Statement) yyVals[-1+yyTop];
+
+		/* Pass the "For" object to the iterator_part4*/
+		oob_stack.Push (f);
+		
+		yyVal = f;
+	  }
+
+void case_876()
+#line 6754 "ps-parser.jay"
+{
+		var locations = (Tuple<Location,Location>) yyVals[-1+yyTop];
+		oob_stack.Pop ();
+		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
+			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
+	  
+		For f = ((For) yyVals[-2+yyTop]);
+		f.Statement = (Statement) yyVals[0+yyTop];
+		lbag.AddStatement (f, current_block.StartLocation, GetLocation (yyVals[-3+yyTop]), GetLocation (locations.Item1), GetLocation (locations.Item2));
+
+		yyVal = end_block (GetLocation (yyVals[-3+yyTop]));
+	  }
+
+void case_877()
+#line 6767 "ps-parser.jay"
+{
+		Lexer.AutoSemiInsertion = true;
+		Error_SyntaxError (yyToken);
+		yyVal = end_block (current_block.StartLocation);
+	  }
+
+void case_878()
+#line 6776 "ps-parser.jay"
+{
+		For f = (For) oob_stack.Peek ();
+		f.Condition = (BooleanExpression) yyVals[-1+yyTop];
+	  }
+
+void case_880()
+#line 6786 "ps-parser.jay"
+{
+		Lexer.AutoSemiInsertion = true;
+		report.Error (1525, GetLocation (yyVals[0+yyTop]), "Unexpected symbol `}'");
+		For f = (For) oob_stack.Peek ();
+		f.Condition = (BooleanExpression) yyVals[-1+yyTop];
+		yyVal = new Tuple<Location,Location> (GetLocation (yyVals[0+yyTop]), GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_881()
+#line 6796 "ps-parser.jay"
+{
+	  	For f = (For) oob_stack.Peek ();
+		f.Iterator = (Statement) yyVals[-1+yyTop];
+		yyVal = GetLocation (yyVals[0+yyTop]);
+	  }
+
+void case_882()
+#line 6801 "ps-parser.jay"
+{
+		Lexer.AutoSemiInsertion = true;
+		report.Error (1525, GetLocation (yyVals[0+yyTop]), "Unexpected symbol expected ')'");
+		For f = (For) oob_stack.Peek ();
+		f.Iterator = (Statement) yyVals[-1+yyTop];
+		yyVal = GetLocation (yyVals[0+yyTop]);
+	  }
+
+void case_887()
+#line 6822 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+		var type = (FullNamedExpression) yyVals[0+yyTop];
+		var li = GetOrCreateLocalVariable (current_block, lt.Value, 0, type, lt.Location);
+		current_variable = new BlockVariableDeclaration (type, li);
+	  }
+
+void case_888()
+#line 6829 "ps-parser.jay"
+{
+		yyVal = current_variable;
+		current_variable = null;
+	  }
+
+void case_896()
+#line 6856 "ps-parser.jay"
+{
+	  	var sl = yyVals[-2+yyTop] as StatementList;
+	  	if (sl == null) {
+	  		sl = new StatementList ((Statement) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop]);
+			lbag.AddStatement (sl, GetLocation (yyVals[-1+yyTop]));
+	  	} else {
+	  		sl.Add ((Statement) yyVals[0+yyTop]);
+	  		lbag.AppendTo (sl, GetLocation (yyVals[-1+yyTop]));
+	  	}
+	  		
+		yyVal = sl;
+	  }
+
+void case_899()
+#line 6880 "ps-parser.jay"
+{
+		start_block (GetLocation (yyVals[-5+yyTop]));
+		current_block.IsCompilerGenerated = true;
+	  }
+
+void case_900()
+#line 6885 "ps-parser.jay"
+{
+		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
+			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
+
+		var blockVar = yyVals[-6+yyTop] as BlockVariableDeclaration;
+		if (blockVar != null) {
+			if (blockVar == null || blockVar.Initializer != null || blockVar.Declarators != null) {
+				report.Error (7036, GetLocation (yyVals[-6+yyTop]), "Invalid for each initializer");	
+				yyVal = end_block (current_block.StartLocation);
+			} else {
+				Foreach f = new Foreach (blockVar.TypeExpression, blockVar.Variable, (Expression) yyVals[-3+yyTop], (Statement) yyVals[0+yyTop], current_block, AsForEachType.ForEachValue, GetLocation (yyVals[-9+yyTop]));
+				lbag.AddStatement (f, GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]));
+				
+				end_block (GetLocation (yyVals[-5+yyTop]));
+				yyVal = f;
+			}
+		} else {
+			var expList = yyVals[-6+yyTop] as List<Expression>;
+			var varRef = (yyVals[-6+yyTop] as FullNamedExpression) ?? ((expList != null && expList.Count == 1) ? (expList[0] as FullNamedExpression) : null);
+			if (varRef == null) {
+				report.Error (7041, GetLocation (yyVals[-6+yyTop]), "Invalid iterator initializer");		
+				yyVal = end_block (current_block.StartLocation);
+			} else {
+				Foreach f = new Foreach (varRef, (Expression) yyVals[-3+yyTop], (Statement) yyVals[0+yyTop], current_block, AsForEachType.ForEachValue, GetLocation (yyVals[-9+yyTop]));
+				lbag.AddStatement (f, GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-5+yyTop]), GetLocation (yyVals[-2+yyTop]));
+				
+				end_block (GetLocation (yyVals[-5+yyTop]));
+				yyVal = f;
+			}
+		}
+	  }
+
+void case_908()
+#line 6930 "ps-parser.jay"
+{
+		yyVal = new Break (GetLocation (yyVals[-1+yyTop]));
+		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_909()
+#line 6938 "ps-parser.jay"
+{
+		yyVal = new Continue (GetLocation (yyVals[-1+yyTop]));
+		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_910()
+#line 6943 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+		yyVal = new Continue (GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_911()
+#line 6951 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
+		yyVal = new Goto (lt.Value, GetLocation (yyVals[-2+yyTop]));
+		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_912()
+#line 6957 "ps-parser.jay"
+{
+		yyVal = new GotoCase ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-3+yyTop]));
+		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_913()
+#line 6962 "ps-parser.jay"
+{
+		yyVal = new GotoDefault (GetLocation (yyVals[-2+yyTop]));
+		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_914()
+#line 6970 "ps-parser.jay"
+{
+		yyVal = new Return ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
+		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_915()
+#line 6975 "ps-parser.jay"
+{
+	    Lexer.AutoSemiInsertion = true;
+		Error_SyntaxError (yyToken);
+		yyVal = new Return ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_916()
+#line 6981 "ps-parser.jay"
+{
+	    Lexer.AutoSemiInsertion = true;
+		Error_SyntaxError (yyToken);
+		yyVal = new Return (null, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_917()
+#line 6990 "ps-parser.jay"
+{
+		yyVal = new Throw ((Expression) yyVals[-1+yyTop], GetLocation (yyVals[-2+yyTop]));
+		lbag.AddStatement (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_918()
+#line 6995 "ps-parser.jay"
+{
+	    Lexer.AutoSemiInsertion = true;
+		Error_SyntaxError (yyToken);
+		yyVal = new Throw (null, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_919()
+#line 7004 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
+		string s = lt.Value;
+		if (s != "yield"){
+			report.Error (1003, lt.Location, "; expected");
+		} else if (yyVals[-1+yyTop] == null) {
+			report.Error (1627, GetLocation (yyVals[0+yyTop]), "Expression expected after yield return");
+		} else if (lang_version == LanguageVersion.ISO_1){
+			FeatureIsNotAvailable (lt.Location, "iterators");
+		}
+		
+		current_block.Explicit.RegisterIteratorYield ();
+		yyVal = new Yield ((Expression) yyVals[-1+yyTop], lt.Location);
+		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]), GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_920()
+#line 7020 "ps-parser.jay"
+{
+	    Lexer.AutoSemiInsertion = true;
+	  
+		Error_SyntaxError (yyToken);
+
+		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
+		string s = lt.Value;
+		if (s != "yield"){
+			report.Error (1003, lt.Location, "; expected");
+		} else if (yyVals[-1+yyTop] == null) {
+			report.Error (1627, GetLocation (yyVals[0+yyTop]), "Expression expected after yield return");
+		} else if (lang_version == LanguageVersion.ISO_1){
+			FeatureIsNotAvailable (lt.Location, "iterators");
+		}
+		
+		current_block.Explicit.RegisterIteratorYield ();
+		yyVal = new Yield ((Expression) yyVals[-1+yyTop], lt.Location);
+		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_921()
+#line 7040 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+		string s = lt.Value;
+		if (s != "yield"){
+			report.Error (1003, lt.Location, "; expected");
+		} else if (lang_version == LanguageVersion.ISO_1){
+			FeatureIsNotAvailable (lt.Location, "iterators");
+		}
+		
+		current_block.Explicit.RegisterIteratorYield ();
+		yyVal = new YieldBreak (lt.Location);
+		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]), GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_925()
+#line 7066 "ps-parser.jay"
+{
+		yyVal = new TryFinally ((Statement) yyVals[-2+yyTop], (Block) yyVals[0+yyTop], GetLocation (yyVals[-3+yyTop]));
+		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_926()
+#line 7071 "ps-parser.jay"
+{
+		yyVal = new TryFinally (new TryCatch ((Block) yyVals[-3+yyTop], (List<Catch>) yyVals[-2+yyTop], Location.Null, true), (Block) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
+		lbag.AddStatement (yyVal, GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_927()
+#line 7076 "ps-parser.jay"
+{
+		Error_SyntaxError (1524, yyToken);
+		yyVal = new TryCatch ((Block) yyVals[-1+yyTop], null, GetLocation (yyVals[-2+yyTop]), false);
+	  }
+
+void case_928()
+#line 7084 "ps-parser.jay"
+{
+		var l = new List<Catch> (2);
+
+		l.Add ((Catch) yyVals[0+yyTop]);
+		yyVal = l;
+	  }
+
+void case_929()
+#line 7091 "ps-parser.jay"
+{
+		var l = (List<Catch>) yyVals[-1+yyTop];
+		
+		Catch c = (Catch) yyVals[0+yyTop];
+		if (l [l.Count - 1].IsGeneral) {
+			report.Error (1017, c.loc, "Try statement already has an empty catch block");
+		}
+		
+		l.Add (c);
+		yyVal = l;
+	  }
+
+void case_933()
+#line 7115 "ps-parser.jay"
+{
+		start_block (GetLocation (yyVals[-4+yyTop]));
+		var c = new Catch (current_block, GetLocation (yyVals[-5+yyTop]));
+		c.TypeExpression = (FullNamedExpression) yyVals[-1+yyTop];
+
+		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
+		c.Variable = new LocalVariable (current_block, lt.Value, lt.Location);
+		c.Variable.TypeExpr = c.TypeExpression;
+		current_block.AddLocalName (c.Variable);
+		
+		lbag.AddLocation (c, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[0+yyTop]));
+		yyVal = c;
+	  }
+
+void case_935()
+#line 7133 "ps-parser.jay"
+{
+	  	if (yyToken == Token.CLOSE_PARENS) {
+			report.Error (1015, lexer.Location,
+				"A type that derives from `System.Exception', `object', or `string' expected");
+		} else {
+			Error_SyntaxError (yyToken);
+		}
+		
+		yyVal = new Catch (null, GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_936()
+#line 7144 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		/* Required otherwise missing block could not be detected because*/
+		/* start_block is run early*/
+		var c = new Catch (null, GetLocation (yyVals[-5+yyTop]));
+		c.TypeExpression = (FullNamedExpression) yyVals[-3+yyTop];
+
+		if (yyVals[-2+yyTop] != null) {
+			var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+			c.Variable = new LocalVariable (current_block, lt.Value, lt.Location);
+		}
+
+		lbag.AddLocation (c, GetLocation (yyVals[-4+yyTop]), GetLocation (yyVals[-1+yyTop]));
+
+		yyVal = c;
+	  }
+
+void case_939()
+#line 7179 "ps-parser.jay"
+{
+		if (!settings.Unsafe)
+			Error_UnsafeCodeNotAllowed (GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_941()
+#line 7189 "ps-parser.jay"
+{
+		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
+			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
+	  
+		yyVal = new Lock ((Expression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
+		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_942()
+#line 7197 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+
+		yyVal = new Lock ((Expression) yyVals[-1+yyTop], null, GetLocation (yyVals[-3+yyTop]));
+		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_943()
+#line 7207 "ps-parser.jay"
+{
+	    start_block (GetLocation (yyVals[-2+yyTop]));
+	    
+		current_block.IsCompilerGenerated = true;
+		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
+		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.FixedVariable | LocalVariable.Flags.Used, lt.Location);
+		current_block.AddLocalName (li);
+		current_variable = new Fixed.VariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
+	  }
+
+void case_944()
+#line 7217 "ps-parser.jay"
+{
+		yyVal = current_variable;
+		current_variable = null;
+	  }
+
+void case_945()
+#line 7222 "ps-parser.jay"
+{
+		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
+			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
+	  
+		Fixed f = new Fixed ((Fixed.VariableDeclaration) yyVals[-1+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-9+yyTop]));
+		current_block.AddStatement (f);
+		lbag.AddStatement (f, GetLocation (yyVals[-8+yyTop]), GetLocation (yyVals[-2+yyTop]));
+		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_946()
+#line 7235 "ps-parser.jay"
+{
+	    start_block (GetLocation (yyVals[-2+yyTop]));
+	    
+		current_block.IsCompilerGenerated = true;
+		var lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
+		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.UsingVariable | LocalVariable.Flags.Used, lt.Location);
+		current_block.AddLocalName (li);
+		current_variable = new Using.VariableDeclaration ((FullNamedExpression) yyVals[-1+yyTop], li);
+	  }
+
+void case_947()
+#line 7245 "ps-parser.jay"
+{
+		yyVal = current_variable;	  
+		current_variable = null;
+	  }
+
+void case_948()
+#line 7250 "ps-parser.jay"
+{
+	  	CheckIsPlayScript("using", GetLocation(yyVals[-7+yyTop]));
+	  	
+		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
+			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
+	  
+		Using u = new Using ((Using.VariableDeclaration) yyVals[-1+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-8+yyTop]));
+		lbag.AddStatement (u, GetLocation (yyVals[-7+yyTop]), GetLocation (yyVals[-2+yyTop]));
+		current_block.AddStatement (u);
+		yyVal = end_block (GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_949()
+#line 7262 "ps-parser.jay"
+{
+	  	CheckIsPlayScript("using", GetLocation(yyVals[-3+yyTop]));
+
+		if (yyVals[0+yyTop] is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
+			Warning_EmptyStatement (GetLocation (yyVals[0+yyTop]));
+	  
+		yyVal = new Using ((Expression) yyVals[-2+yyTop], (Statement) yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
+		lbag.AddStatement (yyVal, GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[-1+yyTop]));
+	  }
+
+void case_950()
+#line 7272 "ps-parser.jay"
+{
+	  	CheckIsPlayScript("using", GetLocation(yyVals[-2+yyTop]));
+	  
+		Error_SyntaxError (yyToken);
+		
+		yyVal = new Using ((Expression) yyVals[-1+yyTop], null, GetLocation (yyVals[-3+yyTop]));
+		lbag.AddStatement (yyVal, GetLocation (yyVals[-2+yyTop]));
+	  }
+
+void case_952()
+#line 7285 "ps-parser.jay"
+{
+		/* It has to be here for the parent to safely restore artificial block*/
+	  	Error_SyntaxError (yyToken);
+	  }
+
+void case_954()
+#line 7297 "ps-parser.jay"
+{
+		current_variable.Initializer = (Expression) yyVals[0+yyTop];
+		lbag.AppendTo (current_variable, GetLocation (yyVals[-1+yyTop]));
+		yyVal = current_variable;
+	  }
+
+void case_955()
+#line 7321 "ps-parser.jay"
+{
+		lexer.query_parsing = false;
+			
+		Linq.AQueryClause from = yyVals[-1+yyTop] as Linq.AQueryClause;
+			
+		from.Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
+		yyVal = from;
+		
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+	  }
+
+void case_956()
+#line 7333 "ps-parser.jay"
+{
+		Linq.AQueryClause from = yyVals[-1+yyTop] as Linq.AQueryClause;
+			
+		from.Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
+		yyVal = from;
+		
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+	  }
+
+void case_957()
+#line 7344 "ps-parser.jay"
+{
+	        lexer.query_parsing = false;
+		yyVal = yyVals[-1+yyTop];
+
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+	  }
+
+void case_958()
+#line 7351 "ps-parser.jay"
+{
+	        yyVal = yyVals[-1+yyTop];
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+	  }
+
+void case_959()
+#line 7360 "ps-parser.jay"
+{
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
+		yyVal = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-3+yyTop])));
+	  }
+
+void case_960()
+#line 7368 "ps-parser.jay"
+{
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
+		yyVal = new Linq.QueryExpression (
+			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-4+yyTop])) {
+				IdentifierType = (FullNamedExpression)yyVals[-3+yyTop]
+			}
+		);
+	  }
+
+void case_961()
+#line 7383 "ps-parser.jay"
+{
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
+		yyVal = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-3+yyTop])));
+	  }
+
+void case_962()
+#line 7391 "ps-parser.jay"
+{
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
+		yyVal = new Linq.QueryExpression (
+			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], rv, GetLocation (yyVals[-4+yyTop])) {
+				IdentifierType = (FullNamedExpression)yyVals[-3+yyTop]
+			}
+		);
+	  }
+
+void case_964()
+#line 7410 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
+		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
+		yyVal = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
+		
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+		
+		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
+	  }
+
+void case_966()
+#line 7425 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
+		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
+
+		yyVal = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop])) {
+			IdentifierType = (FullNamedExpression)yyVals[-4+yyTop]
+		};
+		
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+		
+		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
+	  }
+
+void case_967()
+#line 7442 "ps-parser.jay"
+{
+	  	Linq.AQueryClause head = (Linq.AQueryClause)yyVals[-1+yyTop];
+		
+		if (yyVals[0+yyTop] != null)
+			head.Next = (Linq.AQueryClause)yyVals[0+yyTop];
+				
+		if (yyVals[-2+yyTop] != null) {
+			Linq.AQueryClause clause = (Linq.AQueryClause)yyVals[-2+yyTop];
+			clause.Tail.Next = head;
+			head = clause;
+		}
+		
+		yyVal = head;
+	  }
+
+void case_968()
+#line 7457 "ps-parser.jay"
+{
+	  	Linq.AQueryClause head = (Linq.AQueryClause)yyVals[0+yyTop];
+
+		if (yyVals[-1+yyTop] != null) {
+			Linq.AQueryClause clause = (Linq.AQueryClause)yyVals[-1+yyTop];
+			clause.Tail.Next = head;
+			head = clause;
+		}
+		
+		yyVal = head;
+	  }
+
+void case_970()
+#line 7470 "ps-parser.jay"
+{
+		report.Error (742, GetLocation (yyVals[0+yyTop]), "Unexpected symbol `{0}'. A query body must end with select or group clause", GetSymbolName (yyToken));
+		yyVal = yyVals[-1+yyTop];
+	  }
+
+void case_971()
+#line 7475 "ps-parser.jay"
+{
+		Error_SyntaxError (yyToken);
+		yyVal = null;
+	  }
+
+void case_973()
+#line 7487 "ps-parser.jay"
+{
+		yyVal = new Linq.Select ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
+
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+	  }
+
+void case_974()
+#line 7494 "ps-parser.jay"
+{
+	  	if (linq_clause_blocks == null)
+	  		linq_clause_blocks = new Stack<Linq.QueryBlock> ();
+	  		
+	  	current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  	linq_clause_blocks.Push ((Linq.QueryBlock)current_block);
+	  }
+
+void case_975()
+#line 7502 "ps-parser.jay"
+{
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+	  
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  }
+
+void case_976()
+#line 7509 "ps-parser.jay"
+{
+		yyVal = new Linq.GroupBy ((Linq.QueryBlock)current_block, (Expression)yyVals[-3+yyTop], linq_clause_blocks.Pop (), (Expression)yyVals[0+yyTop], GetLocation (yyVals[-5+yyTop]));
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-1+yyTop]));
+		
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+	  }
+
+void case_978()
+#line 7521 "ps-parser.jay"
+{
+		((Linq.AQueryClause)yyVals[-1+yyTop]).Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
+		yyVal = yyVals[-1+yyTop];
+	  }
+
+void case_985()
+#line 7541 "ps-parser.jay"
+{
+		var lt = (Tokenizer.LocatedToken) yyVals[-3+yyTop];
+		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
+	  	yyVal = new Linq.Let ((Linq.QueryBlock) current_block, sn, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-4+yyTop]));
+		lbag.AddLocation (yyVal, GetLocation (yyVals[-2+yyTop]));
+	  	
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+		
+		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
+	  }
+
+void case_987()
+#line 7560 "ps-parser.jay"
+{
+		yyVal = new Linq.Where ((Linq.QueryBlock)current_block, (Expression)yyVals[0+yyTop], GetLocation (yyVals[-2+yyTop]));
+
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+	  }
+
+void case_988()
+#line 7570 "ps-parser.jay"
+{
+		if (linq_clause_blocks == null)
+			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
+	  		
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
+	  }
+
+void case_989()
+#line 7578 "ps-parser.jay"
+{
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
+	  }
+
+void case_990()
+#line 7586 "ps-parser.jay"
+{
+		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  }
+
+void case_991()
+#line 7594 "ps-parser.jay"
+{
+		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
+		current_block.SetEndLocation (lexer.Location);
+	  
+		var outer_selector = linq_clause_blocks.Pop ();
+		var block = linq_clause_blocks.Pop ();
+
+		var lt = (Tokenizer.LocatedToken) yyVals[-10+yyTop];	
+		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
+		Linq.RangeVariable into;
+		
+		if (yyVals[0+yyTop] == null) {
+			into = sn;
+	  		yyVal = new Linq.Join (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, GetLocation (yyVals[-11+yyTop]));
+			lbag.AddLocation (yyVal, GetLocation (yyVals[-9+yyTop]), GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-3+yyTop]));
+		} else {
+			/**/
+			/* Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions*/
+			/**/
+			var parent = block.Parent;
+			while (parent is Linq.QueryBlock) {
+				parent = parent.Parent;
+			}
+			current_block.Parent = parent;
+			
+			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
+		
+			lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
+			into = new Linq.RangeVariable (lt.Value, lt.Location);
+
+			yyVal = new Linq.GroupJoin (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, into, GetLocation (yyVals[-11+yyTop]));	
+			lbag.AddLocation (yyVal, GetLocation (yyVals[-9+yyTop]), GetLocation (yyVals[-6+yyTop]), GetLocation (yyVals[-3+yyTop]), GetLocation (yyVals[0+yyTop]));
+		}
+
+		current_block = block.Parent;
+		((Linq.QueryBlock)current_block).AddRangeVariable (into);
+	  }
+
+void case_992()
+#line 7632 "ps-parser.jay"
+{
+		if (linq_clause_blocks == null)
+			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
+	  		
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
+	  }
+
+void case_993()
+#line 7640 "ps-parser.jay"
+{
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
+	  }
+
+void case_994()
+#line 7648 "ps-parser.jay"
+{
+		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  }
+
+void case_995()
+#line 7656 "ps-parser.jay"
+{
+		current_block.AddStatement (new ContextualReturn ((Expression) yyVals[-1+yyTop]));
+		current_block.SetEndLocation (lexer.Location);
+	  
+		var outer_selector = linq_clause_blocks.Pop ();
+		var block = linq_clause_blocks.Pop ();
+		
+		var lt = (Tokenizer.LocatedToken) yyVals[-10+yyTop];
+		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
+		Linq.RangeVariable into;
+		
+		if (yyVals[0+yyTop] == null) {
+			into = sn;		
+	  		yyVal = new Linq.Join (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, GetLocation (yyVals[-12+yyTop])) {
+	  			IdentifierType = (FullNamedExpression)yyVals[-11+yyTop]
+	  		};
+		} else {
+			/**/
+			/* Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions*/
+			/**/
+			var parent = block.Parent;
+			while (parent is Linq.QueryBlock) {
+				parent = parent.Parent;
+			}
+			current_block.Parent = parent;
+		
+			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
+		
+			lt = (Tokenizer.LocatedToken) yyVals[0+yyTop];
+			into = new Linq.RangeVariable (lt.Value, lt.Location); /* TODO:*/
+			
+			yyVal = new Linq.GroupJoin (block, sn, (Expression)yyVals[-7+yyTop], outer_selector, (Linq.QueryBlock) current_block, into, GetLocation (yyVals[-12+yyTop])) {
+	  			IdentifierType = (FullNamedExpression)yyVals[-11+yyTop]
+	  		};			
+		}
+		
+		current_block = block.Parent;
+		((Linq.QueryBlock)current_block).AddRangeVariable (into);		
+	  }
+
+void case_999()
+#line 7711 "ps-parser.jay"
+{
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+	  
+		yyVal = yyVals[0+yyTop];
+	  }
+
+void case_1001()
+#line 7722 "ps-parser.jay"
+{
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+	  
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  }
+
+void case_1002()
+#line 7729 "ps-parser.jay"
+{
+		((Linq.AQueryClause)yyVals[-3+yyTop]).Next = (Linq.AQueryClause)yyVals[0+yyTop];
+		yyVal = yyVals[-3+yyTop];
+	  }
+
+void case_1004()
+#line 7738 "ps-parser.jay"
+{
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+	  
+		current_block = new Linq.QueryBlock ((Linq.QueryBlock) current_block, lexer.Location);	 
+	 }
+
+void case_1005()
+#line 7745 "ps-parser.jay"
+{
+		((Linq.AQueryClause)yyVals[-3+yyTop]).Tail.Next = (Linq.AQueryClause)yyVals[0+yyTop];
+		yyVal = yyVals[-3+yyTop];
+	 }
+
+void case_1007()
+#line 7757 "ps-parser.jay"
+{
+		yyVal = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
+		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_1008()
+#line 7762 "ps-parser.jay"
+{
+		yyVal = new Linq.OrderByDescending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
+		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_1010()
+#line 7774 "ps-parser.jay"
+{
+		yyVal = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
+		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_1011()
+#line 7779 "ps-parser.jay"
+{
+		yyVal = new Linq.ThenByDescending ((Linq.QueryBlock) current_block, (Expression)yyVals[-1+yyTop]);	
+		lbag.AddLocation (yyVal, GetLocation (yyVals[0+yyTop]));
+	  }
+
+void case_1013()
+#line 7789 "ps-parser.jay"
+{
+		/* query continuation block is not linked with query block but with block*/
+		/* before. This means each query can use same range variable names for*/
+		/* different identifiers.*/
+
+		current_block.SetEndLocation (GetLocation (yyVals[-1+yyTop]));
+		current_block = current_block.Parent;
+	
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+		
+		if (linq_clause_blocks == null)
+			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
+	  		
+		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);		
+	  }
+
+void case_1014()
+#line 7805 "ps-parser.jay"
+{
+		var current_block = linq_clause_blocks.Pop ();	  
+		var lt = (Tokenizer.LocatedToken) yyVals[-2+yyTop];
+		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
+  		yyVal = new Linq.QueryStartClause ((Linq.QueryBlock)current_block, null, rv, GetLocation (yyVals[-3+yyTop])) {
+  			next = (Linq.AQueryClause)yyVals[0+yyTop]
+  		};
+	  }
+
+void case_1017()
+#line 7832 "ps-parser.jay"
+{ 
+		current_container = current_type = new Class (current_container, new MemberName ("<InteractiveExpressionClass>"), Modifiers.PUBLIC, null);
+
+		/* (ref object retval)*/
+		Parameter [] mpar = new Parameter [1];
+		mpar [0] = new Parameter (new TypeExpression (compiler.BuiltinTypes.Object, Location.Null), "$retval", Parameter.Modifier.REF, null, Location.Null);
+
+		ParametersCompiled pars = new ParametersCompiled (mpar);
+		var mods = Modifiers.PUBLIC | Modifiers.STATIC;
+		if (settings.Unsafe)
+			mods |= Modifiers.UNSAFE;
+
+		current_local_parameters = pars;
+		Method method = new Method (
+			current_type,
+			new TypeExpression (compiler.BuiltinTypes.Void, Location.Null),
+			mods,
+			new MemberName ("Host"),
+			pars,
+			null /* attributes */);
+			
+		current_type.AddMember (method);
+
+		/* Always set to true when in ineractive mode*/
+		is_config_enabled = true; 
+		
+		oob_stack.Push (method);
+		++lexer.parsing_block;
+		start_block (lexer.Location);
+	  }
+
+void case_1018()
+#line 7863 "ps-parser.jay"
+{
+		--lexer.parsing_block;
+		Method method = (Method) oob_stack.Pop ();
+
+		method.Block = (ToplevelBlock) end_block(lexer.Location);
+
+		InteractiveResult = (Class) pop_current_class ();
+		current_local_parameters = null;
+	  }
+
+void case_1026()
+#line 7906 "ps-parser.jay"
+{
+		module.DocumentationBuilder.ParsedBuiltinType = (TypeExpression)yyVals[-1+yyTop];
+		module.DocumentationBuilder.ParsedParameters = (List<DocumentationParameter>)yyVals[0+yyTop];
+		yyVal = null;
+	  }
+
+void case_1027()
+#line 7912 "ps-parser.jay"
+{
+		module.DocumentationBuilder.ParsedBuiltinType = (TypeExpression)yyVals[-3+yyTop];
+		module.DocumentationBuilder.ParsedParameters = (List<DocumentationParameter>)yyVals[0+yyTop];
+		var lt = (Tokenizer.LocatedToken) yyVals[-1+yyTop];
+		yyVal = new MemberName (lt.Value);
+	  }
+
+void case_1030()
+#line 7927 "ps-parser.jay"
+{
+		module.DocumentationBuilder.ParsedParameters = (List<DocumentationParameter>)yyVals[-1+yyTop];
+		yyVal = new MemberName ((MemberName) yyVals[-6+yyTop], MemberCache.IndexerNameAlias, Location.Null);
+	  }
+
+void case_1031()
+#line 7932 "ps-parser.jay"
+{
+		var p = (List<DocumentationParameter>)yyVals[0+yyTop] ?? new List<DocumentationParameter> (1);
+		p.Add (new DocumentationParameter ((FullNamedExpression) yyVals[-1+yyTop]));
+		module.DocumentationBuilder.ParsedParameters = p;
+		module.DocumentationBuilder.ParsedOperator = Operator.OpType.Explicit;
+		yyVal = null;
+	  }
+
+void case_1032()
+#line 7940 "ps-parser.jay"
+{
+		var p = (List<DocumentationParameter>)yyVals[0+yyTop] ?? new List<DocumentationParameter> (1);
+		p.Add (new DocumentationParameter ((FullNamedExpression) yyVals[-1+yyTop]));
+		module.DocumentationBuilder.ParsedParameters = p;
+		module.DocumentationBuilder.ParsedOperator = Operator.OpType.Implicit;
+		yyVal = null;
+	  }
+
+void case_1033()
+#line 7948 "ps-parser.jay"
+{
+		var p = (List<DocumentationParameter>)yyVals[0+yyTop] ?? new List<DocumentationParameter> (1);
+		module.DocumentationBuilder.ParsedParameters = p;
+		module.DocumentationBuilder.ParsedOperator = (Operator.OpType) yyVals[-1+yyTop];
+		yyVal = null;
+	  }
+
+void case_1041()
+#line 7986 "ps-parser.jay"
+{
+		var parameters = new List<DocumentationParameter> ();
+		parameters.Add ((DocumentationParameter) yyVals[0+yyTop]);
+		yyVal = parameters;
+	  }
+
+void case_1042()
+#line 7992 "ps-parser.jay"
+{
+		var parameters = yyVals[-2+yyTop] as List<DocumentationParameter>;
+		parameters.Add ((DocumentationParameter) yyVals[0+yyTop]);
+		yyVal = parameters;
+	  }
+
+void case_1043()
+#line 8001 "ps-parser.jay"
+{
+		if (yyVals[-1+yyTop] != null)
+			yyVal = new DocumentationParameter ((Parameter.Modifier) yyVals[-1+yyTop], (FullNamedExpression) yyVals[0+yyTop]);
+		else
+			yyVal = new DocumentationParameter ((FullNamedExpression) yyVals[0+yyTop]);
+	  }
+
+#line default
+   static readonly short [] yyLhs  = {              -1,
+    0,    4,    0,    0,    1,    1,    1,    1,    2,    2,
+   11,   11,   12,   12,   13,   13,   16,   16,   18,   17,
+   19,   17,   20,   20,   15,   21,   14,   24,   22,   22,
+   22,   22,   27,   28,   30,   31,    8,   26,   26,   32,
+   32,   32,   33,   33,   34,   34,   29,   29,    7,    7,
+    6,    6,   35,   35,   36,   36,   37,   37,   37,   38,
+   38,   38,   42,   39,   43,   39,   40,   40,   40,   40,
+   40,   40,    9,    9,   10,   10,   52,   50,   55,   51,
+   51,   53,   53,   53,   53,   54,   54,   59,   56,   57,
+   58,   58,   60,   60,   60,   60,   60,   61,   61,   65,
+   62,   64,   67,   67,   67,   68,   68,   69,   69,   70,
+   70,   70,   70,   70,   70,   70,   70,   70,   70,   70,
+   70,   70,   70,   70,   81,   82,   84,   79,   85,   78,
+   88,   90,   93,   94,   95,   45,   45,   98,   71,   99,
+   99,  100,  100,  101,   97,   97,  105,  103,  103,  104,
+  108,   72,  112,   72,   72,  107,  115,  107,  109,  109,
+  116,  116,  117,  118,  117,  113,  113,  119,  119,  120,
+  121,  111,  111,  114,  114,  124,   41,  127,  129,  122,
+  130,  122,  132,  122,  133,  134,  135,  122,  122,  122,
+  128,  128,  131,  123,  123,  126,  126,  138,  138,  138,
+  138,  138,  138,  139,  139,  141,  141,  141,  144,  141,
+  142,  142,  145,  145,  146,  146,  146,  140,  140,  140,
+  148,  150,  151,   73,  153,  154,  155,   75,  149,  149,
+  149,  149,  149,  159,  156,  160,  157,  158,  158,  158,
+  161,  162,  163,  165,  166,   46,   46,  164,  164,  167,
+  167,  168,  168,  168,  168,  168,  168,  168,  168,  171,
+   76,  170,  170,  172,  172,  175,  169,  169,  174,  174,
+  174,  174,  174,  174,  174,  174,  174,  174,  174,  174,
+  174,  174,  174,  174,  174,  174,  174,  174,  174,  174,
+  174,  174,  177,  176,  178,  176,  176,  176,  179,   77,
+  181,   74,  184,  185,   74,  180,  187,  180,  182,  182,
+  188,  188,  189,  190,  189,  191,  186,  183,  183,  183,
+  183,  183,  195,  192,  196,  193,  194,  194,   80,  198,
+  200,  201,   47,  197,  197,  197,  199,  199,  199,  202,
+  202,  203,  204,  203,  203,  203,  205,  206,  207,   48,
+   49,  208,  208,  209,  210,  210,   23,  211,  211,  212,
+  213,  213,  213,  214,  214,  216,   87,  147,  125,  125,
+  152,  152,  217,  217,  215,  215,  218,  218,  219,  219,
+  221,  221,  102,   96,   96,  110,  110,  143,  143,  173,
+  173,  222,  222,  222,  225,  225,  226,  224,  224,  224,
+  224,  227,  227,  227,  227,  227,  227,  227,  227,  227,
+  228,  228,  228,  228,  228,  228,  228,  228,  228,  228,
+  228,  228,  228,  228,  228,  228,  228,  229,  229,  229,
+  230,  230,  230,  230,  247,  247,  248,  248,  249,  249,
+  231,  231,  246,  246,  246,  246,  246,  246,  246,  246,
+  246,  246,  246,  246,  246,  246,  246,  233,  233,  233,
+  233,  245,  245,  253,  257,  255,  255,  254,  254,  256,
+  256,  256,  258,  258,  258,  258,  259,  251,  251,  252,
+  252,  252,  252,  252,  261,  261,  260,  260,  262,  262,
+  263,  234,  234,  234,  234,  234,  234,  264,  264,  264,
+  250,  250,  265,  265,  235,  236,  236,  237,  238,  242,
+  242,  242,  242,  223,  223,  266,  266,  267,  267,  244,
+  244,  268,  270,  269,  271,  271,   25,   25,   25,  272,
+  272,  272,  272,  273,  239,  239,  240,  240,  241,  241,
+  274,  275,  243,  276,  277,  243,  279,  280,  278,  281,
+  282,  278,  232,  283,  283,  283,  283,  283,  283,  283,
+  283,  283,  283,  283,  283,  283,  284,  284,  284,  284,
+  284,  284,  284,  284,  284,  284,  284,  285,  285,  285,
+  285,  285,  285,  285,  286,  286,  286,  286,  286,  286,
+  286,  286,  286,  286,  286,  287,  287,  287,  287,  287,
+  287,  287,  288,  288,  288,  288,  288,  288,  288,  288,
+  288,  289,  289,  289,  289,  289,  290,  290,  290,  291,
+  291,  291,  292,  292,  292,  293,  293,  293,  294,  294,
+  294,  295,  295,  296,  296,  296,  296,  297,  297,  297,
+  297,  297,  297,  297,  297,  297,  297,  297,  297,  297,
+  297,  298,  298,  299,  299,  299,  299,  300,  300,  302,
+  301,  301,  301,  303,  303,  305,  304,  306,  304,  307,
+  304,  308,  309,  304,  310,  311,  304,   63,   63,  312,
+  312,  312,  106,  314,  315,  316,  317,  318,  319,   44,
+   86,   86,   83,   83,  136,  136,  320,  320,  320,  320,
+  320,  320,  320,  320,  320,  320,  320,  320,  320,  320,
+  320,  320,  320,   89,   89,   89,   91,   91,   91,   92,
+   92,  321,  321,  322,  322,  323,  323,  324,  324,  324,
+  324,  220,  220,  325,  325,  327,  137,  331,  329,  330,
+  330,  328,  328,  333,  332,  326,  326,  334,  334,  335,
+  335,  335,  335,  339,  339,  340,  340,  340,  337,  337,
+  337,  337,  337,  337,  337,  337,  337,  337,  337,  337,
+  337,  337,  341,  341,  341,  341,  341,  341,  341,  341,
+  341,  341,  341,  341,  341,  341,  355,  355,  355,  355,
+  342,  356,  338,  357,  359,  359,  360,  360,  360,   66,
+   66,  358,  362,  336,  364,  336,  366,  336,  361,  361,
+  361,  363,  363,  370,  370,  369,  369,  371,  371,  371,
+  371,  365,  365,  367,  367,  372,  372,  373,  368,  343,
+  343,  343,  354,  354,  374,  375,  375,  344,  344,  378,
+  379,  376,  376,  376,  381,  377,  377,  380,  380,  382,
+  382,  382,  385,  383,  384,  384,  386,  386,  386,  345,
+  345,  345,  345,  387,  387,  391,  392,  388,  388,  388,
+  394,  389,  396,  393,  399,  393,  393,  402,  398,  398,
+  401,  401,  403,  403,  397,  397,  405,  395,  395,  400,
+  400,  404,  404,  406,  407,  407,  408,  409,  410,  390,
+  346,  346,  346,  346,  346,  346,  346,  411,  412,  412,
+  413,  413,  413,  414,  414,  414,  415,  415,  416,  416,
+  416,  417,  417,  347,  347,  347,  347,  418,  418,  420,
+  420,  419,  421,  419,  419,  419,  348,  349,  422,  352,
+  350,  350,  424,  425,  353,  427,  428,  351,  351,  351,
+  426,  426,  423,  423,  313,  313,  313,  313,  429,  429,
+  431,  431,  433,  432,  434,  432,  430,  430,  430,  430,
+  430,  438,  436,  439,  440,  436,  435,  435,  441,  441,
+  441,  441,  441,  446,  442,  447,  443,  448,  449,  450,
+  444,  452,  453,  454,  444,  451,  451,  456,  445,  455,
+  459,  455,  458,  461,  458,  457,  457,  457,  460,  460,
+  460,  437,  462,  437,    3,    3,  464,    3,    3,  465,
+  465,  463,  463,    5,  466,  466,  466,  466,  470,  466,
+  466,  466,  466,  467,  467,  468,  471,  468,  469,  469,
+  472,  472,  473,
+  };
+   static readonly short [] yyLen = {           2,
+    2,    0,    3,    1,    2,    4,    3,    1,    0,    1,
+    1,    2,    4,    2,    1,    1,    1,    1,    0,    3,
+    0,    5,    1,    2,    1,    4,    1,    0,    5,    3,
+    5,    2,    0,    0,    0,    0,   11,    0,    1,    1,
+    3,    1,    0,    1,    0,    1,    2,    3,    0,    1,
+    0,    1,    0,    1,    1,    2,    1,    1,    2,    1,
+    1,    1,    0,    3,    0,    5,    1,    1,    1,    1,
+    1,    1,    0,    1,    1,    2,    0,    3,    0,    6,
+    3,    1,    1,    1,    1,    1,    3,    0,    3,    1,
+    0,    3,    0,    1,    1,    3,    3,    1,    1,    0,
+    4,    4,    0,    1,    1,    0,    1,    1,    2,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    3,    3,    0,    3,    0,    5,
+    0,    0,    0,    0,    0,   17,    5,    0,   10,    0,
+    1,    1,    2,    5,    0,    1,    0,    3,    1,    1,
+    0,   10,    0,   10,    8,    0,    0,    3,    0,    1,
+    1,    2,    4,    0,    7,    0,    1,    1,    2,    5,
+    0,    4,    2,    1,    1,    0,    3,    0,    0,   11,
+    0,   10,    0,   10,    0,    0,    0,   14,   10,    5,
+    0,    2,    1,    1,    1,    0,    1,    1,    3,    3,
+    5,    1,    1,    1,    3,    5,    2,    5,    0,    8,
+    0,    1,    1,    2,    1,    1,    1,    3,    5,    3,
+    0,    0,    0,   12,    0,    0,    0,   15,    1,    2,
+    1,    2,    1,    0,    5,    0,    5,    1,    1,    1,
+    0,    0,    0,    0,    0,   17,    5,    0,    1,    1,
+    2,    1,    1,    1,    1,    1,    1,    1,    1,    0,
+    5,    1,    1,    1,    1,    0,    8,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    0,    7,    0,    7,    2,    2,    0,    9,
+    0,   10,    0,    0,   11,    0,    0,    3,    0,    1,
+    1,    2,    4,    0,    7,    0,    2,    2,    2,    1,
+    1,    1,    0,    5,    0,    5,    1,    1,    2,    0,
+    0,    0,   12,    0,    2,    2,    0,    1,    2,    1,
+    3,    2,    0,    5,    3,    1,    0,    0,    0,   14,
+    6,    0,    1,    2,    0,    1,    1,    1,    4,    2,
+    0,    3,    2,    1,    3,    0,    3,    1,    1,    3,
+    1,    2,    3,    4,    0,    3,    1,    3,    3,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    2,    2,    1,    2,    1,    3,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    2,    2,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    3,    3,    4,    3,    2,    3,    2,    3,    5,    5,
+    5,    4,    4,    3,    4,    3,    4,    4,    4,    4,
+    4,    3,    4,    1,    1,    1,    1,    0,    1,    1,
+    3,    2,    3,    3,    3,    1,    1,    0,    1,    1,
+    3,    3,    3,    2,    1,    1,    1,    1,    2,    2,
+    1,    4,    4,    3,    4,    4,    3,    1,    3,    2,
+    1,    3,    1,    1,    1,    4,    3,    2,    2,    2,
+    2,    4,    5,    1,    2,    2,    3,    1,    2,    2,
+    4,    1,    1,    1,    1,    3,    1,    1,    1,    2,
+    3,    4,    4,    1,    4,    4,    4,    2,    4,    2,
+    0,    0,    9,    0,    0,   10,    0,    0,   10,    0,
+    0,   11,    4,    1,    2,    2,    2,    2,    2,    2,
+    2,    2,    2,    2,    2,    2,    1,    2,    2,    2,
+    2,    2,    2,    2,    2,    2,    2,    1,    3,    3,
+    3,    3,    3,    3,    1,    3,    3,    3,    3,    3,
+    3,    3,    3,    3,    3,    1,    3,    3,    3,    3,
+    3,    3,    1,    3,    3,    3,    3,    3,    3,    3,
+    3,    1,    3,    3,    3,    3,    1,    3,    3,    1,
+    3,    3,    1,    3,    3,    1,    3,    3,    1,    3,
+    3,    1,    3,    1,    5,    4,    5,    3,    3,    3,
+    3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+    3,    1,    3,    3,    2,    1,    1,    0,    1,    0,
+    2,    1,    1,    1,    1,    0,    4,    0,    4,    0,
+    5,    0,    0,    7,    0,    0,    8,    1,    1,    1,
+    1,    1,    1,    1,    0,    0,    0,    0,    0,   17,
+    0,    1,    0,    1,    1,    2,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    0,    2,    3,    0,    2,    3,    0,
+    1,    1,    2,    4,    3,    1,    3,    1,    3,    1,
+    1,    0,    1,    1,    1,    0,    4,    0,    5,    0,
+    3,    1,    1,    0,    4,    0,    1,    1,    2,    1,
+    1,    1,    1,    1,    2,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    0,    4,    4,    1,    2,    2,    2,    1,    1,
+    1,    1,    0,    8,    0,    6,    0,    8,    0,    2,
+    1,    0,    1,    0,    1,    1,    2,    2,    4,    4,
+    6,    0,    2,    0,    1,    1,    2,    4,    1,    2,
+    2,    2,    2,    2,    1,    1,    1,    1,    1,    1,
+    1,    5,    7,    4,    0,    8,    4,    0,    1,    1,
+    2,    1,    0,    3,    1,    2,    3,    3,    1,    1,
+    1,    1,    1,    5,    4,    1,    1,    7,    3,    6,
+    0,    4,    0,    6,    0,    5,    1,    0,    4,    2,
+    2,    2,    1,    1,    0,    1,    0,    7,    1,    0,
+    1,    0,    1,    1,    1,    3,    0,    0,    0,   10,
+    1,    1,    1,    1,    1,    1,    1,    2,    2,    2,
+    3,    4,    3,    3,    3,    2,    3,    2,    4,    4,
+    3,    0,    1,    3,    4,    5,    3,    1,    2,    0,
+    1,    2,    0,    8,    3,    6,    2,    2,    0,    3,
+    5,    4,    0,    0,   10,    0,    0,    9,    5,    4,
+    2,    1,    0,    2,    2,    2,    2,    2,    4,    5,
+    4,    5,    0,    5,    0,    6,    3,    2,    2,    2,
+    1,    0,    3,    0,    0,    6,    1,    2,    1,    1,
+    1,    1,    1,    0,    5,    0,    3,    0,    0,    0,
+   12,    0,    0,    0,   13,    0,    2,    0,    3,    1,
+    0,    4,    1,    0,    4,    1,    2,    2,    1,    2,
+    2,    0,    0,    4,    2,    3,    0,    4,    2,    2,
+    3,    0,    1,    2,    2,    2,    4,    3,    0,    7,
+    4,    4,    3,    1,    3,    0,    0,    4,    0,    1,
+    1,    3,    2,
+  };
+   static readonly short [] yyDefRed = {            0,
+    8,    0,    0,    0,    0,    0,    0,    0,    2,    4,
+    0,    0,   11,   14,    0, 1015,    0,    0, 1019,    0,
+    0,    0,   17,   15,   16,   23,   18,    0,   25,   27,
+  403,  410,  398,  400,    0,  399,    0,  406,  408,    0,
+  402,  404,  407,  409,  405,  366, 1034,    0,  401, 1024,
+    0,   10,    1,    0,    0,    0,   12,    0,  837,    0,
+    0,    0,    0,    0,    0,    0,  866,  436,    0,    0,
+  897,    0,    0,    0,    0,    0,  434,    0,    0,    0,
+  505,    0,  435,    0,    0,    0,  433,  939,    0,    0,
+    0,    0,    0,    0,    0,    0,  522,    0,  791,    0,
+    0,    0,    0,    0,    0,    0,    0,  432,    0,  672,
+  523,  464,  836,    0,    0,    0,  411,  412,  413,  414,
+  415,  416,  417,  418,  419,  420,  421,  422,  423,  424,
+  425,  426,  427,  430,  431,    0,    0,    0,  786,  567,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  680,  678,  681,  679,  682,  773,    0,  756,
+  758,    0,  754,  757,  774,  776,  777,  778,  779,  780,
+  781,  782,  783,  784,  785,  775,  907,    0,  838,  839,
+  860,  861,  862,  863,    0,  901,  902,  903,  904,  905,
+  906,    0,    0,    0,    0,  382,  801,  393,    0,    0,
+    0,    0,  381,  357,  358,  527,    0,    0,    0,    0,
+    0,    0, 1023,   24, 1016,    0,    0,  274,  273,  270,
+  275,  276,  269,  289,  288,  280,  281,  277,  279,  278,
+  282,  271,  272,  283,  284,  285,  291,  290,  286,  287,
+  292,    0,    0, 1037,    0, 1026,    0, 1025,    3,   77,
+    0,    0,    0,   75,   13,    0,  437,    0,  438,    0,
+    0,  802,  908,  538,  736,  937,    0,  800,    0,  910,
+  909,    0,  566,    0,    0,    0,    0,    0,    0,  560,
+    0,  871,    0,  541,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  511,  916,    0,    0,    0,    0,
+    0,    0,    0,  918,  923,    0,    0,  565,  559,  540,
+  938,    0,    0,    0,    0,    0,    0,  385,    0,    0,
+    0,    0,  384,    0,    0,    0,  675,    0,  563,  668,
+  557,    0,  562,  556,  573,  568,  574,  569,  561,  555,
+  577,  572,  575,  570,  576,  571,  564,  558,  666,    0,
+    0,  429,  428,    0,    0,    0,  792,    0,    0,    0,
+    0,    0,  445,    0,  447,    0,  508,  509,    0,    0,
+    0,    0,    0,  476,    0,    0,  470,  524,  520,  175,
+  174,  525,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,  738,  755, 1018,  833,  834,  790,  835,
+  772,  759,  788,  787,  789,  760,  761,  762,  763,  764,
+  765,  766,  767,  768,  769,  770,  771,    0,    0,  971,
+  986,    0,    0,  972,  974,    0,  998,  957,  955,  979,
+    0,    0,  977,  980,  981,  982,  983,  958,  956, 1021,
+    0,    0,  360,  356,    0,    0,  392,   30,  534,  530,
+    0,  391,    0,  394,    0,    0,   20,    0,    0,    0,
+ 1033,    0,  367,    0,    0,    0, 1035,    0,    6,   33,
+   76,  507,    0,    0,  503,  504,    0,    0,  501,    0,
+    0,    0,  485,  488,    0,    0,  480,  487,  486,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  547,  683,
+    0,  913,  911,  684,    0,    0,    0,    0,    0,  915,
+  914,    0,    0,  917,  927,    0,    0,    0,  928,    0,
+  940,    0,  799,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  544,    0,    0,  670,    0,
+  441,  442,    0,  741,  363,  364,    0,  216,  215,  217,
+  389,  657,    0,    0,    0,  388,    0,  652,    0,  921,
+    0,    0,    0,    0,  456,  497,    0,    0,    0,    0,
+  454,  444,    0,  446,  448,    0,  494,    0,    0,    0,
+    0,    0,    0,  466,  467,  462,  472,    0,    0,    0,
+  638,  648,  650,  639,  640,  641,  642,  643,  644,  645,
+  646,  647,  651,  649,  582,  579,  584,  581,  583,  580,
+  594,  589,  595,  590,  591,  578,    0,  592,    0,  593,
+    0,  600,    0,  601,    0,  602,    0,  608,    0,  609,
+    0,  610,    0,  611,    0,    0,    0,    0,    0,  619,
+    0,  622,    0,  625,    0,  628,    0,  631,    0,  633,
+    0,    0,  869,    0,  832,  831,  830,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,  970,  969,    0,  978,
+    0,  968,    0,    0,    0,    0,  516,  518,    0,  515,
+    0,   26,    0, 1031, 1032,  380,    0,    0,  377,    0,
+    0,  213,    0,    0, 1041, 1027, 1029,   85,   83,   84,
+    0,    0,   78,    0,    0,   86,   88,    0,  453,    0,
+  506,    0,  491,  490,  489,  484,  439,  440,  458,    0,
+  753,    0,    0,  748,  750,  751,  752,  537,  807,  553,
+  943,  877,    0,  498,    0,  872,    0,    0,    0,  203,
+    0,    0,    0,  197,    0,    0,  204,    0,  912,  844,
+  840,    0,  942,    0,  512,    0,    0,  536,  535,  847,
+    0,  932,    0,  925,    0,  929,  539,  794,  950,    0,
+  798,  797,  946,  796,  803,  811,    0,    0,  865,    0,
+  961,    0,  959,    0,    0,  550,    0,    0,  663,  662,
+  669,    0,  667,    0,  362,  655,    0,    0,    0,  920,
+  919,  793,  457,  452,  496,  495,  459,    0,  455,  443,
+    0,    0,  493,  492,  460,  461,  477,  474,  475,  473,
+  465,  463,  471,  526,  521,  636,    0,    0,    0,  665,
+  664,  987,  963,    0,  988,    0,  973,  975,  984,    0,
+  999,    0,  967, 1013,   31,  359,  533,   29,  517,  519,
+  532,   22,  735,  734,    0,  733,    0,  376, 1043,  214,
+ 1038,    0,    0,   79,    0,    0,    0,   42,   40,   34,
+    0,  105,  104,    0,  502,  483,  482,  481,  742,  743,
+  737,  749,    0,    0,    0,  500,    0,  873,  875,  898,
+    0,    0,  207,    0,    0,    0,    0,    0,  941,  513,
+  845,  935,    0,    0,  926,  949,    0,    0,  829,  810,
+    0,    0,    0,  816,  864,  962,  960,    0,    0,    0,
+  671,  661,  365,  654,  653,  673,  451,  450,  449,  637,
+  635,  739,    0,    0,  965,    0,  992,    0,    0, 1007,
+ 1008, 1001,    0,  379,  378, 1042,    0,    0,   87,   81,
+    0,   89,    0,    0,  102,    0,    0,    0,    0,    0,
+  499,    0,    0,    0,  220,    0,    0,    0,    0,  205,
+  200,    0,  841,    0,    0,    0,  931,    0,  952,    0,
+    0,    0,    0,  806,  817,    0,    0,  676,    0,  870,
+  867,    0,  964,    0,    0,    0,    0,  985,    0, 1014,
+ 1030,    0,    0,    0,   94,   95,   98,   99,   35,   41,
+  823,  150,    0,    0,    0,  826,  954,    0,    0,  887,
+    0,  891,    0,    0,    0,    0,    0,  542,  383,    0,
+    0,  843,  852,    0,  859,    0,    0,  850,    0,  855,
+    0,    0,  951,  947,    0,    0,    0,    0,    0,    0,
+  674,  868,  966,  989,    0,  976,    0,    0, 1003,    0,
+  100,   92,    0,    0,    0,  808,  827,  944,    0,    0,
+  876,  884,  883,  878,  880,  899,  219,  208,    0,    0,
+  201,  548,    0,  846,  851,    0,  856,  933,  936,    0,
+  804,    0,  819,  545,    0,  677,    0,  993, 1010, 1011,
+ 1004,   80,    0,   96,   97,    0,    0,    0,    0,    0,
+    0,  874,    0,    0,  209,  543,    0,  858,  857,    0,
+    0,  948,    0,    0,  551,    0,    0,    0,  101,    0,
+    0,    0,    0,   62,   47,    0,   55,   57,   58,   60,
+   61,   67,   68,   69,   70,   71,   72,  176,   36,  828,
+  945,  888,  895,  879,    0,  893,    0,  900,    0,  549,
+  744,  934,  821,  546,    0,  990,    0, 1005,   48,    0,
+    0,  702,  712,  703,  700,  708,  697,  707,  701,  699,
+  698,  705,  704,  710,  706,  709,  711,  713,    0,    0,
+  695,   59,   56,    0,    0,  882,  881,    0,  210,    0,
+  552,    0,  994,   64,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,  696,  195,  177,  194,   37,  896,    0,
+    0,    0,    0,    0,    0,    0,  369,    0,    0,    0,
+    0,    0,    0,  185,  685,    0,    0,  745,    0,  991,
+    0,   66,  347,    0,  330,    0,  190,  178,    0,    0,
+  181,  183,    0,    0,  353,    0,    0,  247,    0,  137,
+    0,  997,  995,    0,  336,  335,    0,  373,    0,    0,
+    0,    0,  370,    0,    0,  354,  351,    0,  686,  242,
+  132,    0,  331,    0,    0,    0,  374,    0,    0,  186,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  346,  332,    0,
+  340,  193,  179,    0,    0,    0,    0,    0,  397,    0,
+    0,    0,    0,    0,  348,    0,  329,    0,    0,    0,
+  192,  189,  182,  184,    0,  716,    0,  395,    0,  687,
+    0,  722,  243,  133,    0,  345,    0,    0,  341,  180,
+    0,  719,    0,    0,    0,  723,    0,    0,  349,    0,
+   44,  333,  187,  396,  725,    0,  688,  244,  134,    0,
+  344,    0,  730,    0,  731,  728,    0,  726,    0,    0,
+    0,  350,  188,    0,    0,  124,    0,    0,  118,  112,
+    0,    0,  108,  110,  111,  113,  114,  115,  116,  117,
+  119,  120,  121,  122,  123,    0,  259,  254,  252,  253,
+  255,  256,  257,  258,    0,    0,  250,    0,  729,  727,
+    0,    0,    0,  689,  109,    0,  245,  251,  135,  128,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  126,  125,  260,  268,    0,    0,    0,    0,    0,
+  368,    0,  298,    0,    0,  299,  297,    0,  371,    0,
+    0,    0,    0,    0,    0,    0,  690,  246,  136,  130,
+    0,    0,    0,    0,    0,    0,  225,  372,    0,  266,
+    0,    0,  263,  262,  261,  138,    0,  295,  387,    0,
+  386,    0,  293,    0,    0,  221,  151,    0,  303,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  149,
+  147,    0,  146,    0,  307,    0,    0,  155,    0,    0,
+    0,    0,    0,    0,  222,  157,    0,    0,    0,    0,
+    0,  142,  322,    0,  304,    0,    0,  316,    0,    0,
+    0,  311,  296,  173,    0,    0,    0,    0,  168,  300,
+  294,    0,    0,    0,    0,    0,    0,    0,  161,  148,
+    0,  139,  143,    0,    0,    0,  318,    0,  319,  308,
+    0,    0,  302,  312,    0,    0,  154,  169,    0,  265,
+  267,  264,  233,    0,  223,    0,    0,  158,    0,  152,
+  162,    0,  323,  325,  305,    0,    0,  317,    0,  172,
+    0,  226,    0,    0,  230,  232,    0,    0,    0,    0,
+    0,    0,    0,  234,  236,  224,    0,  144,  327,  328,
+  324,  326,  314,  170,  227,    0,    0,  164,  316,    0,
+  240,  239,  238,  235,  237,    0,  315,  228,  165,
+  };
+  protected static readonly short [] yyDgoto  = {             7,
+    8,   53,    9,   54,   10, 1137,   55,  251,  771,  471,
+   12,   13,   23,   24,   25,   26,   27,  211,  212,   56,
+   29,   30,  320,  476,  201,  900,  738,  983, 1138, 1094,
+ 1225,  901, 1649,  620, 1165, 1166, 1167, 1168, 1169, 1419,
+ 1420, 1200, 1201, 1172, 1173, 1174, 1175, 1176, 1177,  254,
+  733,  498,  734,  735,  978,  736,  737,  982,  897, 1034,
+ 1035, 1036,  430,  506, 1133,  114,  904, 1421, 1422, 1423,
+ 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433,
+ 1434, 1435, 1219, 1451, 1452, 1243, 1257, 1291, 1332, 1323,
+ 1352, 1370, 1388, 1411, 1478, 1349, 1542, 1528, 1560, 1561,
+ 1562, 1058, 1543, 1041, 1558, 1042, 1557, 1539, 1587, 1520,
+ 1550, 1533, 1577,  939, 1585, 1588, 1589, 1666, 1578, 1579,
+ 1575, 1178, 1246, 1224, 1258,  773, 1299, 1343, 1360, 1304,
+ 1344, 1305, 1286, 1330, 1402, 1220,  820,  774,  775,  776,
+  777,  720,  584, 1189,  721,  722, 1482, 1538, 1615, 1584,
+ 1634, 1491, 1524, 1643, 1660, 1616, 1617, 1664, 1656, 1657,
+ 1289, 1322, 1387, 1445, 1410, 1477, 1446, 1447, 1474, 1515,
+ 1496, 1611,  323,  242, 1525, 1475, 1535, 1531, 1505, 1546,
+ 1530, 1570, 1565, 1544, 1595, 1600, 1568, 1571, 1572, 1659,
+ 1601, 1566, 1567, 1651, 1639, 1640, 1275, 1297, 1339, 1325,
+ 1358, 1340, 1341, 1377, 1294, 1375, 1400, 1284, 1285,  477,
+  204,  205,  473,  577,  493,  243, 1260,  718,  719,  885,
+ 1059,  207,  482,  115, 1367, 1350,   49,  116,  117,  118,
+  119,  120,  121,  122,  123,  124,  125,  126,  127,  128,
+  129,  130,  131,  132,  133,  134,  135,  267,  749,  508,
+  515,  516,  136,  375,  616,  376,  852,  377,  848,  517,
+  518,  519,  744,  765,  509,  483,  709,  137,  379,  138,
+  383,  209,  480,  528, 1110,  815, 1154,  431,  778, 1147,
+  949, 1195,  140,  141,  142,  143,  144,  145,  146,  147,
+  148,  149,  150,  151,  152,  153,  154,  587,  588,  589,
+  821,  822,  862,  155,  573,  570,  818,  354, 1019,  568,
+ 1080,  156,  157,  535, 1287, 1321, 1385, 1409, 1476, 1221,
+ 1371, 1372, 1407, 1408,  886,  752,  520,  911,  432,  159,
+  682, 1192, 1230,  753,  754,  433,  434,  435,  162,  163,
+  164,  436,  437,  438,  439,  440,  441,  442,  443,  444,
+  445,  446,  447,  176,  448,  593,  177,  263,  557,  558,
+  808,  938,  942,  560,  987,  913, 1044,  940,  943, 1049,
+  944, 1045, 1046,  449,  178,  179,  180,  782, 1004, 1066,
+ 1005, 1067, 1068, 1069, 1116, 1070,  181,  182,  183,  184,
+  185, 1022,  766,  526,  767,  992,  768, 1053,  993, 1054,
+ 1184, 1143, 1105, 1185, 1099, 1186, 1187,  283,  994, 1144,
+  186,  187,  188,  189,  190,  191,  301,  548,  549, 1008,
+ 1151,  313,  989,  914, 1140, 1011,  937, 1120,  192,  459,
+  193,  460,  964, 1024,  461,  462,  702,  693,  694,  968,
+  463,  464,  465,  466,  467,  969,  688,  966, 1127, 1232,
+ 1270, 1026, 1157, 1252,  871,  696,  872, 1088, 1029, 1089,
+ 1158,  973,  215,   17,   19,   50,   51,  246,  723,  893,
+  494,  724,  725,
+  };
+  protected static readonly short [] yySindex = {         -205,
+    0, -173, -113, -229, -208, 5831,    0,  101,    0,    0,
+ -208, -229,    0,    0,  -63,    0, 6653, -208,    0, 1176,
+  241,    0,    0,    0,    0,    0,    0,  -47,    0,    0,
+    0,    0,    0,    0,  388,    0,  522,    0,    0,13474,
+    0,    0,    0,    0,    0,    0,    0,  855,    0,    0,
+  872,    0,    0,  101,  263, -208,    0,  343,    0,  672,
+  477, -216,  233, -181,   70, 8902,    0,    0,   70,   70,
+    0, -274, -163,   70,   70, 7295,    0, 7598,   70,   70,
+    0, 7761,    0,  587, 9065, -192,    0,    0,  676,   70,
+  233,   70, 6151, 6151,    6, 8739,    0,14387,    0, 9228,
+ 9391, 9554, 9717, 9880,10043,10206,10369,    0,  246,    0,
+    0,    0,    0, -195,  687,  789,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  421,  677, 7924,    0,    0,
+ 1257,  707,  -85,  818,  631,  846,  612,  656,  719,  721,
+  536,  669,    0,    0,    0,    0,    0,    0,  776,    0,
+    0, 3611,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0, -289,    0,    0,
+    0,    0,    0,    0, 6816,    0,    0,    0,    0,    0,
+    0,   69,  160,  263,    0,    0,    0,    0,  451,  640,
+  769,  748,    0,    0,    0,    0,  792,  798,  841,  808,
+  542,  831,    0,    0,    0, 9583, 9583,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  849,  833,    0,  850,    0, -221,    0,    0,    0,
+  263,  967,  263,    0,    0, 1056,    0,  867,    0,14543,
+13919,    0,    0,    0,    0,    0,14387,    0,  922,    0,
+    0, 9583,    0, -213,  953, -174, 1051,10532, -310,    0,
+ 9583,    0,   70,    0,  966,14387,  477,  477,14387,14387,
+14387, 2169,  908,  968,    0,    0,   48, 8739,  276, 1104,
+  477, 9583,14387,    0,    0,  477,  643,    0,    0,    0,
+    0,14387,  587,  909,14075,  959,14387,    0,  908,  684,
+ 1054,  233,    0, 1055,  233,  317,    0, 1000,    0,    0,
+    0,  447,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  913,
+ 5671,    0,    0,16666,  477,14387,    0,  645, 8087,13919,
+  423,  569,    0,  916,    0,  592,    0,    0, 8250,13919,
+  960,  965,  969,    0,  231, -137,    0,    0,    0,    0,
+    0,    0,  975,14387,14387,14387,14387,14387,14387,14387,
+14387,14387,14387,14387,14387,14387,14387,10695,10858,11021,
+ 5991, 8768,11184,11347,11510,11673,11836,11999,12162,12325,
+12488,12651,15323,15323,15323,15323,12814,12977,13140,13303,
+13466,15323,14387,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0, -126,  425,    0,
+    0, 6151, 6151,    0,    0,  233,    0,    0,    0,    0,
+  234, 1005,    0,    0,    0,    0,    0,    0,    0,    0,
+  263,  925,    0,    0,  496,  991,    0,    0,    0,    0,
+  716,    0,  792,    0,  233,  985,    0, -208,  849,  849,
+    0,  194,    0,  692,  849, 1001,    0, -171,    0,    0,
+    0,    0,  908,  276,    0,    0,  989,  799,    0,14387,
+14387, 1137,    0,    0,  449,  992,    0,    0,    0, 6979,
+ 1003, 9583, 1006, 1008,  233, 7435,14231,  198,    0,    0,
+  477,    0,    0,    0,   99,  104, 1009,  986,  948,    0,
+    0,  105,  132,    0,    0,  482,  587, -132,    0, 1011,
+    0,  477,    0,  152,  553,  798,  233,  792, 9583, -187,
+  196,14387, 1095,14387, 1096,    0, 1016,16666,    0, -146,
+    0,    0, -146,    0,    0,    0,  296,    0,    0,    0,
+    0,    0,  908,  233, 9746,    0, 1007,    0, 1023,    0,
+ 1152,  477, 6979,  539,    0,    0,  -64,  449,14387,  565,
+    0,    0,14543,    0,    0,14543,    0,  -58,  449, -120,
+14387,14387,14387,    0,    0,    0,    0,  367, 7924,  677,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,  707,    0,  707,    0,
+  707,    0,  -85,    0,  -85,    0,  -85,    0,  818,    0,
+  818,    0,  818,    0,  818,  631,  631,  631,  631,    0,
+  846,    0,  612,    0,  656,    0,  719,    0,  721,    0,
+ -157, 6979,    0,   70,    0,    0,    0, 8413, 1107,  233,
+ 1108,  233, 8413, 8413, 1012,14387,    0,    0, 1005,    0,
+  233,    0, -251,  908,  748, 1018,    0,    0,  801,    0,
+  748,    0, 1032,    0,    0,    0,  657,  320,    0, 9746,
+  692,    0, 1031, 1022,    0,    0,    0,    0,    0,    0,
+  908,  968,    0, 1024, 1026,    0,    0, -165,    0,  369,
+    0,14543,    0,    0,    0,    0,    0,    0,    0, 7272,
+    0,  250, 6979,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  233,    0,  -98,    0, 1115, 1025, 1120,    0,
+  561,  252, 1039,    0, 1033, 1035,    0,  198,    0,    0,
+    0, 6816,    0, 6816,    0,  173,  908,    0,    0,    0,
+ 1046,    0, 8931,    0,  587,    0,    0,    0,    0, 6816,
+    0,    0,    0,    0,    0,    0, 7924, 1037,    0, 6816,
+    0,14387,    0,14387,  198,    0, 1042, -146,    0,    0,
+    0,14387,    0, 9583,    0,    0,  233,16666, 1075,    0,
+    0,    0,    0,    0,    0,    0,    0, 1050,    0,    0,
+  807,  812,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0, 8576,  250,14387,    0,
+    0,    0,    0, 1133,    0, 1135,    0,    0,    0,  727,
+    0, 1044,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  994,    0,  194,    0,    0,    0,
+    0,  692,  692,    0,  925, 1059, 1062,    0,    0,    0,
+ 1057,    0,    0,14387,    0,    0,    0,    0,    0,    0,
+    0,    0, 1047, 1049, 1052,    0,14387,    0,    0,    0,
+ -162, 1010,    0, 1060,  263, 1204, 1070, 1178,    0,    0,
+    0,    0,  506,  233,    0,    0, -180, -187,    0,    0,
+  233,  477, 1037,    0,    0,    0,    0, 1074,  198, 1101,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  219, 8413,    0, 8413,    0, 1094, 8413,    0,
+    0,    0,  455,    0,    0,    0, 1079,  925,    0,    0,
+14699,    0, 1084, 1020,    0,14387, 1073, 7924, 1037, 9583,
+    0,14387,14387,14387,    0, 1068, 1081, 9909, 1076,    0,
+    0, 1082,    0, 6816, -209, 9583,    0, 1090,    0, 1037,
+ 1100, 1037,  111,    0,    0, 1085, 1103,    0, -146,    0,
+    0,  477,    0, 8413, 1117, 8413, 8413,    0,14387,    0,
+    0, 1026,  274, -242,    0,    0,    0,    0,    0,    0,
+    0,    0,  233,  477, 1073,    0,    0, 1037, 1106,    0,
+ 1110,    0, 6816,  767, 1110,14387, 9094,    0,    0, 1237,
+ 9909,    0,    0,14387,    0, 1112, -228,    0, -228,    0,
+ 1111, 1248,    0,    0,  477, 9583, 7924, 9909, 1102, -146,
+    0,    0,    0,    0, 1138,    0,  821, 1109,    0, 1122,
+    0,    0,14699,  840, 1113,    0,    0,    0, -187, 6816,
+    0,    0,    0,    0,    0,    0,    0,    0, 1116,  587,
+    0,    0, -124,    0,    0, 6979,    0,    0,    0, 6816,
+    0, 1121,    0,    0, 9909,    0, 8413,    0,    0,    0,
+    0,    0,14387,    0,    0,  840,  114, 1125,14387, 6816,
+ 1037,    0,14387, 6816,    0,    0,  587,    0,    0, 6979,
+ 1123,    0, 7924,  587,    0, 1145, 8413,14387,    0, 1129,
+    0,16591,  531,    0,    0,  114,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  764,    0, 1118,    0,14387,    0,
+    0,    0,    0,    0,  587,    0, 1148,    0,    0,  470,
+ 1139,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  513,16591,
+    0,    0,    0,  330,  840,    0,    0,14387,    0, 6979,
+    0, 8413,    0,    0,  114, 1080, 1080,16553, 1086, 1086,
+ 1088, 1222,  580,    0,    0,    0,    0,    0,    0, 1141,
+ 1157, 8413, 1150, 1154, 1136,  908,    0,  131,16553, 1092,
+ 1160, 1161, 1146,    0,    0, 1305, 1307,    0,  233,    0,
+ 1157,    0,    0, 9257,    0, 1172,    0,    0, 1179, 1119,
+    0,    0, 1114, 1168,    0, 1086, 1080,    0, 1080,    0,
+ 1080,    0,    0,  198,    0,    0, 1186,    0,  198,  198,
+ 1205, 1181,    0,  198,  198,    0,    0, 1184,    0,    0,
+    0, 1191,    0, 1193, 1194,    0,    0, 1195, 1196,    0,
+ 1285, 1285, 1285, 1187,  263, 1188, 1188, 1188, 1188,  198,
+ 9583, 1281, 1281, 1281, 9909, 1144,  879,    0,    0, 1197,
+    0,    0,    0, 9909, 9909, 9909, 9909, 1201,    0, 1339,
+ 9583, 1238, 1238, 1238,    0, 1344,    0, 1214,  263, 1238,
+    0,    0,    0,    0, 1202,    0,  -67,    0, 1153,    0,
+ 1238,    0,    0,    0, 1238,    0, 1206, 1200,    0,    0,
+ 1245,    0, 9583, -109, 1224,    0, 1226, 1227,    0,14387,
+    0,    0,    0,    0,    0,16701,    0,    0,    0, 1212,
+    0, 1238,    0, 1229,    0,    0, 1220,    0, -149,  263,
+ -149,    0,    0, 1231,16701,    0,    0,16591,    0,    0,
+ 1239, -149,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,16591,    0,    0,    0,    0,
+    0,    0,    0,    0, 1240,  263,    0, 1241,    0,    0,
+ -149, 1244,14494,    0,    0, 2650,    0,    0,    0,    0,
+ -149, 1171, 1086,  257, 1182,  550,  422,  110,13474, 1086,
+ 1185,    0,    0,    0,    0, 1200, 1200, 1200, 1247, 1223,
+    0, 1230,    0, 9583, 1235,    0,    0, 9583,    0,  908,
+ 1249,  130, 1250, 1242, 1243,  662,    0,    0,    0,    0,
+ 9583, 9583, 1252,10072, 1190, 1256,    0,    0,  908,    0,
+ 9909, 9909,    0,    0,    0,    0, 1261,    0,    0, 1394,
+    0, 1260,    0,  198,  198,    0,    0, -154,    0, 1251,
+  198, 1258, 1263, 1262,  198, 1264, 1269, 1266, 1259,    0,
+    0, 1265,    0,  262,    0, 1272, 1284,    0, 1421, 1278,
+  330, 1292, 1282, 1286,    0,    0, 1288,14387, 1234, 1283,
+ 1265,    0,    0,16591,    0,  263,  263,    0, 1253, 1299,
+ 1272,    0,    0,    0,14387, 1254, 1301, 1278,    0,    0,
+    0, 9909,10235,  269, 7924, 1274, 1302, 1288,    0,    0,
+ 1309,    0,    0, -151, 1325,16591,    0,16591,    0,    0,
+ 7924, 1312,    0,    0, 1342, 1263,    0,    0, 1346,    0,
+    0,    0,    0,16591,    0,  269,  269,    0, 1326,    0,
+    0, 9909,    0,    0,    0, 1407, 1483,    0, 9909,    0,
+ 1345,    0,  903, 1367,    0,    0, 9909, -154,  664,  664,
+ 1384, 9909,  269,    0,    0,    0, 1387,    0,    0,    0,
+    0,    0,    0,    0,    0, -214, -214,    0,    0, 1409,
+    0,    0,    0,    0,    0, 7924,    0,    0,    0,
+  };
+  protected static readonly short [] yyRindex = {           28,
+    0,    0, 6327,   28,    0,    0,    0, 1798,    0,    0,
+   54, 2523,    0,    0,    0,    0, 1413,   54,    0,    0,
+    0,  516,    0,    0,    0,    0,    0,   44,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0, 1802,    0,    0,
+ 1802,    0,    0, 1798,   55,   31,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0, 1399,    0,    0,
+    0, 1399,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0, -169,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0, 7077,    0,
+    0,    0,    0,    0,    0, 3679,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  255,    0,    0,    0,    0,
+ 3886, 3969, 3003, 4586, 4987, 5386, 5546, 5706, 5866, 6026,
+  390,  882,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,   39,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0, 1413,    0,    0,    0,    0,    0,
+    0,    0,    0,   66, 2310,    0,    0,    0,  636,  722,
+    0,    0,    0,    0,    0,    0, 1967, 1861, 1405,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0, 1802,   37,    0,    0,    0,    0,    0,    0,    0,
+   46,    0,   73,    0,    0,    0,    0,    0,    0,    0,
+  453,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0, 3273,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0, 1347, 3416,    0,    0,    0,    0, 3130, 1406,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,   49,    0,    0,  267, 1861,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0, 1419,    0, 1399,    0,    0,    0,  453,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  453,
+    0,    0,    0,    0,    0,  328,    0,    0,    0,    0,
+    0,    0, 1422,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0, 6186,    0,    0,    0,    0,    0,    0,    0,    0,
+ 2762,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0, 2126,    0,    0,    0,    0, 1425, 1802, 1802,
+    0, -125,    0, 9420, 1802, 1816,    0,    0,    0,    0,
+    0,    0, 3130, 3743,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  458,    0,    0,    0,  281,
+    0,    0,    0,    0,    0, 1416,    0,  230,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0, 1550,    0,    0,
+    0,    0,    0,    0,  331,13540,    0,  508,    0,  869,
+    0,    0,    0,    0,    0,    0,    0, 1419,    0,14855,
+    0,    0,14855,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  699,    0,    0,    0, 1431,    0,    0,    0,
+ 1406,    0, 1413, 3130,    0,    0,    0,    0,    0, 3130,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  458,
+    0,    0,    0,    0,    0,    0,    0,    0, 1438,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0, 4075,    0, 4158,    0,
+ 4264,    0, 4347,    0, 4426,    0, 4507,    0, 4667,    0,
+ 4746,    0, 4827,    0, 4906, 5066, 5147, 5226, 5307,    0,
+ 5467,    0, 5627,    0, 5787,    0, 5947,    0, 6107,    0,
+    0,  281,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0, 6186,    0,
+    0,    0,    0,  636,    0,    0,    0,    0,    0,    0,
+  -42,    0,    0,    0,    0,    0, 1378,    0,    0,    0,
+10398,    0,    0,  902,    0,    0,    0,    0,    0,    0,
+  803,  786,    0,    0, 1422,    0,    0, 1446,    0,15011,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  302,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  170,    0, 1430,    0,    0,    0,
+ 1381,  329,    0,    0, 1444, 1447,    0,  230,    0,    0,
+    0, 1413,    0, 1413,    0,    0, 1347,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0, 1413,
+    0,    0,    0,    0,    0,    0,    0, 1434,    0, 1413,
+    0,    0,    0,    0,  230,    0,    0,14855,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0, -166,
+    0,  251,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0, -125,    0,    0,    0,
+    0,10561,16717,    0, 1438,    0,  814,    0,    0,    0,
+ 1453,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  914,  588,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  345,    0,    0, 1752,    0,    0,
+    0,    0,  754, 1449,    0,    0,  588,  869,    0,    0,
+    0,    0,  229,    0,    0,    0,    0,    0,  230,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  698,    0,    0,    0,    0,    0, 1439,    0, 1452,    0,
+    0,    0,  770,    0,    0,  717,    0,    0, 1455,    0,
+    0,    0,    0, 1413, 1460,    0,    0,    0,    0, 1452,
+    0, 1434,  382,    0,    0,    0,    0,    0,14855,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0, 1422,13731,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0, 1445,    0,    0, 1461,    0,    0,
+    0,    0, 1413,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0, 1466,    0, 6490,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,14855,
+    0,    0,    0,    0,    0,    0, -148,  290,    0,    0,
+    0,    0,    0,15406,    0,    0,    0,    0,  338, 1413,
+    0,    0,    0,    0,    0,    0,    0,    0,  758,    0,
+    0,    0,    0,    0,    0, 1413,    0,    0,    0, 1413,
+    0,  385,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,15406, 2876,    0,    0, 1413,
+  240,    0,  838, 1413,    0,    0,    0,    0,    0, -183,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+16094,  825,16258,    0,    0, 2964,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,  844,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,16343,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  581,14182,
+    0,    0,    0,    0, 2656,    0,    0,    0,    0,  919,
+    0,    0,    0,    0,16182,    0,    0,    0,    0,    0,
+    0,  594,    0,    0,    0,    0,    0,    0,    0,    0,
+  334,    0,    0,    0, 1470, -156,    0,    0,    0,    0,
+    0,    0, 1454,    0,    0, 1408, 1410,    0,    0,    0,
+  334,    0,    0,    0,    0,    0,    0,    0,    0,   34,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,  230,    0,    0,    0,    0,  230,  230,
+  760,    0,    0,  230,  230,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  521,    0,    0,    0,    0,
+  446,  446,  446,    0,   24, -236,    0,    0,    0,  230,
+    0, -224, -224, -224,    0,    0,15508,    0,    0, 1471,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  498,
+    0, 1473, 1473, 1473,    0,  634,    0,    0,  297,  670,
+    0,    0,    0,    0,    0,    0,  578,    0,    0,    0,
+  682,    0,    0,    0, 1462,    0,    0, 2417,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  670,    0,    0,    0,    0, -232,    0,15610,15916,
+15610,    0,    0,    0,    0,    0,13730,14338,    0,    0,
+    0,15712,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0, 7549,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,16018,    0,    0,    0,    0,
+15814,    0,  581,    0,    0,  581,    0,    0,    0,    0,
+15610,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0, 2417, 2417, 2417,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0, 1472,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0, 1472,    0,
+    0,    0,    0,    0,    0,    0,  815,    0,    0, 1480,
+    0,    0,    0,  230,  230,    0,    0,  915,    0,  918,
+  230,    0,    0,    0,  230,    0,    0,    0,  933,    0,
+    0, 1469,    0, 1349,    0, 1474,    0,    0,15167, 1475,
+    0,    0,    0,    0,    0,    0, 1476,    0,    0,    0,
+ 1477,    0,    0,  201,    0, 3002, 7097,    0,    0,    0,
+ 1478,    0,    0,    0,    0,    0,    0, 1479,    0,    0,
+    0,    0,    0,16509,    0,    0,    0, 1481,    0,    0,
+    0,    0,    0,    0,    0, 1533,    0, 1611,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,  947,    0,16389,16427,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  915,16471,  666,
+  934,    0,16509,    0,    0,    0,  941,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  };
+  protected static readonly short [] yyGindex = {            0,
+    0, 1821,    0,    0,    0, 1233,   16, 1682,  -35,   29,
+    0, 1865, -198,  431,  434,  780,    0,    0,    0, 1886,
+    0,    0,   -6,    0,    0,    0,    0,    0,-1023,    0,
+    0,    0, -746, -699,  658,    0,  726,  694,    0,-1044,
+-1017,    0,    0,    0,    0,    0,    0,    0,    0, -241,
+    0,    0,    0,  932,    0, 1017,    0,    0,    0,    0,
+  820,  822,  -17, -244,    0,  478,    0, -895,    0,-1285,
+-1277, -634, -542, -467, -452, -449,    0,    0,    0, -462,
+    0,    0, -959,    0,    0,    0,    2,    0,   26,    0,
+   18, -418,    0,    0,    0,  -88,  273,    0,    0,    0,
+  355,-1029,    0,-1109,    0, -283,    0,    0,    0,    0,
+  313,    0,    0, -131,    0,    0,  332,    0,    0,  344,
+    0,    0,  370,    0,-1116, -669,    0,    0,    0,    0,
+  -26,    0,    0,    0,    0,-1188,  -60,    0,    0,  998,
+  999, 1155, -556,    0,    0, -329,  457,    0, -598,    0,
+    0,    0,    0,    0,    0,    0,    0,  268,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  483,    0,    0,
+    0,    0,   36,  459,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  271,    0,    0,  360,    0,
+    0,  368,  374,  294,    0,    0,    0,    0,    0,    0,
+    0,    0,  577,    0,    0,    0,    0,    0,    0, -170,
+    0,    0, -105,    0,  663,    0,  476,    0, 1058,    0,
+ 1922, -281,   59,   -5,    0, -435,    0,    0, 1631,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0, 1162,    0,    0,    0,  -12,  474, -272,
+  797, 1577,    0,    0,    0,    0,    0, 1331,  743,    0,
+ 1203,    0, 1440,    0, 1208,    0,    0,    0, 1332,    0,
+    0,    0,  520,    0,    0,    0,    0,  179,    0,    0,
+    0,    0,    0, 3070,  906,  907,  870,  884, 1542, 1543,
+ 1541, 1544, 1545,    0, 1546,    0,    0,    0, 1142, 1395,
+ -550,    0, -559,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0, -307,    0,    0,    0,    0,    0, -532,
+    0,  598,    0,  556,    0, -655,    0, 1124,  310,    0,
+    0,    0,    0,  858, -571,   -8, -501,   -1,    0, 1803,
+    0,  319,    0,  323,  364,  386,  387,  394,  396,  397,
+  405,  416,  429,    0, -705,    0,    0,  -31,    0,    0,
+ -886,    0, -953,    0,    0,    0,    0, -966,  -44,  970,
+ -586,    0,  930, -688,    0,    0,    0, -540,    0,    0,
+    0,    0,  910,    0,    0,  912,    0,    0,    0,    0,
+    0,    0,    0,    0, 1451,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,  -37,    0, 1428,    0,
+    0,    0, 1048,    0,    0,    0,    0,    0,    0, -175,
+    0,    0,    0,    0,    0, 1518, 1287,    0,    0,    0,
+ 1522,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  713,    0,    0,    0,    0,    0,    0,    0,    0,  829,
+    0,    0, 1826,    0,    0,    0,    0,  -16, 1097,    0,
+    0,    0, 1099,
+  };
+  protected static readonly short [] yyTable = {           113,
+   48,  266,  531,  353,  322,  325,  382,   47,  160,  561,
+  538,  501,  487,  200,  208,  161,  514,  469,  756,  252,
+  810,  832,  823,  307,  585,  311,  858,   51,  827, 1180,
+   50, 1112,  271,  194,  248,  896,  375,  484, 1022,  264,
+ 1064, 1661,  264, 1022,  306,   73, 1063,  261, 1124, 1259,
+    1, 1012,  272,   49,    5,  203,  281,  282, 1075, 1064,
+  300,  289,  290,  310,  305, 1020,  302,  303,  806,  294,
+  295,  355,    7,  312,  270, 1009,  928,  315,  929,  317,
+  332,  310,   14,  253,  728,  854,  597,  208,  208, 1006,
+  898,  756, 1170,  995,  936, 1155,  608,  801,  856,  366,
+   20, 1540,  360,  370,  945,  286, 1416, 1009,  927,  819,
+ 1123, 1623, 1160,  287,  427,  514,  284,  729,  617, 1171,
+  381, 1170, 1261, 1262,  496,  514,  191,  489,  490,  683,
+  724, 1148, 1439,  867,  868,  846, 1455,  546,  717,  351,
+  356,  539, 1279,   16,  113,  948, 1395,   21, 1171, 1092,
+  191,    2,  875,  160,  724, 1170,  352,  916,  252, 1093,
+  161,  795,  717,  889,  730, 1460,  801,  191, 1439, 1308,
+  265,  724,  265,  353,  257,    2,  401,  257,  428,  285,
+  756,  912, 1171,  523,   73, 1624, 1193, 1182, 1382, 1662,
+ 1170,  835,  525,  353,  265,  139, 1006,  843,  257,   73,
+ 1006, 1248, 1006,  740,  854, 1006, 1006,  357, 1006, 1006,
+  208,  208, 1141,  542, 1009,  499,  257, 1171, 1009,  197,
+ 1009,  807,  262, 1009, 1009,  491, 1009, 1009,  988,  501,
+  402, 1065,   46,  801,  366, 1006,  361,  684,  585,  250,
+  265,  259,  505,  513,  259,  857,  366,   22,  497,  521,
+ 1065,  756,  551, 1009, 1541,  532,  533,    3,    4,    5,
+    6,   20,  576,  312,  618,  259,  208,  951,  530,  541,
+  527,  534,  536,  537,  544,  208,  854, 1259, 1149, 1017,
+   15,  750,  731,  259,   51,  543,  208,   50,  899,  375,
+  268,  996,  375, 1396,  550, 1022,  208,  554, 1062,  534,
+ 1022, 1006,   73,  917,  805, 1355, 1417,  326,   21,  555,
+   49,    5,  642,  644, 1361, 1362, 1363, 1364,  592, 1009,
+  403,  404, 1020,  590,  450,  836,  158,  375,   73,    7,
+  841,  844, 1090,  842, 1383,  165,   51,  742,  591,  166,
+  139,  505,  513,  742,  375,  208, 1481, 1101,  208,  524,
+  531,  505,  513, 1481,  780,   51, 1015,   52,   50,  783,
+  788,  531,  405,  690,  692, 1437,  621,  622,  623,  624,
+  625,  626,  627,  628,  629,  630,  631,  632,  633,  634,
+  167,   49,   73,   51,  801,  802, 1277,  790,  197,  586,
+   58,  890, 1438,   73, 1142,  208,  208,  739,  353,  375,
+   74, 1437,  168,  169, 1023,  681, 1025,  799,   22, 1028,
+  170,  337,  171,  172, 1152,  450,   51,  687,   50,   50,
+  213,  173,   20,  375,  375,  740,  361,  375, 1438,  375,
+  197,  451,  174,  759, 1181,  452,  375,  453, 1188,  375,
+  454,  455,   49,  456,  457,  175,  208,  208, 1590,  716,
+  805,  809,  805,  770, 1183, 1489,  717,  805, 1453,  268,
+  257, 1015,  327,  693, 1083,  703, 1085, 1086, 1081,   21,
+  805,  158,  714,  715, 1020, 1508, 1456,   73,  726,  889,
+  165, 1526, 1527,   51,  166,  792,  794,  854,  834,  697,
+  781,  732,  743,  743,  840,  784,  789,  202,  585,  779,
+ 1109,  268,  250,  713,  327,  907, 1000,  923,  764,  764,
+ 1100,  755, 1483, 1076, 1106, 1448,  208, 1563,  757, 1077,
+  798, 1278,  451,  791, 1613,  167,  452,  259,  453, 1126,
+  501,  454,  455,  793,  456,  457,  458,  693,  813, 1249,
+  269,  710,  360,  800,  811, 1002,  813,  168,  169,  812,
+  288,  963, 1609,  208,   73,  170,  772,  171,  172,  210,
+  831,   97,  208, 1490,   73, 1479,  173, 1156,  316, 1161,
+  321,  324,  328,  889, 1250,   73,  800,  174,  912,  208,
+ 1484,  838,  250, 1509,  755,  505,  250,  781,  505,  996,
+  175,  757, 1638,  847,  847,  847,  451, 1197,  876, 1641,
+  452,  381,  453,  586, 1594,  454,  455, 1647,  456,  457,
+ 1021,  349, 1654, 1000,  756,  197,  804, 1000,  614, 1000,
+  586,  196, 1000, 1000, 1312, 1000, 1000,  468,   73, 1314,
+ 1315, 1392,  813,  111, 1318, 1319, 1626,  909, 1627,  349,
+  250,  349,  468,  812, 1227,  632,  361,  809,  756,  361,
+  250,  250, 1002,   74, 1633,  361, 1002,  250, 1002,  361,
+ 1348, 1002, 1002,   74, 1002, 1002,  350,  740,  746,   73,
+  861,  859, 1251,  755,   74,  861,  861, 1487,  870,   73,
+  757,  876, 1091,   73,  339, 1052,  268, 1244,  740,  747,
+   73,  818, 1271,  902,  820,  351,  996,  824,  615,  632,
+  996,  698,  996,  903,  934,  996,  996,  566,  996,  996,
+  450,  216,  352,  355,  208,  469,  265,  910, 1000,  355,
+  361,  887,  468,  351,  505,  351, 1244,   74,  756, 1497,
+ 1498, 1499,  513, 1245,  935,  953, 1038,  507,  507,  809,
+  352,  809,  352,   73,  755, 1488,  255,  825,  746,  371,
+   73,  757,  632,  714,  851,  586,  632, 1002,  632,  632,
+  632,  632,  632,  632,  632,  632,  632,  632,  632,  747,
+  567,  888, 1107,  818,  328, 1440,  820,  632,   20,  632,
+ 1113,  632,   74,  818,  355,  818,  820,  208,  820,  381,
+ 1236,  632,  632,  632,  946,  469,  947, 1030,   73,  563,
+ 1237,  996,  565,  371,  952,  715,  772,  214,  714,  632,
+ 1202, 1440,  685,  599, 1238, 1239, 1240,  451,  208,  372,
+  373,  452,  208,  453,   19,   21,  454,  455,  262,  456,
+  457, 1241,  714,  374, 1203,  214,  507,  507,  571,  961,
+  747,  534, 1204,  772,  478,  217,  507,  507, 1038,  479,
+   20,  717, 1265,  691, 1536, 1537, 1047,  632,  250,  472,
+  715, 1547, 1338,  586, 1205, 1552,  692, 1441,  265, 1206,
+ 1207,   19,  257,  372,  373, 1208,  600, 1242,  197, 1209,
+  262, 1210, 1211, 1212,  715,  578,  985,  374,  732,  601,
+  795, 1213,  686, 1266,  691,  579, 1338,   21,  545,  991,
+  351, 1050,   21, 1441, 1214, 1229,  580,  692, 1006, 1215,
+ 1014, 1216,  546,  363,  572, 1368,  748, 1071, 1222,  250,
+  478,  501,  380, 1267,  691,  479,   43,  353,   43,  689,
+  691, 1217,  474,  695, 1373, 1374,  547,  692, 1164,  259,
+  718, 1380, 1442,  257, 1048,  358,  861, 1394,  861,  704,
+   43,  861,  705,  772, 1486,  351, 1389, 1443,   43,  921,
+ 1444,  795,  711, 1037,  718, 1048,  883, 1164,  530,  421,
+  381,  732,  380,  265, 1051,  534, 1055,  772, 1442,  953,
+   43,  884,  422, 1413,  208,   43,   43, 1122,  351,  953,
+ 1082,   43,  208, 1443,  314,   43, 1444,   43,   43,   43,
+  208, 1164,  761, 1256, 1218,  833,  861,   43,  861,  861,
+  259, 1087, 1096,  359,  351,  361,  578, 1635, 1636,  474,
+   43,  342,  602,  417,  361,   43,  579,   43,  361,  603,
+  361,  839,  475,  203,  803,  342, 1164,  580,  530,  361,
+  409,  410,  343, 1121, 1655,  605,  530,   43,  265, 1146,
+  265,  208,  606,   43,   43,  208,  720,  411,  412,  381,
+  256,  826,  257,  474,  258, 1513,  378, 1391,  721,   73,
+  208,  837,  208,  720,  418, 1037,  539,  257,  361,  358,
+  507,  361,  845,  507,   73,  721, 1190,  361,  423,   93,
+  656,  361,  586, 1194,  800,  501,  203,  693,  594,   93,
+  656, 1162,  693,  970,  971,  707, 1401,  755,  218,  861,
+  355,  595,  693,  203,  757, 1159,   28,  708,  218,  208,
+   43,  530,  398,  399,  400,  355,  693,  693,  693,  259,
+ 1162,  419,  260,  361, 1231,  381,  361,  634,  693,  861,
+ 1087,  755,  361,  693,  259,  361,  361,  359,  757,  206,
+ 1276, 1226,  361,  420, 1102,  781,  598,  890, 1103,  206,
+  203,  890,  424, 1247, 1162, 1163,  609,  864,  693,  866,
+ 1104,  530,  478,  890, 1302,   90,   90,  474,  874,  257,
+  481,  361,  362,  363,  364, 1296,  365,   90,  741,  693,
+  879,  634,  361,  361, 1163,  361,  958, 1129, 1130, 1162,
+  742,  959,  880,   91,  361,   82,  479,  361,  742,  366,
+  367,  368,  576,  742,  861,   91,  301,  488,  301,  507,
+    2,  755, 1521,  301,  877,  892, 1136,  507,  757,  892,
+  881,  894,   11,  485,  861,  894,   18, 1254, 1255,  244,
+  915,  406,  407,  408,  634,  244,  259,  245,  634,  369,
+  634,  634,  634,  634,  634,  634,  634,  634,  634,  634,
+  634,  486,  244, 1163,  247,  717, 1357,  250,  208,  634,
+  809,  634,  809,  634,  413,  414,  415,  416,  659,  661,
+  663,  665,  492,  634,  634,  634, 1644, 1645, 1309, 1336,
+ 1310, 1040, 1311, 1040,  500,  208,  666,  667,  668,  669,
+ 1345, 1346, 1347,  495,  954,  740,  746, 1406,  647,  649,
+  651,  502,  653,  655,  657,  822,  145,  822,  145,  306,
+  503,  306,  772, 1336,  522,  208, 1406,  772,  772,  208,
+  693,  693,  772,  772,  156,  313,  156,  313,  208,  208,
+  208,  208,  163,  284,  163,  208,  361, 1333, 1334,  634,
+ 1353, 1354,  524, 1337,  849,  850,  529,  351,  772,  540,
+  539,  559,  552,  562,  564,  569,  574,  612,  611,  604,
+  203,  613,  530, 1418, 1436, 1418,  619,  208,  293,  203,
+  203,  203,  203,  701, 1276,  706, 1418, 1337,  712,  727,
+  208,  740,  746,  750,  758, 1503,  786,  760,  566, 1506,
+  785,  787,  797, 1302,  812,  814,  816,  830,  828,  208,
+ 1436, 1007, 1516, 1517,  829, 1418,  863,  865, 1013,  882,
+  869,  878,  891,  892,  918, 1418,  894,  895,  919,  920,
+  924,  195,  931,  950,  925, 1514,  926, 1337,  941, 1337,
+  956,  957,  965,   31,  967,  972,   32,  974,  980,  984,
+ 1337,   33,  981, 1618,  990,  986,   34,  988,  507, 1001,
+ 1316, 1002,  998,  997, 1003, 1016, 1018, 1027, 1031, 1628,
+ 1039,   36,   31, 1040, 1043,   32, 1056, 1060,  208, 1337,
+   33, 1072,  208, 1057, 1061,   34, 1084, 1078,   38, 1337,
+ 1247, 1074, 1111,   39, 1079,  208,  208, 1098,  208, 1114,
+   36,  781, 1118, 1119, 1125,  208,  208, 1128, 1564, 1191,
+ 1131, 1132, 1179,   41,   42, 1196, 1199,   38, 1233, 1228,
+ 1095, 1139,   39, 1264, 1145, 1235,   43,   44, 1268, 1153,
+ 1596, 1598,   45,   46, 1669, 1269,  196, 1272, 1274, 1256,
+  530, 1263,   41,   42, 1273, 1280,  203,  203, 1614,  924,
+ 1281, 1282,  772,  772, 1283,   43,   44, 1605,  197,  772,
+ 1288,   45, 1290,  772, 1298,  318, 1306,  381, 1301, 1300,
+  507, 1307, 1313, 1317, 1320, 1331,  208,  208, 1650, 1650,
+ 1614, 1614, 1324,  381, 1326, 1327, 1328, 1329, 1351, 1335,
+ 1342,  198, 1365,  250, 1366, 1663, 1663, 1356, 1359, 1376,
+ 1369, 1378,  361, 1391, 1381, 1393, 1384, 1614,  361,   73,
+ 1397,   73, 1398, 1399, 1390, 1412,  208,  203, 1612, 1414,
+  198, 1415, 1449,  208, 1480, 1501, 1454, 1457, 1459,  199,
+ 1461,  208, 1502,   73, 1500, 1485,  208, 1504, 1495, 1507,
+ 1510,   73, 1518, 1522, 1511, 1512, 1523, 1529,  381, 1532,
+ 1534, 1549, 1555, 1551,  361, 1553,  361,  203,  293, 1545,
+ 1554, 1548,  361,   73,  203,  384, 1559, 1556,   73,   73,
+  385,  386,  203, 1569,   73, 1573, 1574,  203,   73, 1576,
+   73,   73,   73, 1581, 1582,   73, 1592, 1591, 1583, 1586,
+   73,  387,  388,  389,  390,  391,  392,  393,  394,  395,
+  396,  397, 1603,   73, 1607, 1620, 1602, 1606,   73,  361,
+   73, 1622, 1625,  361, 1629,  361,  361,  361,  361,  361,
+  361,  361,  361,  361,  361,  361,  361, 1619, 1637,  361,
+   73, 1630, 1632,  361,  361,  361,  361,  361,  361,  361,
+  361,  361,  361, 1624,  361, 1623, 1292, 1642,  361,  361,
+  361,  842,  361,  361, 1646,  361,  361,  361,  361,  361,
+  361,  361,  361,  361,  361,  361,  361,  361,  361,  361,
+  361,  361,  361,  361,  361,  361,  361,  361,  361,  361,
+  361,  361,  361,  361,  361,  361,  361,  361,  361,  361,
+  361,  361, 1653,  361,  361, 1658, 1668,    9,  361,  740,
+  361, 1036,  922,   73,  361,  924,  924,  361,  528,  923,
+  658,   45,   49,  924,  361, 1028,  924,  924,  924,  885,
+  924,  924,  659,  924,  924,  924,  924,   46,  924,  924,
+  924,  732,   38,  886,  211,  198,  924,  812,  202,   39,
+  930,  924,  824,  814,  924,  924,  199,  848,  825,  924,
+  924,  924,  815,  849,  924,  924,  334,  352,  338,  720,
+  355,  241,  924,  131,  361,  720,  924,  924,  153,  693,
+  924,  924,  140,  693,  249,  470,   57,  309,  166,  159,
+  141,  310,  167, 1472,  160,  924, 1473,  924,  924,  924,
+   28, 1223, 1253, 1234,  924,  924,  924,  924,  924,  924,
+  924,  924,  924,  924,  924,  924,  924,  924,  924, 1032,
+ 1648,  979, 1134,  924, 1135, 1593,  924,  924, 1631, 1621,
+ 1580, 1608,  999, 1000, 1665,  922, 1494, 1493, 1458, 1667,
+ 1604,  924,  924, 1652, 1599, 1379,  924,  924,  924, 1597,
+  924,  206, 1303, 1492,  975,  556,  610,  930,  853,  905,
+  745,  855,  908,  924,  924,  924,  924,  924,  671,  675,
+  673,  924,  817,  677,  425,  679,  390,  680, 1386,  955,
+ 1450,  924,  924, 1150, 1097,  796, 1115,  769,  699, 1073,
+ 1117,  962,  700, 1293, 1010,  873, 1198,  426,    0,  977,
+  976,    0,    0,    0,    0,    0,    0,    0,  924,    0,
+    0,    0,  924,  924,    0,    0,  924,  842,  842,  924,
+  924,  924,    0,    0,    0,  842,    0,  924,  842,  842,
+  842,    0,  842,  842,    0,  842,  842,  842,  842,    0,
+  842,  842,  842,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,  842,    0,    0,  842,  842,    0,    0,
+    0,  842,  842,  842,    0,    0,  842,  842,    0,    0,
+    0,    0,    0,    0,  842,    0,    0,    0,  842,  842,
+    0,    0,  842,  842,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  842,    0,  842,
+  842,  842,    0,    0,    0,    0,  842,  842,  842,  842,
+  842,  842,  842,  842,  842,  842,  842,  842,  842,  842,
+  842,    0,    0,    0,    0,  842,  355,    0,  842,  842,
+    0,    0,  355,    0,    0,  514,    0,    0,    0,    0,
+    0,    0,    0,  842,  842,    0,    0,    0,  842,  842,
+  842,    0,  842,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  842,  842,  842,  842,  842,
+    0,    0,    0,  842,    0,    0,    0,    0,  355,    0,
+  355,    0,    0,  842,  842,    0,  355,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  842,    0,    0,    0,  842,  842,    0,    0,  842,    0,
+    0,  842,  842,  842,    0,    0,    0,    0,    0,  842,
+    0,    0,  390,  355,    0,    0,    0,  355,  390,  355,
+  355,  355,  355,  355,  355,  355,  355,  355,  355,  355,
+    0,    0,    0,  355,    0,    0,    0,  355,  355,  355,
+  355,  355,  355,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  355,  355,  355,    0,  355,  355,    0,  355,
+  355,  355,  355,  355,  390,    0,  390,    0,    0,  355,
+  355,    0,  390,    0,  355,  355,  355,  355,  355,  355,
+  355,  355,  355,  355,  355,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  355,  355,   32,
+    0,    0,  355,    0,  355,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  355,  390,
+    0,    0,    0,  390,    0,  390,  390,  390,  390,  390,
+  390,  390,  390,  390,  390,  390,    0,    0,    0,  390,
+    0,    0,    0,  390,  390,    0,  390,  390,  390,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  390,  390,
+  390,    0,  390,  390,    0,  390,  390,  390,  390,  390,
+    0,  514,    0,    0,    0,  390,  390,  514,    0,    0,
+  390,  390,  390,  390,  390,  390,  390,  390,  390,  390,
+  390,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,  390,  390,    0,   43,    0,  390,    0,
+  390,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,  514,  390,  514,   31,    0,    0,   32,
+    0,  514,    0,    0,   33,    0,    0,    0,    0,   34,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,   36,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,   38,    0,    0,    0,    0,   39,    0,  514,    0,
+    0,    0,  514,    0,  514,  514,  514,  514,  514,  514,
+  514,  514,  514,  514,  514,    0,   41,   42,  514,    0,
+    0,    0,  514,  514,    0,  514,  514,  514,    0,   43,
+   44,    0,   52,    0,    0,   45,    0,  514,  514,  514,
+    0,  514,  514,    0,  514,  514,  514,  514,  514,    0,
+    0,    0,    0,    0,  514,  514,    0,    0,    0,  514,
+  514,  514,  514,  514,  514,  514,  514,  514,  514,  514,
+    0,    0,    0,    0,    0,   32,   32,    0,    0,    0,
+   32,    0,  514,  514,    0,    0,    0,  514,    0,  514,
+    0,    0,   32,   32,  198,    0,    0,   32,    0,    0,
+    0,    0,    0,  514,   32,    0,    0,   32,   32,   32,
+    0,    0,   32,    0,   32,    0,    0,    0,    0,    0,
+    0,   32,   32,   32,    0,    0,   32,    0,   32,    0,
+   32,    0,  293,   32,   32,    0,    0,    0,   32,   32,
+   32,    0,    0,   32,    0,   32,    0,   32,    0,   32,
+   32,   32,   32,   32,    0,    0,    0,    0,    0,    0,
+    0,   32,    0,   32,    0,   51,    0,    0,    0,    0,
+    0,    0,    0,    0,   32,   32,    0,    0,   32,   32,
+    0,   32,   43,   43,   32,    0,    0,   43,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,   43,
+   43,   32,    0,    0,   43,    0,    0,   32,   32,    0,
+    0,   43,    0,    0,   43,   43,   43,    0,    0,   43,
+    0,   43,    0,  529,    0,    0,    0,    0,   43,   43,
+   43,    0,    0,   43,    0,   43,    0,   43,    0,    0,
+   43,   43,    0,    0,    0,   43,   43,   43,    0,    0,
+   43,    0,   43,    0,    0,    0,   43,   43,   43,   43,
+   43,    0,    0,    0,    0,    0,    0,    0,   43,    0,
+   43,   74,    0,    0,   32,   32,    0,    0,    0,    0,
+    0,   43,   43,    0,    0,   43,   43,   32,   43,   52,
+    0,   43,    0,   52,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,   52,    0,    0,   43,    0,
+   52,    0,    0,    0,   43,   43,    0,   52,    0,    0,
+   52,    0,    0,    0,    0,   52,    0,    0,    0,    0,
+    0,    0,    0,    0,   52,   52,   52,    0,    0,    0,
+    0,   52,    0,    0,    0,    0,   52,   52,    0,    0,
+    0,   52,   52,   52,    0,    0,    0,    0,   52,    0,
+   52,    0,   52,    0,   52,   52,   52,    0,    0,    0,
+    0,    0,    0,    0,   52,    0,   52,    0,    0,    0,
+    0,   43,   43,    0,    0,   53,    0,   52,   52,    0,
+    0,    0,   52,    0,   52,    0,    0,   52,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,   52,    0,    0,    0,    0,    0,
+   52,   52,   51,    0,    0,    0,   51,    0,    0,    0,
+    0,    0,    0, 1462,    0,    0,    0, 1236,   51,    0,
+    0,    0,    0,   51,    0,    0,    0, 1237, 1463, 1464,
+   51,    0,    0,   51, 1465,    0,    0,    0,   51,    0,
+    0, 1238, 1239, 1240,    0,    0, 1467,   51,   51,   51,
+ 1468,    0,    0,   54,   51,    0,    0,    0, 1241,   51,
+   51,    0,    0, 1469,   51,   51,   51,   52,   52,    0,
+ 1470,   51,    0,    0,    0,   51,    0,   51,   51,   51,
+    0,    0,    0,    0,    0,    0,    0,   51,    0,   51,
+    0,    0,    0,    0,    0,    0,    0,    0, 1471,    0,
+   51,   51,    0,    0, 1242,   51,    0,   51,   74,    0,
+   51,    0,   74,    0,   74,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,   74,   74,    0,   51,    0,   74,
+    0,    0,    0,    0,   51,    0,   74,    0,    0,   74,
+   74,   74,    0,    0,   74,    0,   74,    0,    0,    0,
+    0,    0,    0,   74,   74,   74,    0,    0,   74,    0,
+    0,   74,   74,    0,    0,   74,   74,    0,    0,    0,
+   74,   74,   74,    0,    0,   74,   74,   74,    0,   74,
+    0,   74,   74,   74,   74,   74,    0,    0,   74,    0,
+    0,    0,    0,   74,    0,   74,    0,    0,    0,    0,
+   51,   51,    0,    0,    0,    0,   74,    0,    0,    0,
+   74,   74,    0,   74,    0,    0,   74,    0,    0,    0,
+    0,    0,   53,    0,    0,  280,   73,    0,    0,    0,
+    0,    0,    0,   74,    0,   74,   74,    0,   73,    0,
+    0,    0,    0,   73,  309,    0,    0,    0,    0,    0,
+   73,    0,    0,   73,    0,  331,    0,    0,   73,  334,
+  336,  338,  340,  342,  344,  346,  348,   73,   73,   73,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,   73,
+   73,    0,    0,    0,   73,   73,   73,    0,    0,    0,
+    0,   73,    0,    0,    0,   73,    0,   73,   73,   73,
+    0,    0,    0,    0,    0,   74,   74,   73,    0,   73,
+   54,    0,    0,    0,   73,    0,    0,    0,    0,    0,
+   73,    0,    0,    0,    0,   73,   73,   73,    0,    0,
+   73,   73,    0,    0,    0,    0,    0,    0,   73,    0,
+    0,   73,    0,    0,    0,    0,   73,   73,  596,    0,
+    0,    0,   73,   53,    0,   73,   73,   73,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,   73,   73,    0,
+    0,    0,   73,   73,   73,    0,   73,    0,    0,   73,
+    0,    0,    0,   73,   73,   73,   73,   73,    0,    0,
+    0,    0,    0,    0,    0,   73,    0,   73,    0,    0,
+    0,    0,  596,    0,    0,    0,   73,    0,   73,    0,
+    0,   73,   73,   73,    0,   73,    0,   73,   73,    0,
+   73,   73,    0,   73,   73,   73,    0,    0,   73,    0,
+    0,    0,    0,   73,    0,   73,    0,  331,    0,    0,
+    0,   54,    0,    0,    0,    0,   73,    0,    0,    0,
+    0,   73,    0,   73,    0,  596,    0,  331,    0,  596,
+    0,  596,  596,  596,  596,  596,  596,  596,  596,  596,
+  596,  596,    0,   73,    0,  361,    0,    0,    0,  320,
+  596,  361,  596,    0,  596,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  596,  596,  596,    0,    0,    0,
+    0,    0,  596,  596,  596,  596,    0,    0,   73,    0,
+    0,  596,  596,    0,    0,    0,  596,  596,  596,  596,
+  596,  596,  596,  596,  596,  596,  596,    0,    0,  361,
+    0,    0,    0,    0,    0,  361,    0,    0,    0,  596,
+    0,    0,    0,    0,    0,    0,   73,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  636,  638,  640,
+  596,    0,  646,  646,  646,  646,  646,  646,  646,  646,
+  646,  646,  646,  646,  646,  646,  646,  646,  646,  646,
+  646,  646,  361,    0,    0,    0,  361,    0,  361,  361,
+  361,  361,  361,  361,  361,  361,  361,  361,  361,  361,
+    0,    0,  361,    0,    0,    0,    0,  361,  361,  361,
+  361,  361,  361,  361,  361,  361,    0,  361,  361,    0,
+    0,  361,  361,  361,  361,  361,  361,    0,  361,  361,
+  361,  361,  361,  361,  361,  361,  361,  361,  361,  361,
+  361,  361,  361,  361,  361,  361,  361,  361,  361,  361,
+  361,  361,  361,  361,  361,  361,  361,  361,  361,  361,
+  361,  361,  361,  361,  361,    0,  361,  361,    0,    0,
+    0,    0,  361,  361,    0,    0,    0,  361,  361,    0,
+  361,    0,    0,    0,    0,    0,    0,  361,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  361,    0,    0,    0,  361,
+    0,  361,  361,  361,  361,  361,  361,  361,  361,  361,
+  361,  361,    0,    0,    0,    0,    0,    0,    0,    0,
+  361,    0,  361,  361,  361,  361,  361,  361,  361,    0,
+  361,  510,    0,    0,  361,  361,  361,  510,  361,  361,
+    0,  361,  361,  361,  361,  361,  361,  361,  361,  361,
+  361,  361,  361,  361,  361,  361,  361,  361,  361,  361,
+  361,  361,  361,  361,  361,  361,  361,  361,  361,  361,
+  361,  361,  361,  361,  361,  361,  361,  361,    0,  361,
+  361,    0,    0,    0,    0,  510,    0,    0,    0,    0,
+  361,  510,    0,  361,    0,    0,    0,    0,    0,    0,
+  361,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  510,    0,
+    0,    0,  510,    0,  510,  510,  510,  510,  510,  510,
+  510,  510,  510,  510,  510,    0,    0,    0,    0,    0,
+    0,    0,    0,  510,    0,  510,  510,  510,    0,  510,
+  510,  510,    0,  510,    0,    0,    0,  510,  510,  510,
+    0,  510,  510,    0,  510,  510,  510,  510,  510,  510,
+  510,  510,  510,  510,  510,  510,  510,  510,  510,  510,
+  510,  510,  510,  510,  510,  510,  510,  510,  510,  510,
+  510,  510,  510,  510,  510,  510,  510,  510,  510,  510,
+  510,    0,  510,  510,    0,    0,   59,    0,    0,    0,
+    0,    0,    0,  510,   60,    0,  510,   61,   31,    0,
+    0,   32,   62,  510,   63,   64,   33,   65,    0,   66,
+   67,   34,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,   68,    0,    0,   69,   36,    0,    0,    0,
+   70,   71,   72,    0,    0,   73,   74,    0,    0,    0,
+    0,    0,    0,   38,    0,    0,    0,   75,   39,    0,
+    0,   76,   77,    0,  554,    0,    0,    0,    0,    0,
+  554,    0,    0,    0,    0,    0,   78,    0,   41,   42,
+   79,    0,    0,    0,    0,   80,   81,   82,   83,   84,
+   85,   43,   44,   86,   87,   88,   89,   45,   90,   91,
+    0,    0,    0,    0,   92,    0,    0,   93,   94,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  554,    0,
+    0,    0,   95,   96,  554,    0,    0,    0,  361,   97,
+    0,   98,    0,    0,  361,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,   99,  100,  101,  102,  103,    0,
+    0,    0,  104,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  105,  106,    0,    0,    0,    0,    0,    0,
+    0,  554,    0,    0,    0,  554,    0,  554,  554,  554,
+  554,  554,  554,  554,  554,  554,  554,  554,  361,  107,
+    0,    0,    0,  108,  109,    0,  554,  110,  554,    0,
+  554,  111,  112,    0,    0,    0,    0,    0,  213,    0,
+  554,  554,  554,    0,  554,  554,    0,  554,  554,  554,
+  554,  554,  554,  554,  554,  554,  554,  554,  554,    0,
+    0,    0,  554,  554,  554,  554,  554,  554,  554,  554,
+  554,  554,  554,  554,  554,  554,  554,  554,  554,  554,
+  554,  554,  554,  554,    0,  554,  554,    0,    0,    0,
+    0,    0,  361,  361,  361,  361,  361,  361,  361,    0,
+  361,  578,    0,    0,  361,  800,  554,  578,  361,  361,
+    0,  361,  361,  361,  361,  361,  361,  361,  361,  361,
+  361,  361,  361,  361,  361,  361,  361,  361,  361,  361,
+  361,  361,  361,  361,  361,  361,  361,  361,  361,  361,
+  361,  361,  361,  361,  361,  361,  361,  361,    0,  361,
+  361,    0,    0,    0,    0,  578,    0,    0,    0,    0,
+  361,  578,    0,  361,    0,    0,    0,    0,    0,    0,
+  361,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  585,    0,    0,    0,    0,    0,
+  585,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  578,    0,
+    0,    0,  578,    0,  578,  578,  578,  578,  578,  578,
+  578,  578,  578,  578,  578,    0,    0,    0,    0,    0,
+    0,    0,    0,  578,    0,  578,    0,  578,  585,    0,
+    0,    0,    0,    0,  585,    0,    0,  578,  578,  578,
+    0,  578,  578,    0,    0,  578,  578,  578,  578,    0,
+    0,  578,  578,  578,  578,  578,    0,    0,    0,  578,
+  578,  578,  578,  578,  578,  578,  578,  578,  578,  578,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  586,  585,  578,  578,    0,  585,  586,  585,  585,  585,
+  585,  585,  585,  585,  585,  585,  585,  585,    0,    0,
+    0,    0,    0,  578,    0,    0,  585,    0,  585,    0,
+  585,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  585,  585,  585,    0,  585,  585,    0,    0,  585,  585,
+  585,  585,    0,    0,  586,    0,    0,  585,  585,    0,
+  586,    0,  585,  585,  585,  585,  585,  585,  585,  585,
+  585,  585,  585,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,  587,    0,  585,  585,    0,    0,  587,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,  585,  586,    0,    0,
+    0,  586,    0,  586,  586,  586,  586,  586,  586,  586,
+  586,  586,  586,  586,    0,    0,    0,    0,    0,    0,
+    0,    0,  586,    0,  586,    0,  586,  587,    0,    0,
+    0,    0,    0,  587,    0,    0,  586,  586,  586,    0,
+  586,  586,    0,    0,  586,  586,  586,  586,    0,    0,
+    0,    0,    0,  586,  586,    0,    0,    0,  586,  586,
+  586,  586,  586,  586,  586,  586,  586,  586,  586,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  588,
+  587,  586,  586,    0,  587,  588,  587,  587,  587,  587,
+  587,  587,  587,  587,  587,  587,  587,    0,    0,    0,
+    0,    0,  586,    0,    0,  587,    0,  587,    0,  587,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  587,
+  587,  587,    0,  587,  587,    0,    0,  587,  587,  587,
+  587,    0,    0,  588,    0,    0,  587,  587,    0,  588,
+    0,  587,  587,  587,  587,  587,  587,  587,  587,  587,
+  587,  587,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  597,    0,  587,  587,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  587,  588,    0,    0,    0,
+  588,    0,  588,  588,  588,  588,  588,  588,  588,  588,
+  588,  588,  588,    0,    0,    0,    0,    0,    0,    0,
+    0,  588,    0,  588,    0,  588,  597,    0,    0,    0,
+    0,    0,    0,    0,    0,  588,  588,  588,    0,  588,
+  588,    0,    0,  588,  588,  588,  588,    0,    0,    0,
+    0,  598,  588,  588,    0,    0,    0,  588,  588,  588,
+  588,  588,  588,  588,  588,  588,  588,  588,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  597,
+  588,  588,    0,  597,    0,  597,  597,  597,  597,  597,
+  597,  597,  597,  597,  597,  597,    0,    0,    0,    0,
+    0,  588,    0,    0,  597,  598,  597,    0,  597,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  597,  597,
+  597,    0,    0,    0,    0,    0,  597,  597,  597,  597,
+    0,    0,  599,    0,    0,  597,  597,    0,    0,    0,
+  597,  597,  597,  597,  597,  597,  597,  597,  597,  597,
+  597,    0,    0,    0,    0,    0,    0,    0,  598,    0,
+    0,    0,  598,  597,  598,  598,  598,  598,  598,  598,
+  598,  598,  598,  598,  598,    0,    0,    0,    0,    0,
+    0,    0,    0,  598,  597,  598,  599,  598,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  598,  598,  598,
+    0,    0,    0,    0,    0,  598,  598,  598,  598,    0,
+    0,  603,    0,    0,  598,  598,    0,    0,    0,  598,
+  598,  598,  598,  598,  598,  598,  598,  598,  598,  598,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  599,
+    0,    0,  598,  599,    0,  599,  599,  599,  599,  599,
+  599,  599,  599,  599,  599,  599,    0,    0,    0,    0,
+    0,    0,    0,  598,  599,  603,  599,    0,  599,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  599,  599,
+  599,    0,    0,    0,    0,    0,  599,  599,  599,  599,
+    0,    0,  604,    0,    0,  599,  599,    0,    0,    0,
+  599,  599,  599,  599,  599,  599,  599,  599,  599,  599,
+  599,    0,    0,    0,    0,    0,    0,    0,  603,    0,
+    0,    0,  603,  599,  603,  603,  603,  603,  603,  603,
+  603,  603,  603,  603,  603,    0,    0,    0,    0,    0,
+    0,    0,    0,  603,  599,  603,  604,  603,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  603,  603,  603,
+    0,    0,    0,    0,    0,  603,  603,  603,  603,    0,
+    0,  605,    0,    0,  603,  603,    0,    0,    0,    0,
+    0,    0,  603,  603,  603,  603,  603,  603,  603,  603,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  604,
+    0,    0,  603,  604,    0,  604,  604,  604,  604,  604,
+  604,  604,  604,  604,  604,  604,    0,    0,    0,    0,
+    0,    0,    0,  603,  604,  605,  604,    0,  604,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  604,  604,
+  604,    0,    0,    0,    0,    0,  604,  604,  604,  604,
+    0,    0,  606,    0,    0,  604,  604,    0,    0,    0,
+    0,    0,    0,  604,  604,  604,  604,  604,  604,  604,
+  604,    0,    0,    0,    0,    0,    0,    0,  605,    0,
+    0,    0,  605,  604,  605,  605,  605,  605,  605,  605,
+  605,  605,  605,  605,  605,    0,    0,    0,    0,    0,
+    0,    0,    0,  605,  604,  605,  606,  605,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  605,  605,  605,
+    0,    0,    0,    0,    0,  605,  605,  605,  605,    0,
+    0,  607,    0,    0,  605,  605,    0,    0,    0,    0,
+    0,    0,  605,  605,  605,  605,  605,  605,  605,  605,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  606,
+    0,    0,  605,  606,    0,  606,  606,  606,  606,  606,
+  606,  606,  606,  606,  606,  606,    0,    0,    0,    0,
+    0,    0,    0,  605,  606,  607,  606,    0,  606,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  606,  606,
+  606,    0,    0,    0,    0,    0,  606,  606,  606,  606,
+    0,    0,  612,    0,    0,  606,  606,    0,    0,    0,
+    0,    0,    0,  606,  606,  606,  606,  606,  606,  606,
+  606,    0,    0,    0,    0,    0,    0,    0,  607,    0,
+    0,    0,  607,  606,  607,  607,  607,  607,  607,  607,
+  607,  607,  607,  607,  607,    0,    0,    0,    0,    0,
+    0,    0,    0,  607,  606,  607,  612,  607,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  607,  607,  607,
+    0,    0,    0,    0,    0,  607,  607,  607,  607,    0,
+    0,  613,    0,    0,  607,  607,    0,    0,    0,    0,
+    0,    0,  607,  607,  607,  607,  607,  607,  607,  607,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  612,
+    0,    0,  607,  612,    0,  612,  612,  612,  612,  612,
+  612,  612,  612,  612,  612,  612,    0,    0,    0,    0,
+    0,    0,    0,  607,  612,  613,  612,    0,  612,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  612,  612,
+  612,    0,    0,    0,    0,    0,    0,    0,  612,  612,
+    0,    0,  615,    0,    0,  612,  612,    0,    0,    0,
+    0,    0,    0,    0,    0,  612,  612,  612,  612,  612,
+  612,    0,    0,    0,    0,    0,    0,    0,  613,    0,
+    0,    0,  613,  612,  613,  613,  613,  613,  613,  613,
+  613,  613,  613,  613,  613,    0,    0,    0,    0,    0,
+    0,    0,    0,  613,  612,  613,  615,  613,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  613,  613,  613,
+    0,    0,    0,    0,    0,    0,    0,  613,  613,    0,
+    0,  614,    0,    0,  613,  613,    0,    0,    0,    0,
+    0,    0,    0,    0,  613,  613,  613,  613,  613,  613,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  615,
+    0,    0,  613,  615,    0,  615,  615,  615,  615,  615,
+  615,  615,  615,  615,  615,  615,    0,    0,    0,    0,
+    0,    0,    0,  613,  615,  614,  615,    0,  615,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  615,  615,
+  615,    0,    0,    0,    0,    0,    0,    0,  615,  615,
+    0,    0,  616,    0,    0,  615,  615,    0,    0,    0,
+    0,    0,    0,    0,    0,  615,  615,  615,  615,  615,
+  615,    0,    0,    0,    0,    0,    0,    0,  614,    0,
+    0,    0,  614,  615,  614,  614,  614,  614,  614,  614,
+  614,  614,  614,  614,  614,    0,    0,    0,    0,    0,
+    0,    0,    0,  614,  615,  614,  616,  614,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  614,  614,  614,
+    0,    0,    0,    0,    0,    0,    0,  614,  614,    0,
+    0,  617,    0,    0,  614,  614,    0,    0,    0,    0,
+    0,    0,    0,    0,  614,  614,  614,  614,  614,  614,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  616,
+    0,    0,  614,  616,    0,  616,  616,  616,  616,  616,
+  616,  616,  616,  616,  616,  616,    0,    0,    0,    0,
+    0,    0,    0,  614,  616,  617,  616,    0,  616,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  616,  616,
+  616,    0,    0,    0,    0,    0,    0,    0,  616,  616,
+    0,    0,  618,    0,    0,  616,  616,    0,    0,    0,
+    0,    0,    0,    0,    0,  616,  616,  616,  616,  616,
+  616,    0,    0,    0,    0,    0,    0,    0,  617,    0,
+    0,    0,  617,  616,  617,  617,  617,  617,  617,  617,
+  617,  617,  617,  617,  617,    0,    0,    0,    0,    0,
+    0,    0,    0,  617,  616,  617,  618,  617,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  617,  617,  617,
+    0,    0,    0,    0,    0,    0,    0,  617,  617,    0,
+    0,  620,    0,    0,  617,  617,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  617,  617,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  618,
+    0,    0,  617,  618,    0,  618,  618,  618,  618,  618,
+  618,  618,  618,  618,  618,  618,    0,    0,    0,    0,
+    0,    0,    0,  617,  618,  620,  618,    0,  618,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  618,  618,
+  618,    0,    0,    0,    0,    0,    0,    0,  618,  618,
+    0,    0,  621,    0,    0,  618,  618,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  618,
+  618,    0,    0,    0,    0,    0,    0,    0,  620,    0,
+    0,    0,  620,  618,  620,  620,  620,  620,  620,  620,
+  620,  620,  620,  620,  620,    0,  575,    0,    0,    0,
+    0,    0,    0,  620,  618,  620,  621,  620,   31,    0,
+    0,   32,    0,    0,    0,    0,   33,  620,  620,  620,
+    0,   34,    0,    0,    0,    0,    0,    0,  620,    0,
+    0,  623,    0,    0,  620,  620,   36,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  620,  620,
+    0,    0,    0,   38,    0,    0,    0,    0,   39,  621,
+    0,    0,  620,  621,    0,  621,  621,  621,  621,  621,
+  621,  621,  621,  621,  621,  621,    0,    0,   41,   42,
+    0,    0,    0,  620,  621,  623,  621,    0,  621,    0,
+    0,   43,   44,    0,    0,    0,    0,   45,  621,  621,
+  621,  318,    0,    0,    0,    0,    0,    0,    0,  621,
+    0,    0,  624,    0,    0,  621,  621,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  621,
+  621,    0,    0,    0,    0,    0,    0,    0,  623,    0,
+    0,    0,  623,  621,  623,  623,  623,  623,  623,  623,
+  623,  623,  623,  623,  623,    0,  198,    0,    0,    0,
+    0,    0,    0,  623,  621,  623,  624,  623,   31,    0,
+    0,   32,    0,    0,    0,    0,   33,  623,  623,  623,
+    0,   34,    0,    0,    0,    0,    0,    0,  623,    0,
+   35,  626,    0,    0,  293,  623,   36,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,   37,  623,  623,
+    0,    0,    0,   38,    0,    0,    0,    0,   39,  624,
+    0,    0,  623,  624,   40,  624,  624,  624,  624,  624,
+  624,  624,  624,  624,  624,  624,    0,    0,   41,   42,
+    0,    0,    0,  623,  624,  626,  624,    0,  624,    0,
+    0,   43,   44,    0,    0,    0,    0,   45,  624,  624,
+  624,    0,    0,    0,    0,    0,    0,    0,    0,  624,
+    0,    0,  627,    0,    0,    0,  624,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  624,
+  624,    0,    0,    0,    0,    0,    0,    0,  626,    0,
+    0,    0,  626,  624,  626,  626,  626,  626,  626,  626,
+  626,  626,  626,  626,  626,    0,  641,    0,    0,    0,
+    0,    0,    0,  626,  624,  626,  627,  626,   31,    0,
+    0,   32,    0,    0,    0,    0,   33,  626,  626,  626,
+    0,   34,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  629,    0,    0,   46,  626,   36,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  626,  626,
+    0,    0,    0,   38,    0,    0,    0,    0,   39,  627,
+    0,    0,  626,  627,    0,  627,  627,  627,  627,  627,
+  627,  627,  627,  627,  627,  627,    0,    0,   41,   42,
+    0,    0,    0,  626,  627,  629,  627,    0,  627,    0,
+    0,   43,   44,    0,    0,    0,    0,   45,  627,  627,
+  627,  318,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  630,    0,    0,    0,  627,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  627,
+  627,    0,    0,    0,    0,    0,    0,    0,  629,    0,
+    0,    0,  629,  627,  629,  629,  629,  629,  629,  629,
+  629,  629,  629,  629,  629,    0,  198,    0,    0,    0,
+    0,    0,    0,  629,  627,  629,  630,  629,   31,    0,
+    0,   32,    0,    0,    0,    0,   33,  629,  629,  629,
+    0,   34,    0,    0,    0,    0,    0,    0,    0,    0,
+    0, 1012,    0,    0,  293,  629,   36,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  629,
+    0,    0,    0,   38,    0,    0,    0,    0,   39,  630,
+    0,    0,  629,  630,    0,  630,  630,  630,  630,  630,
+  630,  630,  630,  630,  630,  630,    0,    0,   41,   42,
+    0,    0,    0,  629,  630, 1012,  630,    0,  630,    0,
+    0,   43,   44,    0,    0,    0,    0,   45,  630,  630,
+  630,  318,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,  630,    0,    0,    0,
+    0,    0,    0,  197,    0,    0,    0,    0,    0,    0,
+  630,    0,    0,    0,    0,    0,    0,    0, 1012,    0,
+    0,    0, 1012,  630, 1012, 1012, 1012, 1012, 1012, 1012,
+ 1012, 1012, 1012, 1012,    0,    0,  198,    0,    0,    0,
+    0,    0,    0, 1012,  630, 1012,    0, 1012,    0,    0,
+    0,    0, 1017,    0,    0,    0,    0, 1012, 1012, 1012,
+ 1017,    0,    0, 1017, 1017,    0,    0, 1017, 1017,    0,
+ 1017, 1017, 1017, 1017,  319, 1017, 1017, 1017,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0, 1017,    0,
+    0, 1017, 1017,    0,    0,    0, 1017, 1017, 1017,    0,
+    0, 1017, 1017,    0,    0,    0,    0,    0,    0, 1017,
+    0,    0,    0, 1017, 1017,    0,    0, 1017, 1017,    0,
+    0,    0,    0, 1012,    0,    0,    0,    0,    0,    0,
+    0,    0, 1017,    0, 1017, 1017, 1017,    0,    0,    0,
+    0, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017,
+ 1017, 1017, 1017, 1017, 1017, 1017,    0,    0,    0,    0,
+ 1017,    0,    0, 1017, 1017,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0, 1017, 1017,
+    0,    0,    0, 1017,    0, 1017,    0, 1017,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+ 1017, 1017, 1017, 1017, 1017,    0,    0,    0, 1017,    0,
+    0,    0,    0,    0,    0,  853,    0,    0, 1017, 1017,
+    0,    0,    0,  853,    0,    0,  853,  853,    0,    0,
+  853,  853,    0,  853,  853,  853,  853,    0,  853,  853,
+  853,    0,    0,    0,    0, 1017,    0,    0,    0, 1017,
+ 1017,  853,    0, 1017,  853,  853,    0, 1017, 1017,  853,
+  853,  853,    0,    0,  853,  853,    0,    0,    0,    0,
+    0,    0,  853,    0,    0,    0,  853,  853,    0,    0,
+  853,  853,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  853,    0,  853,  853,  853,
+    0,    0,    0,    0,  853,  853,  853,  853,  853,  853,
+  853,  853,  853,  853,  853,  853,  853,  853,  853,    0,
+    0,    0,    0,  853,    0,    0,  853,  853,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  853,  853,    0,    0,    0,  853,    0,  853,    0,
+  853,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,  853,  853,  853,  853,  853,    0,    0,
+    0,  853,    0,    0,    0,    0,    0,    0,   59,    0,
+    0,  853,  853,    0,    0,    0,   60,    0,    0,   61,
+   31,    0,    0,   32,   62,    0,   63,   64,   33,   65,
+    0,   66,   67,   34,    0,    0,    0,    0,  853,    0,
+    0,    0,  853,  853,   68,    0,  853,   69,   36,    0,
+  853,  853,   70,   71,   72,    0,    0,   73,   74,    0,
+    0,    0,    0,    0,    0,   38,    0,    0,    0,   75,
+   39,    0,    0,   76,   77,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,   78,    0,
+   41,   42,   79,    0,    0,    0,    0,   80,   81,   82,
+   83,   84,   85,   43,   44,   86,   87,   88,   89,   45,
+   90,   91,    0,    0,    0,    0,   92,    0,    0,   93,
+   94,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,   95,   96,    0,    0,    0,    0,
+    0,   97,    0,   98,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,   99,  100,  101,  102,
+  103,    0,    0,    0,  104,    0,    0,    0,    0,    0,
+    0,  429,    0,    0,  105,  106,    0,    0,    0,   60,
+    0,    0,   61,   31,    0,    0,   32,   62,    0,   63,
+   64,   33,   65,    0,   66,   67,   34,    0,    0,    0,
+    0,  107,    0,    0,    0,  108,  109,   68,    0,  110,
+   69,   36,    0,  111,  112,   70,   71,   72,    0,    0,
+   73,   74,    0,    0,    0,    0,    0,    0,   38,    0,
+    0,    0,   75,   39,    0,    0,   76,   77,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,   78,    0,   41,   42,   79,    0,    0,    0,    0,
+   80,   81,   82,   83,   84,   85,   43,   44,   86,   87,
+   88,   89,   45,   90,   91,    0,    0,    0,    0,   92,
+    0,    0,   93,   94,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,   95,   96,    0,
+    0,    0,    0,    0,   97,    0,   98,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,   99,
+  100,  101,  102,  103,    0,    0,    0,  104,    0,    0,
+    0,    0,    0,    0,  751,    0,    0,  105,  106,    0,
+    0,    0,   60,    0,    0,   61,   31,    0,    0,   32,
+   62,    0,   63,   64,   33,   65,    0,   66,   67,   34,
+    0,    0,    0,    0,  107,    0,    0,    0,  108,  109,
+   68,    0,  110,   69,   36,    0,  111,  112,   70,   71,
+   72,    0,    0,   73,   74,    0,    0,    0,    0,    0,
+    0,   38,    0,    0,    0,   75,   39,    0,    0,   76,
+   77,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,   78,    0,   41,   42,   79,    0,
+    0,    0,    0,   80,   81,   82,   83,   84,   85,   43,
+   44,   86,   87,   88,   89,   45,   90,   91,  361,    0,
+    0,    0,   92,  800,    0,   93,   94,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,   73,    0,   73,
+   95,   96,    0,    0,    0,    0,    0,   97,    0,   98,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,   73,   99,  100,  101,  102,  103,    0,    0,   73,
+  104,    0,  361,    0,    0,    0,    0,    0,    0,    0,
+  105,  106,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,   73,  800,    0,    0,    0,   73,   73,    0,    0,
+    0,    0,   73,    0,    0,    0,   73,  107,   73,   73,
+   73,  108,  109,    0,    0,  110,    0,    0,   73,  111,
+  112,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,   73,    0,    0,    0,    0,   73,    0,   73,    0,
+    0,    0,    0,    0,  361,    0,    0,  361,    0,  361,
+  361,  361,  361,    0,  361,    0,    0,    0,   73,  800,
+  361,    0,  361,  361,  321,  361,  361,  361,  361,  361,
+  361,  361,  361,  361,  361,  361,  361,    0,  361,  361,
+  361,  361,  361,  361,  361,  361,  361,  361,  361,  361,
+  361,  361,  361,  361,  361,  361,  361,  361,  361,  361,
+  361,  361,    0,  361,  361,    0,    0,  906,    0,    0,
+    0,    0,    0,    0,  361,   60,    0,  361,    0,   31,
+    0,    0,   32,  274,  361,    0,    0,   33,   65,    0,
+   66,   73,   34,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,   31,   68,    0,   32,    0,   36,    0,    0,
+   33,    0,    0,  275,    0,   34,    0,    0,    0,    0,
+    0,    0,    0,    0,   38,    0,    0,    0,    0,   39,
+   36,    0,   76,   77,    0,    0,  510,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,  511,   38,    0,   41,
+   42,   79,   39,    0,    0,    0,    0,   81,    0,   83,
+    0,   85,   43,   44,  276,   87,    0,    0,   45,    0,
+    0,    0,   41,   42,    0,    0,    0,    0,   93,   94,
+    0,    0,    0,    0,    0,   43,   44,    0,    0,    0,
+    0,   45,    0,  297,   96,    0,    0,    0,    0,    0,
+   97,    0,   98,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,  100,  101,  102,  103,
+    0,    0,    0,  104,    0,  291,    0,    0,    0,    0,
+  762,    0,    0,  105,  106,    0,    0,    0,   60,    0,
+    0,    0,   31,    0,  292,   32,  274,    0,    0,    0,
+   33,   65,    0,   66,    0,   34,    0,    0,    0,    0,
+  107,    0,    0,    0,  108,  504,   68,    0,  110,    0,
+   36,    0,  111,  112,    0,    0,  275,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,   38,  293,    0,
+    0,    0,   39,    0,    0,   76,   77,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,   41,   42,   79,    0,    0,    0,    0,    0,
+   81,    0,   83,    0,   85,   43,   44,  276,   87,    0,
+    0,   45,    0,  763,    0,    0,    0,    0,    0,    0,
+    0,   93,   94,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,  297,  298,    0,    0,
+    0,  693,  693,   97,    0,   98,  693,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,  693,  693,  693,  100,
+  101,  102,  103,  693,    0,    0,  104,    0,    0,    0,
+  693,  693,  693,  296,    0,  693,  105,  106,    0,  693,
+    0,   60,  693,    0,    0,   31,    0,  693,   32,  274,
+    0,    0,  693,   33,   65,    0,   66,    0,   34,  693,
+    0,    0,    0,  107,    0,    0,    0,  108,  299,   68,
+    0,  110,  693,   36,    0,  111,  112,    0,    0,  275,
+    0,    0,    0,    0,    0,    0,    0,  693,    0,    0,
+   38,    0,    0,  693,    0,   39,    0,    0,   76,   77,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,   41,   42,   79,    0,    0,
+    0,    0,    0,   81,    0,   83,    0,   85,   43,   44,
+  276,   87,    0,    0,   45,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,   93,   94,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  297,
+  298,    0,    0,    0,    0,    0,   97,    0,   98,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  100,  101,  102,  103,    0,    0,    0,  104,
+    0,    0,    0,    0,    0,    0,  304,    0,    0,  105,
+  106,    0,    0,    0,   60,    0,    0,    0,   31,    0,
+    0,   32,  274,    0,    0,    0,   33,   65,    0,   66,
+    0,   34,    0,    0,    0,    0,  107,    0,    0,    0,
+  108,  299,   68,    0,  110,    0,   36,    0,  111,  112,
+    0,    0,  275,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,   38,    0,    0,    0,    0,   39,    0,
+    0,   76,   77,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,   41,   42,
+   79,    0,    0,    0,    0,    0,   81,    0,   83,    0,
+   85,   43,   44,  276,   87,    0,    0,   45,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,   93,   94,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  297,  298,    0,    0,    0,    0,    0,   97,
+    0,   98,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  100,  101,  102,  103,    0,
+    0,    0,  104,    0,    0,    0,    0,    0,    0,  380,
+    0,    0,  105,  106,    0,    0,    0,   60,    0,    0,
+    0,   31,    0,    0,   32,  274,    0,    0,    0,   33,
+   65,    0,   66,    0,   34,    0,    0,    0,    0,  107,
+    0,    0,    0,  108,  299,   68,    0,  110,    0,   36,
+    0,  111,  112,    0,    0,  275,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,   38,    0,    0,    0,
+    0,   39,    0,    0,   76,   77,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,   41,   42,   79,    0,    0,    0,    0,    0,   81,
+    0,   83,    0,   85,   43,   44,  276,   87,    0,    0,
+   45,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+   93,   94,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  297,  298,    0,    0,    0,
+    0,    0,   97,    0,   98,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  100,  101,
+  102,  103,    0,    0,    0,  104,    0,    0,    0,    0,
+    0,    0,  596,    0,    0,  105,  106,    0,    0,    0,
+   60,    0,    0,    0,   31,    0,    0,   32,  274,    0,
+    0,    0,   33,   65,    0,   66,    0,   34,    0,    0,
+    0,    0,  107,    0,    0,    0,  108,  299,   68,    0,
+  110,    0,   36,    0,  111,  112,    0,    0,  275,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,   38,
+    0,    0,    0,    0,   39,    0,    0,   76,   77,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,   41,   42,   79,    0,    0,    0,
+    0,    0,   81,    0,   83,    0,   85,   43,   44,  276,
+   87,    0,    0,   45,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,   93,   94,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  297,   96,
+    0,    0,    0,    0,    0,   97,    0,   98,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  100,  101,  102,  103,    0,    0,    0,  104,    0,
+    0,    0,    0,    0,    0,  607,    0,    0,  105,  106,
+    0,    0,    0,   60,    0,    0,    0,   31,    0,    0,
+   32,  274,    0,    0,    0,   33,   65,    0,   66,    0,
+   34,    0,    0,    0,    0,  107,    0,    0,    0,  108,
+  504,   68,    0,  110,    0,   36,    0,  111,  112,    0,
+    0,  275,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,   38,    0,    0,    0,    0,   39,    0,    0,
+   76,   77,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,   41,   42,   79,
+    0,    0,    0,    0,    0,   81,    0,   83,    0,   85,
+   43,   44,  276,   87,    0,    0,   45,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,   93,   94,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  297,   96,    0,    0,    0,    0,    0,   97,    0,
+   98,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  100,  101,  102,  103,    0,    0,
+    0,  104,    0,    0,    0,    0,    0,    0,  860,    0,
+    0,  105,  106,    0,    0,    0,   60,    0,    0,    0,
+   31,    0,    0,   32,  274,    0,    0,    0,   33,   65,
+    0,   66,    0,   34,    0,    0,    0,    0,  107,    0,
+    0,    0,  108,  504,   68,    0,  110,    0,   36,    0,
+  111,  112,    0,    0,  275,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,   38,    0,    0,    0,    0,
+   39,    0,    0,   76,   77,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+   41,   42,   79,    0,    0,    0,    0,    0,   81,    0,
+   83,    0,   85,   43,   44,  276,   87,    0,    0,   45,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,   93,
+   94,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  297,  298,    0,    0,    0,    0,
+    0,   97,    0,   98,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  100,  101,  102,
+  103,    0,    0,    0,  104,    0,    0,    0,    0,    0,
+    0,  960,    0,    0,  105,  106,    0,    0,    0,   60,
+    0,    0,    0,   31,    0,    0,   32,  274,    0,    0,
+    0,   33,   65,    0,   66,    0,   34,    0,    0,    0,
+    0,  107,    0,    0,    0,  108,  299,   68,    0,  110,
+    0,   36,    0,  111,  112,    0,    0,  275,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,   38,    0,
+    0,    0,    0,   39,    0,    0,   76,   77,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,   41,   42,   79,    0,    0,    0,    0,
+    0,   81,    0,   83,    0,   85,   43,   44,  276,   87,
+    0,    0,   45,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,   93,   94,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  297,  298,    0,
+    0,    0,    0,    0,   97,    0,   98,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  100,  101,  102,  103,    0,    0,    0,  104,    0,    0,
+    0,    0,    0,    0,  329,    0,    0,  105,  106,    0,
+    0,    0,   60,    0,    0,    0,   31,    0,    0,   32,
+  274,    0,    0,    0,   33,   65,    0,   66,    0,   34,
+    0,    0,    0,  643,  107,    0,    0,    0,  108,  299,
+   68,    0,  110,    0,   36,   31,  111,  112,   32,    0,
+  275,    0,    0,   33,    0,    0,    0,    0,   34,    0,
+    0,   38,    0,    0,    0,    0,   39,    0,    0,   76,
+   77,    0,    0,   36,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,   41,   42,   79,    0,
+   38,    0,    0,    0,   81,   39,   83,    0,   85,   43,
+   44,  276,   87,    0,    0,   45,    0,    0,    0,    0,
+    0,    0,    0,    0,  330,   41,   42,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,   43,   44,
+  277,  278,    0,    0,   45,    0,    0,   97,  318,   98,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,  100,  101,  102,  103,    0,    0,    0,
+  104,    0,    0,    0,    0,    0,    0,  273,    0,    0,
+  105,  106,    0,    0,    0,   60,    0,    0,    0,   31,
+    0,    0,   32,  274,    0,    0,    0,   33,   65,    0,
+   66,    0,   34,  198,    0,    0,  932,  107,    0,    0,
+    0,  108,  279,   68,    0,    0,    0,   36,   31,  111,
+  112,   32,    0,  275,    0,    0,   33,    0,    0,    0,
+    0,   34,    0,    0,   38,    0,    0,    0,    0,   39,
+    0,  293,   76,   77,    0,    0,   36,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,   41,
+   42,   79,    0,   38,    0,    0,    0,   81,   39,   83,
+    0,   85,   43,   44,  276,   87,    0,    0,   45,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,   41,   42,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,   43,   44,  277,  278,    0,    0,   45,    0,    0,
+   97,  318,   98,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,  100,  101,  102,  103,
+    0,    0,    0,  104,    0,    0,    0,    0,    0,    0,
+  308,    0,    0,  105,  106,    0,    0,    0,   60,    0,
+    0,    0,   31,    0,    0,   32,  274,    0,    0,    0,
+   33,   65,    0,   66,    0,   34,  198,    0,    0, 1108,
+  107,    0,    0,    0,  108,  279,   68,    0,    0,    0,
+   36,   31,  111,  112,   32,    0,  275,    0,    0,   33,
+    0,    0,    0,    0,   34,    0,    0,   38,    0,    0,
+    0,    0,   39,    0,  933,   76,   77,    0,    0,   36,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,   41,   42,   79,    0,   38,    0,    0,    0,
+   81,   39,   83,    0,   85,   43,   44,  276,   87,    0,
+    0,   45,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,   41,   42,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,   43,   44,  277,  278,    0,    0,
+   45,    0,    0,   97,  581,   98,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  100,
+  101,  102,  103,    0,    0,    0,  104,    0,    0,    0,
+    0,    0,    0,  333,    0,    0,  105,  106,    0,    0,
+    0,   60,    0,    0,    0,   31,    0,    0,   32,  274,
+    0,    0,    0,   33,   65,    0,   66,    0,   34,  198,
+    0,    0, 1295,  107,    0,    0,    0,  108,  279,   68,
+    0,    0,    0,   36,   31,  111,  112,   32,    0,  275,
+    0,    0,   33,    0,    0,    0,    0,   34,    0,    0,
+   38,    0,    0,    0,    0,   39,    0,  293,   76,   77,
+    0,    0,   36,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,   41,   42,   79,    0,   38,
+    0,    0,    0,   81,   39,   83,    0,   85,   43,   44,
+  276,   87,    0,    0,   45,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,   41,   42,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,   43,   44,  277,
+  278,    0,    0,   45,    0,    0,   97,  318,   98,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  100,  101,  102,  103,    0,    0,    0,  104,
+    0,    0,    0,    0,    0,    0,  335,    0,    0,  105,
+  106,    0,    0,    0,   60,    0,    0,    0,   31,    0,
+    0,   32,  274,    0,    0,    0,   33,   65,    0,   66,
+    0,   34,  198,    0,    0,    0,  107,    0,    0,    0,
+  108,  279,   68,    0,    0,    0,   36,  211,  111,  112,
+  211,    0,  275,    0,    0,  211,    0,    0,    0,    0,
+  211,    0,    0,   38,    0,    0,    0,    0,   39,    0,
+  293,   76,   77,    0,    0,  211,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,   41,   42,
+   79,    0,  211,    0,    0,    0,   81,  211,   83,    0,
+   85,   43,   44,  276,   87,    0,    0,   45,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  211,  211,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  211,  211,  277,  278,    0,    0,  211,    0,    0,   97,
+  211,   98,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  100,  101,  102,  103,    0,
+    0,    0,  104,    0,    0,    0,    0,    0,    0,  337,
+    0, 1039,  105,  106,    0,    0,    0,   60,    0,    0,
+    0,   31,    0,    0,   32,  274,    0,    0,    0,   33,
+   65,    0,   66,    0,   34,  211,    0,    0,    0,  107,
+    0,    0,    0,  108,  279,   68,    0,    0,    0,   36,
+   31,  111,  112,   32,    0,  275,    0,    0,   33,    0,
+    0,    0,    0,   34,    0,    0,   38,    0,    0,    0,
+    0,   39,    0,  211,   76,   77,    0,    0,   36,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,   41,   42,   79,    0,   38,    0,    0,    0,   81,
+   39,   83,    0,   85,   43,   44,  276,   87,    0,    0,
+   45,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+   41,   42,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,   43,   44,  277,  278,    0,    0,   45,
+    0,    0,   97,  318,   98,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  100,  101,
+  102,  103,    0,    0,    0,  104,    0,    0,    0,    0,
+    0,    0,  339,    0,    0,  105,  106,    0,    0,    0,
+   60,    0,    0,    0,   31,    0,    0,   32,  274,    0,
+    0,    0,   33,   65,    0,   66,    0,   34,  198,    0,
+    0,    0,  107,    0,    0,    0,  108,  279,   68,    0,
+    0,    0,   36,   31,  111,  112,   32,    0,  275,    0,
+    0,   33,    0,    0,    0,    0,   34,    0,    0,   38,
+    0,    0,    0,    0,   39,    0,  293,   76,   77,    0,
+    0,   36,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,   41,   42,   79,    0,   38,    0,
+    0,    0,   81,   39,   83,    0,   85,   43,   44,  276,
+   87,    0,    0,   45,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,   41,   42,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,   43,   44,  277,  278,
+    0,    0,   45,    0,    0,   97,  581,   98,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  100,  101,  102,  103,    0,    0,    0,  104,    0,
+    0,    0,    0,    0,    0,  341,    0,    0,  105,  106,
+    0,    0,    0,   60,    0,    0,    0,   31,    0,    0,
+   32,  274,    0,    0,    0,   33,   65,    0,   66,    0,
+   34,  198,    0,    0,    0,  107,    0,    0,    0,  108,
+  279,   68,    0,    0,    0,   36,   31,  111,  112,   32,
+    0,  275,    0,    0,   33,    0,    0,    0,    0,   34,
+    0,    0,   38,    0,    0,    0,    0,   39,    0,  293,
+   76,   77,    0,    0,   36,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,   41,   42,   79,
+    0,   38,    0,    0,    0,   81,   39,   83,    0,   85,
+   43,   44,  276,   87,    0,    0,   45,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,   41,   42,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,   43,
+   44,  277,  278,    0,    0,   45,    0,    0,   97,  196,
+   98,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  100,  101,  102,  103,    0,    0,
+    0,  104,    0,    0,    0,    0,    0,    0,  343,    0,
+    0,  105,  106,    0,    0,    0,   60,    0,    0,    0,
+   31,    0,    0,   32,  274,    0,    0,    0,   33,   65,
+    0,   66,    0,   34,  198,    0,    0,    0,  107,    0,
+    0,    0,  108,  279,   68,    0,    0,    0,   36,   31,
+  111,  112,   32,    0,  275,    0,    0,   33,    0,    0,
+    0,    0,   34,    0,    0,   38,    0,    0,    0,    0,
+   39,    0,  293,   76,   77,    0,    0,   36,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+   41,   42,   79,    0,   38,    0,    0,    0,   81,   39,
+   83,    0,   85,   43,   44,  276,   87,    0,    0,   45,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,   41,
+   42,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,   43,   44,  277,  278,    0,    0,   45,    0,
+    0,   97, 1519,   98,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  100,  101,  102,
+  103,    0,    0,    0,  104,    0,    0,    0,    0,    0,
+    0,  345,    0,    0,  105,  106,    0,    0,    0,   60,
+    0,    0,    0,   31,    0,    0,   32,  274,    0,    0,
+    0,   33,   65,    0,   66,    0,   34,  198,    0,    0,
+    0,  107,    0,    0,    0,  108,  279,   68,    0,    0,
+    0,   36,   31,  111,  112,   32,    0,  275,    0,    0,
+   33,    0,    0,    0,    0,   34,    0,    0,   38,    0,
+    0,    0,    0,   39,    0,  293,   76,   77,    0,    0,
+   36,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,   41,   42,   79,    0,   38,    0,    0,
+    0,   81,   39,   83,    0,   85,   43,   44,  276,   87,
+    0,    0,   45,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,   41,   42,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,   43,   44,  277,  278,    0,
+    0,   45,    0,    0,   97, 1610,   98,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  100,  101,  102,  103,    0,    0,    0,  104,    0,    0,
+    0,    0,    0,    0,  347,    0,    0,  105,  106,    0,
+    0,    0,   60,    0,    0,    0,   31,    0,    0,   32,
+  274,    0,    0,    0,   33,   65,    0,   66,    0,   34,
+  198,    0,    0,    0,  107,    0,    0,    0,  108,  279,
+   68,    0,    0,    0,   36,  212,  111,  112,  212,    0,
+  275,    0,    0,  212,    0,    0,    0,    0,  212,    0,
+    0,   38,    0,    0,    0,    0,   39,    0,  293,   76,
+   77,    0,    0,  212,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,   41,   42,   79,    0,
+  212,    0,    0,    0,   81,  212,   83,    0,   85,   43,
+   44,  276,   87,    0,    0,   45,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  212,  212,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  212,  212,
+  277,  278,    0,    0,  212,    0,    0,   97,  212,   98,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,  100,  101,  102,  103,    0,    0,    0,
+  104,    0,    0,    0,    0,    0,    0,  329,    0,    0,
+  105,  106,    0,    0,    0,   60,    0,    0,    0,   31,
+    0,    0,   32,  274,    0,    0,    0,   33,   65,    0,
+   66,    0,   34,  212,    0,    0,    0,  107,    0,    0,
+    0,  108,  279,   68,    0,    0,    0,   36,  211,  111,
+  112,  211,    0,  275,    0,    0,  211,    0,    0,    0,
+    0,  211,    0,    0,   38,    0,    0,    0,    0,   39,
+    0,  212,   76,   77,    0,    0,  211,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,   41,
+   42,   79,    0,  211,    0,    0,    0,   81,  211,   83,
+    0,   85,   43,   44,  276,   87,    0,    0,   45,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  211,  211,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  211,  211,  277,  278,    0,    0,  211,    0,    0,
+   97,  211,   98,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,  100,  101,  102,  103,
+    0,    0,    0,  104,    0,    0,    0,    0,    0,    0,
+  635,    0,    0,  105,  106,    0,    0,    0,   60,    0,
+    0,    0,   31,    0,    0,   32,  274,    0,    0,    0,
+   33,   65,    0,   66,    0,   34,  211,    0,    0,    0,
+  107,    0,    0,    0,  108,  279,   68,    0,    0,    0,
+   36,    0,  111,  112,    0,    0,  275,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,   38,    0,    0,
+    0,    0,   39,    0,  211,   76,   77,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,   41,   42,   79,    0,    0,    0,    0,    0,
+   81,    0,   83,    0,   85,   43,   44,  276,   87,    0,
+    0,   45,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,  277,  278,    0,    0,
+    0,    0,    0,   97,    0,   98,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  100,
+  101,  102,  103,    0,    0,    0,  104,    0,    0,    0,
+    0,    0,    0,  637,    0,    0,  105,  106,    0,    0,
+    0,   60,    0,    0,    0,   31,    0,    0,   32,  274,
+    0,    0,    0,   33,   65,    0,   66,    0,   34,    0,
+    0,    0,    0,  107,    0,    0,    0,  108,  279,   68,
+    0,    0,    0,   36,    0,  111,  112,    0,    0,  275,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+   38,    0,    0,    0,    0,   39,    0,    0,   76,   77,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,   41,   42,   79,    0,    0,
+    0,    0,    0,   81,    0,   83,    0,   85,   43,   44,
+  276,   87,    0,    0,   45,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  277,
+  278,    0,    0,    0,    0,    0,   97,    0,   98,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  100,  101,  102,  103,    0,    0,    0,  104,
+    0,    0,    0,    0,    0,    0,  639,    0,    0,  105,
+  106,    0,    0,    0,   60,    0,    0,    0,   31,    0,
+    0,   32,  274,    0,    0,    0,   33,   65,    0,   66,
+    0,   34,    0,    0,    0,    0,  107,    0,    0,    0,
+  108,  279,   68,    0,    0,    0,   36,    0,  111,  112,
+    0,    0,  275,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,   38,    0,    0,    0,    0,   39,    0,
+    0,   76,   77,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,   41,   42,
+   79,    0,    0,    0,    0,    0,   81,    0,   83,    0,
+   85,   43,   44,  276,   87,    0,    0,   45,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  277,  278,    0,    0,    0,    0,    0,   97,
+    0,   98,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  100,  101,  102,  103,    0,
+    0,    0,  104,    0,    0,    0,    0,    0,    0,  645,
+    0,    0,  105,  106,    0,    0,    0,   60,    0,    0,
+    0,   31,    0,    0,   32,  274,    0,    0,    0,   33,
+   65,    0,   66,    0,   34,    0,    0,    0,    0,  107,
+    0,    0,    0,  108,  279,   68,    0,    0,    0,   36,
+    0,  111,  112,    0,    0,  275,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,   38,    0,    0,    0,
+    0,   39,    0,    0,   76,   77,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,   41,   42,   79,    0,    0,    0,    0,    0,   81,
+    0,   83,    0,   85,   43,   44,  276,   87,    0,    0,
+   45,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  277,  278,    0,    0,    0,
+    0,    0,   97,    0,   98,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  100,  101,
+  102,  103,    0,    0,    0,  104,    0,    0,    0,    0,
+    0,    0,  648,    0,    0,  105,  106,    0,    0,    0,
+   60,    0,    0,    0,   31,    0,    0,   32,  274,    0,
+    0,    0,   33,   65,    0,   66,    0,   34,    0,    0,
+    0,    0,  107,    0,    0,    0,  108,  279,   68,    0,
+    0,    0,   36,    0,  111,  112,    0,    0,  275,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,   38,
+    0,    0,    0,    0,   39,    0,    0,   76,   77,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,   41,   42,   79,    0,    0,    0,
+    0,    0,   81,    0,   83,    0,   85,   43,   44,  276,
+   87,    0,    0,   45,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  277,  278,
+    0,    0,    0,    0,    0,   97,    0,   98,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  100,  101,  102,  103,    0,    0,    0,  104,    0,
+    0,    0,    0,    0,    0,  650,    0,    0,  105,  106,
+    0,    0,    0,   60,    0,    0,    0,   31,    0,    0,
+   32,  274,    0,    0,    0,   33,   65,    0,   66,    0,
+   34,    0,    0,    0,    0,  107,    0,    0,    0,  108,
+  279,   68,    0,    0,    0,   36,    0,  111,  112,    0,
+    0,  275,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,   38,    0,    0,    0,    0,   39,    0,    0,
+   76,   77,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,   41,   42,   79,
+    0,    0,    0,    0,    0,   81,    0,   83,    0,   85,
+   43,   44,  276,   87,    0,    0,   45,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  277,  278,    0,    0,    0,    0,    0,   97,    0,
+   98,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  100,  101,  102,  103,    0,    0,
+    0,  104,    0,    0,    0,    0,    0,    0,  652,    0,
+    0,  105,  106,    0,    0,    0,   60,    0,    0,    0,
+   31,    0,    0,   32,  274,    0,    0,    0,   33,   65,
+    0,   66,    0,   34,    0,    0,    0,    0,  107,    0,
+    0,    0,  108,  279,   68,    0,    0,    0,   36,    0,
+  111,  112,    0,    0,  275,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,   38,    0,    0,    0,    0,
+   39,    0,    0,   76,   77,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+   41,   42,   79,    0,    0,    0,    0,    0,   81,    0,
+   83,    0,   85,   43,   44,  276,   87,    0,    0,   45,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  277,  278,    0,    0,    0,    0,
+    0,   97,    0,   98,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  100,  101,  102,
+  103,    0,    0,    0,  104,    0,    0,    0,    0,    0,
+    0,  654,    0,    0,  105,  106,    0,    0,    0,   60,
+    0,    0,    0,   31,    0,    0,   32,  274,    0,    0,
+    0,   33,   65,    0,   66,    0,   34,    0,    0,    0,
+    0,  107,    0,    0,    0,  108,  279,   68,    0,    0,
+    0,   36,    0,  111,  112,    0,    0,  275,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,   38,    0,
+    0,    0,    0,   39,    0,    0,   76,   77,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,   41,   42,   79,    0,    0,    0,    0,
+    0,   81,    0,   83,    0,   85,   43,   44,  276,   87,
+    0,    0,   45,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  277,  278,    0,
+    0,    0,    0,    0,   97,    0,   98,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  100,  101,  102,  103,    0,    0,    0,  104,    0,    0,
+    0,    0,    0,    0,  656,    0,    0,  105,  106,    0,
+    0,    0,   60,    0,    0,    0,   31,    0,    0,   32,
+  274,    0,    0,    0,   33,   65,    0,   66,    0,   34,
+    0,    0,    0,    0,  107,    0,    0,    0,  108,  279,
+   68,    0,    0,    0,   36,    0,  111,  112,    0,    0,
+  275,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,   38,    0,    0,    0,    0,   39,    0,    0,   76,
+   77,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,   41,   42,   79,    0,
+    0,    0,    0,    0,   81,    0,   83,    0,   85,   43,
+   44,  276,   87,    0,    0,   45,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  277,  278,    0,    0,    0,    0,    0,   97,    0,   98,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,  100,  101,  102,  103,    0,    0,    0,
+  104,    0,    0,    0,    0,    0,    0,  658,    0,    0,
+  105,  106,    0,    0,    0,   60,    0,    0,    0,   31,
+    0,    0,   32,  274,    0,    0,    0,   33,   65,    0,
+   66,    0,   34,    0,    0,    0,    0,  107,    0,    0,
+    0,  108,  279,   68,    0,    0,    0,   36,    0,  111,
+  112,    0,    0,  275,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,   38,    0,    0,    0,    0,   39,
+    0,    0,   76,   77,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,   41,
+   42,   79,    0,    0,    0,    0,    0,   81,    0,   83,
+    0,   85,   43,   44,  276,   87,    0,    0,   45,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,  277,  278,    0,    0,    0,    0,    0,
+   97,    0,   98,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,  100,  101,  102,  103,
+    0,    0,    0,  104,    0,    0,    0,    0,    0,    0,
+  660,    0,    0,  105,  106,    0,    0,    0,   60,    0,
+    0,    0,   31,    0,    0,   32,  274,    0,    0,    0,
+   33,   65,    0,   66,    0,   34,    0,    0,    0,    0,
+  107,    0,    0,    0,  108,  279,   68,    0,    0,    0,
+   36,    0,  111,  112,    0,    0,  275,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,   38,    0,    0,
+    0,    0,   39,    0,    0,   76,   77,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,   41,   42,   79,    0,    0,    0,    0,    0,
+   81,    0,   83,    0,   85,   43,   44,  276,   87,    0,
+    0,   45,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,  277,  278,    0,    0,
+    0,    0,    0,   97,    0,   98,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  100,
+  101,  102,  103,    0,    0,    0,  104,    0,    0,    0,
+    0,    0,    0,  662,    0,    0,  105,  106,    0,    0,
+    0,   60,    0,    0,    0,   31,    0,    0,   32,  274,
+    0,    0,    0,   33,   65,    0,   66,    0,   34,    0,
+    0,    0,    0,  107,    0,    0,    0,  108,  279,   68,
+    0,    0,    0,   36,    0,  111,  112,    0,    0,  275,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+   38,    0,    0,    0,    0,   39,    0,    0,   76,   77,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,   41,   42,   79,    0,    0,
+    0,    0,    0,   81,    0,   83,    0,   85,   43,   44,
+  276,   87,    0,    0,   45,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  277,
+  278,    0,    0,    0,    0,    0,   97,    0,   98,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  100,  101,  102,  103,    0,    0,    0,  104,
+    0,    0,    0,    0,    0,    0,  664,    0,    0,  105,
+  106,    0,    0,    0,   60,    0,    0,    0,   31,    0,
+    0,   32,  274,    0,    0,    0,   33,   65,    0,   66,
+    0,   34,    0,    0,    0,    0,  107,    0,    0,    0,
+  108,  279,   68,    0,    0,    0,   36,    0,  111,  112,
+    0,    0,  275,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,   38,    0,    0,    0,    0,   39,    0,
+    0,   76,   77,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,   41,   42,
+   79,    0,    0,    0,    0,    0,   81,    0,   83,    0,
+   85,   43,   44,  276,   87,    0,    0,   45,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  277,  278,    0,    0,    0,    0,    0,   97,
+    0,   98,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  100,  101,  102,  103,    0,
+    0,    0,  104,    0,    0,    0,    0,    0,    0,  670,
+    0,    0,  105,  106,    0,    0,    0,   60,    0,    0,
+    0,   31,    0,    0,   32,  274,    0,    0,    0,   33,
+   65,    0,   66,    0,   34,    0,    0,    0,    0,  107,
+    0,    0,    0,  108,  279,   68,    0,    0,    0,   36,
+    0,  111,  112,    0,    0,  275,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,   38,    0,    0,    0,
+    0,   39,    0,    0,   76,   77,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,   41,   42,   79,    0,    0,    0,    0,    0,   81,
+    0,   83,    0,   85,   43,   44,  276,   87,    0,    0,
+   45,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  277,  278,    0,    0,    0,
+    0,    0,   97,    0,   98,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  100,  101,
+  102,  103,    0,    0,    0,  104,    0,    0,    0,    0,
+    0,    0,  672,    0,    0,  105,  106,    0,    0,    0,
+   60,    0,    0,    0,   31,    0,    0,   32,  274,    0,
+    0,    0,   33,   65,    0,   66,    0,   34,    0,    0,
+    0,    0,  107,    0,    0,    0,  108,  279,   68,    0,
+    0,    0,   36,    0,  111,  112,    0,    0,  275,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,   38,
+    0,    0,    0,    0,   39,    0,    0,   76,   77,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,   41,   42,   79,    0,    0,    0,
+    0,    0,   81,    0,   83,    0,   85,   43,   44,  276,
+   87,    0,    0,   45,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  277,  278,
+    0,    0,    0,    0,    0,   97,    0,   98,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  100,  101,  102,  103,    0,    0,    0,  104,    0,
+    0,    0,    0,    0,    0,  674,    0,    0,  105,  106,
+    0,    0,    0,   60,    0,    0,    0,   31,    0,    0,
+   32,  274,    0,    0,    0,   33,   65,    0,   66,    0,
+   34,    0,    0,    0,    0,  107,    0,    0,    0,  108,
+  279,   68,    0,    0,    0,   36,    0,  111,  112,    0,
+    0,  275,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,   38,    0,    0,    0,    0,   39,    0,    0,
+   76,   77,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,   41,   42,   79,
+    0,    0,    0,    0,    0,   81,    0,   83,    0,   85,
+   43,   44,  276,   87,    0,    0,   45,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  277,  278,    0,    0,    0,    0,    0,   97,    0,
+   98,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  100,  101,  102,  103,    0,    0,
+    0,  104,    0,    0,    0,    0,    0,    0,  676,    0,
+    0,  105,  106,    0,    0,    0,   60,    0,    0,    0,
+   31,    0,    0,   32,  274,    0,    0,    0,   33,   65,
+    0,   66,    0,   34,    0,    0,    0,    0,  107,    0,
+    0,    0,  108,  279,   68,    0,    0,    0,   36,    0,
+  111,  112,    0,    0,  275,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,   38,    0,    0,    0,    0,
+   39,    0,    0,   76,   77,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+   41,   42,   79,    0,    0,    0,    0,    0,   81,    0,
+   83,    0,   85,   43,   44,  276,   87,    0,    0,   45,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  277,  278,    0,    0,    0,    0,
+    0,   97,    0,   98,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  100,  101,  102,
+  103,    0,    0,    0,  104,    0,    0,    0,    0,    0,
+    0,  678,    0,    0,  105,  106,    0,    0,    0,   60,
+    0,    0,    0,   31,    0,    0,   32,  274,    0,    0,
+    0,   33,   65,    0,   66,    0,   34,    0,    0,    0,
+    0,  107,    0,    0,    0,  108,  279,   68,    0,    0,
+    0,   36,    0,  111,  112,  218,    0,  275,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,   38,    0,
+    0,    0,    0,   39,    0,    0,   76,   77,    0,    0,
+    0,    0,    0,    0,    0,  411,    0,    0,    0,    0,
+    0,  411,    0,   41,   42,   79,    0,    0,    0,    0,
+    0,   81,    0,   83,    0,   85,   43,   44,  276,   87,
+    0,  219,   45,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  277,  278,    0,
+    0,    0,    0,    0,   97,  411,   98,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  100,  101,  102,  103,    0,    0,    0,  104,  220,  221,
+  222,  223,    0,  224,  225,  226,  227,  105,  106,  228,
+  229,  230,  231,    0,    0,  232,  233,  234,  235,  236,
+  237,  238,  239,    0,  240,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  107,    0,    0,    0,  108,  279,
+    0,  241,  355,    0,    0,    0,  111,  112,  355,    0,
+  411,  411,  411,  411,  411,  411,    0,  411,    0,    0,
+    0,    0,    0,    0,    0,  411,  411,    0,  411,  411,
+  411,  411,  411,  411,  411,  411,  411,  411,  411,  411,
+  411,  411,  411,  411,  411,  411,  411,  411,  411,  411,
+  411,  411,  411,  411,  411,  411,  411,  411,  411,  411,
+  411,  411,  411,  411,  411,  127,  411,  411,    0,    0,
+  127,    0,  361,  355,    0,    0,    0,  411,    0,    0,
+  411,    0,  127,  127,    0,    0,    0,  127,    0,    0,
+    0,    0,    0,    0,  127,    0,    0,  127,  127,  127,
+    0,    0,  127,    0,  127,    0,    0,    0,    0,    0,
+    0,  127,  127,  127,    0,    0,  127,    0,  127,    0,
+  127,    0,    0,  127,  127,    0,  361,    0,  127,  127,
+  127,    0,    0,  127,    0,  127,    0,    0,    0,  127,
+  127,  127,  127,  127,    0,    0,    0,    0,    0,    0,
+    0,  127,    0,  127,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  127,  127,    0,    0,  127,  127,
+    0,  127,    0,    0,  127,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  127,    0,    0,    0,    0,  129,    0,  127,    0,
+    0,  361,  361,  361,  361,  361,  361,    0,  361,    0,
+    0,    0,  361,  800,    0,    0,  361,  361,    0,    0,
+  361,  361,  361,  361,  361,  361,  361,  361,  361,  361,
+  361,  361,  361,  361,  361,  361,  361,  361,  361,  361,
+  361,  361,  361,  361,  361,  361,  361,  361,  361,  361,
+  361,  361,  361,  361,  361,  361,    0,  361,  361,    0,
+    0,    0,   60,    0,  127,  127,   31,    0,  361,   32,
+  274,  361,    0,    0,   33,   65,    0,   66,    0,   34,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+   68,    0,    0,    0,   36,    0,    0,    0,    0,    0,
+  275,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,   38,    0,    0,    0,    0,   39,    0,    0,   76,
+   77,    0,    0,  510,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,  511,    0,    0,   41,   42,   79,    0,
+    0,    0,    0,    0,   81,    0,   83,    0,   85,   43,
+   44,  276,   87,    0,    0,   45,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,   93,   94,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  297,   96,    0,    0,    0,    0,    0,   97,    0,   98,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  512,    0,    0,  100,  101,  102,  103,    0,    0,    0,
+  104,    0,    0,    0,    0,    0,    0,    0,   60,    0,
+  105,  106,   31,    0,    0,   32,  274,    0,    0,    0,
+   33,   65,    0,   66,    0,   34,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,   68,  107,    0,    0,
+   36,  108,  504,    0,    0,  110,  275,    0,    0,  111,
+  112,    0,    0,    0,    0,    0,    0,   38,    0,    0,
+    0,    0,   39,    0,    0,   76,   77,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,   41,   42,   79,    0,    0,    0,    0,    0,
+   81,    0,   83,    0,   85,   43,   44,  276,   87,    0,
+    0,   45,    0,    0,    0,  553,    0,    0,    0,    0,
+    0,   93,   94,    0,  694,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  694,  694,  297,  298,    0,  694,
+    0,    0,    0,   97,    0,   98,    0,    0,    0,  694,
+  694,  694,    0,    0,    0,    0,  694,    0,    0,  100,
+  101,  102,  103,  694,  694,  694,  104,    0,  694,    0,
+  694,    0,  694,    0,   60,  694,  105,  106,   31,    0,
+  694,   32,  274,    0,    0,  694,   33,   65,    0,   66,
+    0,   34,  694,    0,    0,    0,    0,    0,  694,    0,
+    0,    0,   68,  107,    0,  694,   36,  108,  299,    0,
+    0,  110,  275,    0,    0,  111,  112,  694,    0,    0,
+  694,    0,    0,   38,    0,    0,  694,    0,   39,    0,
+    0,   76,   77,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  694,  694,    0,   41,   42,
+   79,    0,    0,    0,    0,    0,   81,    0,   83,    0,
+   85,   43,   44,  276,   87,    0,    0,   45,    0,  763,
+    0,    0,    0,    0,    0,    0,    0,   93,   94,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  693,  693,  297,  298,    0,  693,    0,    0,    0,   97,
+    0,   98,    0,    0,    0,  693,  693,  693,    0,    0,
+    0,    0,  693,    0,    0,  100,  101,  102,  103,  693,
+  693,  693,  104,    0,  693,    0,  693,    0,  693,    0,
+   60,  693,  105,  106,   31,    0,  693,   32,  274,    0,
+    0,  693,   33,   65,    0,   66,    0,   34,  693,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,   68,  107,
+    0,  693,   36,  108,  299,    0,    0,  110,  275,    0,
+    0,  111,  112,  693,    0,    0,  693,    0,    0,   38,
+    0,    0,  693,    0,   39,    0,    0,   76,   77,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,   41,   42,   79,    0,    0,    0,
+    0,    0,   81,    0,   83,    0,   85,   43,   44,  276,
+   87,    0,    0,   45,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,   93,   94,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0, 1462,  297,  298,
+    0, 1236,    0,    0,    0,   97,    0,   98,    0,    0,
+    0, 1237, 1463, 1464,    0,    0,    0,    0, 1465,    0,
+    0,  100,  101,  102,  103, 1466, 1239, 1240,  104,    0,
+ 1467,    0,   20,    0, 1468,    0,   60,    0,  105,  106,
+   31,    0, 1241,   32,  274,    0,    0, 1469,   33,   65,
+    0,   66,    0,   34, 1470,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,   68,  107,    0,    0,   36,  108,
+  299,    0,    0,  110,  275,    0,    0,  111,  112,   21,
+    0,    0, 1471,    0,    0,   38,    0,    0, 1242,    0,
+   39,    0,    0,   76,   77,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+   41,   42,   79,    0,    0,    0,    0,    0,   81,    0,
+   83,    0,   85,   43,   44,  276,   87,    0,    0,   45,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,   93,
+   94,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  297,   96,    0,    0,    0,    0,
+    0,   97,    0,   98,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  100,  101,  102,
+  103,    0,    0,    0,  104,    0,    0,    0,    0,    0,
+    0,    0,   60,    0,  105,  106,   31,    0,    0,   32,
+  274,    0,    0,    0,   33,   65,    0,   66,    0,   34,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+   68,  107,    0,    0,   36,  108,  504,    0,    0,  110,
+  275,    0,    0,  111,  112,    0,    0,    0,    0,    0,
+    0,   38,    0,    0,    0,    0,   39,    0,    0,   76,
+   77,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,   41,   42,   79,    0,
+    0,    0,    0,    0,   81,    0,   83,    0,   85,   43,
+   44,  276,   87,    0,    0,   45,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,   93,   94,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  297,   96,    0,    0,    0,    0,    0,   97,    0,   98,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,  100,  101,  102,  103,    0,    0,    0,
+  104,    0,    0,    0,    0,    0,    0,    0,  660,    0,
+  105,  106,  660,    0,    0,  660,  660,    0,    0,    0,
+  660,  660,    0,  660,    0,  660,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,  660,  107,    0,    0,
+  660,  108, 1033,    0,    0,  110,  660,    0,    0,  111,
+  112,    0,    0,    0,    0,    0,    0,  660,    0,    0,
+    0,    0,  660,    0,    0,  660,  660,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  660,  660,  660,    0,    0,    0,    0,    0,
+  660,    0,  660,    0,  660,  660,  660,  660,  660,    0,
+    0,  660,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  660,  660,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,  660,  660,    0,    0,
+    0,    0,    0,  660,    0,  660,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  660,
+  660,  660,  660,    0,    0,    0,  660,    0,    0,    0,
+    0,    0,    0,    0,  103,    0,  660,  660,  103,    0,
+    0,  103,  103,    0,    0,    0,  103,  103,    0,  103,
+    0,  103,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  103,  660,    0,    0,  103,  660,  660,    0,
+    0,  660,  103,    0,    0,  660,  660,    0,    0,    0,
+    0,    0,    0,  103,    0,    0,    0,    0,  103,    0,
+    0,  103,  103,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  103,  103,
+  103,    0,    0,    0,    0,    0,  103,    0,  103,    0,
+  103,  103,  103,  103,  103,    0,    0,  103,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  103,  103,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  103,  103,    0,    0,    0,    0,    0,  103,
+    0,  103,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  103,  103,  103,  103,    0,
+    0,    0,  103,    0,    0,    0,    0,    0,    0,    0,
+  171,    0,  103,  103,  171,    0,    0,  171,  171,    0,
+    0,    0,  171,  171,    0,  171,    0,  171,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  171,  103,
+    0,    0,  171,  103,  103,    0,    0,  103,  171,    0,
+    0,  103,  103,    0,    0,    0,    0,    0,    0,  171,
+    0,    0,    0,    0,  171,    0,    0,  171,  171,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  171,  171,  171,    0,    0,    0,
+    0,    0,  171,    0,  171,    0,  171,  171,  171,  171,
+  171,    0,    0,  171,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,  171,  171,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  171,  171,
+    0,    0,    0,    0,    0,  171,    0,  171,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  171,  171,  171,  171,    0,    0,    0,  171,    0,
+    0,    0,    0,    0,    0,    0,   60,    0,  171,  171,
+   31,    0,    0,   32,  274,    0,    0,    0,   33,   65,
+    0,   66,    0,   34,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,   68,  171,    0,    0,   36,  171,
+  171,    0,    0,  171,  275,    0,    0,  171,  171,    0,
+    0,    0,    0,    0,    0,   38,    0,    0,    0,    0,
+   39,    0,    0,   76,   77,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+   41,   42,   79,    0,    0,    0,   51,    0,   81,    0,
+   83,    0,   85,   43,   44,  276,   87,    0,   51,   45,
+    0,    0,    0,   51,    0,    0,    0,    0,    0,    0,
+   51,    0,    0,   51,    0,    0,    0,    0,   51,    0,
+    0,    0,    0,    0,  277,  278,    0,   51,   51,   51,
+    0,   97,    0,   98,   51,    0,    0,    0,    0,   51,
+   51,    0,    0,    0,   51,   51,   51,  100,  101,  102,
+  103,   51,    0,    0,  104,   51,    0,   51,   51,   51,
+    0,    0,    0,    0,  105,  106,    0,   51,    0,   51,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+   51,   51,    0,    0,    0,   51,    0,   51,   74,    0,
+   51,  107,    0,    0,    0,  108,  279,    0,    0,    0,
+   74,   74,    0,  111,  112,   74,    0,   51,    0,    0,
+    0,    0,   74,   51,   51,   74,   74,   74,    0,    0,
+   74,    0,   74,    0,    0,    0,    0,    0,    0,   74,
+   74,   74,    0,    0,   74,    0,   74,    0,   74,    0,
+    0,   74,   74,    0,    0,    0,   74,   74,   74,    0,
+    0,   74,    0,   74,    0,    0,    0,   74,   74,   74,
+   74,   74,    0,    0,    0,    0,    0,    0,    0,   74,
+    0,   74,    0,    0,    0,    0,    0,    0,    0,    0,
+   51,   51,   74,   74,    0,    0,   74,   74,    0,   74,
+   73,    0,   74,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,   73,   73,    0,    0,    0,   73,    0,   74,
+    0,    0,    0,    0,   73,    0,    0,   73,   73,   73,
+    0,    0,   73,    0,   73,    0,    0,    0,    0,    0,
+    0,   73,   73,   73,    0,    0,   73,    0,   73,    0,
+   73,    0,    0,   73,   73,    0,    0,    0,   73,   73,
+   73,    0,    0,   73,    0,   73,    0,    0,    0,   73,
+   73,   73,   73,   73,    0,    0,    0,    0,    0,    0,
+    0,   73,    0,   73,    0,    0,    0,    0,    0,    0,
+    0,   74,   74,    0,   73,   73,    0,    0,   73,   73,
+    0,   73,   73,    0,   73,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,   73,   73,    0,    0,    0,   73,
+    0,   73,    0,    0,    0,    0,   73,  106,    0,   73,
+   73,   73,    0,    0,   73,    0,   73,    0,    0,    0,
+    0,    0,    0,   73,   73,   73,    0,    0,   73,    0,
+   73,    0,   73,    0,    0,   73,   73,    0,    0,    0,
+   73,   73,   73,    0,    0,   73,    0,   73,    0,    0,
+    0,   73,   73,   73,   73,   73,    0,    0,    0,    0,
+    0,    0,    0,   73,    0,   73,    0,    0,    0,    0,
+    0,    0,    0,    0,   73,    0,   73,   73,    0,    0,
+   73,   73,    0,   73,   73,    0,   73,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,   73,   73,    0,    0,
+    0,   73,    0,   73,    0,    0,    0,    0,   73,  107,
+    0,   73,   73,   73,    0,    0,   73,    0,   73,    0,
+    0,    0,    0,    0,    0,   73,   73,   73,    0,    0,
+   73,    0,   73,    0,   73,    0,    0,   73,   73,    0,
+    0,    0,   73,   73,   73,    0,    0,   73,    0,   73,
+    0,    0,    0,   73,   73,   73,   73,   73,    0,    0,
+    0,    0,    0,    0,    0,   73,    0,   73,    0,    0,
+    0,    0,    0,    0,    0,    0,   73,    0,   73,   73,
+    0,    0,   73,   73,    0,   73,   73,    0,   73,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,   73,   73,
+    0,    0,    0,   73,    0,   73,    0,    0,    0,    0,
+   73,    0,    0,   73,   73,   73,    0,    0,   73,    0,
+   73,    0,    0,    0,    0,    0,    0,   73,   73,   73,
+    0,    0,   73,    0,    0,    0,   73,    0,    0,   73,
+   73,    0,    0,    0,   73,   73,   73,    0,    0,   73,
+    0,   73,    0,    0,    0,   73,   73,   73,   73,   73,
+    0,    0,    0,    0,    0,    0,    0,   73,    0,   73,
+    0,    0,    0,    0,    0,    0,    0,    0,   73,    0,
+   73,    0,    0,    0,   73,   73,    0,   73,   73,    0,
+   73,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+   73,   73,    0,    0,    0,   73,    0,   73,    0,    0,
+    0,    0,   73,  248,    0,   73,   73,   73,    0,    0,
+   73,    0,   73,    0,    0,    0,    0,    0,    0,   73,
+   73,   73,    0,    0,   73,    0,    0,    0,   73,    0,
+    0,   73,   73,    0,    0,    0,   73,   73,   73,    0,
+    0,   73,    0,   73,    0,    0,    0,   73,   73,   73,
+   73,   73,    0,    0,   63,    0,    0,    0,    0,   73,
+    0,   73,    0,    0,    0,    0,   63,    0,    0,    0,
+   73,   63,   73,    0,    0,    0,   73,   73,   63,   73,
+    0,   63,   73,    0,    0,    0,   63,    0,    0,    0,
+    0,    0,    0,    0,    0,   63,   63,   63,    0,   73,
+    0,    0,   63,    0,    0,  249,    0,   63,   63,    0,
+    0,    0,   63,   63,   63,    0,    0,    0,    0,   63,
+    0,    0,    0,   63,    0,   63,   63,   63,    0,    0,
+    0,    0,    0,    0,    0,   63,    0,   63,    0,    0,
+    0,    0,   73,    0,    0,    0,    0,    0,   63,   63,
+    0,    0,    0,   63,   73,   63,    0,    0,   63,   73,
+    0,    0,    0,    0,    0,    0,   73,    0,    0,   73,
+    0,    0,   73,    0,   73,   63,    0,    0,    0,    0,
+   65,    0,   63,   73,   73,   73,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,   73,   73,    0,    0,    0,
+   73,   73,   73,    0,    0,    0,    0,   73,    0,    0,
+    0,   73,    0,   73,   73,   73,    0,    0,   74,    0,
+    0,    0,    0,   73,    0,   73,    0,    0,    0,    0,
+   74,    0,    0,    0,    0,   74,   73,    0,    0,    0,
+    0,   73,   74,   73,    0,   74,   73,    0,   63,    0,
+   74,    0,    0,    0,    0,    0,    0,    0,    0,   74,
+   74,   74,    0,   73,    0,    0,    0,    0,    0,   53,
+    0,   74,   74,    0,    0,    0,   74,   74,   74,    0,
+    0,    0,    0,   74,    0,    0,    0,   74,    0,   74,
+   74,   74,    0,    0,    0,    0,    0,    0,    0,   74,
+    0,   74,    0,   73,    0,    0,    0,    0,    0,    0,
+    0,    0,   74,    0,    0,   73,    0,   74,    0,   74,
+   73,    0,   74,    0,    0,    0,    0,   73,    0,    0,
+   73,    0,    0,    0,    0,   73,   73,    0,    0,   74,
+    0,    0,    0,    0,   73,   73,   73,    0,    0,   73,
+    0,    0,    0,    0,    0,    0,   73,   73,    0,    0,
+    0,   73,   73,   73,    0,    0,    0,    0,   73,    0,
+    0,    0,   73,   73,   73,   73,   73,    0,    0,    0,
+    0,   73,    0,    0,   73,    0,   73,   73,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,   73,    0,    0,
+    0,    0,   73,   73,   73,    0,    0,   73,   73,   73,
+    0,   73,   74,    0,   73,    0,    0,    0,   73,   73,
+   73,   73,   73,    0,   73,    0,    0,    0,    0,    0,
+   73,   43,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,   73,    0,   73,    0,    0,   73,   73,   73,    0,
+   73,    0,   73,    0,    0,   43,   73,    0,   73,   73,
+   73,    0,    0,   43,    0,    0,    0,    0,   73,   73,
+   73,    0,   73,   73,    0,    0,  229,    0,    0,    0,
+    0,   73,    0,    0,    0,   43,   73,    0,   73,    0,
+   43,   43,    0,   73,    0,    0,   43,   73,    0,    0,
+   43,   73,   43,   43,   43,    0,    0,   43,   73,    0,
+   73,   73,   43, 1202,  231,    0,    0,    0,    0,    0,
+    0,    0,    0,   73,    0,   43,    0,    0,   73,   73,
+   43,    0,   43,    0,   73,    0,    0, 1203,   73,    0,
+   73,   73,   73,   73,    0, 1204,    0,    0,    0,    0,
+   73, 1202,   43,    0,    0,    0,    0,    0,   43,   43,
+    0,    0,    0,   73,    0,    0,    0, 1205,   73,    0,
+   73,    0, 1206, 1207,    0, 1203,    0,    0, 1208,    0,
+    0,   73, 1209, 1204, 1210, 1211, 1212,    0,    0,    0,
+   73,    0,   73,   73, 1213,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0, 1205,    0, 1214,    0,    0,
+ 1206, 1207, 1215,    0, 1216,    0, 1208,    0,    0,    0,
+ 1209,    0, 1210, 1211, 1212,   43,    0,    0,    0,    0,
+    0,    0, 1213,   31, 1217,    0,   32,    0,    0,    0,
+    0,   33,    0,    0,    0, 1214,   34,    0,    0,    0,
+ 1215,    0, 1216,    0,    0,    0,    0,    0,    0,    0,
+    0,   36,    0,   73,    0,    0,    0,    0,   31,    0,
+    0,   32, 1217, 1403,    0,    0,   33,    0,   38,    0,
+    0,   34,    0,   39,  211,    0,    0,  211,    0,    0,
+  578,    0,  211,    0,    0,    0,   36,  211,    0,    0,
+  579,    0,    0,   41,   42,    0, 1256, 1218,    0,    0,
+    0,  580,  211,   38,    0,    0,   43,   44,   39,    0,
+    0, 1404,   45,    0,    0,    0,  581,    0,    0,  211,
+    0,    0,    0,    0,  211,    0,    0,    0,   41,   42,
+    0,    0,    0,    0, 1405, 1218,    0,    0,  582,    0,
+    0,   43,   44,    0,  211,  211,    0,   45,    0,    0,
+    0,  318,    0,    0,    0,    0,    0,  211,  211,    0,
+    0,    0,    0,  211,    0,    0,    0,  211,    0,    0,
+    0,  198,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0, 1039,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,  198,    0,    0,  583,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  211,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  293,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  211,
+  };
+  protected static readonly short [] yyCheck = {            17,
+    6,   62,  286,  109,   93,   94,  138,    6,   17,  317,
+  292,  253,  211,   20,   20,   17,  261,  193,  520,   55,
+  561,  593,  573,   84,  354,   86,  682,    0,  585, 1139,
+    0, 1061,   64,   18,   51,  735,    0,  208,    0,  256,
+  269,  256,  256,    0,   82,    0,  256,   60, 1078, 1238,
+  256,  938,   65,    0,    0,   20,   69,   70, 1012,  269,
+   78,   74,   75,  256,   82,    0,   79,   80,  256,   76,
+   76,  267,    0,   86,  256,  256,  782,   90,  784,   92,
+   98,  256,  256,   55,  256,  269,  359,   93,   94,  256,
+  256,  593, 1137,  256,  800, 1125,  369,  267,  256,  256,
+  309,  256,  115,  116,  810,  269,  256,  256,  778,  256,
+ 1077,  263, 1136,  277,  404,  360,  391,  289,  256, 1137,
+  138, 1166, 1239, 1240,  346,  370,  363,  216,  217,  256,
+  363,  256, 1410,  693,  694,  256, 1422,  270,  363,  450,
+  336,  393, 1259,  257,  162,  815,  256,  356, 1166,  392,
+  387,  381,  404,  162,  387, 1200,  467,  256,  194,  402,
+  162,  294,  387,  720,  336, 1451,  336,  404, 1446, 1286,
+  387,  404,  387,  279,  391,  381,  262,  391,  468,  454,
+  682,  753, 1200,  272,  310,  337, 1153, 1141,  256,  404,
+ 1235,  256,  281,  299,  387,   17,  363,  256,  391,  325,
+  367, 1225,  369,  387,  388,  372,  373,  403,  375,  376,
+  216,  217, 1099,  302,  363,  251,  391, 1235,  367,  383,
+  369,  409,  404,  372,  373,  242,  375,  376,  409,  471,
+  316,  460,  454,  403,  391,  402,  393,  364,  568,  389,
+  387,  458,  260,  261,  458,  403,  403,  456,  247,  267,
+  460,  753,  313,  402,  409,  287,  288,  463,  464,  465,
+  466,  309,  351,  276,  402,  458,  272,  818,  286,  301,
+  283,  289,  290,  291,  306,  281,  460, 1466,  403,  949,
+  454,  402,  454,  458,  257,  303,  292,  257,  454,  256,
+  454,  454,  256,  403,  312,  257,  302,  315, 1004,  317,
+  257,  468,  257,  402,  256, 1335,  456,  302,  356,  315,
+  257,  257,  401,  402, 1344, 1345, 1346, 1347,  356,  468,
+  406,  407,  257,  355,  256,  390,   17,  291,  454,  257,
+  603,  390, 1032,  606,  402,   17,  309,  402,  356,   17,
+  162,  359,  360,  402,  308,  351, 1463, 1053,  354,  302,
+  393,  369,  370, 1470,  256,  328,  943,  257,  328,  256,
+  256,  404,  448,  452,  453, 1410,  384,  385,  386,  387,
+  388,  389,  390,  391,  392,  393,  394,  395,  396,  397,
+   17,  328,  328,  356,  555,  556,  256,  256,  383,  354,
+  454,  721, 1410,  328, 1100,  401,  402,  503,  504,  363,
+  328, 1446,   17,   17,  964,  423,  966,  256,  456,  969,
+   17,  388,   17,   17, 1120,  256,  389,  449,  388,  389,
+  468,   17,  309,  387,  391,  387,  393,  391, 1446,  393,
+  383,  363,   17,  522, 1140,  367,  403,  369, 1144,  403,
+  372,  373,  389,  375,  376,   17,  452,  453, 1558,  256,
+  402,  256,  404,  256, 1143,  346,  492,  409, 1418,  454,
+  391, 1048,  457,  263, 1024,  472, 1026, 1027, 1019,  356,
+  559,  162,  489,  490,  256,  346, 1436,  454,  495,  310,
+  162, 1511, 1512,  456,  162,  546,  547,  619,  594,  256,
+  392,  498,  510,  511,  600,  392,  392,   20,  828,  531,
+ 1057,  454,  389,  488,  457,  750,  256,  256,  526,  527,
+ 1051,  520,  256,  403, 1055, 1411,  522,  256,  520,  409,
+  552,  391,  363,  392,  256,  162,  367,  458,  369, 1080,
+  772,  372,  373,  546,  375,  376,  468,  337,  310, 1228,
+   63,  483,  555,  392,  562,  256,  564,  162,  162,  310,
+   73,  859, 1582,  559,  325,  162,  528,  162,  162,  319,
+  592,  389,  568,  454,  335, 1461,  162, 1127,   91,  456,
+   93,   94,   95,  404, 1230,  346,  310,  162, 1150,  585,
+  324,  599,  389,  454,  593,  603,  389,  392,  606,  256,
+  162,  593, 1622,  611,  612,  613,  363, 1157,  704, 1629,
+  367,  619,  369,  568, 1564,  372,  373, 1637,  375,  376,
+  392,  366, 1642,  363, 1116,  383,  558,  367,  388,  369,
+  585,  392,  372,  373, 1294,  375,  376,  468,  399, 1299,
+ 1300, 1378,  404,  461, 1304, 1305, 1596,  388, 1598,  366,
+  389,  366,  388,  404, 1185,  256,  380,  310, 1150,  383,
+  389,  389,  363,  325, 1614,  389,  367,  389,  369,  393,
+ 1330,  372,  373,  335,  375,  376,  421,  387,  388,  325,
+  688,  684, 1232,  682,  346,  693,  694,  256,  696,  335,
+  682,  787,  409,  454,  388,  993,  454, 1220,  387,  388,
+  346,  310, 1252,  325,  310,  450,  363,  402,  468,  310,
+  367,  468,  369,  335,  793,  372,  373,  391,  375,  376,
+  256,  324,  467,  383,  720,  388,  387,  468,  468,  389,
+  454,  402,  468,  450,  742,  450, 1259,  399, 1230, 1476,
+ 1477, 1478,  750,  404,  795,  824,  981,  260,  261,  402,
+  467,  404,  467,  399,  753,  324,  404,  452,  468,  383,
+  454,  753,  363,  308,  388,  720,  367,  468,  369,  370,
+  371,  372,  373,  374,  375,  376,  377,  378,  379,  468,
+  454,  452, 1056,  392,  297, 1410,  392,  388,  309,  390,
+ 1064,  392,  454,  402,  454,  404,  402,  793,  404,  807,
+  278,  402,  403,  404,  812,  468,  814,  973,  454,  322,
+  288,  468,  325,  383,  822,  308,  778,   28,  363,  420,
+  261, 1446,  388,  391,  302,  303,  304,  363,  824,  453,
+  454,  367,  828,  369,  309,  356,  372,  373,  404,  375,
+  376,  319,  387,  467,  285,   56,  359,  360,  392,  857,
+  392,  859,  293,  815,  392,  324,  369,  370, 1093,  392,
+  309,  887,  273,  273, 1524, 1525,  988,  468,  389,  409,
+  363, 1531, 1325,  828,  315, 1535,  273, 1410,  387,  320,
+  321,  356,  391,  453,  454,  326,  454,  365,  383,  330,
+  404,  332,  333,  334,  387,  325,  904,  467,  895,  467,
+  383,  342,  468,  314,  314,  335, 1359,  356,  256,  917,
+  450,  990,  387, 1446,  355, 1189,  346,  314,  403,  360,
+  942,  362,  270,  393,  468, 1351,  468, 1006,  388,  389,
+  468, 1163,  402,  344,  344,  468,  261, 1033,  263,  452,
+  453,  382,  380,  456, 1353, 1354,  294,  344, 1137,  458,
+  363, 1360, 1410,  391,  989,  393,  964, 1383,  966,  454,
+  285,  969,  475,  925,  405,  450, 1375, 1410,  293,  399,
+ 1410,  454,  485,  981,  387, 1010,  310, 1166,  986,  434,
+  988,  978,  452,  387,  992,  993,  994,  949, 1446,  392,
+  315,  325,  447, 1402,  990,  320,  321, 1076,  450,  402,
+ 1022,  326,  998, 1446,  319,  330, 1446,  332,  333,  334,
+ 1006, 1200,  525,  454,  455,  467, 1024,  342, 1026, 1027,
+  458, 1029, 1044,  461,  450,  380,  325, 1616, 1617,  380,
+  355,  388,  454,  412,  389,  360,  335,  362,  393,  461,
+  395,  467,  393,  998,  557,  402, 1235,  346, 1056,  404,
+  410,  411,  409, 1075, 1643,  454, 1064,  382,  387, 1110,
+  387, 1057,  461,  388,  389, 1061,  387,  427,  428, 1077,
+  389,  584,  391,  380,  393,  404,  390,  404,  387,  310,
+ 1076,  598, 1078,  404,  419, 1093,  393,  391,  380,  393,
+  603,  383,  609,  606,  325,  404, 1147,  389,  420,  392,
+  392,  393, 1057, 1154,  459, 1337, 1061,  273,  454,  402,
+  402, 1137,  278,  377,  378,  390, 1390, 1116,  392, 1127,
+  389,  467,  288, 1078, 1116, 1133,  395,  402,  402, 1125,
+  455, 1139,  416,  417,  418,  404,  302,  303,  304,  458,
+ 1166,  413,  461,  380, 1195, 1153,  383,  256,  314, 1157,
+ 1158, 1150,  389,  319,  458,  392,  393,  461, 1150,  392,
+ 1256,  388,  454,  433,  388,  392,  360,  388,  392,  402,
+ 1125,  392,  387, 1224, 1200, 1137,  370,  690,  344,  692,
+  404, 1189,  404,  404, 1280,  390,  391,  380,  701,  391,
+  389,  393,  394,  395,  396, 1274,  398,  402,  390,  365,
+  390,  310,  390,  391, 1166,  393,  390,  377,  378, 1235,
+  402,  390,  402,  390,  402,  403,  459,  454,  402,  421,
+  422,  423, 1301,  402, 1232,  402,  402,  387,  404,  742,
+  381, 1230, 1504,  409,  705,  388,  387,  750, 1230,  392,
+  711,  388,    0,  393, 1252,  392,    4, 1236, 1237,  391,
+  763,  424,  425,  426,  363,  391,  458,  393,  367,  461,
+  369,  370,  371,  372,  373,  374,  375,  376,  377,  378,
+  379,  454,  391, 1235,  393, 1301,  388,  389, 1274,  388,
+  402,  390,  404,  392,  429,  430,  431,  432,  409,  410,
+  411,  412,  450,  402,  403,  404,  384,  385, 1287, 1325,
+ 1289,  390, 1291,  392,  328, 1301,  413,  414,  415,  416,
+ 1327, 1328, 1329,  454,  827,  387,  388, 1396,  403,  404,
+  405,  256,  406,  407,  408,  402,  402,  404,  404,  402,
+  454,  404, 1294, 1359,  403, 1331, 1415, 1299, 1300, 1335,
+  384,  385, 1304, 1305,  402,  402,  404,  404, 1344, 1345,
+ 1346, 1347,  402,  391,  404, 1351,    0, 1322, 1323,  468,
+ 1333, 1334,  302, 1325,  612,  613,  391,  450, 1330,  256,
+  393,  403,  454,  310,  310,  366,  454,  403,  409,  454,
+ 1335,  403, 1390, 1409, 1410, 1411,  402, 1383,  454, 1344,
+ 1345, 1346, 1347,  379, 1490,  395, 1422, 1359,  404,  389,
+ 1396,  403,  256,  402,  392, 1484,  411,  392,  391, 1488,
+  392,  454,  392, 1509,  310,  310,  391,  256,  402, 1415,
+ 1446,  934, 1501, 1502,  392, 1451,  310,  310,  941,  388,
+  409,  404,  392,  402,  310, 1461,  403,  402,  404,  310,
+  392,  256,  387,  392,  402, 1496,  402, 1409,  402, 1411,
+  366,  392,  310,  268,  310,  402,  271,  454,  390,  393,
+ 1422,  276,  391, 1585,  403,  409,  281,  409,  981,  256,
+  256,  392,  403,  454,  287,  392,  366,  374,  390, 1601,
+  387,  296,  268,  454,  402,  271,  409,  402, 1484, 1451,
+  276,  392, 1488,  403,  403,  281,  370,  403,  313, 1461,
+ 1551,  392,  256,  318,  392, 1501, 1502,  392, 1504,  388,
+  296,  392,  392,  256,  403, 1511, 1512,  370, 1544,  387,
+  402,  390,  388,  338,  339,  371,  388,  313,  371,  402,
+ 1043,  409,  318,  302,  409,  387,  351,  352,  388,  409,
+ 1566, 1567,  357,  454, 1666,  379,  361,  388,  403,  454,
+ 1558,  454,  338,  339,  391,  454, 1511, 1512, 1584,    0,
+  391,  391, 1524, 1525,  409,  351,  352, 1575,  383, 1531,
+  256,  357,  256, 1535,  393,  361,  453, 1585,  450,  391,
+ 1093,  404,  387,  393,  391,  291, 1582, 1583, 1639, 1640,
+ 1616, 1617,  392, 1601,  392,  392,  392,  392,  308,  403,
+  403,  416,  392,  389,  256, 1656, 1657,  454,  402,  256,
+  363,  388,  256,  404,  403,  361,  454, 1643,  262,  261,
+  387,  263,  387,  387,  409,  404, 1622, 1582, 1583,  391,
+  416,  402,  392, 1629,  454,  403,  388,  388,  388,  454,
+  387, 1637,  403,  285,  388,  454, 1642,  403,  454,  391,
+  391,  293,  391,  454,  403,  403,  391,  387, 1666,  256,
+  391,  389,  387,  392,  308,  392,  310, 1622,  454,  409,
+  392,  404,  316,  315, 1629,  409,  402,  409,  320,  321,
+  414,  415, 1637,  402,  326,  392,  256, 1642,  330,  402,
+  332,  333,  334,  392,  403,  337,  404,  454,  403,  402,
+  342,  435,  436,  437,  438,  439,  440,  441,  442,  443,
+  444,  445,  404,  355,  404,  404,  454,  454,  360,  363,
+  362,  403,  388,  367,  403,  369,  370,  371,  372,  373,
+  374,  375,  376,  377,  378,  379,  380,  454,  403,  383,
+  382,  390,  387,  387,  388,  389,  390,  391,  392,  393,
+  394,  395,  396,  337,  398,  263, 1269,  403,  402,  403,
+  404,    0,  406,  407,  388,  409,  410,  411,  412,  413,
+  414,  415,  416,  417,  418,  419,  420,  421,  422,  423,
+  424,  425,  426,  427,  428,  429,  430,  431,  432,  433,
+  434,  435,  436,  437,  438,  439,  440,  441,  442,  443,
+  444,  445,  409,  447,  448,  409,  388,    0,  452,  387,
+  454,    0,  404,  455,  458,  256,  257,  461,  404,  404,
+  392,  390,  388,  264,  468,    0,  267,  268,  269,  404,
+  271,  272,  392,  274,  275,  276,  277,  390,  279,  280,
+  281,  454,  387,  404,  454,  392,  287,  404,  392,  387,
+  392,  292,  404,  392,  295,  296,  392,  388,  404,  300,
+  301,  302,  392,  388,  305,  306,  387,  404,  388,  387,
+    0,  454,  313,  454,  393,  404,  317,  318,  389,  337,
+  321,  322,  404,  263,   54,  194,   12,  404,  404,  404,
+  404,  404,  404, 1453,  404,  336, 1453,  338,  339,  340,
+    5, 1166, 1235, 1200,  345,  346,  347,  348,  349,  350,
+  351,  352,  353,  354,  355,  356,  357,  358,  359,  978,
+ 1638,  895, 1093,  364, 1093, 1561,  367,  368, 1606, 1588,
+ 1551, 1578,  925,  925, 1657,  771, 1470, 1469, 1446, 1659,
+ 1571,  382,  383, 1640, 1567, 1359,  387,  388,  389, 1566,
+  391,   20, 1280, 1468,  887,  315,  370,  786,  618,  742,
+  511,  620,  750,  404,  405,  406,  407,  408,  417,  419,
+  418,  412,  568,  420,  162,  421,    0,  422, 1371,  828,
+ 1415,  422,  423, 1116, 1045,  548, 1067,  527,  461, 1010,
+ 1069,  858,  461, 1271,  937,  699, 1158,  162,   -1,  893,
+  892,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  449,   -1,
+   -1,   -1,  453,  454,   -1,   -1,  457,  256,  257,  460,
+  461,  462,   -1,   -1,   -1,  264,   -1,  468,  267,  268,
+  269,   -1,  271,  272,   -1,  274,  275,  276,  277,   -1,
+  279,  280,  281,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  292,   -1,   -1,  295,  296,   -1,   -1,
+   -1,  300,  301,  302,   -1,   -1,  305,  306,   -1,   -1,
+   -1,   -1,   -1,   -1,  313,   -1,   -1,   -1,  317,  318,
+   -1,   -1,  321,  322,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  336,   -1,  338,
+  339,  340,   -1,   -1,   -1,   -1,  345,  346,  347,  348,
+  349,  350,  351,  352,  353,  354,  355,  356,  357,  358,
+  359,   -1,   -1,   -1,   -1,  364,  256,   -1,  367,  368,
+   -1,   -1,  262,   -1,   -1,    0,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  382,  383,   -1,   -1,   -1,  387,  388,
+  389,   -1,  391,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  404,  405,  406,  407,  408,
+   -1,   -1,   -1,  412,   -1,   -1,   -1,   -1,  308,   -1,
+  310,   -1,   -1,  422,  423,   -1,  316,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  449,   -1,   -1,   -1,  453,  454,   -1,   -1,  457,   -1,
+   -1,  460,  461,  462,   -1,   -1,   -1,   -1,   -1,  468,
+   -1,   -1,  256,  363,   -1,   -1,   -1,  367,  262,  369,
+  370,  371,  372,  373,  374,  375,  376,  377,  378,  379,
+   -1,   -1,   -1,  383,   -1,   -1,   -1,  387,  388,  389,
+  390,  391,  392,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  402,  403,  404,   -1,  406,  407,   -1,  409,
+  410,  411,  412,  413,  308,   -1,  310,   -1,   -1,  419,
+  420,   -1,  316,   -1,  424,  425,  426,  427,  428,  429,
+  430,  431,  432,  433,  434,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  447,  448,    0,
+   -1,   -1,  452,   -1,  454,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  468,  363,
+   -1,   -1,   -1,  367,   -1,  369,  370,  371,  372,  373,
+  374,  375,  376,  377,  378,  379,   -1,   -1,   -1,  383,
+   -1,   -1,   -1,  387,  388,   -1,  390,  391,  392,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  402,  403,
+  404,   -1,  406,  407,   -1,  409,  410,  411,  412,  413,
+   -1,  256,   -1,   -1,   -1,  419,  420,  262,   -1,   -1,
+  424,  425,  426,  427,  428,  429,  430,  431,  432,  433,
+  434,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  447,  448,   -1,    0,   -1,  452,   -1,
+  454,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  308,  468,  310,  268,   -1,   -1,  271,
+   -1,  316,   -1,   -1,  276,   -1,   -1,   -1,   -1,  281,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  296,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  313,   -1,   -1,   -1,   -1,  318,   -1,  363,   -1,
+   -1,   -1,  367,   -1,  369,  370,  371,  372,  373,  374,
+  375,  376,  377,  378,  379,   -1,  338,  339,  383,   -1,
+   -1,   -1,  387,  388,   -1,  390,  391,  392,   -1,  351,
+  352,   -1,    0,   -1,   -1,  357,   -1,  402,  403,  404,
+   -1,  406,  407,   -1,  409,  410,  411,  412,  413,   -1,
+   -1,   -1,   -1,   -1,  419,  420,   -1,   -1,   -1,  424,
+  425,  426,  427,  428,  429,  430,  431,  432,  433,  434,
+   -1,   -1,   -1,   -1,   -1,  256,  257,   -1,   -1,   -1,
+  261,   -1,  447,  448,   -1,   -1,   -1,  452,   -1,  454,
+   -1,   -1,  273,  274,  416,   -1,   -1,  278,   -1,   -1,
+   -1,   -1,   -1,  468,  285,   -1,   -1,  288,  289,  290,
+   -1,   -1,  293,   -1,  295,   -1,   -1,   -1,   -1,   -1,
+   -1,  302,  303,  304,   -1,   -1,  307,   -1,  309,   -1,
+  311,   -1,  454,  314,  315,   -1,   -1,   -1,  319,  320,
+  321,   -1,   -1,  324,   -1,  326,   -1,  328,   -1,  330,
+  331,  332,  333,  334,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  342,   -1,  344,   -1,    0,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  355,  356,   -1,   -1,  359,  360,
+   -1,  362,  256,  257,  365,   -1,   -1,  261,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  273,
+  274,  382,   -1,   -1,  278,   -1,   -1,  388,  389,   -1,
+   -1,  285,   -1,   -1,  288,  289,  290,   -1,   -1,  293,
+   -1,  295,   -1,  404,   -1,   -1,   -1,   -1,  302,  303,
+  304,   -1,   -1,  307,   -1,  309,   -1,  311,   -1,   -1,
+  314,  315,   -1,   -1,   -1,  319,  320,  321,   -1,   -1,
+  324,   -1,  326,   -1,   -1,   -1,  330,  331,  332,  333,
+  334,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  342,   -1,
+  344,    0,   -1,   -1,  455,  456,   -1,   -1,   -1,   -1,
+   -1,  355,  356,   -1,   -1,  359,  360,  468,  362,  257,
+   -1,  365,   -1,  261,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  273,   -1,   -1,  382,   -1,
+  278,   -1,   -1,   -1,  388,  389,   -1,  285,   -1,   -1,
+  288,   -1,   -1,   -1,   -1,  293,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  302,  303,  304,   -1,   -1,   -1,
+   -1,  309,   -1,   -1,   -1,   -1,  314,  315,   -1,   -1,
+   -1,  319,  320,  321,   -1,   -1,   -1,   -1,  326,   -1,
+  328,   -1,  330,   -1,  332,  333,  334,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  342,   -1,  344,   -1,   -1,   -1,
+   -1,  455,  456,   -1,   -1,    0,   -1,  355,  356,   -1,
+   -1,   -1,  360,   -1,  362,   -1,   -1,  365,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  382,   -1,   -1,   -1,   -1,   -1,
+  388,  389,  257,   -1,   -1,   -1,  261,   -1,   -1,   -1,
+   -1,   -1,   -1,  274,   -1,   -1,   -1,  278,  273,   -1,
+   -1,   -1,   -1,  278,   -1,   -1,   -1,  288,  289,  290,
+  285,   -1,   -1,  288,  295,   -1,   -1,   -1,  293,   -1,
+   -1,  302,  303,  304,   -1,   -1,  307,  302,  303,  304,
+  311,   -1,   -1,    0,  309,   -1,   -1,   -1,  319,  314,
+  315,   -1,   -1,  324,  319,  320,  321,  455,  456,   -1,
+  331,  326,   -1,   -1,   -1,  330,   -1,  332,  333,  334,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  342,   -1,  344,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  359,   -1,
+  355,  356,   -1,   -1,  365,  360,   -1,  362,  257,   -1,
+  365,   -1,  261,   -1,  263,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  273,  274,   -1,  382,   -1,  278,
+   -1,   -1,   -1,   -1,  389,   -1,  285,   -1,   -1,  288,
+  289,  290,   -1,   -1,  293,   -1,  295,   -1,   -1,   -1,
+   -1,   -1,   -1,  302,  303,  304,   -1,   -1,  307,   -1,
+   -1,  310,  311,   -1,   -1,  314,  315,   -1,   -1,   -1,
+  319,  320,  321,   -1,   -1,  324,  325,  326,   -1,  328,
+   -1,  330,  331,  332,  333,  334,   -1,   -1,  337,   -1,
+   -1,   -1,   -1,  342,   -1,  344,   -1,   -1,   -1,   -1,
+  455,  456,   -1,   -1,   -1,   -1,  355,   -1,   -1,   -1,
+  359,  360,   -1,  362,   -1,   -1,  365,   -1,   -1,   -1,
+   -1,   -1,  257,   -1,   -1,   66,  261,   -1,   -1,   -1,
+   -1,   -1,   -1,  382,   -1,  384,  385,   -1,  273,   -1,
+   -1,   -1,   -1,  278,   85,   -1,   -1,   -1,   -1,   -1,
+  285,   -1,   -1,  288,   -1,   96,   -1,   -1,  293,  100,
+  101,  102,  103,  104,  105,  106,  107,  302,  303,  304,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  314,
+  315,   -1,   -1,   -1,  319,  320,  321,   -1,   -1,   -1,
+   -1,  326,   -1,   -1,   -1,  330,   -1,  332,  333,  334,
+   -1,   -1,   -1,   -1,   -1,  454,  455,  342,   -1,  344,
+  257,   -1,   -1,   -1,  261,   -1,   -1,   -1,   -1,   -1,
+  355,   -1,   -1,   -1,   -1,  360,  273,  362,   -1,   -1,
+  365,  278,   -1,   -1,   -1,   -1,   -1,   -1,  285,   -1,
+   -1,  288,   -1,   -1,   -1,   -1,  293,  382,  256,   -1,
+   -1,   -1,  261,  388,   -1,  302,  303,  304,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  314,  315,   -1,
+   -1,   -1,  319,  320,  321,   -1,  285,   -1,   -1,  326,
+   -1,   -1,   -1,  330,  293,  332,  333,  334,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  342,   -1,  344,   -1,   -1,
+   -1,   -1,  310,   -1,   -1,   -1,  315,   -1,  355,   -1,
+   -1,  320,  321,  360,   -1,  362,   -1,  326,  365,   -1,
+  455,  330,   -1,  332,  333,  334,   -1,   -1,  337,   -1,
+   -1,   -1,   -1,  342,   -1,  382,   -1,  278,   -1,   -1,
+   -1,  388,   -1,   -1,   -1,   -1,  355,   -1,   -1,   -1,
+   -1,  360,   -1,  362,   -1,  363,   -1,  298,   -1,  367,
+   -1,  369,  370,  371,  372,  373,  374,  375,  376,  377,
+  378,  379,   -1,  382,   -1,  256,   -1,   -1,   -1,  388,
+  388,  262,  390,   -1,  392,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  402,  403,  404,   -1,   -1,   -1,
+   -1,   -1,  410,  411,  412,  413,   -1,   -1,  455,   -1,
+   -1,  419,  420,   -1,   -1,   -1,  424,  425,  426,  427,
+  428,  429,  430,  431,  432,  433,  434,   -1,   -1,  310,
+   -1,   -1,   -1,   -1,   -1,  316,   -1,   -1,   -1,  447,
+   -1,   -1,   -1,   -1,   -1,   -1,  455,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  398,  399,  400,
+  468,   -1,  403,  404,  405,  406,  407,  408,  409,  410,
+  411,  412,  413,  414,  415,  416,  417,  418,  419,  420,
+  421,  422,  363,   -1,   -1,   -1,  367,   -1,  369,  370,
+  371,  372,  373,  374,  375,  376,  377,  378,  379,  380,
+   -1,   -1,  383,   -1,   -1,   -1,   -1,  388,  389,  390,
+  391,  392,  393,  394,  395,  396,   -1,  398,  256,   -1,
+   -1,  402,  403,  404,  262,  406,  407,   -1,  409,  410,
+  411,  412,  413,  414,  415,  416,  417,  418,  419,  420,
+  421,  422,  423,  424,  425,  426,  427,  428,  429,  430,
+  431,  432,  433,  434,  435,  436,  437,  438,  439,  440,
+  441,  442,  443,  444,  445,   -1,  447,  448,   -1,   -1,
+   -1,   -1,  310,  454,   -1,   -1,   -1,  458,  316,   -1,
+  461,   -1,   -1,   -1,   -1,   -1,   -1,  468,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  363,   -1,   -1,   -1,  367,
+   -1,  369,  370,  371,  372,  373,  374,  375,  376,  377,
+  378,  379,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  388,   -1,  390,  391,  392,  393,  394,  395,  396,   -1,
+  398,  256,   -1,   -1,  402,  403,  404,  262,  406,  407,
+   -1,  409,  410,  411,  412,  413,  414,  415,  416,  417,
+  418,  419,  420,  421,  422,  423,  424,  425,  426,  427,
+  428,  429,  430,  431,  432,  433,  434,  435,  436,  437,
+  438,  439,  440,  441,  442,  443,  444,  445,   -1,  447,
+  448,   -1,   -1,   -1,   -1,  310,   -1,   -1,   -1,   -1,
+  458,  316,   -1,  461,   -1,   -1,   -1,   -1,   -1,   -1,
+  468,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  363,   -1,
+   -1,   -1,  367,   -1,  369,  370,  371,  372,  373,  374,
+  375,  376,  377,  378,  379,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  388,   -1,  390,  391,  392,   -1,  394,
+  395,  396,   -1,  398,   -1,   -1,   -1,  402,  403,  404,
+   -1,  406,  407,   -1,  409,  410,  411,  412,  413,  414,
+  415,  416,  417,  418,  419,  420,  421,  422,  423,  424,
+  425,  426,  427,  428,  429,  430,  431,  432,  433,  434,
+  435,  436,  437,  438,  439,  440,  441,  442,  443,  444,
+  445,   -1,  447,  448,   -1,   -1,  256,   -1,   -1,   -1,
+   -1,   -1,   -1,  458,  264,   -1,  461,  267,  268,   -1,
+   -1,  271,  272,  468,  274,  275,  276,  277,   -1,  279,
+  280,  281,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  292,   -1,   -1,  295,  296,   -1,   -1,   -1,
+  300,  301,  302,   -1,   -1,  305,  306,   -1,   -1,   -1,
+   -1,   -1,   -1,  313,   -1,   -1,   -1,  317,  318,   -1,
+   -1,  321,  322,   -1,  256,   -1,   -1,   -1,   -1,   -1,
+  262,   -1,   -1,   -1,   -1,   -1,  336,   -1,  338,  339,
+  340,   -1,   -1,   -1,   -1,  345,  346,  347,  348,  349,
+  350,  351,  352,  353,  354,  355,  356,  357,  358,  359,
+   -1,   -1,   -1,   -1,  364,   -1,   -1,  367,  368,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  310,   -1,
+   -1,   -1,  382,  383,  316,   -1,   -1,   -1,  256,  389,
+   -1,  391,   -1,   -1,  262,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  404,  405,  406,  407,  408,   -1,
+   -1,   -1,  412,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  422,  423,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  363,   -1,   -1,   -1,  367,   -1,  369,  370,  371,
+  372,  373,  374,  375,  376,  377,  378,  379,  316,  449,
+   -1,   -1,   -1,  453,  454,   -1,  388,  457,  390,   -1,
+  392,  461,  462,   -1,   -1,   -1,   -1,   -1,  468,   -1,
+  402,  403,  404,   -1,  406,  407,   -1,  409,  410,  411,
+  412,  413,  414,  415,  416,  417,  418,  419,  420,   -1,
+   -1,   -1,  424,  425,  426,  427,  428,  429,  430,  431,
+  432,  433,  434,  435,  436,  437,  438,  439,  440,  441,
+  442,  443,  444,  445,   -1,  447,  448,   -1,   -1,   -1,
+   -1,   -1,  390,  391,  392,  393,  394,  395,  396,   -1,
+  398,  256,   -1,   -1,  402,  403,  468,  262,  406,  407,
+   -1,  409,  410,  411,  412,  413,  414,  415,  416,  417,
+  418,  419,  420,  421,  422,  423,  424,  425,  426,  427,
+  428,  429,  430,  431,  432,  433,  434,  435,  436,  437,
+  438,  439,  440,  441,  442,  443,  444,  445,   -1,  447,
+  448,   -1,   -1,   -1,   -1,  310,   -1,   -1,   -1,   -1,
+  458,  316,   -1,  461,   -1,   -1,   -1,   -1,   -1,   -1,
+  468,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  256,   -1,   -1,   -1,   -1,   -1,
+  262,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  363,   -1,
+   -1,   -1,  367,   -1,  369,  370,  371,  372,  373,  374,
+  375,  376,  377,  378,  379,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  388,   -1,  390,   -1,  392,  310,   -1,
+   -1,   -1,   -1,   -1,  316,   -1,   -1,  402,  403,  404,
+   -1,  406,  407,   -1,   -1,  410,  411,  412,  413,   -1,
+   -1,  416,  417,  418,  419,  420,   -1,   -1,   -1,  424,
+  425,  426,  427,  428,  429,  430,  431,  432,  433,  434,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  256,  363,  447,  448,   -1,  367,  262,  369,  370,  371,
+  372,  373,  374,  375,  376,  377,  378,  379,   -1,   -1,
+   -1,   -1,   -1,  468,   -1,   -1,  388,   -1,  390,   -1,
+  392,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  402,  403,  404,   -1,  406,  407,   -1,   -1,  410,  411,
+  412,  413,   -1,   -1,  310,   -1,   -1,  419,  420,   -1,
+  316,   -1,  424,  425,  426,  427,  428,  429,  430,  431,
+  432,  433,  434,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  256,   -1,  447,  448,   -1,   -1,  262,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  468,  363,   -1,   -1,
+   -1,  367,   -1,  369,  370,  371,  372,  373,  374,  375,
+  376,  377,  378,  379,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  388,   -1,  390,   -1,  392,  310,   -1,   -1,
+   -1,   -1,   -1,  316,   -1,   -1,  402,  403,  404,   -1,
+  406,  407,   -1,   -1,  410,  411,  412,  413,   -1,   -1,
+   -1,   -1,   -1,  419,  420,   -1,   -1,   -1,  424,  425,
+  426,  427,  428,  429,  430,  431,  432,  433,  434,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  256,
+  363,  447,  448,   -1,  367,  262,  369,  370,  371,  372,
+  373,  374,  375,  376,  377,  378,  379,   -1,   -1,   -1,
+   -1,   -1,  468,   -1,   -1,  388,   -1,  390,   -1,  392,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  402,
+  403,  404,   -1,  406,  407,   -1,   -1,  410,  411,  412,
+  413,   -1,   -1,  310,   -1,   -1,  419,  420,   -1,  316,
+   -1,  424,  425,  426,  427,  428,  429,  430,  431,  432,
+  433,  434,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  256,   -1,  447,  448,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  468,  363,   -1,   -1,   -1,
+  367,   -1,  369,  370,  371,  372,  373,  374,  375,  376,
+  377,  378,  379,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  388,   -1,  390,   -1,  392,  310,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  402,  403,  404,   -1,  406,
+  407,   -1,   -1,  410,  411,  412,  413,   -1,   -1,   -1,
+   -1,  256,  419,  420,   -1,   -1,   -1,  424,  425,  426,
+  427,  428,  429,  430,  431,  432,  433,  434,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  363,
+  447,  448,   -1,  367,   -1,  369,  370,  371,  372,  373,
+  374,  375,  376,  377,  378,  379,   -1,   -1,   -1,   -1,
+   -1,  468,   -1,   -1,  388,  310,  390,   -1,  392,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  402,  403,
+  404,   -1,   -1,   -1,   -1,   -1,  410,  411,  412,  413,
+   -1,   -1,  256,   -1,   -1,  419,  420,   -1,   -1,   -1,
+  424,  425,  426,  427,  428,  429,  430,  431,  432,  433,
+  434,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  363,   -1,
+   -1,   -1,  367,  447,  369,  370,  371,  372,  373,  374,
+  375,  376,  377,  378,  379,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  388,  468,  390,  310,  392,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  402,  403,  404,
+   -1,   -1,   -1,   -1,   -1,  410,  411,  412,  413,   -1,
+   -1,  256,   -1,   -1,  419,  420,   -1,   -1,   -1,  424,
+  425,  426,  427,  428,  429,  430,  431,  432,  433,  434,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  363,
+   -1,   -1,  447,  367,   -1,  369,  370,  371,  372,  373,
+  374,  375,  376,  377,  378,  379,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  468,  388,  310,  390,   -1,  392,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  402,  403,
+  404,   -1,   -1,   -1,   -1,   -1,  410,  411,  412,  413,
+   -1,   -1,  256,   -1,   -1,  419,  420,   -1,   -1,   -1,
+  424,  425,  426,  427,  428,  429,  430,  431,  432,  433,
+  434,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  363,   -1,
+   -1,   -1,  367,  447,  369,  370,  371,  372,  373,  374,
+  375,  376,  377,  378,  379,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  388,  468,  390,  310,  392,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  402,  403,  404,
+   -1,   -1,   -1,   -1,   -1,  410,  411,  412,  413,   -1,
+   -1,  256,   -1,   -1,  419,  420,   -1,   -1,   -1,   -1,
+   -1,   -1,  427,  428,  429,  430,  431,  432,  433,  434,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  363,
+   -1,   -1,  447,  367,   -1,  369,  370,  371,  372,  373,
+  374,  375,  376,  377,  378,  379,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  468,  388,  310,  390,   -1,  392,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  402,  403,
+  404,   -1,   -1,   -1,   -1,   -1,  410,  411,  412,  413,
+   -1,   -1,  256,   -1,   -1,  419,  420,   -1,   -1,   -1,
+   -1,   -1,   -1,  427,  428,  429,  430,  431,  432,  433,
+  434,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  363,   -1,
+   -1,   -1,  367,  447,  369,  370,  371,  372,  373,  374,
+  375,  376,  377,  378,  379,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  388,  468,  390,  310,  392,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  402,  403,  404,
+   -1,   -1,   -1,   -1,   -1,  410,  411,  412,  413,   -1,
+   -1,  256,   -1,   -1,  419,  420,   -1,   -1,   -1,   -1,
+   -1,   -1,  427,  428,  429,  430,  431,  432,  433,  434,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  363,
+   -1,   -1,  447,  367,   -1,  369,  370,  371,  372,  373,
+  374,  375,  376,  377,  378,  379,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  468,  388,  310,  390,   -1,  392,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  402,  403,
+  404,   -1,   -1,   -1,   -1,   -1,  410,  411,  412,  413,
+   -1,   -1,  256,   -1,   -1,  419,  420,   -1,   -1,   -1,
+   -1,   -1,   -1,  427,  428,  429,  430,  431,  432,  433,
+  434,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  363,   -1,
+   -1,   -1,  367,  447,  369,  370,  371,  372,  373,  374,
+  375,  376,  377,  378,  379,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  388,  468,  390,  310,  392,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  402,  403,  404,
+   -1,   -1,   -1,   -1,   -1,  410,  411,  412,  413,   -1,
+   -1,  256,   -1,   -1,  419,  420,   -1,   -1,   -1,   -1,
+   -1,   -1,  427,  428,  429,  430,  431,  432,  433,  434,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  363,
+   -1,   -1,  447,  367,   -1,  369,  370,  371,  372,  373,
+  374,  375,  376,  377,  378,  379,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  468,  388,  310,  390,   -1,  392,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  402,  403,
+  404,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  412,  413,
+   -1,   -1,  256,   -1,   -1,  419,  420,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  429,  430,  431,  432,  433,
+  434,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  363,   -1,
+   -1,   -1,  367,  447,  369,  370,  371,  372,  373,  374,
+  375,  376,  377,  378,  379,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  388,  468,  390,  310,  392,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  402,  403,  404,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  412,  413,   -1,
+   -1,  256,   -1,   -1,  419,  420,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  429,  430,  431,  432,  433,  434,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  363,
+   -1,   -1,  447,  367,   -1,  369,  370,  371,  372,  373,
+  374,  375,  376,  377,  378,  379,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  468,  388,  310,  390,   -1,  392,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  402,  403,
+  404,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  412,  413,
+   -1,   -1,  256,   -1,   -1,  419,  420,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  429,  430,  431,  432,  433,
+  434,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  363,   -1,
+   -1,   -1,  367,  447,  369,  370,  371,  372,  373,  374,
+  375,  376,  377,  378,  379,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  388,  468,  390,  310,  392,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  402,  403,  404,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  412,  413,   -1,
+   -1,  256,   -1,   -1,  419,  420,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  429,  430,  431,  432,  433,  434,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  363,
+   -1,   -1,  447,  367,   -1,  369,  370,  371,  372,  373,
+  374,  375,  376,  377,  378,  379,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  468,  388,  310,  390,   -1,  392,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  402,  403,
+  404,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  412,  413,
+   -1,   -1,  256,   -1,   -1,  419,  420,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  429,  430,  431,  432,  433,
+  434,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  363,   -1,
+   -1,   -1,  367,  447,  369,  370,  371,  372,  373,  374,
+  375,  376,  377,  378,  379,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  388,  468,  390,  310,  392,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  402,  403,  404,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  412,  413,   -1,
+   -1,  256,   -1,   -1,  419,  420,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  433,  434,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  363,
+   -1,   -1,  447,  367,   -1,  369,  370,  371,  372,  373,
+  374,  375,  376,  377,  378,  379,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  468,  388,  310,  390,   -1,  392,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  402,  403,
+  404,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  412,  413,
+   -1,   -1,  256,   -1,   -1,  419,  420,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  433,
+  434,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  363,   -1,
+   -1,   -1,  367,  447,  369,  370,  371,  372,  373,  374,
+  375,  376,  377,  378,  379,   -1,  256,   -1,   -1,   -1,
+   -1,   -1,   -1,  388,  468,  390,  310,  392,  268,   -1,
+   -1,  271,   -1,   -1,   -1,   -1,  276,  402,  403,  404,
+   -1,  281,   -1,   -1,   -1,   -1,   -1,   -1,  413,   -1,
+   -1,  256,   -1,   -1,  419,  420,  296,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  433,  434,
+   -1,   -1,   -1,  313,   -1,   -1,   -1,   -1,  318,  363,
+   -1,   -1,  447,  367,   -1,  369,  370,  371,  372,  373,
+  374,  375,  376,  377,  378,  379,   -1,   -1,  338,  339,
+   -1,   -1,   -1,  468,  388,  310,  390,   -1,  392,   -1,
+   -1,  351,  352,   -1,   -1,   -1,   -1,  357,  402,  403,
+  404,  361,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  413,
+   -1,   -1,  256,   -1,   -1,  419,  420,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  433,
+  434,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  363,   -1,
+   -1,   -1,  367,  447,  369,  370,  371,  372,  373,  374,
+  375,  376,  377,  378,  379,   -1,  416,   -1,   -1,   -1,
+   -1,   -1,   -1,  388,  468,  390,  310,  392,  268,   -1,
+   -1,  271,   -1,   -1,   -1,   -1,  276,  402,  403,  404,
+   -1,  281,   -1,   -1,   -1,   -1,   -1,   -1,  413,   -1,
+  290,  256,   -1,   -1,  454,  420,  296,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  307,  433,  434,
+   -1,   -1,   -1,  313,   -1,   -1,   -1,   -1,  318,  363,
+   -1,   -1,  447,  367,  324,  369,  370,  371,  372,  373,
+  374,  375,  376,  377,  378,  379,   -1,   -1,  338,  339,
+   -1,   -1,   -1,  468,  388,  310,  390,   -1,  392,   -1,
+   -1,  351,  352,   -1,   -1,   -1,   -1,  357,  402,  403,
+  404,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  413,
+   -1,   -1,  256,   -1,   -1,   -1,  420,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  433,
+  434,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  363,   -1,
+   -1,   -1,  367,  447,  369,  370,  371,  372,  373,  374,
+  375,  376,  377,  378,  379,   -1,  256,   -1,   -1,   -1,
+   -1,   -1,   -1,  388,  468,  390,  310,  392,  268,   -1,
+   -1,  271,   -1,   -1,   -1,   -1,  276,  402,  403,  404,
+   -1,  281,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  256,   -1,   -1,  454,  420,  296,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  433,  434,
+   -1,   -1,   -1,  313,   -1,   -1,   -1,   -1,  318,  363,
+   -1,   -1,  447,  367,   -1,  369,  370,  371,  372,  373,
+  374,  375,  376,  377,  378,  379,   -1,   -1,  338,  339,
+   -1,   -1,   -1,  468,  388,  310,  390,   -1,  392,   -1,
+   -1,  351,  352,   -1,   -1,   -1,   -1,  357,  402,  403,
+  404,  361,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  256,   -1,   -1,   -1,  420,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  433,
+  434,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  363,   -1,
+   -1,   -1,  367,  447,  369,  370,  371,  372,  373,  374,
+  375,  376,  377,  378,  379,   -1,  416,   -1,   -1,   -1,
+   -1,   -1,   -1,  388,  468,  390,  310,  392,  268,   -1,
+   -1,  271,   -1,   -1,   -1,   -1,  276,  402,  403,  404,
+   -1,  281,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  256,   -1,   -1,  454,  420,  296,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  434,
+   -1,   -1,   -1,  313,   -1,   -1,   -1,   -1,  318,  363,
+   -1,   -1,  447,  367,   -1,  369,  370,  371,  372,  373,
+  374,  375,  376,  377,  378,  379,   -1,   -1,  338,  339,
+   -1,   -1,   -1,  468,  388,  310,  390,   -1,  392,   -1,
+   -1,  351,  352,   -1,   -1,   -1,   -1,  357,  402,  403,
+  404,  361,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  420,   -1,   -1,   -1,
+   -1,   -1,   -1,  383,   -1,   -1,   -1,   -1,   -1,   -1,
+  434,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  363,   -1,
+   -1,   -1,  367,  447,  369,  370,  371,  372,  373,  374,
+  375,  376,  377,  378,   -1,   -1,  416,   -1,   -1,   -1,
+   -1,   -1,   -1,  388,  468,  390,   -1,  392,   -1,   -1,
+   -1,   -1,  256,   -1,   -1,   -1,   -1,  402,  403,  404,
+  264,   -1,   -1,  267,  268,   -1,   -1,  271,  272,   -1,
+  274,  275,  276,  277,  454,  279,  280,  281,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  292,   -1,
+   -1,  295,  296,   -1,   -1,   -1,  300,  301,  302,   -1,
+   -1,  305,  306,   -1,   -1,   -1,   -1,   -1,   -1,  313,
+   -1,   -1,   -1,  317,  318,   -1,   -1,  321,  322,   -1,
+   -1,   -1,   -1,  468,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  336,   -1,  338,  339,  340,   -1,   -1,   -1,
+   -1,  345,  346,  347,  348,  349,  350,  351,  352,  353,
+  354,  355,  356,  357,  358,  359,   -1,   -1,   -1,   -1,
+  364,   -1,   -1,  367,  368,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  382,  383,
+   -1,   -1,   -1,  387,   -1,  389,   -1,  391,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  404,  405,  406,  407,  408,   -1,   -1,   -1,  412,   -1,
+   -1,   -1,   -1,   -1,   -1,  256,   -1,   -1,  422,  423,
+   -1,   -1,   -1,  264,   -1,   -1,  267,  268,   -1,   -1,
+  271,  272,   -1,  274,  275,  276,  277,   -1,  279,  280,
+  281,   -1,   -1,   -1,   -1,  449,   -1,   -1,   -1,  453,
+  454,  292,   -1,  457,  295,  296,   -1,  461,  462,  300,
+  301,  302,   -1,   -1,  305,  306,   -1,   -1,   -1,   -1,
+   -1,   -1,  313,   -1,   -1,   -1,  317,  318,   -1,   -1,
+  321,  322,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  336,   -1,  338,  339,  340,
+   -1,   -1,   -1,   -1,  345,  346,  347,  348,  349,  350,
+  351,  352,  353,  354,  355,  356,  357,  358,  359,   -1,
+   -1,   -1,   -1,  364,   -1,   -1,  367,  368,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  382,  383,   -1,   -1,   -1,  387,   -1,  389,   -1,
+  391,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  404,  405,  406,  407,  408,   -1,   -1,
+   -1,  412,   -1,   -1,   -1,   -1,   -1,   -1,  256,   -1,
+   -1,  422,  423,   -1,   -1,   -1,  264,   -1,   -1,  267,
+  268,   -1,   -1,  271,  272,   -1,  274,  275,  276,  277,
+   -1,  279,  280,  281,   -1,   -1,   -1,   -1,  449,   -1,
+   -1,   -1,  453,  454,  292,   -1,  457,  295,  296,   -1,
+  461,  462,  300,  301,  302,   -1,   -1,  305,  306,   -1,
+   -1,   -1,   -1,   -1,   -1,  313,   -1,   -1,   -1,  317,
+  318,   -1,   -1,  321,  322,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  336,   -1,
+  338,  339,  340,   -1,   -1,   -1,   -1,  345,  346,  347,
+  348,  349,  350,  351,  352,  353,  354,  355,  356,  357,
+  358,  359,   -1,   -1,   -1,   -1,  364,   -1,   -1,  367,
+  368,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  382,  383,   -1,   -1,   -1,   -1,
+   -1,  389,   -1,  391,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  404,  405,  406,  407,
+  408,   -1,   -1,   -1,  412,   -1,   -1,   -1,   -1,   -1,
+   -1,  256,   -1,   -1,  422,  423,   -1,   -1,   -1,  264,
+   -1,   -1,  267,  268,   -1,   -1,  271,  272,   -1,  274,
+  275,  276,  277,   -1,  279,  280,  281,   -1,   -1,   -1,
+   -1,  449,   -1,   -1,   -1,  453,  454,  292,   -1,  457,
+  295,  296,   -1,  461,  462,  300,  301,  302,   -1,   -1,
+  305,  306,   -1,   -1,   -1,   -1,   -1,   -1,  313,   -1,
+   -1,   -1,  317,  318,   -1,   -1,  321,  322,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  336,   -1,  338,  339,  340,   -1,   -1,   -1,   -1,
+  345,  346,  347,  348,  349,  350,  351,  352,  353,  354,
+  355,  356,  357,  358,  359,   -1,   -1,   -1,   -1,  364,
+   -1,   -1,  367,  368,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  382,  383,   -1,
+   -1,   -1,   -1,   -1,  389,   -1,  391,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  404,
+  405,  406,  407,  408,   -1,   -1,   -1,  412,   -1,   -1,
+   -1,   -1,   -1,   -1,  256,   -1,   -1,  422,  423,   -1,
+   -1,   -1,  264,   -1,   -1,  267,  268,   -1,   -1,  271,
+  272,   -1,  274,  275,  276,  277,   -1,  279,  280,  281,
+   -1,   -1,   -1,   -1,  449,   -1,   -1,   -1,  453,  454,
+  292,   -1,  457,  295,  296,   -1,  461,  462,  300,  301,
+  302,   -1,   -1,  305,  306,   -1,   -1,   -1,   -1,   -1,
+   -1,  313,   -1,   -1,   -1,  317,  318,   -1,   -1,  321,
+  322,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  336,   -1,  338,  339,  340,   -1,
+   -1,   -1,   -1,  345,  346,  347,  348,  349,  350,  351,
+  352,  353,  354,  355,  356,  357,  358,  359,  262,   -1,
+   -1,   -1,  364,  267,   -1,  367,  368,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  261,   -1,  263,
+  382,  383,   -1,   -1,   -1,   -1,   -1,  389,   -1,  391,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  285,  404,  405,  406,  407,  408,   -1,   -1,  293,
+  412,   -1,  316,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  422,  423,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  315,  336,   -1,   -1,   -1,  320,  321,   -1,   -1,
+   -1,   -1,  326,   -1,   -1,   -1,  330,  449,  332,  333,
+  334,  453,  454,   -1,   -1,  457,   -1,   -1,  342,  461,
+  462,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  355,   -1,   -1,   -1,   -1,  360,   -1,  362,   -1,
+   -1,   -1,   -1,   -1,  388,   -1,   -1,  391,   -1,  393,
+  394,  395,  396,   -1,  398,   -1,   -1,   -1,  382,  403,
+  404,   -1,  406,  407,  388,  409,  410,  411,  412,  413,
+  414,  415,  416,  417,  418,  419,  420,   -1,  422,  423,
+  424,  425,  426,  427,  428,  429,  430,  431,  432,  433,
+  434,  435,  436,  437,  438,  439,  440,  441,  442,  443,
+  444,  445,   -1,  447,  448,   -1,   -1,  256,   -1,   -1,
+   -1,   -1,   -1,   -1,  458,  264,   -1,  461,   -1,  268,
+   -1,   -1,  271,  272,  468,   -1,   -1,  276,  277,   -1,
+  279,  455,  281,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  268,  292,   -1,  271,   -1,  296,   -1,   -1,
+  276,   -1,   -1,  302,   -1,  281,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  313,   -1,   -1,   -1,   -1,  318,
+  296,   -1,  321,  322,   -1,   -1,  325,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  335,  313,   -1,  338,
+  339,  340,  318,   -1,   -1,   -1,   -1,  346,   -1,  348,
+   -1,  350,  351,  352,  353,  354,   -1,   -1,  357,   -1,
+   -1,   -1,  338,  339,   -1,   -1,   -1,   -1,  367,  368,
+   -1,   -1,   -1,   -1,   -1,  351,  352,   -1,   -1,   -1,
+   -1,  357,   -1,  382,  383,   -1,   -1,   -1,   -1,   -1,
+  389,   -1,  391,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  405,  406,  407,  408,
+   -1,   -1,   -1,  412,   -1,  391,   -1,   -1,   -1,   -1,
+  256,   -1,   -1,  422,  423,   -1,   -1,   -1,  264,   -1,
+   -1,   -1,  268,   -1,  410,  271,  272,   -1,   -1,   -1,
+  276,  277,   -1,  279,   -1,  281,   -1,   -1,   -1,   -1,
+  449,   -1,   -1,   -1,  453,  454,  292,   -1,  457,   -1,
+  296,   -1,  461,  462,   -1,   -1,  302,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  313,  454,   -1,
+   -1,   -1,  318,   -1,   -1,  321,  322,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  338,  339,  340,   -1,   -1,   -1,   -1,   -1,
+  346,   -1,  348,   -1,  350,  351,  352,  353,  354,   -1,
+   -1,  357,   -1,  359,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  367,  368,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  382,  383,   -1,   -1,
+   -1,  273,  274,  389,   -1,  391,  278,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  288,  289,  290,  405,
+  406,  407,  408,  295,   -1,   -1,  412,   -1,   -1,   -1,
+  302,  303,  304,  256,   -1,  307,  422,  423,   -1,  311,
+   -1,  264,  314,   -1,   -1,  268,   -1,  319,  271,  272,
+   -1,   -1,  324,  276,  277,   -1,  279,   -1,  281,  331,
+   -1,   -1,   -1,  449,   -1,   -1,   -1,  453,  454,  292,
+   -1,  457,  344,  296,   -1,  461,  462,   -1,   -1,  302,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  359,   -1,   -1,
+  313,   -1,   -1,  365,   -1,  318,   -1,   -1,  321,  322,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  338,  339,  340,   -1,   -1,
+   -1,   -1,   -1,  346,   -1,  348,   -1,  350,  351,  352,
+  353,  354,   -1,   -1,  357,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  367,  368,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  382,
+  383,   -1,   -1,   -1,   -1,   -1,  389,   -1,  391,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  405,  406,  407,  408,   -1,   -1,   -1,  412,
+   -1,   -1,   -1,   -1,   -1,   -1,  256,   -1,   -1,  422,
+  423,   -1,   -1,   -1,  264,   -1,   -1,   -1,  268,   -1,
+   -1,  271,  272,   -1,   -1,   -1,  276,  277,   -1,  279,
+   -1,  281,   -1,   -1,   -1,   -1,  449,   -1,   -1,   -1,
+  453,  454,  292,   -1,  457,   -1,  296,   -1,  461,  462,
+   -1,   -1,  302,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  313,   -1,   -1,   -1,   -1,  318,   -1,
+   -1,  321,  322,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  338,  339,
+  340,   -1,   -1,   -1,   -1,   -1,  346,   -1,  348,   -1,
+  350,  351,  352,  353,  354,   -1,   -1,  357,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  367,  368,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  382,  383,   -1,   -1,   -1,   -1,   -1,  389,
+   -1,  391,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  405,  406,  407,  408,   -1,
+   -1,   -1,  412,   -1,   -1,   -1,   -1,   -1,   -1,  256,
+   -1,   -1,  422,  423,   -1,   -1,   -1,  264,   -1,   -1,
+   -1,  268,   -1,   -1,  271,  272,   -1,   -1,   -1,  276,
+  277,   -1,  279,   -1,  281,   -1,   -1,   -1,   -1,  449,
+   -1,   -1,   -1,  453,  454,  292,   -1,  457,   -1,  296,
+   -1,  461,  462,   -1,   -1,  302,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  313,   -1,   -1,   -1,
+   -1,  318,   -1,   -1,  321,  322,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  338,  339,  340,   -1,   -1,   -1,   -1,   -1,  346,
+   -1,  348,   -1,  350,  351,  352,  353,  354,   -1,   -1,
+  357,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  367,  368,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  382,  383,   -1,   -1,   -1,
+   -1,   -1,  389,   -1,  391,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  405,  406,
+  407,  408,   -1,   -1,   -1,  412,   -1,   -1,   -1,   -1,
+   -1,   -1,  256,   -1,   -1,  422,  423,   -1,   -1,   -1,
+  264,   -1,   -1,   -1,  268,   -1,   -1,  271,  272,   -1,
+   -1,   -1,  276,  277,   -1,  279,   -1,  281,   -1,   -1,
+   -1,   -1,  449,   -1,   -1,   -1,  453,  454,  292,   -1,
+  457,   -1,  296,   -1,  461,  462,   -1,   -1,  302,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  313,
+   -1,   -1,   -1,   -1,  318,   -1,   -1,  321,  322,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  338,  339,  340,   -1,   -1,   -1,
+   -1,   -1,  346,   -1,  348,   -1,  350,  351,  352,  353,
+  354,   -1,   -1,  357,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  367,  368,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  382,  383,
+   -1,   -1,   -1,   -1,   -1,  389,   -1,  391,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  405,  406,  407,  408,   -1,   -1,   -1,  412,   -1,
+   -1,   -1,   -1,   -1,   -1,  256,   -1,   -1,  422,  423,
+   -1,   -1,   -1,  264,   -1,   -1,   -1,  268,   -1,   -1,
+  271,  272,   -1,   -1,   -1,  276,  277,   -1,  279,   -1,
+  281,   -1,   -1,   -1,   -1,  449,   -1,   -1,   -1,  453,
+  454,  292,   -1,  457,   -1,  296,   -1,  461,  462,   -1,
+   -1,  302,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  313,   -1,   -1,   -1,   -1,  318,   -1,   -1,
+  321,  322,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  338,  339,  340,
+   -1,   -1,   -1,   -1,   -1,  346,   -1,  348,   -1,  350,
+  351,  352,  353,  354,   -1,   -1,  357,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  367,  368,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  382,  383,   -1,   -1,   -1,   -1,   -1,  389,   -1,
+  391,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  405,  406,  407,  408,   -1,   -1,
+   -1,  412,   -1,   -1,   -1,   -1,   -1,   -1,  256,   -1,
+   -1,  422,  423,   -1,   -1,   -1,  264,   -1,   -1,   -1,
+  268,   -1,   -1,  271,  272,   -1,   -1,   -1,  276,  277,
+   -1,  279,   -1,  281,   -1,   -1,   -1,   -1,  449,   -1,
+   -1,   -1,  453,  454,  292,   -1,  457,   -1,  296,   -1,
+  461,  462,   -1,   -1,  302,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  313,   -1,   -1,   -1,   -1,
+  318,   -1,   -1,  321,  322,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  338,  339,  340,   -1,   -1,   -1,   -1,   -1,  346,   -1,
+  348,   -1,  350,  351,  352,  353,  354,   -1,   -1,  357,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  367,
+  368,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  382,  383,   -1,   -1,   -1,   -1,
+   -1,  389,   -1,  391,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  405,  406,  407,
+  408,   -1,   -1,   -1,  412,   -1,   -1,   -1,   -1,   -1,
+   -1,  256,   -1,   -1,  422,  423,   -1,   -1,   -1,  264,
+   -1,   -1,   -1,  268,   -1,   -1,  271,  272,   -1,   -1,
+   -1,  276,  277,   -1,  279,   -1,  281,   -1,   -1,   -1,
+   -1,  449,   -1,   -1,   -1,  453,  454,  292,   -1,  457,
+   -1,  296,   -1,  461,  462,   -1,   -1,  302,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  313,   -1,
+   -1,   -1,   -1,  318,   -1,   -1,  321,  322,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  338,  339,  340,   -1,   -1,   -1,   -1,
+   -1,  346,   -1,  348,   -1,  350,  351,  352,  353,  354,
+   -1,   -1,  357,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  367,  368,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  382,  383,   -1,
+   -1,   -1,   -1,   -1,  389,   -1,  391,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  405,  406,  407,  408,   -1,   -1,   -1,  412,   -1,   -1,
+   -1,   -1,   -1,   -1,  256,   -1,   -1,  422,  423,   -1,
+   -1,   -1,  264,   -1,   -1,   -1,  268,   -1,   -1,  271,
+  272,   -1,   -1,   -1,  276,  277,   -1,  279,   -1,  281,
+   -1,   -1,   -1,  256,  449,   -1,   -1,   -1,  453,  454,
+  292,   -1,  457,   -1,  296,  268,  461,  462,  271,   -1,
+  302,   -1,   -1,  276,   -1,   -1,   -1,   -1,  281,   -1,
+   -1,  313,   -1,   -1,   -1,   -1,  318,   -1,   -1,  321,
+  322,   -1,   -1,  296,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  338,  339,  340,   -1,
+  313,   -1,   -1,   -1,  346,  318,  348,   -1,  350,  351,
+  352,  353,  354,   -1,   -1,  357,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  366,  338,  339,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  351,  352,
+  382,  383,   -1,   -1,  357,   -1,   -1,  389,  361,  391,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  405,  406,  407,  408,   -1,   -1,   -1,
+  412,   -1,   -1,   -1,   -1,   -1,   -1,  256,   -1,   -1,
+  422,  423,   -1,   -1,   -1,  264,   -1,   -1,   -1,  268,
+   -1,   -1,  271,  272,   -1,   -1,   -1,  276,  277,   -1,
+  279,   -1,  281,  416,   -1,   -1,  256,  449,   -1,   -1,
+   -1,  453,  454,  292,   -1,   -1,   -1,  296,  268,  461,
+  462,  271,   -1,  302,   -1,   -1,  276,   -1,   -1,   -1,
+   -1,  281,   -1,   -1,  313,   -1,   -1,   -1,   -1,  318,
+   -1,  454,  321,  322,   -1,   -1,  296,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  338,
+  339,  340,   -1,  313,   -1,   -1,   -1,  346,  318,  348,
+   -1,  350,  351,  352,  353,  354,   -1,   -1,  357,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  338,  339,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  351,  352,  382,  383,   -1,   -1,  357,   -1,   -1,
+  389,  361,  391,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  405,  406,  407,  408,
+   -1,   -1,   -1,  412,   -1,   -1,   -1,   -1,   -1,   -1,
+  256,   -1,   -1,  422,  423,   -1,   -1,   -1,  264,   -1,
+   -1,   -1,  268,   -1,   -1,  271,  272,   -1,   -1,   -1,
+  276,  277,   -1,  279,   -1,  281,  416,   -1,   -1,  256,
+  449,   -1,   -1,   -1,  453,  454,  292,   -1,   -1,   -1,
+  296,  268,  461,  462,  271,   -1,  302,   -1,   -1,  276,
+   -1,   -1,   -1,   -1,  281,   -1,   -1,  313,   -1,   -1,
+   -1,   -1,  318,   -1,  454,  321,  322,   -1,   -1,  296,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  338,  339,  340,   -1,  313,   -1,   -1,   -1,
+  346,  318,  348,   -1,  350,  351,  352,  353,  354,   -1,
+   -1,  357,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  338,  339,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  351,  352,  382,  383,   -1,   -1,
+  357,   -1,   -1,  389,  361,  391,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  405,
+  406,  407,  408,   -1,   -1,   -1,  412,   -1,   -1,   -1,
+   -1,   -1,   -1,  256,   -1,   -1,  422,  423,   -1,   -1,
+   -1,  264,   -1,   -1,   -1,  268,   -1,   -1,  271,  272,
+   -1,   -1,   -1,  276,  277,   -1,  279,   -1,  281,  416,
+   -1,   -1,  256,  449,   -1,   -1,   -1,  453,  454,  292,
+   -1,   -1,   -1,  296,  268,  461,  462,  271,   -1,  302,
+   -1,   -1,  276,   -1,   -1,   -1,   -1,  281,   -1,   -1,
+  313,   -1,   -1,   -1,   -1,  318,   -1,  454,  321,  322,
+   -1,   -1,  296,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  338,  339,  340,   -1,  313,
+   -1,   -1,   -1,  346,  318,  348,   -1,  350,  351,  352,
+  353,  354,   -1,   -1,  357,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  338,  339,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  351,  352,  382,
+  383,   -1,   -1,  357,   -1,   -1,  389,  361,  391,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  405,  406,  407,  408,   -1,   -1,   -1,  412,
+   -1,   -1,   -1,   -1,   -1,   -1,  256,   -1,   -1,  422,
+  423,   -1,   -1,   -1,  264,   -1,   -1,   -1,  268,   -1,
+   -1,  271,  272,   -1,   -1,   -1,  276,  277,   -1,  279,
+   -1,  281,  416,   -1,   -1,   -1,  449,   -1,   -1,   -1,
+  453,  454,  292,   -1,   -1,   -1,  296,  268,  461,  462,
+  271,   -1,  302,   -1,   -1,  276,   -1,   -1,   -1,   -1,
+  281,   -1,   -1,  313,   -1,   -1,   -1,   -1,  318,   -1,
+  454,  321,  322,   -1,   -1,  296,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  338,  339,
+  340,   -1,  313,   -1,   -1,   -1,  346,  318,  348,   -1,
+  350,  351,  352,  353,  354,   -1,   -1,  357,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  338,  339,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  351,  352,  382,  383,   -1,   -1,  357,   -1,   -1,  389,
+  361,  391,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  405,  406,  407,  408,   -1,
+   -1,   -1,  412,   -1,   -1,   -1,   -1,   -1,   -1,  256,
+   -1,  392,  422,  423,   -1,   -1,   -1,  264,   -1,   -1,
+   -1,  268,   -1,   -1,  271,  272,   -1,   -1,   -1,  276,
+  277,   -1,  279,   -1,  281,  416,   -1,   -1,   -1,  449,
+   -1,   -1,   -1,  453,  454,  292,   -1,   -1,   -1,  296,
+  268,  461,  462,  271,   -1,  302,   -1,   -1,  276,   -1,
+   -1,   -1,   -1,  281,   -1,   -1,  313,   -1,   -1,   -1,
+   -1,  318,   -1,  454,  321,  322,   -1,   -1,  296,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  338,  339,  340,   -1,  313,   -1,   -1,   -1,  346,
+  318,  348,   -1,  350,  351,  352,  353,  354,   -1,   -1,
+  357,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  338,  339,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  351,  352,  382,  383,   -1,   -1,  357,
+   -1,   -1,  389,  361,  391,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  405,  406,
+  407,  408,   -1,   -1,   -1,  412,   -1,   -1,   -1,   -1,
+   -1,   -1,  256,   -1,   -1,  422,  423,   -1,   -1,   -1,
+  264,   -1,   -1,   -1,  268,   -1,   -1,  271,  272,   -1,
+   -1,   -1,  276,  277,   -1,  279,   -1,  281,  416,   -1,
+   -1,   -1,  449,   -1,   -1,   -1,  453,  454,  292,   -1,
+   -1,   -1,  296,  268,  461,  462,  271,   -1,  302,   -1,
+   -1,  276,   -1,   -1,   -1,   -1,  281,   -1,   -1,  313,
+   -1,   -1,   -1,   -1,  318,   -1,  454,  321,  322,   -1,
+   -1,  296,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  338,  339,  340,   -1,  313,   -1,
+   -1,   -1,  346,  318,  348,   -1,  350,  351,  352,  353,
+  354,   -1,   -1,  357,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  338,  339,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  351,  352,  382,  383,
+   -1,   -1,  357,   -1,   -1,  389,  361,  391,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  405,  406,  407,  408,   -1,   -1,   -1,  412,   -1,
+   -1,   -1,   -1,   -1,   -1,  256,   -1,   -1,  422,  423,
+   -1,   -1,   -1,  264,   -1,   -1,   -1,  268,   -1,   -1,
+  271,  272,   -1,   -1,   -1,  276,  277,   -1,  279,   -1,
+  281,  416,   -1,   -1,   -1,  449,   -1,   -1,   -1,  453,
+  454,  292,   -1,   -1,   -1,  296,  268,  461,  462,  271,
+   -1,  302,   -1,   -1,  276,   -1,   -1,   -1,   -1,  281,
+   -1,   -1,  313,   -1,   -1,   -1,   -1,  318,   -1,  454,
+  321,  322,   -1,   -1,  296,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  338,  339,  340,
+   -1,  313,   -1,   -1,   -1,  346,  318,  348,   -1,  350,
+  351,  352,  353,  354,   -1,   -1,  357,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  338,  339,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  351,
+  352,  382,  383,   -1,   -1,  357,   -1,   -1,  389,  361,
+  391,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  405,  406,  407,  408,   -1,   -1,
+   -1,  412,   -1,   -1,   -1,   -1,   -1,   -1,  256,   -1,
+   -1,  422,  423,   -1,   -1,   -1,  264,   -1,   -1,   -1,
+  268,   -1,   -1,  271,  272,   -1,   -1,   -1,  276,  277,
+   -1,  279,   -1,  281,  416,   -1,   -1,   -1,  449,   -1,
+   -1,   -1,  453,  454,  292,   -1,   -1,   -1,  296,  268,
+  461,  462,  271,   -1,  302,   -1,   -1,  276,   -1,   -1,
+   -1,   -1,  281,   -1,   -1,  313,   -1,   -1,   -1,   -1,
+  318,   -1,  454,  321,  322,   -1,   -1,  296,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  338,  339,  340,   -1,  313,   -1,   -1,   -1,  346,  318,
+  348,   -1,  350,  351,  352,  353,  354,   -1,   -1,  357,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  338,
+  339,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  351,  352,  382,  383,   -1,   -1,  357,   -1,
+   -1,  389,  361,  391,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  405,  406,  407,
+  408,   -1,   -1,   -1,  412,   -1,   -1,   -1,   -1,   -1,
+   -1,  256,   -1,   -1,  422,  423,   -1,   -1,   -1,  264,
+   -1,   -1,   -1,  268,   -1,   -1,  271,  272,   -1,   -1,
+   -1,  276,  277,   -1,  279,   -1,  281,  416,   -1,   -1,
+   -1,  449,   -1,   -1,   -1,  453,  454,  292,   -1,   -1,
+   -1,  296,  268,  461,  462,  271,   -1,  302,   -1,   -1,
+  276,   -1,   -1,   -1,   -1,  281,   -1,   -1,  313,   -1,
+   -1,   -1,   -1,  318,   -1,  454,  321,  322,   -1,   -1,
+  296,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  338,  339,  340,   -1,  313,   -1,   -1,
+   -1,  346,  318,  348,   -1,  350,  351,  352,  353,  354,
+   -1,   -1,  357,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  338,  339,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  351,  352,  382,  383,   -1,
+   -1,  357,   -1,   -1,  389,  361,  391,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  405,  406,  407,  408,   -1,   -1,   -1,  412,   -1,   -1,
+   -1,   -1,   -1,   -1,  256,   -1,   -1,  422,  423,   -1,
+   -1,   -1,  264,   -1,   -1,   -1,  268,   -1,   -1,  271,
+  272,   -1,   -1,   -1,  276,  277,   -1,  279,   -1,  281,
+  416,   -1,   -1,   -1,  449,   -1,   -1,   -1,  453,  454,
+  292,   -1,   -1,   -1,  296,  268,  461,  462,  271,   -1,
+  302,   -1,   -1,  276,   -1,   -1,   -1,   -1,  281,   -1,
+   -1,  313,   -1,   -1,   -1,   -1,  318,   -1,  454,  321,
+  322,   -1,   -1,  296,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  338,  339,  340,   -1,
+  313,   -1,   -1,   -1,  346,  318,  348,   -1,  350,  351,
+  352,  353,  354,   -1,   -1,  357,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  338,  339,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  351,  352,
+  382,  383,   -1,   -1,  357,   -1,   -1,  389,  361,  391,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  405,  406,  407,  408,   -1,   -1,   -1,
+  412,   -1,   -1,   -1,   -1,   -1,   -1,  256,   -1,   -1,
+  422,  423,   -1,   -1,   -1,  264,   -1,   -1,   -1,  268,
+   -1,   -1,  271,  272,   -1,   -1,   -1,  276,  277,   -1,
+  279,   -1,  281,  416,   -1,   -1,   -1,  449,   -1,   -1,
+   -1,  453,  454,  292,   -1,   -1,   -1,  296,  268,  461,
+  462,  271,   -1,  302,   -1,   -1,  276,   -1,   -1,   -1,
+   -1,  281,   -1,   -1,  313,   -1,   -1,   -1,   -1,  318,
+   -1,  454,  321,  322,   -1,   -1,  296,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  338,
+  339,  340,   -1,  313,   -1,   -1,   -1,  346,  318,  348,
+   -1,  350,  351,  352,  353,  354,   -1,   -1,  357,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  338,  339,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  351,  352,  382,  383,   -1,   -1,  357,   -1,   -1,
+  389,  361,  391,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  405,  406,  407,  408,
+   -1,   -1,   -1,  412,   -1,   -1,   -1,   -1,   -1,   -1,
+  256,   -1,   -1,  422,  423,   -1,   -1,   -1,  264,   -1,
+   -1,   -1,  268,   -1,   -1,  271,  272,   -1,   -1,   -1,
+  276,  277,   -1,  279,   -1,  281,  416,   -1,   -1,   -1,
+  449,   -1,   -1,   -1,  453,  454,  292,   -1,   -1,   -1,
+  296,   -1,  461,  462,   -1,   -1,  302,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  313,   -1,   -1,
+   -1,   -1,  318,   -1,  454,  321,  322,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  338,  339,  340,   -1,   -1,   -1,   -1,   -1,
+  346,   -1,  348,   -1,  350,  351,  352,  353,  354,   -1,
+   -1,  357,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  382,  383,   -1,   -1,
+   -1,   -1,   -1,  389,   -1,  391,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  405,
+  406,  407,  408,   -1,   -1,   -1,  412,   -1,   -1,   -1,
+   -1,   -1,   -1,  256,   -1,   -1,  422,  423,   -1,   -1,
+   -1,  264,   -1,   -1,   -1,  268,   -1,   -1,  271,  272,
+   -1,   -1,   -1,  276,  277,   -1,  279,   -1,  281,   -1,
+   -1,   -1,   -1,  449,   -1,   -1,   -1,  453,  454,  292,
+   -1,   -1,   -1,  296,   -1,  461,  462,   -1,   -1,  302,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  313,   -1,   -1,   -1,   -1,  318,   -1,   -1,  321,  322,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  338,  339,  340,   -1,   -1,
+   -1,   -1,   -1,  346,   -1,  348,   -1,  350,  351,  352,
+  353,  354,   -1,   -1,  357,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  382,
+  383,   -1,   -1,   -1,   -1,   -1,  389,   -1,  391,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  405,  406,  407,  408,   -1,   -1,   -1,  412,
+   -1,   -1,   -1,   -1,   -1,   -1,  256,   -1,   -1,  422,
+  423,   -1,   -1,   -1,  264,   -1,   -1,   -1,  268,   -1,
+   -1,  271,  272,   -1,   -1,   -1,  276,  277,   -1,  279,
+   -1,  281,   -1,   -1,   -1,   -1,  449,   -1,   -1,   -1,
+  453,  454,  292,   -1,   -1,   -1,  296,   -1,  461,  462,
+   -1,   -1,  302,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  313,   -1,   -1,   -1,   -1,  318,   -1,
+   -1,  321,  322,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  338,  339,
+  340,   -1,   -1,   -1,   -1,   -1,  346,   -1,  348,   -1,
+  350,  351,  352,  353,  354,   -1,   -1,  357,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  382,  383,   -1,   -1,   -1,   -1,   -1,  389,
+   -1,  391,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  405,  406,  407,  408,   -1,
+   -1,   -1,  412,   -1,   -1,   -1,   -1,   -1,   -1,  256,
+   -1,   -1,  422,  423,   -1,   -1,   -1,  264,   -1,   -1,
+   -1,  268,   -1,   -1,  271,  272,   -1,   -1,   -1,  276,
+  277,   -1,  279,   -1,  281,   -1,   -1,   -1,   -1,  449,
+   -1,   -1,   -1,  453,  454,  292,   -1,   -1,   -1,  296,
+   -1,  461,  462,   -1,   -1,  302,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  313,   -1,   -1,   -1,
+   -1,  318,   -1,   -1,  321,  322,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  338,  339,  340,   -1,   -1,   -1,   -1,   -1,  346,
+   -1,  348,   -1,  350,  351,  352,  353,  354,   -1,   -1,
+  357,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  382,  383,   -1,   -1,   -1,
+   -1,   -1,  389,   -1,  391,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  405,  406,
+  407,  408,   -1,   -1,   -1,  412,   -1,   -1,   -1,   -1,
+   -1,   -1,  256,   -1,   -1,  422,  423,   -1,   -1,   -1,
+  264,   -1,   -1,   -1,  268,   -1,   -1,  271,  272,   -1,
+   -1,   -1,  276,  277,   -1,  279,   -1,  281,   -1,   -1,
+   -1,   -1,  449,   -1,   -1,   -1,  453,  454,  292,   -1,
+   -1,   -1,  296,   -1,  461,  462,   -1,   -1,  302,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  313,
+   -1,   -1,   -1,   -1,  318,   -1,   -1,  321,  322,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  338,  339,  340,   -1,   -1,   -1,
+   -1,   -1,  346,   -1,  348,   -1,  350,  351,  352,  353,
+  354,   -1,   -1,  357,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  382,  383,
+   -1,   -1,   -1,   -1,   -1,  389,   -1,  391,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  405,  406,  407,  408,   -1,   -1,   -1,  412,   -1,
+   -1,   -1,   -1,   -1,   -1,  256,   -1,   -1,  422,  423,
+   -1,   -1,   -1,  264,   -1,   -1,   -1,  268,   -1,   -1,
+  271,  272,   -1,   -1,   -1,  276,  277,   -1,  279,   -1,
+  281,   -1,   -1,   -1,   -1,  449,   -1,   -1,   -1,  453,
+  454,  292,   -1,   -1,   -1,  296,   -1,  461,  462,   -1,
+   -1,  302,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  313,   -1,   -1,   -1,   -1,  318,   -1,   -1,
+  321,  322,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  338,  339,  340,
+   -1,   -1,   -1,   -1,   -1,  346,   -1,  348,   -1,  350,
+  351,  352,  353,  354,   -1,   -1,  357,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  382,  383,   -1,   -1,   -1,   -1,   -1,  389,   -1,
+  391,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  405,  406,  407,  408,   -1,   -1,
+   -1,  412,   -1,   -1,   -1,   -1,   -1,   -1,  256,   -1,
+   -1,  422,  423,   -1,   -1,   -1,  264,   -1,   -1,   -1,
+  268,   -1,   -1,  271,  272,   -1,   -1,   -1,  276,  277,
+   -1,  279,   -1,  281,   -1,   -1,   -1,   -1,  449,   -1,
+   -1,   -1,  453,  454,  292,   -1,   -1,   -1,  296,   -1,
+  461,  462,   -1,   -1,  302,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  313,   -1,   -1,   -1,   -1,
+  318,   -1,   -1,  321,  322,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  338,  339,  340,   -1,   -1,   -1,   -1,   -1,  346,   -1,
+  348,   -1,  350,  351,  352,  353,  354,   -1,   -1,  357,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  382,  383,   -1,   -1,   -1,   -1,
+   -1,  389,   -1,  391,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  405,  406,  407,
+  408,   -1,   -1,   -1,  412,   -1,   -1,   -1,   -1,   -1,
+   -1,  256,   -1,   -1,  422,  423,   -1,   -1,   -1,  264,
+   -1,   -1,   -1,  268,   -1,   -1,  271,  272,   -1,   -1,
+   -1,  276,  277,   -1,  279,   -1,  281,   -1,   -1,   -1,
+   -1,  449,   -1,   -1,   -1,  453,  454,  292,   -1,   -1,
+   -1,  296,   -1,  461,  462,   -1,   -1,  302,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  313,   -1,
+   -1,   -1,   -1,  318,   -1,   -1,  321,  322,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  338,  339,  340,   -1,   -1,   -1,   -1,
+   -1,  346,   -1,  348,   -1,  350,  351,  352,  353,  354,
+   -1,   -1,  357,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  382,  383,   -1,
+   -1,   -1,   -1,   -1,  389,   -1,  391,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  405,  406,  407,  408,   -1,   -1,   -1,  412,   -1,   -1,
+   -1,   -1,   -1,   -1,  256,   -1,   -1,  422,  423,   -1,
+   -1,   -1,  264,   -1,   -1,   -1,  268,   -1,   -1,  271,
+  272,   -1,   -1,   -1,  276,  277,   -1,  279,   -1,  281,
+   -1,   -1,   -1,   -1,  449,   -1,   -1,   -1,  453,  454,
+  292,   -1,   -1,   -1,  296,   -1,  461,  462,   -1,   -1,
+  302,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  313,   -1,   -1,   -1,   -1,  318,   -1,   -1,  321,
+  322,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  338,  339,  340,   -1,
+   -1,   -1,   -1,   -1,  346,   -1,  348,   -1,  350,  351,
+  352,  353,  354,   -1,   -1,  357,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  382,  383,   -1,   -1,   -1,   -1,   -1,  389,   -1,  391,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  405,  406,  407,  408,   -1,   -1,   -1,
+  412,   -1,   -1,   -1,   -1,   -1,   -1,  256,   -1,   -1,
+  422,  423,   -1,   -1,   -1,  264,   -1,   -1,   -1,  268,
+   -1,   -1,  271,  272,   -1,   -1,   -1,  276,  277,   -1,
+  279,   -1,  281,   -1,   -1,   -1,   -1,  449,   -1,   -1,
+   -1,  453,  454,  292,   -1,   -1,   -1,  296,   -1,  461,
+  462,   -1,   -1,  302,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  313,   -1,   -1,   -1,   -1,  318,
+   -1,   -1,  321,  322,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  338,
+  339,  340,   -1,   -1,   -1,   -1,   -1,  346,   -1,  348,
+   -1,  350,  351,  352,  353,  354,   -1,   -1,  357,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  382,  383,   -1,   -1,   -1,   -1,   -1,
+  389,   -1,  391,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  405,  406,  407,  408,
+   -1,   -1,   -1,  412,   -1,   -1,   -1,   -1,   -1,   -1,
+  256,   -1,   -1,  422,  423,   -1,   -1,   -1,  264,   -1,
+   -1,   -1,  268,   -1,   -1,  271,  272,   -1,   -1,   -1,
+  276,  277,   -1,  279,   -1,  281,   -1,   -1,   -1,   -1,
+  449,   -1,   -1,   -1,  453,  454,  292,   -1,   -1,   -1,
+  296,   -1,  461,  462,   -1,   -1,  302,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  313,   -1,   -1,
+   -1,   -1,  318,   -1,   -1,  321,  322,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  338,  339,  340,   -1,   -1,   -1,   -1,   -1,
+  346,   -1,  348,   -1,  350,  351,  352,  353,  354,   -1,
+   -1,  357,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  382,  383,   -1,   -1,
+   -1,   -1,   -1,  389,   -1,  391,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  405,
+  406,  407,  408,   -1,   -1,   -1,  412,   -1,   -1,   -1,
+   -1,   -1,   -1,  256,   -1,   -1,  422,  423,   -1,   -1,
+   -1,  264,   -1,   -1,   -1,  268,   -1,   -1,  271,  272,
+   -1,   -1,   -1,  276,  277,   -1,  279,   -1,  281,   -1,
+   -1,   -1,   -1,  449,   -1,   -1,   -1,  453,  454,  292,
+   -1,   -1,   -1,  296,   -1,  461,  462,   -1,   -1,  302,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  313,   -1,   -1,   -1,   -1,  318,   -1,   -1,  321,  322,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  338,  339,  340,   -1,   -1,
+   -1,   -1,   -1,  346,   -1,  348,   -1,  350,  351,  352,
+  353,  354,   -1,   -1,  357,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  382,
+  383,   -1,   -1,   -1,   -1,   -1,  389,   -1,  391,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  405,  406,  407,  408,   -1,   -1,   -1,  412,
+   -1,   -1,   -1,   -1,   -1,   -1,  256,   -1,   -1,  422,
+  423,   -1,   -1,   -1,  264,   -1,   -1,   -1,  268,   -1,
+   -1,  271,  272,   -1,   -1,   -1,  276,  277,   -1,  279,
+   -1,  281,   -1,   -1,   -1,   -1,  449,   -1,   -1,   -1,
+  453,  454,  292,   -1,   -1,   -1,  296,   -1,  461,  462,
+   -1,   -1,  302,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  313,   -1,   -1,   -1,   -1,  318,   -1,
+   -1,  321,  322,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  338,  339,
+  340,   -1,   -1,   -1,   -1,   -1,  346,   -1,  348,   -1,
+  350,  351,  352,  353,  354,   -1,   -1,  357,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  382,  383,   -1,   -1,   -1,   -1,   -1,  389,
+   -1,  391,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  405,  406,  407,  408,   -1,
+   -1,   -1,  412,   -1,   -1,   -1,   -1,   -1,   -1,  256,
+   -1,   -1,  422,  423,   -1,   -1,   -1,  264,   -1,   -1,
+   -1,  268,   -1,   -1,  271,  272,   -1,   -1,   -1,  276,
+  277,   -1,  279,   -1,  281,   -1,   -1,   -1,   -1,  449,
+   -1,   -1,   -1,  453,  454,  292,   -1,   -1,   -1,  296,
+   -1,  461,  462,   -1,   -1,  302,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  313,   -1,   -1,   -1,
+   -1,  318,   -1,   -1,  321,  322,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  338,  339,  340,   -1,   -1,   -1,   -1,   -1,  346,
+   -1,  348,   -1,  350,  351,  352,  353,  354,   -1,   -1,
+  357,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  382,  383,   -1,   -1,   -1,
+   -1,   -1,  389,   -1,  391,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  405,  406,
+  407,  408,   -1,   -1,   -1,  412,   -1,   -1,   -1,   -1,
+   -1,   -1,  256,   -1,   -1,  422,  423,   -1,   -1,   -1,
+  264,   -1,   -1,   -1,  268,   -1,   -1,  271,  272,   -1,
+   -1,   -1,  276,  277,   -1,  279,   -1,  281,   -1,   -1,
+   -1,   -1,  449,   -1,   -1,   -1,  453,  454,  292,   -1,
+   -1,   -1,  296,   -1,  461,  462,   -1,   -1,  302,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  313,
+   -1,   -1,   -1,   -1,  318,   -1,   -1,  321,  322,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  338,  339,  340,   -1,   -1,   -1,
+   -1,   -1,  346,   -1,  348,   -1,  350,  351,  352,  353,
+  354,   -1,   -1,  357,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  382,  383,
+   -1,   -1,   -1,   -1,   -1,  389,   -1,  391,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  405,  406,  407,  408,   -1,   -1,   -1,  412,   -1,
+   -1,   -1,   -1,   -1,   -1,  256,   -1,   -1,  422,  423,
+   -1,   -1,   -1,  264,   -1,   -1,   -1,  268,   -1,   -1,
+  271,  272,   -1,   -1,   -1,  276,  277,   -1,  279,   -1,
+  281,   -1,   -1,   -1,   -1,  449,   -1,   -1,   -1,  453,
+  454,  292,   -1,   -1,   -1,  296,   -1,  461,  462,   -1,
+   -1,  302,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  313,   -1,   -1,   -1,   -1,  318,   -1,   -1,
+  321,  322,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  338,  339,  340,
+   -1,   -1,   -1,   -1,   -1,  346,   -1,  348,   -1,  350,
+  351,  352,  353,  354,   -1,   -1,  357,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  382,  383,   -1,   -1,   -1,   -1,   -1,  389,   -1,
+  391,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  405,  406,  407,  408,   -1,   -1,
+   -1,  412,   -1,   -1,   -1,   -1,   -1,   -1,  256,   -1,
+   -1,  422,  423,   -1,   -1,   -1,  264,   -1,   -1,   -1,
+  268,   -1,   -1,  271,  272,   -1,   -1,   -1,  276,  277,
+   -1,  279,   -1,  281,   -1,   -1,   -1,   -1,  449,   -1,
+   -1,   -1,  453,  454,  292,   -1,   -1,   -1,  296,   -1,
+  461,  462,   -1,   -1,  302,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  313,   -1,   -1,   -1,   -1,
+  318,   -1,   -1,  321,  322,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  338,  339,  340,   -1,   -1,   -1,   -1,   -1,  346,   -1,
+  348,   -1,  350,  351,  352,  353,  354,   -1,   -1,  357,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  382,  383,   -1,   -1,   -1,   -1,
+   -1,  389,   -1,  391,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  405,  406,  407,
+  408,   -1,   -1,   -1,  412,   -1,   -1,   -1,   -1,   -1,
+   -1,  256,   -1,   -1,  422,  423,   -1,   -1,   -1,  264,
+   -1,   -1,   -1,  268,   -1,   -1,  271,  272,   -1,   -1,
+   -1,  276,  277,   -1,  279,   -1,  281,   -1,   -1,   -1,
+   -1,  449,   -1,   -1,   -1,  453,  454,  292,   -1,   -1,
+   -1,  296,   -1,  461,  462,  292,   -1,  302,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  313,   -1,
+   -1,   -1,   -1,  318,   -1,   -1,  321,  322,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  256,   -1,   -1,   -1,   -1,
+   -1,  262,   -1,  338,  339,  340,   -1,   -1,   -1,   -1,
+   -1,  346,   -1,  348,   -1,  350,  351,  352,  353,  354,
+   -1,  348,  357,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  382,  383,   -1,
+   -1,   -1,   -1,   -1,  389,  316,  391,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  405,  406,  407,  408,   -1,   -1,   -1,  412,  405,  406,
+  407,  408,   -1,  410,  411,  412,  413,  422,  423,  416,
+  417,  418,  419,   -1,   -1,  422,  423,  424,  425,  426,
+  427,  428,  429,   -1,  431,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  449,   -1,   -1,   -1,  453,  454,
+   -1,  448,  383,   -1,   -1,   -1,  461,  462,  389,   -1,
+  391,  392,  393,  394,  395,  396,   -1,  398,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  406,  407,   -1,  409,  410,
+  411,  412,  413,  414,  415,  416,  417,  418,  419,  420,
+  421,  422,  423,  424,  425,  426,  427,  428,  429,  430,
+  431,  432,  433,  434,  435,  436,  437,  438,  439,  440,
+  441,  442,  443,  444,  445,  256,  447,  448,   -1,   -1,
+  261,   -1,  262,  454,   -1,   -1,   -1,  458,   -1,   -1,
+  461,   -1,  273,  274,   -1,   -1,   -1,  278,   -1,   -1,
+   -1,   -1,   -1,   -1,  285,   -1,   -1,  288,  289,  290,
+   -1,   -1,  293,   -1,  295,   -1,   -1,   -1,   -1,   -1,
+   -1,  302,  303,  304,   -1,   -1,  307,   -1,  309,   -1,
+  311,   -1,   -1,  314,  315,   -1,  316,   -1,  319,  320,
+  321,   -1,   -1,  324,   -1,  326,   -1,   -1,   -1,  330,
+  331,  332,  333,  334,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  342,   -1,  344,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  355,  356,   -1,   -1,  359,  360,
+   -1,  362,   -1,   -1,  365,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  382,   -1,   -1,   -1,   -1,  387,   -1,  389,   -1,
+   -1,  391,  392,  393,  394,  395,  396,   -1,  398,   -1,
+   -1,   -1,  402,  403,   -1,   -1,  406,  407,   -1,   -1,
+  410,  411,  412,  413,  414,  415,  416,  417,  418,  419,
+  420,  421,  422,  423,  424,  425,  426,  427,  428,  429,
+  430,  431,  432,  433,  434,  435,  436,  437,  438,  439,
+  440,  441,  442,  443,  444,  445,   -1,  447,  448,   -1,
+   -1,   -1,  264,   -1,  455,  456,  268,   -1,  458,  271,
+  272,  461,   -1,   -1,  276,  277,   -1,  279,   -1,  281,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  292,   -1,   -1,   -1,  296,   -1,   -1,   -1,   -1,   -1,
+  302,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  313,   -1,   -1,   -1,   -1,  318,   -1,   -1,  321,
+  322,   -1,   -1,  325,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  335,   -1,   -1,  338,  339,  340,   -1,
+   -1,   -1,   -1,   -1,  346,   -1,  348,   -1,  350,  351,
+  352,  353,  354,   -1,   -1,  357,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  367,  368,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  382,  383,   -1,   -1,   -1,   -1,   -1,  389,   -1,  391,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  402,   -1,   -1,  405,  406,  407,  408,   -1,   -1,   -1,
+  412,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  264,   -1,
+  422,  423,  268,   -1,   -1,  271,  272,   -1,   -1,   -1,
+  276,  277,   -1,  279,   -1,  281,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  292,  449,   -1,   -1,
+  296,  453,  454,   -1,   -1,  457,  302,   -1,   -1,  461,
+  462,   -1,   -1,   -1,   -1,   -1,   -1,  313,   -1,   -1,
+   -1,   -1,  318,   -1,   -1,  321,  322,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  338,  339,  340,   -1,   -1,   -1,   -1,   -1,
+  346,   -1,  348,   -1,  350,  351,  352,  353,  354,   -1,
+   -1,  357,   -1,   -1,   -1,  361,   -1,   -1,   -1,   -1,
+   -1,  367,  368,   -1,  263,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  273,  274,  382,  383,   -1,  278,
+   -1,   -1,   -1,  389,   -1,  391,   -1,   -1,   -1,  288,
+  289,  290,   -1,   -1,   -1,   -1,  295,   -1,   -1,  405,
+  406,  407,  408,  302,  303,  304,  412,   -1,  307,   -1,
+  309,   -1,  311,   -1,  264,  314,  422,  423,  268,   -1,
+  319,  271,  272,   -1,   -1,  324,  276,  277,   -1,  279,
+   -1,  281,  331,   -1,   -1,   -1,   -1,   -1,  337,   -1,
+   -1,   -1,  292,  449,   -1,  344,  296,  453,  454,   -1,
+   -1,  457,  302,   -1,   -1,  461,  462,  356,   -1,   -1,
+  359,   -1,   -1,  313,   -1,   -1,  365,   -1,  318,   -1,
+   -1,  321,  322,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  384,  385,   -1,  338,  339,
+  340,   -1,   -1,   -1,   -1,   -1,  346,   -1,  348,   -1,
+  350,  351,  352,  353,  354,   -1,   -1,  357,   -1,  359,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  367,  368,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  273,  274,  382,  383,   -1,  278,   -1,   -1,   -1,  389,
+   -1,  391,   -1,   -1,   -1,  288,  289,  290,   -1,   -1,
+   -1,   -1,  295,   -1,   -1,  405,  406,  407,  408,  302,
+  303,  304,  412,   -1,  307,   -1,  309,   -1,  311,   -1,
+  264,  314,  422,  423,  268,   -1,  319,  271,  272,   -1,
+   -1,  324,  276,  277,   -1,  279,   -1,  281,  331,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  292,  449,
+   -1,  344,  296,  453,  454,   -1,   -1,  457,  302,   -1,
+   -1,  461,  462,  356,   -1,   -1,  359,   -1,   -1,  313,
+   -1,   -1,  365,   -1,  318,   -1,   -1,  321,  322,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  338,  339,  340,   -1,   -1,   -1,
+   -1,   -1,  346,   -1,  348,   -1,  350,  351,  352,  353,
+  354,   -1,   -1,  357,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  367,  368,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  274,  382,  383,
+   -1,  278,   -1,   -1,   -1,  389,   -1,  391,   -1,   -1,
+   -1,  288,  289,  290,   -1,   -1,   -1,   -1,  295,   -1,
+   -1,  405,  406,  407,  408,  302,  303,  304,  412,   -1,
+  307,   -1,  309,   -1,  311,   -1,  264,   -1,  422,  423,
+  268,   -1,  319,  271,  272,   -1,   -1,  324,  276,  277,
+   -1,  279,   -1,  281,  331,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  292,  449,   -1,   -1,  296,  453,
+  454,   -1,   -1,  457,  302,   -1,   -1,  461,  462,  356,
+   -1,   -1,  359,   -1,   -1,  313,   -1,   -1,  365,   -1,
+  318,   -1,   -1,  321,  322,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  338,  339,  340,   -1,   -1,   -1,   -1,   -1,  346,   -1,
+  348,   -1,  350,  351,  352,  353,  354,   -1,   -1,  357,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  367,
+  368,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  382,  383,   -1,   -1,   -1,   -1,
+   -1,  389,   -1,  391,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  405,  406,  407,
+  408,   -1,   -1,   -1,  412,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  264,   -1,  422,  423,  268,   -1,   -1,  271,
+  272,   -1,   -1,   -1,  276,  277,   -1,  279,   -1,  281,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  292,  449,   -1,   -1,  296,  453,  454,   -1,   -1,  457,
+  302,   -1,   -1,  461,  462,   -1,   -1,   -1,   -1,   -1,
+   -1,  313,   -1,   -1,   -1,   -1,  318,   -1,   -1,  321,
+  322,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  338,  339,  340,   -1,
+   -1,   -1,   -1,   -1,  346,   -1,  348,   -1,  350,  351,
+  352,  353,  354,   -1,   -1,  357,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  367,  368,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  382,  383,   -1,   -1,   -1,   -1,   -1,  389,   -1,  391,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  405,  406,  407,  408,   -1,   -1,   -1,
+  412,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  264,   -1,
+  422,  423,  268,   -1,   -1,  271,  272,   -1,   -1,   -1,
+  276,  277,   -1,  279,   -1,  281,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  292,  449,   -1,   -1,
+  296,  453,  454,   -1,   -1,  457,  302,   -1,   -1,  461,
+  462,   -1,   -1,   -1,   -1,   -1,   -1,  313,   -1,   -1,
+   -1,   -1,  318,   -1,   -1,  321,  322,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  338,  339,  340,   -1,   -1,   -1,   -1,   -1,
+  346,   -1,  348,   -1,  350,  351,  352,  353,  354,   -1,
+   -1,  357,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  367,  368,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  382,  383,   -1,   -1,
+   -1,   -1,   -1,  389,   -1,  391,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  405,
+  406,  407,  408,   -1,   -1,   -1,  412,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  264,   -1,  422,  423,  268,   -1,
+   -1,  271,  272,   -1,   -1,   -1,  276,  277,   -1,  279,
+   -1,  281,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  292,  449,   -1,   -1,  296,  453,  454,   -1,
+   -1,  457,  302,   -1,   -1,  461,  462,   -1,   -1,   -1,
+   -1,   -1,   -1,  313,   -1,   -1,   -1,   -1,  318,   -1,
+   -1,  321,  322,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  338,  339,
+  340,   -1,   -1,   -1,   -1,   -1,  346,   -1,  348,   -1,
+  350,  351,  352,  353,  354,   -1,   -1,  357,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  367,  368,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  382,  383,   -1,   -1,   -1,   -1,   -1,  389,
+   -1,  391,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  405,  406,  407,  408,   -1,
+   -1,   -1,  412,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  264,   -1,  422,  423,  268,   -1,   -1,  271,  272,   -1,
+   -1,   -1,  276,  277,   -1,  279,   -1,  281,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  292,  449,
+   -1,   -1,  296,  453,  454,   -1,   -1,  457,  302,   -1,
+   -1,  461,  462,   -1,   -1,   -1,   -1,   -1,   -1,  313,
+   -1,   -1,   -1,   -1,  318,   -1,   -1,  321,  322,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  338,  339,  340,   -1,   -1,   -1,
+   -1,   -1,  346,   -1,  348,   -1,  350,  351,  352,  353,
+  354,   -1,   -1,  357,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  367,  368,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  382,  383,
+   -1,   -1,   -1,   -1,   -1,  389,   -1,  391,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  405,  406,  407,  408,   -1,   -1,   -1,  412,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  264,   -1,  422,  423,
+  268,   -1,   -1,  271,  272,   -1,   -1,   -1,  276,  277,
+   -1,  279,   -1,  281,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  292,  449,   -1,   -1,  296,  453,
+  454,   -1,   -1,  457,  302,   -1,   -1,  461,  462,   -1,
+   -1,   -1,   -1,   -1,   -1,  313,   -1,   -1,   -1,   -1,
+  318,   -1,   -1,  321,  322,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  338,  339,  340,   -1,   -1,   -1,  261,   -1,  346,   -1,
+  348,   -1,  350,  351,  352,  353,  354,   -1,  273,  357,
+   -1,   -1,   -1,  278,   -1,   -1,   -1,   -1,   -1,   -1,
+  285,   -1,   -1,  288,   -1,   -1,   -1,   -1,  293,   -1,
+   -1,   -1,   -1,   -1,  382,  383,   -1,  302,  303,  304,
+   -1,  389,   -1,  391,  309,   -1,   -1,   -1,   -1,  314,
+  315,   -1,   -1,   -1,  319,  320,  321,  405,  406,  407,
+  408,  326,   -1,   -1,  412,  330,   -1,  332,  333,  334,
+   -1,   -1,   -1,   -1,  422,  423,   -1,  342,   -1,  344,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  355,  356,   -1,   -1,   -1,  360,   -1,  362,  261,   -1,
+  365,  449,   -1,   -1,   -1,  453,  454,   -1,   -1,   -1,
+  273,  274,   -1,  461,  462,  278,   -1,  382,   -1,   -1,
+   -1,   -1,  285,  388,  389,  288,  289,  290,   -1,   -1,
+  293,   -1,  295,   -1,   -1,   -1,   -1,   -1,   -1,  302,
+  303,  304,   -1,   -1,  307,   -1,  309,   -1,  311,   -1,
+   -1,  314,  315,   -1,   -1,   -1,  319,  320,  321,   -1,
+   -1,  324,   -1,  326,   -1,   -1,   -1,  330,  331,  332,
+  333,  334,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  342,
+   -1,  344,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  455,  456,  355,  356,   -1,   -1,  359,  360,   -1,  362,
+  261,   -1,  365,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  273,  274,   -1,   -1,   -1,  278,   -1,  382,
+   -1,   -1,   -1,   -1,  285,   -1,   -1,  288,  289,  290,
+   -1,   -1,  293,   -1,  295,   -1,   -1,   -1,   -1,   -1,
+   -1,  302,  303,  304,   -1,   -1,  307,   -1,  309,   -1,
+  311,   -1,   -1,  314,  315,   -1,   -1,   -1,  319,  320,
+  321,   -1,   -1,  324,   -1,  326,   -1,   -1,   -1,  330,
+  331,  332,  333,  334,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  342,   -1,  344,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  454,  455,   -1,  355,  356,   -1,   -1,  359,  360,
+   -1,  362,  261,   -1,  365,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  273,  274,   -1,   -1,   -1,  278,
+   -1,  382,   -1,   -1,   -1,   -1,  285,  388,   -1,  288,
+  289,  290,   -1,   -1,  293,   -1,  295,   -1,   -1,   -1,
+   -1,   -1,   -1,  302,  303,  304,   -1,   -1,  307,   -1,
+  309,   -1,  311,   -1,   -1,  314,  315,   -1,   -1,   -1,
+  319,  320,  321,   -1,   -1,  324,   -1,  326,   -1,   -1,
+   -1,  330,  331,  332,  333,  334,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  342,   -1,  344,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  455,   -1,  355,  356,   -1,   -1,
+  359,  360,   -1,  362,  261,   -1,  365,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  273,  274,   -1,   -1,
+   -1,  278,   -1,  382,   -1,   -1,   -1,   -1,  285,  388,
+   -1,  288,  289,  290,   -1,   -1,  293,   -1,  295,   -1,
+   -1,   -1,   -1,   -1,   -1,  302,  303,  304,   -1,   -1,
+  307,   -1,  309,   -1,  311,   -1,   -1,  314,  315,   -1,
+   -1,   -1,  319,  320,  321,   -1,   -1,  324,   -1,  326,
+   -1,   -1,   -1,  330,  331,  332,  333,  334,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  342,   -1,  344,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  455,   -1,  355,  356,
+   -1,   -1,  359,  360,   -1,  362,  261,   -1,  365,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  273,  274,
+   -1,   -1,   -1,  278,   -1,  382,   -1,   -1,   -1,   -1,
+  285,   -1,   -1,  288,  289,  290,   -1,   -1,  293,   -1,
+  295,   -1,   -1,   -1,   -1,   -1,   -1,  302,  303,  304,
+   -1,   -1,  307,   -1,   -1,   -1,  311,   -1,   -1,  314,
+  315,   -1,   -1,   -1,  319,  320,  321,   -1,   -1,  324,
+   -1,  326,   -1,   -1,   -1,  330,  331,  332,  333,  334,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  342,   -1,  344,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  455,   -1,
+  355,   -1,   -1,   -1,  359,  360,   -1,  362,  261,   -1,
+  365,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  273,  274,   -1,   -1,   -1,  278,   -1,  382,   -1,   -1,
+   -1,   -1,  285,  388,   -1,  288,  289,  290,   -1,   -1,
+  293,   -1,  295,   -1,   -1,   -1,   -1,   -1,   -1,  302,
+  303,  304,   -1,   -1,  307,   -1,   -1,   -1,  311,   -1,
+   -1,  314,  315,   -1,   -1,   -1,  319,  320,  321,   -1,
+   -1,  324,   -1,  326,   -1,   -1,   -1,  330,  331,  332,
+  333,  334,   -1,   -1,  261,   -1,   -1,   -1,   -1,  342,
+   -1,  344,   -1,   -1,   -1,   -1,  273,   -1,   -1,   -1,
+  455,  278,  355,   -1,   -1,   -1,  359,  360,  285,  362,
+   -1,  288,  365,   -1,   -1,   -1,  293,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  302,  303,  304,   -1,  382,
+   -1,   -1,  309,   -1,   -1,  388,   -1,  314,  315,   -1,
+   -1,   -1,  319,  320,  321,   -1,   -1,   -1,   -1,  326,
+   -1,   -1,   -1,  330,   -1,  332,  333,  334,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  342,   -1,  344,   -1,   -1,
+   -1,   -1,  261,   -1,   -1,   -1,   -1,   -1,  355,  356,
+   -1,   -1,   -1,  360,  273,  362,   -1,   -1,  365,  278,
+   -1,   -1,   -1,   -1,   -1,   -1,  285,   -1,   -1,  288,
+   -1,   -1,  455,   -1,  293,  382,   -1,   -1,   -1,   -1,
+  387,   -1,  389,  302,  303,  304,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  314,  315,   -1,   -1,   -1,
+  319,  320,  321,   -1,   -1,   -1,   -1,  326,   -1,   -1,
+   -1,  330,   -1,  332,  333,  334,   -1,   -1,  261,   -1,
+   -1,   -1,   -1,  342,   -1,  344,   -1,   -1,   -1,   -1,
+  273,   -1,   -1,   -1,   -1,  278,  355,   -1,   -1,   -1,
+   -1,  360,  285,  362,   -1,  288,  365,   -1,  455,   -1,
+  293,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  302,
+  303,  304,   -1,  382,   -1,   -1,   -1,   -1,   -1,  388,
+   -1,  314,  315,   -1,   -1,   -1,  319,  320,  321,   -1,
+   -1,   -1,   -1,  326,   -1,   -1,   -1,  330,   -1,  332,
+  333,  334,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  342,
+   -1,  344,   -1,  261,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  355,   -1,   -1,  273,   -1,  360,   -1,  362,
+  278,   -1,  365,   -1,   -1,   -1,   -1,  285,   -1,   -1,
+  288,   -1,   -1,   -1,   -1,  293,  455,   -1,   -1,  382,
+   -1,   -1,   -1,   -1,  302,  303,  304,   -1,   -1,  261,
+   -1,   -1,   -1,   -1,   -1,   -1,  314,  315,   -1,   -1,
+   -1,  319,  320,  321,   -1,   -1,   -1,   -1,  326,   -1,
+   -1,   -1,  330,  285,  332,  333,  334,   -1,   -1,   -1,
+   -1,  293,   -1,   -1,  342,   -1,  344,  261,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,  355,   -1,   -1,
+   -1,   -1,  360,  315,  362,   -1,   -1,  365,  320,  321,
+   -1,  285,  455,   -1,  326,   -1,   -1,   -1,  330,  293,
+  332,  333,  334,   -1,  382,   -1,   -1,   -1,   -1,   -1,
+  342,  261,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  315,   -1,  355,   -1,   -1,  320,  321,  360,   -1,
+  362,   -1,  326,   -1,   -1,  285,  330,   -1,  332,  333,
+  334,   -1,   -1,  293,   -1,   -1,   -1,   -1,  342,  261,
+  382,   -1,  384,  385,   -1,   -1,  388,   -1,   -1,   -1,
+   -1,  355,   -1,   -1,   -1,  315,  360,   -1,  362,   -1,
+  320,  321,   -1,  285,   -1,   -1,  326,  455,   -1,   -1,
+  330,  293,  332,  333,  334,   -1,   -1,  337,  382,   -1,
+  384,  385,  342,  261,  388,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  315,   -1,  355,   -1,   -1,  320,  321,
+  360,   -1,  362,   -1,  326,   -1,   -1,  285,  330,   -1,
+  332,  333,  334,  455,   -1,  293,   -1,   -1,   -1,   -1,
+  342,  261,  382,   -1,   -1,   -1,   -1,   -1,  388,  389,
+   -1,   -1,   -1,  355,   -1,   -1,   -1,  315,  360,   -1,
+  362,   -1,  320,  321,   -1,  285,   -1,   -1,  326,   -1,
+   -1,  455,  330,  293,  332,  333,  334,   -1,   -1,   -1,
+  382,   -1,  384,  385,  342,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  315,   -1,  355,   -1,   -1,
+  320,  321,  360,   -1,  362,   -1,  326,   -1,   -1,   -1,
+  330,   -1,  332,  333,  334,  455,   -1,   -1,   -1,   -1,
+   -1,   -1,  342,  268,  382,   -1,  271,   -1,   -1,   -1,
+   -1,  276,   -1,   -1,   -1,  355,  281,   -1,   -1,   -1,
+  360,   -1,  362,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  296,   -1,  455,   -1,   -1,   -1,   -1,  268,   -1,
+   -1,  271,  382,  273,   -1,   -1,  276,   -1,  313,   -1,
+   -1,  281,   -1,  318,  268,   -1,   -1,  271,   -1,   -1,
+  325,   -1,  276,   -1,   -1,   -1,  296,  281,   -1,   -1,
+  335,   -1,   -1,  338,  339,   -1,  454,  455,   -1,   -1,
+   -1,  346,  296,  313,   -1,   -1,  351,  352,  318,   -1,
+   -1,  321,  357,   -1,   -1,   -1,  361,   -1,   -1,  313,
+   -1,   -1,   -1,   -1,  318,   -1,   -1,   -1,  338,  339,
+   -1,   -1,   -1,   -1,  344,  455,   -1,   -1,  383,   -1,
+   -1,  351,  352,   -1,  338,  339,   -1,  357,   -1,   -1,
+   -1,  361,   -1,   -1,   -1,   -1,   -1,  351,  352,   -1,
+   -1,   -1,   -1,  357,   -1,   -1,   -1,  361,   -1,   -1,
+   -1,  416,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  390,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  416,   -1,   -1,  454,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  416,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  454,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  454,
+  };
+
+#line 8010 "ps-parser.jay"
+
+// <summary>
+//  A class used to hold info about an operator declarator
+// </summary>
+class OperatorDeclaration {
+	public readonly Operator.OpType optype;
+	public readonly FullNamedExpression ret_type;
+	public readonly Location location;
+
+	public OperatorDeclaration (Operator.OpType op, FullNamedExpression ret_type, Location location)
+	{
+		optype = op;
+		this.ret_type = ret_type;
+		this.location = location;
+	}
+}
+
+void Error_ExpectingTypeName (Expression expr)
+{
+	if (expr is Invocation){
+		report.Error (1002, expr.Location, "Expecting `;'");
+	} else {
+		expr.Error_InvalidExpressionStatement (report);
+	}
+}
+
+void Error_ParameterModifierNotValid (string modifier, Location loc)
+{
+	report.Error (631, loc, "The parameter modifier `{0}' is not valid in this context",
+			              modifier);
+}
+
+void Error_DuplicateParameterModifier (Location loc, Parameter.Modifier mod)
+{
+	report.Error (1107, loc, "Duplicate parameter modifier `{0}'",
+  		Parameter.GetModifierSignature (mod));
+}
+
+void Error_TypeExpected (Location loc)
+{
+	report.Error (1031, loc, "Type expected");
+}
+
+void Error_UnsafeCodeNotAllowed (Location loc)
+{
+	report.Error (227, loc, "Unsafe code requires the `unsafe' command line option to be specified");
+}
+
+void Warning_EmptyStatement (Location loc)
+{
+	report.Warning (642, 3, loc, "Possible mistaken empty statement");
+}
+
+void Error_NamedArgumentExpected (NamedArgument a)
+{
+	report.Error (1738, a.Location, "Named arguments must appear after the positional arguments");
+}
+
+void Error_MissingInitializer (Location loc)
+{
+	report.Error (210, loc, "You must provide an initializer in a fixed or using statement declaration");
+}
+
+object Error_AwaitAsIdentifier (object token)
+{
+	if (async_block) {
+		report.Error (4003, GetLocation (token), "`await' cannot be used as an identifier within an async method or lambda expression");
+		return new Tokenizer.LocatedToken ("await", GetLocation (token));
+	}
+
+	return token;
+}
+
+void push_current_container (TypeDefinition tc, object partial_token)
+{
+	if (module.Evaluator != null){
+		tc.Definition.Modifiers = tc.ModFlags = (tc.ModFlags & ~Modifiers.AccessibilityMask) | Modifiers.PUBLIC;
+		if (undo == null)
+			undo = new Undo ();
+
+		undo.AddTypeContainer (current_container, tc);
+	}
+	
+	if (is_config_enabled) {
+		if (partial_token != null)
+			current_container.AddPartial (tc);
+		else
+			current_container.AddTypeContainer (tc);
+	}
+	
+	is_config_enabled = true;
+		
+	++lexer.parsing_declaration;
+	current_container = tc;
+	current_type = tc;
+}
+
+TypeContainer pop_current_class ()
+{
+	var retval = current_container;
+
+	current_container = current_container.Parent;
+	current_type = current_type.Parent as TypeDefinition;
+
+	return retval;
+}
+
+[System.Diagnostics.Conditional ("FULL_AST")]
+void StoreModifierLocation (object token, Location loc)
+{
+	if (lbag == null)
+		return;
+
+	if (mod_locations == null)
+  		mod_locations = new List<Tuple<Modifiers, Location>> ();
+
+	mod_locations.Add (Tuple.Create ((Modifiers) token, loc));
+}
+
+List<Tuple<Modifiers, Location>> GetModifierLocations ()
+{
+	var result = mod_locations;
+	mod_locations = null;
+	return result;
+}
+
+string CheckAttributeTarget (string a, Location l)
+{
+	switch (a) {
+	case "assembly" : case "module" : case "field" : case "method" : case "param" : case "property" : case "type" :
+			return a;
+	}
+
+	report.Warning (658, 1, l,
+		 "`{0}' is invalid attribute target. All attributes in this attribute section will be ignored", a);
+	return string.Empty;
+}
+
+bool IsPartial (object a)
+{
+	var attrs = a as Attributes;
+	if (attrs == null)
+		return false;
+	foreach (var attr in attrs.Attrs) {
+		if (attr.TypeExpression.Name == "Partial")
+			return true;
+	}
+	return false;
+}
+
+static bool IsUnaryOperator (Operator.OpType op)
+{
+	switch (op) {
+		
+	case Operator.OpType.LogicalNot: 
+	case Operator.OpType.OnesComplement: 
+	case Operator.OpType.Increment:
+	case Operator.OpType.Decrement:
+	case Operator.OpType.True: 
+	case Operator.OpType.False: 
+	case Operator.OpType.UnaryPlus: 
+	case Operator.OpType.UnaryNegation:
+		return true;
+	}
+	return false;
+}
+
+void syntax_error (Location l, string msg)
+{
+	report.Error (1003, l, "Syntax error, " + msg);
+}
+
+Tokenizer lexer;
+
+public Tokenizer Lexer {
+	get {
+		return lexer;
+	}
+}		   
+
+public PlayScriptParser (SeekableStreamReader reader, CompilationSourceFile file, ParserSession session)
+	: this (reader, file, file.Compiler.Report, session)
+{
+}
+
+public PlayScriptParser (SeekableStreamReader reader, CompilationSourceFile file, Report report, ParserSession session)
+{
+	this.file = file;
+	current_container = current_namespace = file;
+	
+	this.module = file.Module;
+	this.compiler = file.Compiler;
+	this.settings = compiler.Settings;
+	this.report = report;
+	
+	lang_version = settings.Version;
+	yacc_verbose_flag = settings.VerboseParserFlag;
+	doc_support = settings.DocumentationFile != null;
+	lexer = new Tokenizer (reader, file, session);
+	oob_stack = new Stack<object> ();
+	lbag = session.LocationsBag;
+	use_global_stacks = session.UseJayGlobalArrays;
+	parameters_bucket = session.ParametersStack;
+}
+
+public void parse ()
+{
+	eof_token = Token.EOF;
+	
+	try {
+		if (yacc_verbose_flag > 1)
+			yyparse (lexer, new yydebug.yyDebugSimple ());
+		else
+			yyparse (lexer);
+			
+		Tokenizer tokenizer = lexer as Tokenizer;
+		tokenizer.cleanup ();		
+	} catch (Exception e){
+	  	if (e is yyParser.yyUnexpectedEof) {
+			Error_SyntaxError (yyToken);
+			UnexpectedEOF = true;
+			return;
+		}
+			
+		if (e is yyParser.yyException) {
+			if (report.Errors == 0)
+				report.Error (-25, lexer.Location, "Parsing error");
+		} else {
+			// Used by compiler-tester to test internal errors
+			if (yacc_verbose_flag > 0 || e is FatalException)
+				throw;
+		
+			report.Error (589, lexer.Location, "Internal compiler error during parsing" + e);
+		}
+	}
+}
+
+void CheckToken (int error, int yyToken, string msg, Location loc)
+{
+	if (yyToken >= Token.FIRST_KEYWORD && yyToken <= Token.LAST_KEYWORD)
+		report.Error (error, loc, "{0}: `{1}' is a keyword", msg, GetTokenName (yyToken));
+	else
+		report.Error (error, loc, msg);
+}
+
+string ConsumeStoredComment ()
+{
+	string s = tmpComment;
+	tmpComment = null;
+	Lexer.doc_state = XmlCommentState.Allowed;
+	return s;
+}
+
+void FeatureIsNotAvailable (Location loc, string feature)
+{
+	report.FeatureIsNotAvailable (compiler, loc, feature);
+}
+
+Location GetLocation (object obj)
+{
+	var lt = obj as Tokenizer.LocatedToken;
+	if (lt != null)
+		return lt.Location;
+		
+	var mn = obj as MemberName;
+	if (mn != null)
+		return mn.Location;
+		
+	var expr = obj as Expression;
+	if (expr != null)
+		return expr.Location;
+
+	return lexer.Location;
+}
+
+void start_block (Location loc)
+{
+	if (current_block == null) {
+		current_block = new ToplevelBlock (compiler, current_local_parameters, loc);
+		parsing_anonymous_method = false;
+	} else if (parsing_anonymous_method) {
+		current_block = new ParametersBlock (current_block, current_local_parameters, loc);
+		parsing_anonymous_method = false;
+	} else {
+		current_block = new ExplicitBlock (current_block, loc, Location.Null);
+	}
+}
+
+Block
+end_block (Location loc)
+{
+	Block retval = current_block.Explicit;
+	retval.SetEndLocation (loc);
+	current_block = retval.Parent;
+	return retval;
+}
+
+void start_anonymous (bool isLambda, ParametersCompiled parameters, FullNamedExpression retType, bool isAsync, Location loc)
+{
+	oob_stack.Push (current_anonymous_method);
+	oob_stack.Push (current_local_parameters);
+	oob_stack.Push (current_variable);
+	oob_stack.Push (async_block);
+	oob_stack.Push (Lexer.AutoSemiInsertion);
+
+	current_local_parameters = parameters;
+	if (isLambda) {
+		if (lang_version <= LanguageVersion.ISO_2)
+			FeatureIsNotAvailable (loc, "lambda expressions");
+
+		current_anonymous_method = new LambdaExpression (loc);
+	} else {
+		if (lang_version == LanguageVersion.ISO_1)
+			FeatureIsNotAvailable (loc, "anonymous methods");
+			
+		current_anonymous_method = new AnonymousMethodExpression (loc, parameters, retType);
+	}
+
+	async_block = isAsync;
+	// Force the next block to be created as a ToplevelBlock
+	parsing_anonymous_method = true;
+}
+
+/*
+ * Completes the anonymous method processing, if lambda_expr is null, this
+ * means that we have a Statement instead of an Expression embedded 
+ */
+AnonymousMethodExpression end_anonymous (ParametersBlock anon_block)
+{
+	AnonymousMethodExpression retval;
+
+	if (async_block)
+		anon_block.IsAsync = true;
+
+	current_anonymous_method.Block = anon_block;
+	retval = current_anonymous_method;
+
+	Lexer.AutoSemiInsertion = (bool) oob_stack.Pop ();
+	async_block = (bool) oob_stack.Pop ();
+	current_variable = (BlockVariableDeclaration) oob_stack.Pop ();
+	current_local_parameters = (ParametersCompiled) oob_stack.Pop ();
+	current_anonymous_method = (AnonymousMethodExpression) oob_stack.Pop ();
+
+	return retval;
+}
+
+void Error_SyntaxError (int token)
+{
+	Error_SyntaxError (0, token);
+}
+
+void Error_SyntaxError (int error_code, int token)
+{
+	Error_SyntaxError (error_code, token, "Unexpected symbol");
+}
+
+void Error_SyntaxError (int error_code, int token, string msg)
+{
+	Lexer.CompleteOnEOF = false;
+
+	// An error message has been reported by tokenizer
+	if (token == Token.ERROR)
+		return;
+	
+	// Avoid duplicit error message after unterminated string literals
+	if (token == Token.LITERAL && lexer.Location.Column == 0)
+		return;
+
+	string symbol = GetSymbolName (token);
+	string expecting = GetExpecting ();
+	var loc = lexer.Location - symbol.Length;
+	
+	if (error_code == 0) {
+		if (expecting == "`identifier'") {
+			if (token > Token.FIRST_KEYWORD && token < Token.LAST_KEYWORD) {
+				report.Error (1041, loc, "Identifier expected, `{0}' is a keyword", symbol);
+				return;
+			}
+			
+			error_code = 1001;
+			expecting = "identifier";
+		} else if (expecting == "`)'") {
+			error_code = 1026;
+		} else {
+			error_code = 1525;
+		}
+	}
+	
+	if (string.IsNullOrEmpty (expecting))
+		report.Error (error_code, loc, "{1} `{0}'", symbol, msg);
+	else
+		report.Error (error_code, loc, "{2} `{0}', expecting {1}", symbol, expecting, msg);	  
+}
+
+void CheckIsPlayScript(string elem, Location loc) 
+{
+	if (!parsing_playscript) {
+		report.Error (7035, loc, "`{0}' only supported in PlayScript", elem);
+	}
+
+}
+
+object ConvertAsType(SimpleName sn, object e)
+{
+	if (sn.Name == "Object") 
+		return new TypeExpression (compiler.BuiltinTypes.Dynamic, GetLocation (e));
+	else if (sn.Name == "Boolean") 
+		return new TypeExpression (compiler.BuiltinTypes.Bool, GetLocation (e));
+	else if (sn.Name == "Number")
+		return new TypeExpression (compiler.BuiltinTypes.Double, GetLocation (e));
+	else if (sn.Name == "String")
+		return new TypeExpression (compiler.BuiltinTypes.String, GetLocation (e));
+	else if (sn.Name == "void")
+		return new TypeExpression (compiler.BuiltinTypes.Void, GetLocation (e));
+	else if (sn.Name == "Function")
+		return new TypeExpression (compiler.BuiltinTypes.Delegate, GetLocation (e));
+	else if (sn.Name == "Class")
+		return new TypeExpression (compiler.BuiltinTypes.Type, GetLocation (e));
+	else
+		return e;
+}
+
+Statement ExpressionListToStatementList(List<Expression> list)
+{
+	if (list.Count == 1) {
+		return ConvertExpressionToStatement(list[0]);
+	} else if (list.Count > 1) {
+		var sl = new StatementList(ConvertExpressionToStatement(list[0]), ConvertExpressionToStatement(list[1]));
+		for (var i = 2; i < list.Count; i++) {
+			sl.Add(ConvertExpressionToStatement(list[i]));
+		}
+		return sl;
+	}
+	
+	return new StatementErrorExpression (EmptyExpression.MissingValue);
+}
+
+Statement ConvertExpressionToStatement(Expression ex)
+{
+	Statement ret;
+	ExpressionStatement s = ex as ExpressionStatement;
+	if (s == null) {
+		if (Lexer.ParsingPlayScript) {
+			ex.Error_InvalidExpressionStatement (report);
+			ret = new StatementErrorExpression (ex);
+		} else {
+			ret = new AsNonAssignStatementExpression (ex);
+		}
+	} else {
+		ret = new StatementExpression (s);
+	}
+	return ret;
+}
+
+Expression MakeMonoSimdType(string typeName, Location loc)
+{
+	return new MemberAccess(new MemberAccess(new SimpleName("Mono", loc), "Simd", loc), typeName, loc);
+}
+
+LocalVariable GetOrCreateLocalVariable(Block block, string name, LocalVariable.Flags flags, FullNamedExpression typeExpr, Location loc)
+{
+	INamedBlockVariable existing = null;
+	LocalVariable li = null;
+
+	if (!parsing_playscript) {
+		if (block.ParametersBlock.TopBlock.GetLocalName (name, block, ref existing)) {
+			if (existing is LocalVariable) {
+				li = existing as LocalVariable;
+				if (li.TypeExpr != null && existing.TypeExpr != null && li.TypeExpr.Equals (existing.TypeExpr)) {
+					report.Warning (7138, 1, loc, "Variable is declared more than once.");
+					li.DeclFlags |= LocalVariable.Flags.AsIgnoreMultiple;
+					return li;
+				}
+			}
+		}
+	}
+	
+	li = new LocalVariable(block, name, flags, loc);
+	li.TypeExpr = typeExpr;
+
+	block.AddLocalName (li);
+	
+	return li;
+}
+
+string GetExpecting ()
+{
+	int [] tokens = yyExpectingTokens (yyExpectingState);
+	var names = new List<string> (tokens.Length);
+	bool has_type = false;
+	bool has_identifier = false;
+	for (int i = 0; i < tokens.Length; i++){
+		int token = tokens [i];
+		has_identifier |= token == Token.IDENTIFIER;
+		
+		string name = GetTokenName (token);
+		if (name == "<internal>")
+			continue;
+			
+		has_type |= name == "type";
+		if (names.Contains (name))
+			continue;
+		
+		names.Add (name);
+	}
+
+	//
+	// Too many tokens to enumerate
+	//
+	if (names.Count > 8)
+		return null;
+
+	if (has_type && has_identifier)
+		names.Remove ("identifier");
+
+	if (names.Count == 1)
+		return "`" + GetTokenName (tokens [0]) + "'";
+	
+	StringBuilder sb = new StringBuilder ();
+	names.Sort ();
+	int count = names.Count;
+	for (int i = 0; i < count; i++){
+		bool last = i + 1 == count;
+		if (last)
+			sb.Append ("or ");
+		sb.Append ('`');
+		sb.Append (names [i]);
+		sb.Append (last ? "'" : count < 3 ? "' " : "', ");
+	}
+	return sb.ToString ();
+}
+
+
+string GetSymbolName (int token)
+{
+	switch (token){
+	case Token.LITERAL:
+		return "Literal " + ((Constant)lexer.Value).GetValue ().ToString ();
+	case Token.IDENTIFIER:
+	case Token.IDENTIFIER_MODIFIER:
+	case Token.IDENTIFIER_CONFIG:
+		return "Identifier " + ((Tokenizer.LocatedToken)lexer.Value).Value ?? "";
+	case Token.BOOL:
+		return "bool";
+	case Token.BOOLEAN:
+		return "boolean";
+	case Token.BYTE:
+		return "byte";
+	case Token.CHAR:
+		return "char";
+	case Token.VOID:
+		return "void";
+	case Token.DECIMAL:
+		return "decimal";
+	case Token.DOUBLE:
+		return "double";
+	case Token.DOUBLE2:
+		return "double2";
+	case Token.DOUBLE3:
+		return "double3";
+	case Token.DOUBLE4:
+		return "double4";
+	case Token.DYNAMIC:
+		return "dynamic";
+	case Token.FLOAT:
+		return "float";
+	case Token.FLOAT2:
+		return "float2";
+	case Token.FLOAT3:
+		return "float3";
+	case Token.FLOAT4:
+		return "float4";
+	case Token.INT:
+		return "int";
+	case Token.LONG:
+		return "long";
+	case Token.SBYTE:
+		return "sbyte";
+	case Token.SHORT:
+		return "short";
+	case Token.STRING:
+		return "string";
+	case Token.UINT:
+		return "uint";
+	case Token.ULONG:
+		return "ulong";
+	case Token.USHORT:
+		return "ushort";
+	case Token.OBJECT:
+		return "object";
+		
+	case Token.PLUS:
+		return "+";
+	case Token.UMINUS:
+	case Token.MINUS:
+		return "-";
+	case Token.BANG:
+		return "!";
+	case Token.BITWISE_AND:
+		return "&";
+	case Token.BITWISE_OR:
+		return "|";
+	case Token.LOGICAL_AND_ASSIGN:
+		return "&&=";
+	case Token.LOGICAL_OR_ASSIGN:
+		return "||=";
+	case Token.STAR:
+		return "*";
+	case Token.PERCENT:
+		return "%";
+	case Token.DIV:
+		return "/";
+	case Token.CARRET:
+		return "^";
+	case Token.OP_INC:
+		return "++";
+	case Token.OP_DEC:
+		return "--";
+	case Token.OP_SHIFT_LEFT:
+		return "<<";
+	case Token.OP_SHIFT_RIGHT:
+		return ">>";
+	case Token.OP_USHIFT_RIGHT:
+		return ">>>";
+	case Token.OP_LT:
+		return "<";
+	case Token.OP_GT:
+		return ">";
+	case Token.OP_LE:
+		return "<=";
+	case Token.OP_GE:
+		return ">=";
+	case Token.OP_EQ:
+		return "==";
+	case Token.OP_REF_EQ:
+		return "===";
+	case Token.OP_NE:
+		return "!=";
+	case Token.OP_AND:
+		return "&&";
+	case Token.OP_OR:
+		return "||";
+	case Token.OP_PTR:
+		return "->";
+	case Token.OP_IN:
+		return "in";
+	case Token.OP_COALESCING:	
+		return "??";
+	case Token.OP_MULT_ASSIGN:
+		return "*=";
+	case Token.OP_DIV_ASSIGN:
+		return "/=";
+	case Token.OP_MOD_ASSIGN:
+		return "%=";
+	case Token.OP_ADD_ASSIGN:
+		return "+=";
+	case Token.OP_SUB_ASSIGN:
+		return "-=";
+	case Token.OP_SHIFT_LEFT_ASSIGN:
+		return "<<=";
+	case Token.OP_SHIFT_RIGHT_ASSIGN:
+		return ">>=";
+	case Token.OP_USHIFT_RIGHT_ASSIGN:
+		return ">>>=";
+	case Token.OP_AND_ASSIGN:
+		return "&=";
+	case Token.OP_XOR_ASSIGN:
+		return "^=";
+	case Token.OP_OR_ASSIGN:
+		return "|=";
+	}
+
+	return GetTokenName (token);
+}
+
+static string GetTokenName (int token)
+{
+	switch (token){
+	case Token.ABSTRACT:
+		return "abstract";
+	case Token.AS:
+		return "as";
+	case Token.ADD:
+		return "add";
+	case Token.ASYNC:
+		return "async";
+	case Token.SUPER:
+		return "super";
+	case Token.BREAK:
+		return "break";
+	case Token.CASE:
+		return "case";
+	case Token.CATCH:
+		return "catch";
+	case Token.CHECKED:
+		return "checked";
+	case Token.CLASS:
+		return "class";
+	case Token.CONST:
+		return "const";
+	case Token.CONTINUE:
+		return "continue";
+	case Token.DEFAULT:
+		return "default";
+	case Token.DELEGATE:
+		return "delegate";
+	case Token.DELETE:
+		return "delete";
+	case Token.DO:
+		return "do";
+	case Token.EACH:
+		return "each";
+	case Token.ELSE:
+		return "else";
+	case Token.ENUM:
+		return "enum";
+	case Token.EVENT:
+		return "event";
+	case Token.EXPLICIT:
+		return "explicit";
+	case Token.EXTENDS:
+		return "extends";
+	case Token.EXTERN:
+		return "extern";
+	case Token.FALSE:
+		return "false";
+	case Token.FINAL:
+		return "final";
+	case Token.FINALLY:
+		return "finally";
+	case Token.FIXED:
+		return "fixed";
+	case Token.FOR:
+		return "for";
+	case Token.FOR_EACH:
+		return "for each";
+	case Token.FUNCTION:
+		return "function";
+	case Token.FUNCTION_GET:
+		return "function get";
+	case Token.FUNCTION_SET:
+		return "function set";
+	case Token.GOTO:
+		return "goto";
+	case Token.IF:
+		return "if";
+	case Token.IMPLEMENTS:
+		return "implements";
+	case Token.IMPLICIT:
+		return "implicit";
+	case Token.IMPORT:
+		return "import";
+	case Token.IN:
+		return "in";
+	case Token.INDEXER:
+		return "indexer";
+	case Token.INSTANCEOF:
+		return "instanceof";
+	case Token.INTERFACE:
+		return "interface";
+	case Token.INTERNAL:
+		return "internal";
+	case Token.IS:
+		return "is";
+	case Token.LOCK:
+		return "lock";
+	case Token.NAMESPACE:
+		return "namespace";
+	case Token.NATIVE:
+		return "native";
+	case Token.NEW:
+		return "new";
+	case Token.NULL:
+		return "null";
+	case Token.OPERATOR:
+		return "operator";
+	case Token.OUT:
+		return "out";
+	case Token.OVERRIDE:
+		return "override";
+	case Token.OVERLOAD:
+		return "overload";
+	case Token.PARAMS:
+		return "params";
+	case Token.PRIVATE:
+		return "private";
+	case Token.PROPERTY:
+		return "property";
+	case Token.PROTECTED:
+		return "protected";
+	case Token.PUBLIC:
+		return "public";
+	case Token.READONLY:
+		return "readonly";
+	case Token.REF:
+		return "ref";
+	case Token.RETURN:
+		return "return";
+	case Token.REMOVE:
+		return "remove";
+	case Token.SIZEOF:
+		return "sizeof";
+	case Token.STACKALLOC:
+		return "stackalloc";
+	case Token.STATIC:
+		return "static";
+	case Token.STRUCT:
+		return "struct";
+	case Token.SWITCH:
+		return "switch";
+	case Token.THIS:
+		return "this";
+	case Token.THROW:
+		return "throw";
+	case Token.TRUE:
+		return "true";
+	case Token.TRY:
+		return "try";
+	case Token.TYPEOF:
+		return "typeof";
+	case Token.UNCHECKED:
+		return "unchecked";
+	case Token.UNDEFINED:
+		return "undefined";
+	case Token.UNSAFE:
+		return "unsafe";
+	case Token.USE:
+		return "use";
+	case Token.USING:
+		return "using";
+	case Token.VAR:
+		return "var";
+	case Token.VIRTUAL:
+		return "virtual";
+	case Token.VOLATILE:
+		return "volatile";
+	case Token.WHERE:
+		return "where";
+	case Token.WHILE:
+		return "while";
+//	case Token.ARGLIST:
+//		return "__arglist";
+//	case Token.REFVALUE:
+//		return "__refvalue";
+//	case Token.REFTYPE:
+//		return "__reftype";
+//	case Token.MAKEREF:
+//		return "__makeref";
+	case Token.PARTIAL:
+		return "partial";
+	case Token.ARROW:
+		return "=>";
+	case Token.FROM:
+	case Token.FROM_FIRST:
+		return "from";
+	case Token.JOIN:
+		return "join";
+	case Token.ON:
+		return "on";
+	case Token.EQUALS:
+		return "equals";
+	case Token.SELECT:
+		return "select";
+	case Token.GROUP:
+		return "group";
+	case Token.BY:
+		return "by";
+	case Token.LET:
+		return "let";
+	case Token.ORDERBY:
+		return "orderby";
+	case Token.ASCENDING:
+		return "ascending";
+	case Token.DESCENDING:
+		return "descending";
+	case Token.INTO:
+		return "into";
+	case Token.GET:
+		return "get";
+	case Token.SET:
+		return "set";
+	case Token.OPEN_BRACE:
+	case Token.OPEN_BRACE_INIT:
+		return "{";
+	case Token.CLOSE_BRACE:
+		return "}";
+	case Token.OPEN_BRACKET:
+	case Token.OPEN_BRACKET_EXPR:
+		return "[";
+	case Token.CLOSE_BRACKET:
+		return "]";
+	case Token.OPEN_PARENS_CAST:
+	case Token.OPEN_PARENS_LAMBDA:
+	case Token.OPEN_PARENS:
+		return "(";
+	case Token.CLOSE_PARENS:
+		return ")";
+	case Token.DOT:
+		return ".";
+	case Token.DOT_AT:
+		return ".@";
+	case Token.DOT_STAR:
+		return ".*";
+	case Token.DOTDOT:
+		return "..";
+	case Token.DOTDOT_AT:
+		return "..@";
+	case Token.DOTDOT_STAR:
+		return "..*";
+	case Token.DOTDOTDOT:
+		return "...";
+	case Token.COMMA:
+		return ",";
+	case Token.DEFAULT_COLON:
+		return "default:";
+	case Token.COLON:
+		return ":";
+	case Token.SEMICOLON:
+		return ";";
+	case Token.TILDE:
+		return "~";
+		
+	case Token.PLUS:
+	case Token.UMINUS:
+	case Token.MINUS:
+	case Token.BANG:
+	case Token.OP_LT:
+	case Token.OP_GT:
+	case Token.BITWISE_AND:
+	case Token.BITWISE_OR:
+	case Token.STAR:
+	case Token.PERCENT:
+	case Token.DIV:
+	case Token.CARRET:
+	case Token.OP_INC:
+	case Token.OP_DEC:
+	case Token.OP_SHIFT_LEFT:
+	case Token.OP_SHIFT_RIGHT:
+	case Token.OP_LE:
+	case Token.OP_GE:
+	case Token.OP_EQ:
+	case Token.OP_NE:
+	case Token.OP_AND:
+	case Token.OP_OR:
+	case Token.OP_PTR:
+	case Token.OP_COALESCING:	
+	case Token.OP_MULT_ASSIGN:
+	case Token.OP_DIV_ASSIGN:
+	case Token.OP_MOD_ASSIGN:
+	case Token.OP_ADD_ASSIGN:
+	case Token.OP_SUB_ASSIGN:
+	case Token.OP_SHIFT_LEFT_ASSIGN:
+	case Token.OP_SHIFT_RIGHT_ASSIGN:
+	case Token.OP_AND_ASSIGN:
+	case Token.OP_XOR_ASSIGN:
+	case Token.OP_OR_ASSIGN:
+	case Token.OP_AT:
+		return "<operator>";
+
+	case Token.BOOL:
+	case Token.BYTE:
+	case Token.CHAR:
+	case Token.VOID:
+	case Token.DECIMAL:
+	case Token.DOUBLE:
+	case Token.FLOAT:
+	case Token.INT:
+	case Token.LONG:
+	case Token.SBYTE:
+	case Token.SHORT:
+	case Token.STRING:
+	case Token.UINT:
+	case Token.ULONG:
+	case Token.USHORT:
+	case Token.OBJECT:
+		return "type";
+	
+	case Token.ASSIGN:
+		return "=";
+	case Token.OP_GENERICS_LT:
+	case Token.GENERIC_DIMENSION:
+		return ".<";
+	case Token.OP_GENERICS_GT:
+		return ">";
+	case Token.INTERR:
+	case Token.INTERR_NULLABLE:
+		return "?";
+	case Token.DOUBLE_COLON:
+		return "::";
+	case Token.LITERAL:
+		return "value";
+	case Token.IDENTIFIER:
+	case Token.AWAIT:
+		return "identifier";
+
+	case Token.EOF:
+		return "end-of-file";
+
+		// All of these are internal.
+	case Token.NONE:
+	case Token.ERROR:
+	case Token.FIRST_KEYWORD:
+	case Token.EVAL_COMPILATION_UNIT_PARSER:
+	case Token.EVAL_USING_DECLARATIONS_UNIT_PARSER:
+	case Token.EVAL_STATEMENT_PARSER:
+	case Token.LAST_KEYWORD:
+	case Token.GENERATE_COMPLETION:
+	case Token.COMPLETE_COMPLETION:
+		return "<internal>";
+
+		// A bit more robust.
+	default:
+		return yyNames [token];
+        }
+}
+
+/* end end end */
+}
+#line default
+namespace yydebug {
+        using System;
+	 internal interface yyDebug {
+		 void push (int state, Object value);
+		 void lex (int state, int token, string name, Object value);
+		 void shift (int from, int to, int errorFlag);
+		 void pop (int state);
+		 void discard (int state, int token, string name, Object value);
+		 void reduce (int from, int to, int rule, string text, int len);
+		 void shift (int from, int to);
+		 void accept (Object value);
+		 void error (string message);
+		 void reject ();
+	 }
+	 
+	 class yyDebugSimple : yyDebug {
+		 void println (string s){
+			 Console.Error.WriteLine (s);
+		 }
+		 
+		 public void push (int state, Object value) {
+			 println ("push\tstate "+state+"\tvalue "+value);
+		 }
+		 
+		 public void lex (int state, int token, string name, Object value) {
+			 println("lex\tstate "+state+"\treading "+name+"\tvalue "+value);
+		 }
+		 
+		 public void shift (int from, int to, int errorFlag) {
+			 switch (errorFlag) {
+			 default:				// normally
+				 println("shift\tfrom state "+from+" to "+to);
+				 break;
+			 case 0: case 1: case 2:		// in error recovery
+				 println("shift\tfrom state "+from+" to "+to
+					     +"\t"+errorFlag+" left to recover");
+				 break;
+			 case 3:				// normally
+				 println("shift\tfrom state "+from+" to "+to+"\ton error");
+				 break;
+			 }
+		 }
+		 
+		 public void pop (int state) {
+			 println("pop\tstate "+state+"\ton error");
+		 }
+		 
+		 public void discard (int state, int token, string name, Object value) {
+			 println("discard\tstate "+state+"\ttoken "+name+"\tvalue "+value);
+		 }
+		 
+		 public void reduce (int from, int to, int rule, string text, int len) {
+			 println("reduce\tstate "+from+"\tuncover "+to
+				     +"\trule ("+rule+") "+text);
+		 }
+		 
+		 public void shift (int from, int to) {
+			 println("goto\tfrom state "+from+" to "+to);
+		 }
+		 
+		 public void accept (Object value) {
+			 println("accept\tvalue "+value);
+		 }
+		 
+		 public void error (string message) {
+			 println("error\t"+message);
+		 }
+		 
+		 public void reject () {
+			 println("reject");
+		 }
+		 
+	 }
+}
+// %token constants
+ class Token {
+  public const int EOF = 257;
+  public const int NONE = 258;
+  public const int ERROR = 259;
+  public const int FIRST_KEYWORD = 260;
+  public const int ABSTRACT = 261;
+  public const int AS = 262;
+  public const int ADD = 263;
+  public const int SUPER = 264;
+  public const int BOOL = 265;
+  public const int BOOLEAN = 266;
+  public const int BREAK = 267;
+  public const int BYTE = 268;
+  public const int CASE = 269;
+  public const int CATCH = 270;
+  public const int CHAR = 271;
+  public const int CHECKED = 272;
+  public const int CLASS = 273;
+  public const int CONST = 274;
+  public const int CONTINUE = 275;
+  public const int DECIMAL = 276;
+  public const int DEFAULT = 277;
+  public const int DELEGATE = 278;
+  public const int DELETE = 279;
+  public const int DO = 280;
+  public const int DOUBLE = 281;
+  public const int DOUBLE2 = 282;
+  public const int DOUBLE3 = 283;
+  public const int DOUBLE4 = 284;
+  public const int DYNAMIC = 285;
+  public const int EACH = 286;
+  public const int ELSE = 287;
+  public const int ENUM = 288;
+  public const int EVENT = 289;
+  public const int EXPLICIT = 290;
+  public const int EXTENDS = 291;
+  public const int FALSE = 292;
+  public const int FINAL = 293;
+  public const int FINALLY = 294;
+  public const int FIXED = 295;
+  public const int FLOAT = 296;
+  public const int FLOAT2 = 297;
+  public const int FLOAT3 = 298;
+  public const int FLOAT4 = 299;
+  public const int FOR = 300;
+  public const int FOR_EACH = 301;
+  public const int FUNCTION = 302;
+  public const int FUNCTION_GET = 303;
+  public const int FUNCTION_SET = 304;
+  public const int GOTO = 305;
+  public const int IF = 306;
+  public const int IMPLICIT = 307;
+  public const int IMPLEMENTS = 308;
+  public const int IMPORT = 309;
+  public const int IN = 310;
+  public const int INDEXER = 311;
+  public const int INSTANCEOF = 312;
+  public const int INT = 313;
+  public const int INTERFACE = 314;
+  public const int INTERNAL = 315;
+  public const int IS = 316;
+  public const int LOCK = 317;
+  public const int LONG = 318;
+  public const int NAMESPACE = 319;
+  public const int NATIVE = 320;
+  public const int NEW = 321;
+  public const int NULL = 322;
+  public const int OBJECT = 323;
+  public const int OPERATOR = 324;
+  public const int OUT = 325;
+  public const int OVERRIDE = 326;
+  public const int OVERLOAD = 327;
+  public const int PACKAGE = 328;
+  public const int PARAMS = 329;
+  public const int PRIVATE = 330;
+  public const int PROPERTY = 331;
+  public const int PROTECTED = 332;
+  public const int PUBLIC = 333;
+  public const int READONLY = 334;
+  public const int REF = 335;
+  public const int RETURN = 336;
+  public const int REMOVE = 337;
+  public const int SBYTE = 338;
+  public const int SHORT = 339;
+  public const int SIZEOF = 340;
+  public const int STACKALLOC = 341;
+  public const int STATIC = 342;
+  public const int STRING = 343;
+  public const int STRUCT = 344;
+  public const int SWITCH = 345;
+  public const int THIS = 346;
+  public const int THROW = 347;
+  public const int TRUE = 348;
+  public const int TRY = 349;
+  public const int TYPEOF = 350;
+  public const int UINT = 351;
+  public const int ULONG = 352;
+  public const int UNCHECKED = 353;
+  public const int UNDEFINED = 354;
+  public const int UNSAFE = 355;
+  public const int USE = 356;
+  public const int USHORT = 357;
+  public const int USING = 358;
+  public const int VAR = 359;
+  public const int VIRTUAL = 360;
+  public const int VOID = 361;
+  public const int VOLATILE = 362;
+  public const int WHERE = 363;
+  public const int WHILE = 364;
+  public const int PARTIAL = 365;
+  public const int ARROW = 366;
+  public const int FROM = 367;
+  public const int FROM_FIRST = 368;
+  public const int JOIN = 369;
+  public const int ON = 370;
+  public const int EQUALS = 371;
+  public const int SELECT = 372;
+  public const int GROUP = 373;
+  public const int BY = 374;
+  public const int LET = 375;
+  public const int ORDERBY = 376;
+  public const int ASCENDING = 377;
+  public const int DESCENDING = 378;
+  public const int INTO = 379;
+  public const int INTERR_NULLABLE = 380;
+  public const int EXTERN = 381;
+  public const int ASYNC = 382;
+  public const int AWAIT = 383;
+  public const int GET = 384;
+  public const int SET = 385;
+  public const int LAST_KEYWORD = 386;
+  public const int OPEN_BRACE = 387;
+  public const int CLOSE_BRACE = 388;
+  public const int OPEN_BRACKET = 389;
+  public const int CLOSE_BRACKET = 390;
+  public const int OPEN_PARENS = 391;
+  public const int CLOSE_PARENS = 392;
+  public const int DOT = 393;
+  public const int DOT_AT = 394;
+  public const int DOT_STAR = 395;
+  public const int DOTDOT = 396;
+  public const int DOTDOT_AT = 397;
+  public const int DOTDOT_STAR = 398;
+  public const int DOTDOTDOT = 399;
+  public const int DOT_OPEN_PARENS = 400;
+  public const int CLOSE_PARENS_DOT = 401;
+  public const int COMMA = 402;
+  public const int COLON = 403;
+  public const int SEMICOLON = 404;
+  public const int TILDE = 405;
+  public const int PLUS = 406;
+  public const int MINUS = 407;
+  public const int BANG = 408;
+  public const int ASSIGN = 409;
+  public const int OP_LT = 410;
+  public const int OP_GT = 411;
+  public const int BITWISE_AND = 412;
+  public const int BITWISE_OR = 413;
+  public const int LOGICAL_AND_ASSIGN = 414;
+  public const int LOGICAL_OR_ASSIGN = 415;
+  public const int STAR = 416;
+  public const int PERCENT = 417;
+  public const int DIV = 418;
+  public const int CARRET = 419;
+  public const int INTERR = 420;
+  public const int DOUBLE_COLON = 421;
+  public const int OP_INC = 422;
+  public const int OP_DEC = 423;
+  public const int OP_SHIFT_LEFT = 424;
+  public const int OP_SHIFT_RIGHT = 425;
+  public const int OP_USHIFT_RIGHT = 426;
+  public const int OP_LE = 427;
+  public const int OP_GE = 428;
+  public const int OP_EQ = 429;
+  public const int OP_REF_EQ = 430;
+  public const int OP_NE = 431;
+  public const int OP_REF_NE = 432;
+  public const int OP_AND = 433;
+  public const int OP_OR = 434;
+  public const int OP_MULT_ASSIGN = 435;
+  public const int OP_DIV_ASSIGN = 436;
+  public const int OP_MOD_ASSIGN = 437;
+  public const int OP_ADD_ASSIGN = 438;
+  public const int OP_SUB_ASSIGN = 439;
+  public const int OP_SHIFT_LEFT_ASSIGN = 440;
+  public const int OP_SHIFT_RIGHT_ASSIGN = 441;
+  public const int OP_USHIFT_RIGHT_ASSIGN = 442;
+  public const int OP_AND_ASSIGN = 443;
+  public const int OP_XOR_ASSIGN = 444;
+  public const int OP_OR_ASSIGN = 445;
+  public const int OP_PTR = 446;
+  public const int OP_COALESCING = 447;
+  public const int OP_IN = 448;
+  public const int OP_AT = 449;
+  public const int OP_GENERICS_LT = 450;
+  public const int OP_GENERICS_LT_DECL = 451;
+  public const int OP_GENERICS_GT = 452;
+  public const int LITERAL = 453;
+  public const int IDENTIFIER = 454;
+  public const int IDENTIFIER_MODIFIER = 455;
+  public const int IDENTIFIER_CONFIG = 456;
+  public const int OPEN_PARENS_LAMBDA = 457;
+  public const int OPEN_PARENS_CAST = 458;
+  public const int GENERIC_DIMENSION = 459;
+  public const int DEFAULT_COLON = 460;
+  public const int OPEN_BRACKET_EXPR = 461;
+  public const int OPEN_BRACE_INIT = 462;
+  public const int EVAL_STATEMENT_PARSER = 463;
+  public const int EVAL_COMPILATION_UNIT_PARSER = 464;
+  public const int EVAL_USING_DECLARATIONS_UNIT_PARSER = 465;
+  public const int DOC_SEE = 466;
+  public const int GENERATE_COMPLETION = 467;
+  public const int COMPLETE_COMPLETION = 468;
+  public const int UMINUS = 469;
+  public const int yyErrorCode = 256;
+ }
+ namespace yyParser {
+  using System;
+  /** thrown for irrecoverable syntax errors and stack overflow.
+    */
+  internal class yyException : System.Exception {
+    public yyException (string message) : base (message) {
+    }
+  }
+  internal class yyUnexpectedEof : yyException {
+    public yyUnexpectedEof (string message) : base (message) {
+    }
+    public yyUnexpectedEof () : base ("") {
+    }
+  }
+
+  /** must be implemented by a scanner object to supply input to the parser.
+    */
+  internal interface yyInput {
+    /** move on to next token.
+        @return false if positioned beyond tokens.
+        @throws IOException on input error.
+      */
+    bool advance (); // throws java.io.IOException;
+    /** classifies current token.
+        Should not be called if advance() returned false.
+        @return current %token or single character.
+      */
+    int token ();
+    /** associated with current token.
+        Should not be called if advance() returned false.
+        @return value for token().
+      */
+    Object value ();
+  }
+ }
+} // close outermost namespace, that MUST HAVE BEEN opened in the prolog
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/ps-parser.jay ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/ps-parser.jay
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/ps-parser.jay	1969-12-31 16:00:00.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/ps-parser.jay	2013-04-23 21:04:54.000000000 -0700
@@ -0,0 +1,9027 @@
+%{
+//
+// ps-parser.jay: The Parser for the PlayScript language
+// Authors: Miguel de Icaza (miguel@gnome.org)
+//          Ravi Pratap     (ravi@ximian.com)
+//          Marek Safar	    (marek.safar@gmail.com)
+//          Ben Cooley	    (bcooley@zynga.com)
+// Dual Licensed under the terms of the GNU GPL and the MIT X11 license
+//
+// (C) 2001 Ximian, Inc (http://www.ximian.com)
+// (C) 2004-2011 Novell, Inc
+// Copyright 2011-2012 Xamarin Inc.
+//
+
+using System.Text;
+using System.IO;
+using System;
+using System.Collections.Generic;
+using Mono.CSharpPs;
+using Linq = Mono.CSharpPs.Linq;
+using Enum = Mono.CSharpPs.Enum;
+using Attribute = Mono.CSharpPs.Attribute;
+using Delegate = Mono.CSharpPs.Delegate;
+using Nullable = Mono.CSharpPs.Nullable;
+
+namespace Mono.PlayScript
+{
+	/// <summary>
+	///    The PlayScript Parser
+	/// </summary>
+	public class PlayScriptParser
+	{
+		[Flags]
+		enum ParameterModifierType
+		{
+			Ref		= 1 << 1,
+			Out		= 1 << 2,
+			This	= 1 << 3,
+			Params	= 1 << 4,
+			Arglist	= 1 << 5,
+			DefaultValue = 1 << 6,
+			
+			All = Ref | Out | This | Params | Arglist | DefaultValue
+		}
+		
+		public bool parsing_playscript = false;
+		
+		static readonly object ModifierNone = 0;
+	
+		const string RootNs = PsConsts.PsRootNamespace;
+	
+		NamespaceContainer current_namespace;
+		NamespaceContainer prev_namespace;
+		NamespaceContainer private_namespace;
+		TypeContainer current_container;
+		TypeDefinition current_type;
+		PropertyBase current_property;
+		EventProperty current_event;
+		EventField current_event_field;
+		FieldBase current_field;
+		Constructor current_constructor;
+		
+		// Set by config params to enable/disable inclusion of methods, fields, consts, classes, structs, etc.
+		bool is_config_enabled = true;
+		
+		bool is_package_function = false;
+	
+		/// <summary>
+		///   Current block is used to add statements as we find
+		///   them.  
+		/// </summary>
+		Block      current_block;
+		
+		BlockVariableDeclaration current_variable;
+
+		Delegate   current_delegate;
+		
+		AnonymousMethodExpression current_anonymous_method;
+
+		/// <summary>
+		///   This is used by the unary_expression code to resolve
+		///   a name against a parameter.  
+		/// </summary>
+		
+		// FIXME: This is very ugly and it's very hard to reset it correctly
+		// on all places, especially when some parameters are autogenerated.
+		ParametersCompiled current_local_parameters;
+
+		bool parsing_anonymous_method;
+		
+		bool async_block;
+
+		///
+		/// An out-of-band stack.
+		///
+		Stack<object> oob_stack;
+
+		///
+		/// Controls the verbosity of the errors produced by the parser
+		///
+		int yacc_verbose_flag;
+
+		/// 
+		/// Used by the interactive shell, flags whether EOF was reached
+		/// and an error was produced
+		///
+		public bool UnexpectedEOF;
+
+		///
+		/// The current file.
+		///
+		readonly CompilationSourceFile file;
+
+		///
+		/// Temporary Xml documentation cache.
+		/// For enum types, we need one more temporary store.
+		///
+		string tmpComment;
+		string enumTypeComment;
+	       		
+		/// Current attribute target
+		string current_attr_target;
+		
+		ParameterModifierType valid_param_mod;
+		
+		bool default_parameter_used;
+
+		/// When using the interactive parser, this holds the
+		/// resulting expression
+		public Class InteractiveResult;
+
+		// Current modifier namespace identifier
+		public string ns_modifier;
+
+		//
+		// Keeps track of global data changes to undo on parser error
+		//
+		public Undo undo;
+		
+		Stack<Linq.QueryBlock> linq_clause_blocks;
+
+		ModuleContainer module;
+		
+		readonly CompilerContext compiler;
+		readonly LanguageVersion lang_version;
+		readonly bool doc_support;
+		readonly CompilerSettings settings;
+		readonly Report report;
+		
+		//
+		// Instead of allocating carrier array everytime we
+		// share the bucket for very common constructs which can never
+		// be recursive
+		//
+		List<Parameter> parameters_bucket;
+		
+		//
+		// Full AST support members
+		//
+		LocationsBag lbag;
+		List<Tuple<Modifiers, Location>> mod_locations;
+		Location parameterModifierLocation, savedLocation, savedOpenLocation, savedCloseLocation, savedEventAssignLocation;
+		Location savedAttrParenOpenLocation, savedAttrParenCloseLocation, savedOperatorLocation;
+		Stack<List<Location>> locationListStack = new Stack<List<Location>> (); // used for type parameters
+		Stack<Location> opt_intoStack = new Stack<Location> ();
+
+		bool HadAttributeParens;
+		List<Location> attributeCommas = new List<Location> ();
+		List<Location> attributeArgumentCommas = new List<Location> ();
+		List<Location> parameterListCommas = new List<Location> ();
+%}
+
+%token EOF
+%token NONE   /* This token is never returned by our lexer */
+%token ERROR		// This is used not by the parser, but by the tokenizer.
+			// do not remove.
+
+/*
+ *These are the C# keywords
+ */
+%token FIRST_KEYWORD
+%token ABSTRACT	
+%token AS
+%token ADD
+%token SUPER	
+%token BOOL
+%token BOOLEAN	
+%token BREAK	
+%token BYTE	
+%token CASE	
+%token CATCH
+%token CHAR	
+%token CHECKED	
+%token CLASS	
+%token CONST	
+%token CONTINUE	
+%token DECIMAL	
+%token DEFAULT	
+%token DELEGATE	
+%token DELETE
+%token DO	
+%token DOUBLE
+%token DOUBLE2
+%token DOUBLE3
+%token DOUBLE4
+%token DYNAMIC
+%token EACH	
+%token ELSE	
+%token ENUM	
+%token EVENT	
+%token EXPLICIT
+%token EXTENDS	
+%token FALSE
+%token FINAL	
+%token FINALLY	
+%token FIXED	
+%token FLOAT
+%token FLOAT2
+%token FLOAT3
+%token FLOAT4
+%token FOR	
+%token FOR_EACH	
+%token FUNCTION 
+%token FUNCTION_GET
+%token FUNCTION_SET
+%token GOTO	
+%token IF	
+%token IMPLICIT	
+%token IMPLEMENTS
+%token IMPORT
+%token IN
+%token INDEXER	
+%token INSTANCEOF
+%token INT	
+%token INTERFACE
+%token INTERNAL	
+%token IS	
+%token LOCK	
+%token LONG	
+%token NAMESPACE
+%token NATIVE	
+%token NEW	
+%token NULL	
+%token OBJECT	
+%token OPERATOR	
+%token OUT	
+%token OVERRIDE
+%token OVERLOAD
+%token PACKAGE
+%token PARAMS	
+%token PRIVATE
+%token PROPERTY	
+%token PROTECTED
+%token PUBLIC	
+%token READONLY	
+%token REF	
+%token RETURN	
+%token REMOVE
+%token SBYTE	
+%token SHORT	
+%token SIZEOF	
+%token STACKALLOC
+%token STATIC	
+%token STRING	
+%token STRUCT	
+%token SWITCH	
+%token THIS	
+%token THROW	
+%token TRUE	
+%token TRY	
+%token TYPEOF	
+%token UINT	
+%token ULONG	
+%token UNCHECKED
+%token UNDEFINED
+%token UNSAFE
+%token USE	
+%token USHORT	
+%token USING	
+%token VAR
+%token VIRTUAL	
+%token VOID	
+%token VOLATILE
+%token WHERE
+%token WHILE	
+%token PARTIAL
+%token ARROW
+%token FROM
+%token FROM_FIRST
+%token JOIN
+%token ON
+%token EQUALS
+%token SELECT
+%token GROUP
+%token BY
+%token LET
+%token ORDERBY
+%token ASCENDING
+%token DESCENDING
+%token INTO
+%token INTERR_NULLABLE
+%token EXTERN
+%token ASYNC
+%token AWAIT
+
+/* C# keywords which are not really keywords */
+%token GET
+%token SET
+
+%left LAST_KEYWORD
+
+/* C# single character operators/punctuation. */
+%token OPEN_BRACE
+%token CLOSE_BRACE
+%token OPEN_BRACKET
+%token CLOSE_BRACKET
+%token OPEN_PARENS
+%token CLOSE_PARENS
+
+%token DOT
+%token DOT_AT
+%token DOT_STAR
+%token DOTDOT
+%token DOTDOT_AT
+%token DOTDOT_STAR
+%token DOTDOTDOT
+%token DOT_OPEN_PARENS
+%token CLOSE_PARENS_DOT
+%token COMMA
+%token COLON
+%token SEMICOLON
+%token TILDE
+
+%token PLUS
+%token MINUS
+%token BANG
+%token ASSIGN
+%token OP_LT
+%token OP_GT
+%token BITWISE_AND
+%token BITWISE_OR
+%token LOGICAL_AND_ASSIGN
+%token LOGICAL_OR_ASSIGN
+%token STAR
+%token PERCENT
+%token DIV
+%token CARRET
+%token INTERR
+
+/* C# multi-character operators. */
+%token DOUBLE_COLON
+%token OP_INC
+%token OP_DEC
+%token OP_SHIFT_LEFT
+%token OP_SHIFT_RIGHT
+%token OP_USHIFT_RIGHT
+%token OP_LE
+%token OP_GE
+%token OP_EQ
+%token OP_REF_EQ
+%token OP_NE
+%token OP_REF_NE
+%token OP_AND
+%token OP_OR
+%token OP_MULT_ASSIGN
+%token OP_DIV_ASSIGN
+%token OP_MOD_ASSIGN
+%token OP_ADD_ASSIGN
+%token OP_SUB_ASSIGN
+%token OP_SHIFT_LEFT_ASSIGN
+%token OP_SHIFT_RIGHT_ASSIGN
+%token OP_USHIFT_RIGHT_ASSIGN
+%token OP_AND_ASSIGN
+%token OP_XOR_ASSIGN
+%token OP_OR_ASSIGN
+%token OP_PTR
+%token OP_COALESCING
+%token OP_IN
+%token OP_AT
+
+/* Generics <,> tokens */
+%token OP_GENERICS_LT
+%token OP_GENERICS_LT_DECL
+%token OP_GENERICS_GT
+
+%token LITERAL
+
+%token IDENTIFIER
+%token IDENTIFIER_MODIFIER
+%token IDENTIFIER_CONFIG
+%token OPEN_PARENS_LAMBDA
+%token OPEN_PARENS_CAST
+%token GENERIC_DIMENSION
+%token DEFAULT_COLON
+%token OPEN_BRACKET_EXPR
+%token OPEN_BRACE_INIT
+
+// Make the parser go into eval mode parsing (statements and compilation units).
+%token EVAL_STATEMENT_PARSER
+%token EVAL_COMPILATION_UNIT_PARSER
+%token EVAL_USING_DECLARATIONS_UNIT_PARSER
+
+%token DOC_SEE
+
+// 
+// This token is generated to trigger the completion engine at this point
+//
+%token GENERATE_COMPLETION
+
+//
+// This token is return repeatedly after the first GENERATE_COMPLETION
+// token is produced and before the final EOF
+//
+%token COMPLETE_COMPLETION
+
+/* Add precedence rules to solve dangling else s/r conflict */
+%nonassoc IF
+%nonassoc ELSE
+
+/* Define the operator tokens and their precedences */
+%right ASSIGN
+%right OP_COALESCING
+%right INTERR
+%left OP_OR
+%left OP_AND
+%left BITWISE_OR
+%left BITWISE_AND
+%left OP_SHIFT_LEFT OP_SHIFT_RIGHT
+%left PLUS MINUS
+%left STAR DIV PERCENT
+%right BANG CARRET UMINUS
+%nonassoc OP_INC OP_DEC
+%left OPEN_PARENS
+%left NEW
+%left OPEN_BRACKET OPEN_BRACE
+%left DOT
+
+%start compilation_unit
+%%
+
+compilation_unit
+	: outer_declaration opt_EOF
+	  {
+		Lexer.check_incorrect_doc_comment ();
+	  }
+	| interactive_parsing  { Lexer.CompleteOnEOF = false; } opt_EOF
+	| documentation_parsing
+	;
+	
+outer_declaration
+	: opt_extern_alias_directives opt_package_directives
+	| opt_extern_alias_directives opt_package_directives package_declaration opt_attributes
+	  {
+		if ($4 != null) {
+			Attributes attrs = (Attributes) $4;
+			report.Error (1730, attrs.Attrs [0].Location,
+				"Assembly and module attributes must precede all other elements except using clauses and extern alias declarations");
+
+			current_namespace.UnattachedAttributes = attrs;
+		}
+	  }
+	| opt_extern_alias_directives opt_package_directives attribute_sections
+	  {
+		module.AddAttributes ((Attributes) $3, current_namespace);
+	  }
+	| error
+	  {
+		if (yyToken == Token.EXTERN)
+			report.Error (439, lexer.Location, "An extern alias declaration must precede all other elements");
+		else
+			Error_SyntaxError (yyToken);
+	  }
+	;
+	
+opt_EOF
+	: /* empty */
+	| EOF
+	;
+
+extern_alias_directives
+	: extern_alias_directive
+	| extern_alias_directives extern_alias_directive
+	;
+
+extern_alias_directive
+	: EXTERN IDENTIFIER IDENTIFIER SEMICOLON
+	  {
+		var lt = (Tokenizer.LocatedToken) $2;
+		string s = lt.Value;
+		if (s != "alias") {
+			syntax_error (lt.Location, "`alias' expected");
+		} else {
+			if (lang_version == LanguageVersion.ISO_1)
+				FeatureIsNotAvailable (lt.Location, "external alias");
+
+			lt = (Tokenizer.LocatedToken) $3;
+			if (lt.Value == QualifiedAliasMember.GlobalAlias) {
+				RootNamespace.Error_GlobalNamespaceRedefined (report, lt.Location);
+			}
+			
+			var na = new UsingExternAlias (new SimpleMemberName (lt.Value, lt.Location), GetLocation ($1));
+			current_namespace.AddUsing (na);
+			
+			lbag.AddLocation (na, GetLocation ($2), GetLocation ($4));
+		}
+	  }
+	| EXTERN error
+	  {
+		Error_SyntaxError (yyToken);
+	  }
+	;
+ 
+no_config_package_directive
+	: import_directive
+	| use_namespace_directive
+	; 
+ 
+package_directive
+	: no_config_package_directive
+	| config_package_directive
+	;
+
+config_package_directive
+	: IDENTIFIER_CONFIG 
+	  {
+		var lt = (Tokenizer.LocatedToken) $1;
+	    is_config_enabled = file.IsConditionalDefined (lt.Value.Replace("::","_"));	  
+	  } 
+	  no_config_package_directive
+	  {
+	  	is_config_enabled = true;
+	  	$$ = $3;
+	  }
+	| IDENTIFIER_CONFIG 
+	  {
+		var lt = (Tokenizer.LocatedToken) $1;
+	    is_config_enabled = file.IsConditionalDefined (lt.Value.Replace("::","_"));	  
+	  } 
+	  OPEN_BRACE opt_package_directives CLOSE_BRACE
+	  {
+	  	is_config_enabled = true;
+	  	$$ = $4;
+	  }
+	; 
+   
+package_directives
+    : package_directive
+    | package_directives package_directive
+    ;
+
+use_namespace_directive
+	: use_namespace
+	  {
+		if (doc_support)
+			Lexer.doc_state = XmlCommentState.Allowed;
+	  }
+	;
+
+use_namespace
+	: USE NAMESPACE IDENTIFIER SEMICOLON
+	;
+ 
+import_directive
+	: import_package
+	  {
+		if (doc_support)
+			Lexer.doc_state = XmlCommentState.Allowed;
+	  }
+	;
+
+import_package
+	: IMPORT namespace_or_type_expr
+	  {
+	    Lexer.AllowAutoSemiAfterToken(Token.DOT_STAR, true);
+	  }
+	  DOT_STAR SEMICOLON 
+	  {
+	    if (is_config_enabled) {
+			var un = new UsingNamespace ((ATypeNameExpression) $2, GetLocation ($1));
+		  	current_namespace.AddUsing (un);
+		
+			lbag.AddLocation (un, GetLocation ($5));
+			
+		    Lexer.AllowAutoSemiAfterToken(Token.DOT_STAR, false);
+		}
+	  }	
+	| IMPORT typeof_type_expression SEMICOLON 
+	  {
+	    if (is_config_enabled) {
+			var ut = new UsingType ((ATypeNameExpression) $2, GetLocation ($1));
+			current_namespace.AddUsing (ut);
+		
+			lbag.AddLocation (ut, GetLocation ($3));
+		}
+	  }
+	| IMPORT IDENTIFIER ASSIGN namespace_or_type_expr SEMICOLON
+	  {
+	    if (is_config_enabled) {
+			var lt = (Tokenizer.LocatedToken) $2;
+			if (lang_version != LanguageVersion.ISO_1 && lt.Value == "global") {
+				report.Warning (440, 2, lt.Location,
+				 "An alias named `global' will not be used when resolving `global::'. The global namespace will be used instead");
+			}
+
+			var un = new UsingAliasNamespace (new SimpleMemberName (lt.Value, lt.Location), (ATypeNameExpression) $4, GetLocation ($1));
+			current_namespace.AddUsing (un);
+		
+			lbag.AddLocation (un, GetLocation ($3), GetLocation ($5));
+		}
+	  }
+	| IMPORT error
+	  {
+		Error_SyntaxError (yyToken);
+		$$ = null;
+	  }
+	;
+
+//
+// Strictly speaking, namespaces don't have attributes but
+// we parse global attributes along with namespace declarations and then
+// detach them
+// 
+package_declaration
+	: opt_attributes PACKAGE 
+	  {
+	  	Lexer.AutoSemiInsertion = false;
+	  }
+	  opt_package_name
+	  {
+		Attributes attrs = (Attributes) $1;
+		var name = $4 as MemberName;
+		if (name == null) {
+			name = new MemberName(RootNs);
+		}
+		if (attrs != null) {
+			bool valid_global_attrs = true;
+			if ((current_namespace.DeclarationFound || current_namespace != file)) {
+				valid_global_attrs = false;
+			} else {
+				foreach (var a in attrs.Attrs) {
+					if (a.ExplicitTarget == "assembly" || a.ExplicitTarget == "module")
+						continue;
+						
+					valid_global_attrs = false;
+					break;
+				}
+			}
+			
+			if (!valid_global_attrs)
+				report.Error (1671, name.Location, "A namespace declaration cannot have modifiers or attributes");
+		}
+	
+		module.AddAttributes (attrs, current_namespace);
+		
+	    // Close the private package namespace (if it's active)
+	  	if (current_namespace == private_namespace) {
+	  		if (private_namespace.Containers.Count > 0) {
+		  		prev_namespace.AddTypeContainer(private_namespace);
+				var priv_un = new UsingNamespace (
+					private_namespace.NS.MakeTypeNameExpression(GetLocation($1)), GetLocation ($1));
+				prev_namespace.AddUsing(priv_un, true);
+			}
+			current_container = current_namespace = prev_namespace.Parent;
+			prev_namespace = private_namespace = null; 
+	  	}
+		
+		var ns = new NamespaceContainer (name, current_namespace);
+		current_namespace.AddTypeContainer (ns);
+		current_container = current_namespace = ns;
+		var un = new UsingNamespace (new SimpleName (RootNs, GetLocation ($1)), GetLocation ($1));
+		current_namespace.AddUsing(un, true);
+	  }
+	  OPEN_BRACE
+	  {
+		if (doc_support)
+			Lexer.doc_state = XmlCommentState.Allowed;
+			
+		Lexer.AutoSemiInsertion = true;
+	  }
+	  opt_package_statements_or_blocks CLOSE_BRACE
+	  {
+	  	lbag.AddLocation (current_container, GetLocation ($2), GetLocation ($6), GetLocation ($8));
+	  
+	  	if (current_namespace.Parent != null && current_namespace.Parent.Parent == null) { // Is this the top level package?
+			var ns = new NamespaceContainer (new MemberName("__" + file.FileName.Replace(".","_")), current_namespace);
+			prev_namespace = current_namespace;
+			current_container = private_namespace = current_namespace = ns;
+	    } else {
+			current_container = current_namespace = current_namespace.Parent;
+		}
+		
+		lexer.parsing_modifiers = false;
+	  }
+	  opt_package_statements_or_blocks
+	  {
+	    // Close the private package namespace (if it's active)
+	  	if (current_namespace == private_namespace) {
+	  		if (private_namespace.Containers.Count > 0) {
+		  		prev_namespace.AddTypeContainer(private_namespace);
+				var priv_un = new UsingNamespace (
+					private_namespace.NS.MakeTypeNameExpression(GetLocation($1)), GetLocation ($1));
+				prev_namespace.AddUsing(priv_un, true);
+			}
+			current_container = current_namespace = prev_namespace.Parent;
+			prev_namespace = private_namespace = null; 
+	  	}
+	  
+//	  	lbag.AddLocation (current_container, GetLocation ($2), GetLocation ($6), GetLocation ($11));
+	  }
+	;
+
+opt_package_name
+	: /* empty */
+	| package_name
+	;
+
+package_name
+	: IDENTIFIER
+	  {
+		var lt = (Tokenizer.LocatedToken) $1;
+		$$ = new MemberName (lt.Value, lt.Location);
+	  }
+	| package_name DOT IDENTIFIER
+	  {
+		var lt = (Tokenizer.LocatedToken) $3;
+		$$ = new MemberName ((MemberName) $1, lt.Value, lt.Location);		
+	  }
+	| error
+	  {
+		Error_SyntaxError (yyToken);
+		$$ = new MemberName ("<invalid>", lexer.Location);
+	  }
+	;
+
+opt_semicolon
+	: /* empty */
+	| SEMICOLON
+	;
+
+opt_comma
+	: /* empty */
+	| COMMA
+	;
+
+opt_package_statements_or_blocks
+	: opt_extern_alias_directives opt_package_statements
+	| OPEN_BRACE opt_package_statements_or_blocks CLOSE_BRACE
+	;
+	
+opt_package_directives
+	: /* empty */
+	| package_directives
+	;
+
+opt_extern_alias_directives
+	: /* empty */
+	| extern_alias_directives
+	;
+
+opt_package_statements
+	: /* empty */
+	| package_statements
+	;
+
+package_statements
+	: package_statement
+	| package_statements package_statement
+	;
+
+package_statement
+	: no_config_package_statement
+	| config_package_statement
+	| attribute_sections CLOSE_BRACE {
+		current_namespace.UnattachedAttributes = (Attributes) $1;
+		report.Error (1518, lexer.Location, "Attributes must be attached to class, delegate, enum, interface or struct");
+		lexer.putback ('}');
+		is_config_enabled = true;		
+	  }
+	;
+
+no_config_package_statement
+	: type_declaration
+	  {
+	    if (is_config_enabled) {
+			if ($1 != null) {
+				TypeContainer ds = (TypeContainer)$1;
+
+				if ((ds.ModFlags & (Modifiers.PRIVATE | Modifiers.PROTECTED)) != 0){
+					report.Error (1527, ds.Location, 
+					"Namespace elements cannot be explicitly declared as private, protected or protected internal");
+				}
+
+				// Here is a trick, for explicit attributes we don't know where they belong to until
+				// we parse succeeding declaration hence we parse them as normal and re-attach them
+				// when we know whether they are global (assembly:, module:) or local (type:).
+				if (ds.OptAttributes != null) {
+					ds.OptAttributes.ConvertGlobalAttributes (ds, current_namespace, !current_namespace.DeclarationFound && current_namespace == file);
+				}
+			}
+			current_namespace.DeclarationFound = true;
+		}
+	  }
+	| method_declaration
+	  {
+	  	if (is_config_enabled) {
+			current_namespace.DeclarationFound = true;
+		}
+	  }
+	| no_config_package_directive	  
+	;
+
+config_package_statement
+	: IDENTIFIER_CONFIG 
+	  {
+		var lt = (Tokenizer.LocatedToken) $1;
+	    is_config_enabled = file.IsConditionalDefined (lt.Value.Replace("::","_"));	 	  
+	  }
+	  no_config_package_statement
+	  {
+	    is_config_enabled = true;
+	    $$ = $3;
+	  }
+	| IDENTIFIER_CONFIG 
+	  {
+		var lt = (Tokenizer.LocatedToken) $1;
+	    is_config_enabled = file.IsConditionalDefined (lt.Value.Replace("::","_"));	  
+	  } 
+	  OPEN_BRACE opt_package_statements CLOSE_BRACE
+	  {
+	  	is_config_enabled = true;
+	  	$$ = $4;
+	  }	  
+	;
+
+type_declaration
+	: class_declaration	
+	| struct_declaration
+	| interface_declaration
+	| enum_declaration		
+	| delegate_declaration
+	| namespace_declaration	
+	;
+		
+//
+// Enable this when we have handled all errors, because this acts as a generic fallback
+//
+//	| error {
+//		Console.WriteLine ("Token=" + yyToken);
+//		report.Error (1518, GetLocation ($1), "Expected class, struct, interface, enum or delegate");
+//	  }
+	;
+
+//
+// Attributes
+//
+
+opt_attributes
+	: /* empty */ 
+	| attribute_sections
+    ;
+ 
+attribute_sections
+	: attribute_section
+	  {
+		var sect = $1 as List<Attribute>;
+		if (sect != null) {
+			$$ = new Attributes (sect);
+		}
+	  }
+	| attribute_sections attribute_section
+	  {
+		Attributes attrs = $1 as Attributes;
+		var sect = $2 as List<Attribute>;
+		if (sect != null) {
+			if (attrs == null)
+				attrs = new Attributes (sect);
+			else
+				attrs.AddAttributes (sect);
+		}
+		$$ = attrs;
+	  }
+	;
+	
+attribute_section
+	: OPEN_BRACKET
+	  {
+		lexer.parsing_attribute_section = true;
+	  }
+	  attribute_section_cont
+	  {
+		lexer.parsing_attribute_section = false;
+		$$ = $3;
+	  }
+	;
+	
+attribute_section_cont
+	: attribute_target COLON
+	  {
+		current_attr_target = (string) $1;
+		if (current_attr_target == "assembly" || current_attr_target == "module") {
+			Lexer.check_incorrect_doc_comment ();
+		}
+	  }
+	  attribute_list opt_comma CLOSE_BRACKET
+	  {
+		// when attribute target is invalid
+		if (current_attr_target == string.Empty)
+			$$ = new List<Attribute> (0);
+		else
+			$$ = $4;
+	  
+		current_attr_target = null;
+		lexer.parsing_attribute_section = false;
+		lexer.AutoSemiInsertionAfter = 1;
+ 	  }
+	| attribute_list opt_comma CLOSE_BRACKET
+	  {
+		lexer.AutoSemiInsertionAfter = 1;
+		$$ = $1;
+	  }
+	;	
+
+attribute_target
+	: IDENTIFIER
+	  {
+		var lt = (Tokenizer.LocatedToken) $1;
+		$$ = CheckAttributeTarget (lt.Value, lt.Location);
+	  }
+	| EVENT  { $$ = "event"; }
+	| RETURN { $$ = "return"; }
+	| error
+	  {
+		if (yyToken == Token.IDENTIFIER) {
+			Error_SyntaxError (yyToken);
+			$$ = null;
+		} else {
+			string name = GetTokenName (yyToken);
+			$$ = CheckAttributeTarget (name, GetLocation ($1));
+		}
+	  }
+	;
+
+attribute_list
+	: attribute
+	  {
+		$$ = new List<Attribute> (4) { (Attribute) $1 };
+	  }
+	| attribute_list COMMA attribute
+	  {
+		var attrs = (List<Attribute>) $1;
+		attrs.Add ((Attribute) $3);
+
+		$$ = attrs;
+	  }
+	;
+
+attribute
+	: attribute_name
+	  {
+		++lexer.parsing_block;
+	  }
+	  opt_attribute_arguments
+	  {
+		--lexer.parsing_block;
+		
+		var tne = (ATypeNameExpression) $1;
+		if (tne.HasTypeArguments) {
+			report.Error (404, tne.Location, "Attributes cannot be generic");
+		}
+
+		$$ = new Attribute (current_attr_target, tne, (Arguments[]) $3, GetLocation ($1), lexer.IsEscapedIdentifier (tne));
+	  }
+	;
+
+attribute_name
+	: namespace_or_type_expr
+	;
+
+opt_attribute_arguments
+	: /* empty */   { $$ = null; }
+	| OPEN_PARENS attribute_arguments CLOSE_PARENS
+	  {
+	    lexer.AutoSemiInsertionAfter = 1;
+		$$ = $2;
+	  }
+	;
+
+
+attribute_arguments
+	: /* empty */ 		{ $$ = null; } 
+	| positional_or_named_argument
+	  {
+	  	Arguments a = new Arguments (4);
+		a.Add ((Argument) $1);
+		$$ = new Arguments [] { a, null };
+	  }
+	| named_attribute_argument
+	  {
+	  	Arguments a = new Arguments (4);
+		a.Add ((Argument) $1);  
+		$$ = new Arguments [] { null, a };
+	  }
+    | attribute_arguments COMMA positional_or_named_argument
+	  {
+		Arguments[] o = (Arguments[]) $1;
+		if (o [1] != null) {
+			report.Error (1016, ((Argument) $3).Expr.Location, "Named attribute arguments must appear after the positional arguments");
+			o [0] = new Arguments (4);
+		}
+		
+		Arguments args = ((Arguments) o [0]);
+		if (args.Count > 0 && !($3 is NamedArgument) && args [args.Count - 1] is NamedArgument)
+			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
+		
+		args.Add ((Argument) $3);
+	  }
+    | attribute_arguments COMMA named_attribute_argument
+	  {
+		Arguments[] o = (Arguments[]) $1;
+		if (o [1] == null) {
+			o [1] = new Arguments (4);
+		}
+
+		((Arguments) o [1]).Add ((Argument) $3);
+	  }
+    ;
+
+positional_or_named_argument
+	: expression
+	  {
+	  	$$ = new Argument ((Expression) $1);
+	  }
+	| named_argument
+	;
+
+named_attribute_argument
+	: IDENTIFIER ASSIGN
+	  {
+		++lexer.parsing_block;
+	  }
+	  expression
+	  {
+	  	--lexer.parsing_block;
+	  	var lt = (Tokenizer.LocatedToken) $1;
+		$$ = new NamedArgument (lt.Value, lt.Location, (Expression) $4);	  
+		lbag.AddLocation ($$, GetLocation($2));
+	  }
+	;
+	
+named_argument
+	: identifier_inside_body COLON opt_named_modifier expression
+	  {
+		if (lang_version <= LanguageVersion.V_3)
+			FeatureIsNotAvailable (GetLocation ($1), "named argument");
+			
+		// Avoid boxing in common case (no modifier)
+		var arg_mod = $3 == null ? Argument.AType.None : (Argument.AType) $3;
+			
+		var lt = (Tokenizer.LocatedToken) $1;
+		$$ = new NamedArgument (lt.Value, lt.Location, (Expression) $4, arg_mod);
+		lbag.AddLocation ($$, GetLocation($2));
+	  }
+	;
+	
+opt_named_modifier
+	: /* empty */   { $$ = null; }
+	| REF
+	  { 
+	  	CheckIsPlayScript("ref parameters", GetLocation($1));
+		$$ = Argument.AType.Ref;
+	  }
+	| OUT
+	  { 
+	  	CheckIsPlayScript("out parameters", GetLocation($1));
+		$$ = Argument.AType.Out;
+	  }
+	;
+		  
+opt_class_member_declarations
+	: /* empty */
+	| class_member_declarations
+	;
+
+class_member_declarations
+	: class_member_declaration
+	  {
+		lexer.parsing_modifiers = true;
+	  }
+	| class_member_declarations class_member_declaration
+	  {
+		lexer.parsing_modifiers = true;
+	  }
+	;
+	
+class_member_declaration
+	: constant_declaration
+	| field_declaration
+	| method_declaration
+	| property_declaration
+	| event_declaration
+	| indexer_declaration
+	| operator_declaration
+//	| constructor_declaration
+	| destructor_declaration
+	| type_declaration
+	| member_config_block
+	| config_member_declaration	
+	| attributes_without_members
+	| use_namespace_class_directive
+	| import_class_directive
+	| error
+	  {
+		report.Error (1519, lexer.Location, "Unexpected symbol `{0}' in class, struct, or interface member declaration",
+			GetSymbolName (yyToken));
+		$$ = null;
+		lexer.parsing_generic_declaration = false;
+	  }
+	;
+	
+use_namespace_class_directive
+	: opt_attributes
+	  opt_modifiers
+	  use_namespace_directive
+	  {
+	  	if ($1 != null || (Modifiers) $2 != 0) {
+			report.Error (7058, GetLocation($1 ?? $2), "Modifiers and attributes not allowed");
+	  	}
+	  }
+	;
+
+import_class_directive
+	: opt_attributes
+	  opt_modifiers
+	  import_directive
+	  {
+	  	if ($1 != null || (Modifiers) $2 != 0) {
+			report.Error (7058, GetLocation($1 ?? $2), "Modifiers and attributes not allowed");
+	  	}
+	  }
+	;
+
+config_member_declaration
+	: IDENTIFIER_CONFIG
+	  {
+		var lt = (Tokenizer.LocatedToken) $1;
+	    is_config_enabled = file.IsConditionalDefined (lt.Value.Replace("::","_"));	  
+	  }
+	  class_member_declaration
+	  {
+	    is_config_enabled = true;
+	    $$ = $3;
+	  }
+	;
+	  
+
+member_config_block
+	: IDENTIFIER_CONFIG 
+	  {
+		var lt = (Tokenizer.LocatedToken) $1;
+	    is_config_enabled = file.IsConditionalDefined (lt.Value.Replace("::","_"));	  
+	  } 
+	  OPEN_BRACE opt_class_member_declarations CLOSE_BRACE
+	  {
+	  	is_config_enabled = true;
+	  	$$ = $4;
+	  }
+	;	  
+
+struct_declaration
+	: opt_attributes
+	  opt_modifiers
+	  opt_partial
+	  STRUCT
+	  {
+		lexer.AutoSemiInsertion = false;
+	  }
+	  type_declaration_name
+	  {
+		lexer.ConstraintsParsing = true;	  
+	  	bool is_partial = IsPartial($1) || $3 != null;
+		push_current_container (new Struct (current_container, (MemberName) $6, (Modifiers) $2, (Attributes) $1), is_partial);
+		lbag.AddMember (current_container, GetModifierLocations (), GetLocation ($4));
+	  }
+	  opt_class_extends
+	  opt_class_implements
+	  opt_type_parameter_constraints_clauses
+	  {
+		lexer.ConstraintsParsing = false;
+
+		if ($10 != null)
+			current_container.SetConstraints ((List<Constraints>) $10);
+
+		if (doc_support)
+			current_container.PartialContainer.DocComment = Lexer.consume_doc_comment ();
+
+		
+		lexer.parsing_modifiers = true;
+		lexer.AutoSemiInsertion = true;
+	  }
+	  OPEN_BRACE
+	  {
+		if (doc_support)
+			Lexer.doc_state = XmlCommentState.Allowed;
+		lexer.DynamicParsing = false;
+	  }
+	  opt_class_member_declarations CLOSE_BRACE
+	  {
+		lexer.DynamicParsing = true;
+		--lexer.parsing_declaration;
+		if (doc_support)
+			Lexer.doc_state = XmlCommentState.Allowed;
+	  }
+	  opt_semicolon
+	  {
+		if ($17 == null) {
+			lbag.AppendToMember (current_container, GetLocation ($12), GetLocation ($15));
+		} else {
+			lbag.AppendToMember (current_container, GetLocation ($12), GetLocation ($15), GetLocation ($17));
+		}
+		$$ = pop_current_class ();
+	  }
+	| opt_attributes opt_modifiers opt_partial STRUCT error
+	  {
+		Error_SyntaxError (yyToken);
+	  }
+	;
+	
+constant_declaration
+	: opt_attributes 
+	  opt_modifiers
+	  CONST IDENTIFIER COLON type
+	  {
+		var lt = (Tokenizer.LocatedToken) $4;
+		var mod = (Modifiers) $2;
+		mod &= ~Modifiers.STATIC;
+		current_field = new Const (current_type, (FullNamedExpression) $6, mod, new MemberName (lt.Value, lt.Location), (Attributes) $1);
+		if (is_config_enabled) {
+			current_type.AddMember (current_field);
+		}
+		is_config_enabled = true;
+				
+		$$ = current_field;
+	  }
+	  opt_constant_initializer opt_constant_declarators SEMICOLON
+	  {
+		if (doc_support) {
+			current_field.DocComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.Allowed;
+		}
+		
+		current_field.Initializer = (ConstInitializer) $8;
+		lbag.AddMember (current_field, GetModifierLocations (), GetLocation ($3), GetLocation ($10));
+		current_field = null;
+	  }
+	;
+	
+opt_constant_declarators
+	: /* empty */
+	| constant_declarators
+	;
+	
+constant_declarators
+	: constant_declarator
+	  {
+		current_field.AddDeclarator ((FieldDeclarator) $1);
+	  }
+	| constant_declarators constant_declarator
+	  {
+		current_field.AddDeclarator ((FieldDeclarator) $2);
+	  }
+	;
+	
+constant_declarator
+	: COMMA IDENTIFIER COLON member_type opt_constant_initializer
+	  {
+		var lt = (Tokenizer.LocatedToken) $2;
+	  	$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) $5, (FullNamedExpression) $4);
+	  	lbag.AddLocation ($$, GetLocation ($1));
+	  }
+	;		
+
+opt_constant_initializer
+	: /* empty */ { $$ = null; }
+	| constant_initializer
+	;
+
+constant_initializer
+	: ASSIGN
+	  {
+		++lexer.parsing_block;
+	  }
+	  constant_initializer_expr
+	  {
+		--lexer.parsing_block;
+		$$ = new ConstInitializer (current_field, (Expression) $3, GetLocation ($1));
+	  }
+	| error
+	  {
+		report.Error (145, lexer.Location, "A const field requires a value to be provided");
+		$$ = null;
+	  }	  
+	;
+	
+constant_initializer_expr
+	: constant_expression
+	;
+
+field_declaration
+	: opt_attributes
+	  opt_modifiers
+	  VAR IDENTIFIER COLON member_type
+	  {
+	  	lexer.parsing_generic_declaration = false;
+
+		FullNamedExpression type = (FullNamedExpression) $6;
+		if (type.Type != null && type.Type.Kind == MemberKind.Void)
+			report.Error (670, GetLocation ($6), "Fields cannot have void type");
+			
+		var lt = (Tokenizer.LocatedToken) $4;
+		current_field = new Field (current_type, type, (Modifiers) $2, new MemberName (lt.Value, lt.Location), (Attributes) $1);
+		if (is_config_enabled) {
+			current_type.AddField (current_field);
+		}
+		is_config_enabled = true;
+		$$ = current_field;
+	  }
+	  opt_field_initializer
+	  opt_field_declarators
+	  SEMICOLON
+	  { 
+		if (doc_support) {
+			current_field.DocComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.Allowed;
+		}
+			
+		lbag.AddMember (current_field, GetModifierLocations (), GetLocation ($10));
+		$$ = current_field;
+		current_field = null;
+	  }
+	| opt_attributes
+	  opt_modifiers
+	  FIXED IDENTIFIER COLON simple_type 
+	  { 
+		if (lang_version < LanguageVersion.ISO_2)
+			FeatureIsNotAvailable (GetLocation ($6), "fixed size buffers");
+
+		var lt = (Tokenizer.LocatedToken) $4;
+		current_field = new FixedField (current_type, (FullNamedExpression) $6, (Modifiers) $2,
+			new MemberName (lt.Value, lt.Location), (Attributes) $1);
+			
+		if (is_config_enabled) {
+			current_type.AddField (current_field);
+		}
+		is_config_enabled = true;
+	  }
+	  fixed_field_size opt_fixed_field_declarators SEMICOLON
+	  {
+		if (doc_support) {
+			current_field.DocComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.Allowed;
+	    }
+
+		current_field.Initializer = (ConstInitializer) $8;	    
+		lbag.AddMember (current_field, GetModifierLocations (), GetLocation ($10));
+		$$ = current_field;
+	    current_field = null;
+	  }
+	| opt_attributes
+	  opt_modifiers
+	  FIXED IDENTIFIER COLON simple_type error
+	  SEMICOLON
+	  {
+		report.Error (1641, GetLocation ($8), "A fixed size buffer field must have the array size specifier after the field name");
+	  }
+	;
+	
+opt_field_initializer
+	: /* empty */
+	| ASSIGN
+	  {
+	  	++lexer.parsing_block;
+		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
+	  	start_block (GetLocation ($1));
+	  }
+	  variable_initializer
+	  {
+	  	--lexer.parsing_block;
+		current_field.Initializer = (Expression) $3;
+		end_block (lexer.Location);
+		current_local_parameters = null;
+	  }
+	;
+	
+opt_field_declarators
+	: /* empty */
+	| field_declarators
+	;
+	
+field_declarators
+	: field_declarator
+	  {
+		current_field.AddDeclarator ((FieldDeclarator) $1);
+	  }
+	| field_declarators field_declarator
+	  {
+		current_field.AddDeclarator ((FieldDeclarator) $2);
+	  }
+	;
+	
+field_declarator
+	: COMMA IDENTIFIER COLON member_type
+	  {
+		var lt = (Tokenizer.LocatedToken) $2;
+	  	$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null, (FullNamedExpression) $4);
+	  	lbag.AddLocation ($$, GetLocation ($1));
+	  }
+	| COMMA IDENTIFIER COLON member_type ASSIGN
+	  {
+		++lexer.parsing_block;
+	  }
+	  variable_initializer
+	  {
+		--lexer.parsing_block;
+		var lt = (Tokenizer.LocatedToken) $2;	  
+	  	$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) $7, (FullNamedExpression) $4);
+	  	lbag.AddLocation ($$, GetLocation ($1), GetLocation ($5));
+	  }
+	;	
+
+opt_fixed_field_declarators
+	: /* empty */
+	| fixed_field_declarators
+	;
+	
+fixed_field_declarators
+	: fixed_field_declarator
+	  {
+		current_field.AddDeclarator ((FieldDeclarator) $1);
+	  }
+	| fixed_field_declarators fixed_field_declarator
+	  {
+		current_field.AddDeclarator ((FieldDeclarator) $2);
+	  }
+	;
+	
+fixed_field_declarator
+	: COMMA IDENTIFIER fixed_field_size COLON member_type
+	  {
+		var lt = (Tokenizer.LocatedToken) $2;	  
+		$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (ConstInitializer) $3, (FullNamedExpression) $5);
+		lbag.AddLocation ($$, GetLocation ($1));
+	  }
+	;
+
+fixed_field_size
+	: OPEN_BRACKET
+	  {
+		++lexer.parsing_block;
+	  }
+	  expression CLOSE_BRACKET
+	  {
+		--lexer.parsing_block;
+		$$ = new ConstInitializer (current_field, (Expression) $3, GetLocation ($1));
+		lbag.AddLocation ($$, GetLocation ($4));
+	  }
+	| OPEN_BRACKET error
+	  {
+		report.Error (443, lexer.Location, "Value or constant expected");
+		$$ = null;
+	  }	  
+	;
+
+variable_initializer
+	: expression
+	| error
+	  {
+		// It has to be here for the parent to safely restore artificial block
+	  	Error_SyntaxError (yyToken);
+	  	$$ = null;
+	  }
+	;
+
+method_declaration
+	: method_header
+	  {
+		if (doc_support)
+			Lexer.doc_state = XmlCommentState.NotAllowed;
+
+		// Add it early in the case of body being eof for full ast
+		Method m = $1 as Method;
+		if (m != null) {
+			async_block = (m.ModFlags & Modifiers.ASYNC) != 0;
+			if (is_config_enabled) {
+				current_type.AddMember (m);
+			}
+			is_config_enabled = true;
+		}
+		
+		Constructor c = $1 as Constructor;
+		if (c != null) {
+			if (is_config_enabled) {
+				current_type.AddConstructor (c);
+			}
+			is_config_enabled = true;
+			current_constructor = c;
+		}
+		
+		if (is_package_function)
+			lexer.DynamicParsing = false;
+			
+	  }
+	  method_body
+	  {
+		if (is_package_function)
+			lexer.DynamicParsing = true;
+	  
+	 	async_block = false;
+
+		if ($1 is Method) {
+		
+			Method method = $1 as Method;
+			
+			if ($3 == null) {
+				lbag.AppendToMember (method, savedLocation); // semicolon			
+				method.ParameterInfo.CheckParameters (method);
+	
+				if ((method.ModFlags & Modifiers.ASYNC) != 0) {
+					report.Error (1994, method.Location, "`{0}': The async modifier can only be used with methods that have a body",
+						method.GetSignatureForError ());
+				}
+			} else {
+				method.Block = (ToplevelBlock) $3;
+				
+				if (current_container.Kind == MemberKind.Interface) {
+					report.Error (531, method.Location, "`{0}': interface members cannot have a definition",
+						method.GetSignatureForError ());
+				}
+			}
+			
+		} else if ($1 is Constructor) {
+		
+			Constructor c = $1 as Constructor;
+			
+			if ($3 != null) {		
+				c.Block = (ToplevelBlock) $3;
+			}
+			
+			if (doc_support)
+				c.DocComment = ConsumeStoredComment ();
+		
+		} else {
+		
+			Property.PropertyMethod propMethod = $1 as Property.PropertyMethod;
+			
+			if ($3 != null) {
+		  		propMethod.Block = (ToplevelBlock) $3;			
+		  	
+				if (current_container.Kind == MemberKind.Interface) {
+					report.Error (531, propMethod.Block.StartLocation,
+						"`{0}': interface members cannot have a definition", propMethod.GetSignatureForError ());
+				}
+			}
+			
+		}
+
+		current_local_parameters = null;
+		current_property = null;
+		current_constructor = null;
+		
+		// If this was a package function, pop the container xxxxx_fn class.
+		if (is_package_function) {
+			pop_current_class();
+			is_package_function = false;
+		}
+	
+		if (doc_support)
+			Lexer.doc_state = XmlCommentState.Allowed;
+	  }
+	;
+
+method_header
+	: opt_attributes
+	  opt_modifiers
+	  FUNCTION
+	  method_declaration_name OPEN_PARENS
+	  {
+		valid_param_mod = ParameterModifierType.All;
+		
+		// If package level function, create a new package function class with 
+		// the name of the function plus "_fn".
+		if (current_container is NamespaceContainer) {
+			MemberName methodName = (MemberName) $4;
+			MemberName className = new MemberName(methodName.Name + "_fn", GetLocation($4));
+			var fnClassModifiers = (Modifiers) $2 | Modifiers.PARTIAL | Modifiers.STATIC; // Allows overloads..
+			push_current_container(new Class (current_container, className, fnClassModifiers, (Attributes) $1), GetLocation($3));
+			is_package_function = true;
+		}
+		
+	  }
+	  opt_formal_parameter_list CLOSE_PARENS opt_method_return_type
+	  {
+		lexer.ConstraintsParsing = true;
+	  }
+	  opt_type_parameter_constraints_clauses
+	  {
+		lexer.ConstraintsParsing = false;
+		valid_param_mod = 0;
+		MemberName name = (MemberName) $4;
+		current_local_parameters = (ParametersCompiled) $7;
+
+		var modifiers = (Modifiers) $2;
+		if (is_package_function) {
+			modifiers |= Modifiers.STATIC;
+		}
+		
+		if (current_type != null && name.Name == current_type.MemberName.Name) {
+
+			var c = new Constructor (current_type, name.Name, modifiers, (Attributes) $1, current_local_parameters, name.Location);
+
+			if ($11 != null) {
+					report.Error (7011, c.Location,
+						"`{0}': constructor can not have type constraints.",
+						c.GetSignatureForError ());
+			}
+
+			if ((modifiers & Modifiers.STATIC) != 0) {
+				if ((modifiers & Modifiers.AccessibilityMask) != 0){
+					report.Error (515, c.Location,
+						"`{0}': static constructor cannot have an access modifier",
+						c.GetSignatureForError ());
+				}
+			}
+
+			if (doc_support)
+				c.DocComment = Lexer.consume_doc_comment ();
+				
+			lbag.AddMember (c, GetModifierLocations (), GetLocation ($5), GetLocation ($8));
+			$$ = c;
+		
+		} else {
+
+			if (current_container.Kind == MemberKind.Class && name.ExplicitInterface == null &&
+				(modifiers & (Modifiers.NEW | Modifiers.SEALED | Modifiers.STATIC | Modifiers.PRIVATE | Modifiers.VIRTUAL | Modifiers.OVERRIDE)) == 0)
+					modifiers |= Modifiers.VIRTUAL;
+
+			var ret_type = $9 as FullNamedExpression;
+			
+			if (ret_type == null) {
+				report.Error (7012, GetLocation($8), "Method must specify a return type.");
+				ret_type = new TypeExpression (compiler.BuiltinTypes.Void, GetLocation ($8));
+			}
+
+			var method = Method.Create (current_type, ret_type, modifiers,
+					     name, current_local_parameters, (Attributes) $1);
+
+			if ($11 != null)
+				method.SetConstraints ((List<Constraints>) $11);
+					     
+			if (doc_support)
+				method.DocComment = Lexer.consume_doc_comment ();
+
+			lbag.AddMember (method, GetModifierLocations (), GetLocation ($5), GetLocation ($8));
+			$$ = method;
+			
+		}
+	  }
+	| opt_attributes
+	  opt_modifiers
+	  FUNCTION_GET method_declaration_name OPEN_PARENS  
+	  {
+		valid_param_mod = ParameterModifierType.All;
+	  }
+	  opt_formal_parameter_list CLOSE_PARENS method_colon member_type
+	  {
+		var type = (FullNamedExpression) $10;
+		var name = (MemberName) $4;
+		var modifiers = (Modifiers) $2;
+		var parameters = (ParametersCompiled) $7;		
+		
+		if (current_container.Kind == MemberKind.Class && name.ExplicitInterface == null &&
+			(modifiers & (Modifiers.NEW | Modifiers.SEALED | Modifiers.STATIC | Modifiers.PRIVATE | Modifiers.VIRTUAL | Modifiers.OVERRIDE)) == 0)
+				modifiers |= Modifiers.VIRTUAL;
+
+		if (parameters != null && parameters.Count > 0)
+			report.Error (7016, GetLocation ($10), "Property getter functions may not have parameters");
+
+		current_property = null;		
+						
+		MemberCore member;
+		if (current_type.DefinedNames.TryGetValue(name.Name, out member)) {
+			current_property = member as Property;
+		}
+		
+		if (current_property == null) {
+			current_property = new Property (current_type, type, modifiers, name, (Attributes) $1);
+			if (is_config_enabled) {
+				current_type.AddMember (current_property);
+			}
+			is_config_enabled = true;
+			modifiers = (Modifiers) 0;
+		} else {
+//			if (!type.Equals(current_property.TypeExpression)) {
+//				report.Error (7002, GetLocation ($10), "Type of property getter and setter must match", current_property.GetSignatureForError ());
+//			}
+			if (current_property.Set != null && ModifiersExtensions.IsRestrictedModifier (current_property.ModFlags & Modifiers.AccessibilityMask, modifiers & Modifiers.AccessibilityMask)) {
+				current_property.Set.ModFlags |= current_property.ModFlags & Modifiers.AccessibilityMask;
+				current_property.ModFlags = (current_property.ModFlags & ~Modifiers.AccessibilityMask) | (modifiers & Modifiers.AccessibilityMask);
+				modifiers = (Modifiers) 0;
+			} else if ((modifiers & Modifiers.AccessibilityMask) == (current_property.ModFlags & Modifiers.AccessibilityMask)) {
+				modifiers = (Modifiers) 0;
+			}
+		}
+		
+		if (type.Type != null && type.Type.Kind == MemberKind.Void)
+			report.Error (547, GetLocation ($10), "`{0}': property or indexer cannot have void type", current_property.GetSignatureForError ());					
+			
+		if (current_property.Get != null) {
+			report.Error (1007, GetLocation ($3), "Property accessor already defined");
+		}
+		
+		current_property.Get = new Property.GetMethod (current_property,
+			modifiers & Modifiers.AccessibilityMask, (Attributes) $1, GetLocation ($3));
+	  
+		lbag.AddMember (current_property, GetModifierLocations (), GetLocation ($10));
+		current_local_parameters = current_property.Get.ParameterInfo;
+		$$ = current_property.Get;
+	  }
+    | opt_attributes
+	  opt_modifiers
+	  FUNCTION_SET method_declaration_name OPEN_PARENS  
+	  {
+		valid_param_mod = ParameterModifierType.All;
+	  }
+	  opt_formal_parameter_list CLOSE_PARENS method_colon member_type
+	  {
+		var void_type = (FullNamedExpression) $10;
+		var name = (MemberName) $4;
+		var modifiers = (Modifiers) $2;
+		var parameters = (ParametersCompiled) $7;
+		
+		if (current_container.Kind == MemberKind.Class && name.ExplicitInterface == null &&
+			(modifiers & (Modifiers.NEW | Modifiers.SEALED | Modifiers.STATIC | Modifiers.PRIVATE | Modifiers.VIRTUAL | Modifiers.OVERRIDE)) == 0)
+				modifiers |= Modifiers.VIRTUAL;
+		
+		if (void_type.Type != null && void_type.Type.Kind != MemberKind.Void)
+			report.Error (7003, GetLocation ($10), "Property setter function must not be of type void");					
+
+		current_property = null;
+						
+		MemberCore member;
+		if (current_type.DefinedNames.TryGetValue(name.Name, out member)) {
+			current_property = member as Property;
+		}
+
+		FullNamedExpression type; 
+		
+		if (parameters == null || parameters.Count != 1 || parameters.FixedParameters.Length != parameters.Count) {
+			report.Error (7001, GetLocation ($7), "Property setter must have a single parameter");
+			type = new TypeExpression (compiler.BuiltinTypes.Int, GetLocation ($7));
+		} else {
+			type = ((Parameter)parameters.FixedParameters[0]).TypeExpression;	
+		}
+				
+		if (current_property == null) {
+			current_property = new Property (current_type, type, modifiers, name, (Attributes) $1);
+			if (is_config_enabled) {
+				current_type.AddMember (current_property);
+			}
+			is_config_enabled = true;
+			modifiers = (Modifiers) 0;			
+		} else {
+//			if (!type.Equals(current_property.TypeExpression)) {
+//				report.Error (7002, GetLocation ($10), "Type of property getter and setter must match", current_property.GetSignatureForError ());
+//			}
+			if (current_property.Get != null && ModifiersExtensions.IsRestrictedModifier (current_property.ModFlags & Modifiers.AccessibilityMask, modifiers & Modifiers.AccessibilityMask)) {
+				current_property.Get.ModFlags |= current_property.ModFlags & Modifiers.AccessibilityMask;
+				current_property.ModFlags = (current_property.ModFlags & ~Modifiers.AccessibilityMask) | (modifiers & Modifiers.AccessibilityMask);
+				modifiers = (Modifiers) 0;
+			} else if ((modifiers & Modifiers.AccessibilityMask) == (current_property.ModFlags & Modifiers.AccessibilityMask)) {
+				modifiers = (Modifiers) 0;
+			}
+		}
+		
+		if (current_property.Set != null) {
+			report.Error (1007, GetLocation ($3), "Property accessor already defined");
+		}
+		
+		current_property.Set = new Property.SetMethod (current_property, 
+			modifiers & Modifiers.AccessibilityMask, (ParametersCompiled) $7, (Attributes) $1, GetLocation ($3));
+	  
+		lbag.AddMember (current_property, GetModifierLocations (), GetLocation ($10));
+		current_local_parameters = parameters;
+		$$ = current_property.Set;
+	  }
+	| opt_attributes
+	  opt_modifiers
+	  PARTIAL
+	  FUNCTION
+	  {
+		lexer.parsing_generic_declaration = true;
+	  }
+	  method_declaration_name
+	  OPEN_PARENS
+	  {
+		lexer.parsing_generic_declaration = false;
+	  	valid_param_mod = ParameterModifierType.All;
+	  }
+	  opt_formal_parameter_list CLOSE_PARENS COLON VOID
+	  {
+		lexer.ConstraintsParsing = true;
+	  }
+	  opt_type_parameter_constraints_clauses
+	  {
+		lexer.ConstraintsParsing = false;
+		valid_param_mod = 0;
+
+		MemberName name = (MemberName) $6;
+		current_local_parameters = (ParametersCompiled) $9;
+
+		var modifiers = (Modifiers) $2;
+		modifiers |= Modifiers.PARTIAL;
+
+		if (name.ExplicitInterface == null && (modifiers & (Modifiers.NEW | Modifiers.SEALED | Modifiers.STATIC | Modifiers.PRIVATE | Modifiers.VIRTUAL | Modifiers.OVERRIDE)) == 0)
+			modifiers |= Modifiers.VIRTUAL;
+			
+		var method = Method.Create (current_type, new TypeExpression (compiler.BuiltinTypes.Void, GetLocation ($12)),
+				     modifiers, name, current_local_parameters, (Attributes) $1);
+
+		if ($14 != null)
+			method.SetConstraints ((List<Constraints>) $14);
+
+		if (doc_support)
+			method.DocComment = Lexer.consume_doc_comment ();
+
+		StoreModifierLocation (Modifiers.PARTIAL, GetLocation ($3));
+		lbag.AddMember (method, GetModifierLocations (), GetLocation ($7), GetLocation ($10));
+		$$ = method;
+	  }
+	| opt_attributes
+	  opt_modifiers
+	  FUNCTION
+	  modifiers method_declaration_name OPEN_PARENS opt_formal_parameter_list CLOSE_PARENS method_colon member_type
+	  {
+		MemberName name = (MemberName) $5;
+		report.Error (1585, name.Location, 
+			"Member modifier `{0}' must precede the member type and name", ModifiersExtensions.Name ((Modifiers) $4));
+
+		var method = Method.Create (current_type, (FullNamedExpression) $1,
+					    0, name, (ParametersCompiled) $7, (Attributes) $1);
+
+		current_local_parameters = (ParametersCompiled) $7;
+
+		if (doc_support)
+			method.DocComment = Lexer.consume_doc_comment ();
+
+		$$ = method;
+	  }
+	| opt_attributes
+	  opt_modifiers
+	  FUNCTION
+	  method_declaration_name error
+	  {
+		Error_SyntaxError (yyToken);
+		current_local_parameters = ParametersCompiled.Undefined;
+
+		MemberName name = (MemberName) $4;
+		var method = Method.Create (current_type, new TypeExpression (compiler.BuiltinTypes.Void, GetLocation ($4)), (Modifiers) $2,
+									name, current_local_parameters, (Attributes) $1);
+
+		if (doc_support)
+			method.DocComment = Lexer.consume_doc_comment ();
+
+		$$ = method;
+	  }
+	;
+
+opt_method_return_type
+	: /* empty */
+	| method_colon member_type
+	  {
+		$$ = $2;
+	  }
+	;
+
+method_colon
+	: COLON
+	  {
+		if (current_container.Kind == MemberKind.Interface) 
+			Lexer.AutoSemiInsertion = true;	  
+	  }
+	;	
+
+method_body
+	: block
+	| SEMICOLON		
+	  { 
+	  	// method body.
+	   	savedLocation = GetLocation ($1);
+	   	$$ = null; 
+	  }
+	;
+
+opt_formal_parameter_list
+	: /* empty */			{ $$ = ParametersCompiled.EmptyReadOnlyParameters; }
+	| formal_parameter_list
+	;
+	
+formal_parameter_list
+	: fixed_parameters
+	  {
+		var pars_list = (List<Parameter>) $1;
+	  	$$ = new ParametersCompiled (pars_list.ToArray ());
+	  	lbag.AddLocation ($$, parameterListCommas);
+	  } 
+	| fixed_parameters COMMA parameter_array
+	  {
+		var pars_list = (List<Parameter>) $1;
+		pars_list.Add ((Parameter) $3);
+		parameterListCommas.Add (GetLocation ($2));
+
+		$$ = new ParametersCompiled (pars_list.ToArray ()); 
+	  	lbag.AddLocation ($$, parameterListCommas);		
+	  }
+//	| fixed_parameters COMMA arglist_modifier
+//	  {
+//		var pars_list = (List<Parameter>) $1;
+//		pars_list.Add (new ArglistParameter (GetLocation ($3)));
+//		parameterListCommas.Add (GetLocation ($2));
+//		
+//		$$ = new ParametersCompiled (pars_list.ToArray (), true);
+//	  	lbag.AddLocation ($$, parameterListCommas);
+//	  }
+	| parameter_array COMMA error
+	  {
+		if ($1 != null)
+			report.Error (231, ((Parameter) $1).Location, "A params parameter must be the last parameter in a formal parameter list");
+
+		$$ = new ParametersCompiled (new Parameter[] { (Parameter) $1 } );			
+	  	lbag.AddLocation ($$, parameterListCommas);
+	  }
+	| fixed_parameters COMMA parameter_array COMMA error
+	  {
+		if ($3 != null)
+			report.Error (231, ((Parameter) $3).Location, "A params parameter must be the last parameter in a formal parameter list");
+
+		var pars_list = (List<Parameter>) $1;
+		pars_list.Add (new ArglistParameter (GetLocation ($3)));
+		parameterListCommas.Add (GetLocation ($2));
+		parameterListCommas.Add (GetLocation ($4));
+
+		$$ = new ParametersCompiled (pars_list.ToArray (), true);
+	  	lbag.AddLocation ($$, parameterListCommas);		
+	  }
+//	| arglist_modifier COMMA error
+//	  {
+//		report.Error (257, GetLocation ($1), "An __arglist parameter must be the last parameter in a formal parameter list");
+//
+//		$$ = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation ($1)) }, true);
+//	  	lbag.AddLocation ($$, parameterListCommas);
+//	  }
+//	| fixed_parameters COMMA ARGLIST COMMA error 
+//	  {
+//		report.Error (257, GetLocation ($3), "An __arglist parameter must be the last parameter in a formal parameter list");
+//
+//		var pars_list = (List<Parameter>) $1;
+//		pars_list.Add (new ArglistParameter (GetLocation ($3)));
+//		parameterListCommas.Add (GetLocation ($2));
+//		parameterListCommas.Add (GetLocation ($4));
+//
+//		$$ = new ParametersCompiled (pars_list.ToArray (), true);
+//	  	lbag.AddLocation ($$, parameterListCommas);
+//	  }
+	| parameter_array 
+	  {
+		$$ = new ParametersCompiled (new Parameter[] { (Parameter) $1 } );
+	  }
+//	| arglist_modifier
+//	  {
+//		$$ = new ParametersCompiled (new Parameter [] { new ArglistParameter (GetLocation ($1)) }, true);
+//	  }
+	| error
+	  {
+		Error_SyntaxError (yyToken);
+		$$ = ParametersCompiled.EmptyReadOnlyParameters;
+	  }
+	;
+
+fixed_parameters
+	: fixed_parameter	
+	  {
+		parameters_bucket.Clear ();
+		Parameter p = (Parameter) $1;
+		parameters_bucket.Add (p);
+		parameterListCommas.Clear ();
+		default_parameter_used = p.HasDefaultValue;
+		$$ = parameters_bucket;
+	  }
+	| fixed_parameters COMMA fixed_parameter
+	  {
+		var pars = (List<Parameter>) $1;
+		Parameter p = (Parameter) $3;
+		if (p != null) {
+			if (p.HasExtensionMethodModifier)
+				report.Error (1100, p.Location, "The parameter modifier `this' can only be used on the first parameter");
+			else if (!p.HasDefaultValue && default_parameter_used)
+				report.Error (1737, p.Location, "Optional parameter cannot precede required parameters");
+
+			default_parameter_used |= p.HasDefaultValue;
+			pars.Add (p);
+			
+			parameterListCommas.Add (GetLocation ($2));
+		}
+		
+		$$ = $1;
+	  }
+	;
+
+fixed_parameter
+	: opt_attributes
+	  opt_parameter_modifier
+	  IDENTIFIER
+	  COLON
+	  parameter_type
+	  {
+		var lt = (Tokenizer.LocatedToken) $3;
+		$$ = new Parameter ((FullNamedExpression) $5, lt.Value, (Parameter.Modifier) $2, (Attributes) $1, lt.Location);
+		lbag.AddLocation ($$, parameterModifierLocation);
+	  }
+	| attribute_sections error
+	  {
+		Error_SyntaxError (yyToken);
+	  	Location l = GetLocation ($2);
+		$$ = new Parameter (null, null, Parameter.Modifier.NONE, (Attributes) $1, l);
+	  }
+	| opt_attributes
+	  opt_parameter_modifier
+	  IDENTIFIER
+	  COLON
+	  error
+	  {
+		Error_SyntaxError (yyToken);
+	  	Location l = GetLocation ($5);
+		var lt = (Tokenizer.LocatedToken) $3;
+		$$ = new Parameter (new TypeExpression (compiler.BuiltinTypes.Object, GetLocation ($5)), lt.Value, (Parameter.Modifier) $2, (Attributes) $1, l);
+		lbag.AddLocation ($$, parameterModifierLocation);
+	  }
+	| opt_attributes
+	  opt_parameter_modifier
+	  IDENTIFIER
+	  COLON
+	  parameter_type
+	  ASSIGN
+	  {
+	  	++lexer.parsing_block;
+	  }
+	  constant_expression
+	  {
+	  	--lexer.parsing_block;
+		if (lang_version <= LanguageVersion.V_3) {
+			FeatureIsNotAvailable (GetLocation ($6), "optional parameter");
+		}
+		
+		Parameter.Modifier mod = (Parameter.Modifier) $2;
+		if (mod != Parameter.Modifier.NONE) {
+			switch (mod) {
+			case Parameter.Modifier.REF:
+			case Parameter.Modifier.OUT:
+				report.Error (1741, GetLocation ($2), "Cannot specify a default value for the `{0}' parameter",
+					Parameter.GetModifierSignature (mod));
+				break;
+				
+			case Parameter.Modifier.This:
+				report.Error (1743, GetLocation ($2), "Cannot specify a default value for the `{0}' parameter",
+					Parameter.GetModifierSignature (mod));
+				break;
+			default:
+				throw new NotImplementedException (mod.ToString ());
+			}
+				
+			mod = Parameter.Modifier.NONE;
+		}
+		
+		if ((valid_param_mod & ParameterModifierType.DefaultValue) == 0)
+			report.Error (1065, GetLocation ($6), "Optional parameter is not valid in this context");
+		
+		var lt = (Tokenizer.LocatedToken) $3;
+		$$ = new Parameter ((FullNamedExpression) $5, lt.Value, mod, (Attributes) $1, lt.Location);
+		lbag.AddLocation ($$, parameterModifierLocation, GetLocation ($6)); // parameterModifierLocation should be ignored when mod == NONE
+		
+		if ($8 != null)
+			((Parameter) $$).DefaultValue = new DefaultParameterValueExpression ((Expression) $8);
+	  }
+	;
+
+opt_parameter_modifier
+	: /* empty */		{ $$ = Parameter.Modifier.NONE; }
+	| parameter_modifiers
+	;
+
+parameter_modifiers
+	: parameter_modifier
+	  {
+		$$ = $1;
+	  }
+	| parameter_modifiers parameter_modifier
+	  {
+		Parameter.Modifier p2 = (Parameter.Modifier)$2;
+  		Parameter.Modifier mod = (Parameter.Modifier)$1 | p2;
+  		if (((Parameter.Modifier)$1 & p2) == p2) {
+  			Error_DuplicateParameterModifier (lexer.Location, p2);
+  		} else {
+	  		switch (mod & ~Parameter.Modifier.This) {
+  				case Parameter.Modifier.REF:
+					report.Error (1101, lexer.Location, "The parameter modifiers `this' and `ref' cannot be used altogether");
+  					break;
+   				case Parameter.Modifier.OUT:
+					report.Error (1102, lexer.Location, "The parameter modifiers `this' and `out' cannot be used altogether");
+  					break;
+  				default:
+ 					report.Error (1108, lexer.Location, "A parameter cannot have specified more than one modifier");
+ 					break;
+ 			}
+  		}
+  		$$ = mod;
+	  }
+	;
+
+parameter_modifier
+	: REF
+	  {
+	  	if ((valid_param_mod & ParameterModifierType.Ref) == 0)
+	  		Error_ParameterModifierNotValid ("ref", GetLocation ($1));
+	  		
+	  	$$ = Parameter.Modifier.REF;
+	  }
+	| OUT
+	  {
+	  	if ((valid_param_mod & ParameterModifierType.Out) == 0)
+	  		Error_ParameterModifierNotValid ("out", GetLocation ($1));
+	  
+	  	$$ = Parameter.Modifier.OUT;
+	  }
+	| THIS
+	  {
+		if ((valid_param_mod & ParameterModifierType.This) == 0)
+	  		Error_ParameterModifierNotValid ("this", GetLocation ($1));
+
+	  	if (lang_version <= LanguageVersion.ISO_2)
+	  		FeatureIsNotAvailable (GetLocation ($1), "extension methods");
+	  			
+		$$ = Parameter.Modifier.This;
+	  }
+	;
+
+parameter_array
+	: opt_attributes DOTDOTDOT IDENTIFIER
+	  {
+		var lt = (Tokenizer.LocatedToken) $3;
+		var type = new ComposedCast (
+			new TypeExpression(compiler.BuiltinTypes.Object, GetLocation($3)),  
+			ComposedTypeSpecifier.CreateArrayDimension (1, GetLocation ($3)));
+		$$ = new ParamsParameter (type, lt.Value, (Attributes) $1, lt.Location);
+		lbag.AddLocation ($$, savedLocation);
+	  }
+	| opt_attributes DOTDOTDOT IDENTIFIER ASSIGN constant_expression
+	  {
+		report.Error (1751, GetLocation ($2), "Cannot specify a default value for a variable argument array");
+		
+		var lt = (Tokenizer.LocatedToken) $3;
+		var type = new ComposedCast (
+			new TypeExpression(compiler.BuiltinTypes.Object, GetLocation($3)),  
+			ComposedTypeSpecifier.CreateArrayDimension (1, GetLocation ($3)));
+		$$ = new ParamsParameter (type, lt.Value, (Attributes) $1, lt.Location);
+		lbag.AddLocation ($$, savedLocation);
+	  }
+	| opt_attributes DOTDOTDOT error
+	  {
+		Error_SyntaxError (yyToken);
+		
+		$$ = new ParamsParameter ((FullNamedExpression) $3, null, (Attributes) $1, Location.Null);
+	  }
+	;
+	
+//params_modifier
+//	: PARAMS
+//	  {
+//		if ((valid_param_mod & ParameterModifierType.Params) == 0)
+//			report.Error (1670, (GetLocation ($1)), "The `params' modifier is not allowed in current context");
+//		savedLocation = GetLocation ($1);
+//	  }
+//	| PARAMS parameter_modifier
+//	  {
+//		Parameter.Modifier mod = (Parameter.Modifier)$2;
+//		if ((mod & Parameter.Modifier.This) != 0) {
+//			report.Error (1104, GetLocation ($1), "The parameter modifiers `this' and `params' cannot be used altogether");
+//		} else {
+//			report.Error (1611, GetLocation ($1), "The params parameter cannot be declared as ref or out");
+//		}	  
+//		savedLocation = GetLocation ($1);
+//	  }
+//	| PARAMS params_modifier
+//	  {
+//		Error_DuplicateParameterModifier (GetLocation ($1), Parameter.Modifier.PARAMS);
+//	  }
+//	;
+//	
+//arglist_modifier
+//	: ARGLIST
+//	  {
+//	  	if ((valid_param_mod & ParameterModifierType.Arglist) == 0)
+//	  		report.Error (1669, GetLocation ($1), "__arglist is not valid in this context");
+//	  }
+//	;
+
+property_declaration
+	: opt_attributes
+	  opt_modifiers
+	  PROPERTY member_declaration_name COLON member_type
+	  {
+		if (doc_support)
+			tmpComment = Lexer.consume_doc_comment ();
+	  }
+	  OPEN_BRACE
+	  {
+		var type = (FullNamedExpression) $6;
+	
+		var modifiers = (Modifiers) $2;
+	
+		var name = (MemberName) $4;
+		
+		if (current_container.Kind == MemberKind.Class && name.ExplicitInterface == null && 
+			(modifiers & (Modifiers.NEW | Modifiers.SEALED | Modifiers.STATIC | Modifiers.PRIVATE | Modifiers.VIRTUAL | Modifiers.OVERRIDE)) == 0)
+				modifiers |= Modifiers.VIRTUAL;
+		
+		current_property = new Property (current_type, type, modifiers,
+			name, (Attributes) $1);
+			
+		if (type.Type != null && type.Type.Kind == MemberKind.Void)
+			report.Error (547, GetLocation ($3), "`{0}': property or indexer cannot have void type", current_property.GetSignatureForError ());					
+			
+		if (is_config_enabled) {
+			current_type.AddMember (current_property);
+		}
+		is_config_enabled = true;
+		lbag.AddMember (current_property, GetModifierLocations (), GetLocation ($8));
+		
+		lexer.PropertyParsing = true;
+	  }
+	  accessor_declarations 
+	  {
+		lexer.PropertyParsing = false;
+		
+		if (doc_support)
+			current_property.DocComment = ConsumeStoredComment ();				
+	  }
+	  CLOSE_BRACE
+	  {
+  		CheckIsPlayScript("property", GetLocation($3)); 	
+  		  
+		lbag.AppendToMember (current_property, GetLocation ($12));
+		current_property = null;
+	  }
+	;
+
+indexer_declaration
+	: opt_attributes opt_modifiers
+	  INDEXER indexer_declaration_name OPEN_PARENS
+	  {
+	  	valid_param_mod = ParameterModifierType.Params | ParameterModifierType.DefaultValue;
+	  }
+	  opt_formal_parameter_list CLOSE_PARENS COLON member_type OPEN_BRACE
+	  {
+		valid_param_mod = 0;
+		var type = (FullNamedExpression) $10;
+
+		var modifiers = (Modifiers) $2;
+		
+		var name = (MemberName) $4;
+
+		if (current_container.Kind == MemberKind.Class && name.ExplicitInterface == null && 
+			(modifiers & (Modifiers.NEW | Modifiers.SEALED | Modifiers.STATIC | Modifiers.PRIVATE | Modifiers.VIRTUAL | Modifiers.OVERRIDE)) == 0)
+				modifiers |= Modifiers.VIRTUAL;
+		
+		Indexer indexer = new Indexer (current_type, type, name, modifiers, (ParametersCompiled) $7, (Attributes) $1);
+			
+		current_property = indexer;
+
+		if (is_config_enabled) {
+	  		current_type.AddIndexer (indexer);
+	  	}
+	  	is_config_enabled = true;
+		lbag.AddMember (current_property, GetModifierLocations (), GetLocation ($5), GetLocation ($8));
+  		
+		if (type.Type != null && type.Type.Kind == MemberKind.Void)
+			report.Error (620, GetLocation ($3), "`{0}': indexer return type cannot be `void'", indexer.GetSignatureForError ());  		
+
+		if (indexer.ParameterInfo.IsEmpty) {
+			report.Error (1551, GetLocation ($5), "Indexers must have at least one parameter");
+		}
+
+		if (doc_support) {
+			tmpComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.Allowed;
+		}
+
+		lexer.PropertyParsing = true;
+	  }
+	  accessor_declarations 
+	  {
+		lexer.PropertyParsing = false;
+	  }
+	  CLOSE_BRACE
+	  {
+  		CheckIsPlayScript("indexer", GetLocation($3)); 	
+	  
+		if (current_property.AccessorFirst != null && current_property.AccessorFirst.Block == null)
+			((Indexer) current_property).ParameterInfo.CheckParameters (current_property);
+	  
+		if (doc_support)
+			current_property.DocComment = ConsumeStoredComment ();
+			
+		lbag.AppendToMember (current_property, GetLocation ($12));
+		current_property = null;		
+	  }
+	;
+
+
+accessor_declarations
+	: get_accessor_declaration
+	| get_accessor_declaration accessor_declarations
+	| set_accessor_declaration
+	| set_accessor_declaration accessor_declarations
+	| error
+	  {
+	  	if (yyToken == Token.CLOSE_BRACE) {
+	  		report.Error (548, lexer.Location, "`{0}': property or indexer must have at least one accessor", current_property.GetSignatureForError ());
+		} else {
+			if (yyToken == Token.SEMICOLON)
+				report.Error (1597, lexer.Location, "Semicolon after method or accessor block is not valid");
+			else
+				report.Error (1014, GetLocation ($1), "A get or set accessor expected");
+		}
+	  }
+	;
+
+get_accessor_declaration
+	: opt_attributes opt_modifiers GET
+	  {
+		if ($2 != ModifierNone && lang_version == LanguageVersion.ISO_1) {
+			FeatureIsNotAvailable (GetLocation ($2), "access modifiers on properties");
+		}
+	  
+		if (current_property.Get != null) {
+			report.Error (1007, GetLocation ($3), "Property accessor already defined");
+		}
+		
+		if (current_property is Indexer) {
+			current_property.Get = new Indexer.GetIndexerMethod (current_property, (Modifiers) $2, ((Indexer)current_property).ParameterInfo.Clone (),
+				(Attributes) $1, GetLocation ($3));
+		} else {
+			current_property.Get = new Property.GetMethod (current_property,
+				(Modifiers) $2, (Attributes) $1, GetLocation ($3));
+		}	
+	  
+		current_local_parameters = current_property.Get.ParameterInfo;	  
+		lbag.AddMember (current_property.Get, GetModifierLocations ());
+		lexer.PropertyParsing = false;
+	  }
+	  accessor_body
+	  {
+	  	if ($5 != null) {
+	  		current_property.Get.Block = (ToplevelBlock) $5;			
+	  	
+			if (current_container.Kind == MemberKind.Interface) {
+				report.Error (531, current_property.Get.Block.StartLocation,
+					"`{0}': interface members cannot have a definition", current_property.Get.GetSignatureForError ());
+			}
+			lbag.AddMember (current_property.Get, GetModifierLocations ());
+		} else {
+			lbag.AddMember (current_property.Get, GetModifierLocations (), savedLocation);
+		}
+	  
+		current_local_parameters = null;
+		lexer.PropertyParsing = true;
+
+		if (doc_support)
+			if (Lexer.doc_state == XmlCommentState.Error)
+				Lexer.doc_state = XmlCommentState.NotAllowed;
+	  }
+	;
+
+set_accessor_declaration
+	: opt_attributes opt_modifiers SET 
+	  {
+		if ($2 != ModifierNone && lang_version == LanguageVersion.ISO_1) {
+			FeatureIsNotAvailable (GetLocation ($2), "access modifiers on properties");
+		}
+		
+		if (current_property.Set != null) {
+			report.Error (1007, GetLocation ($3), "Property accessor already defined");
+		}
+	  
+		if (current_property is Indexer) {
+			current_property.Set = new Indexer.SetIndexerMethod (current_property, (Modifiers) $2,
+				ParametersCompiled.MergeGenerated (compiler,
+				((Indexer)current_property).ParameterInfo, true, new Parameter (
+					current_property.TypeExpression, "value", Parameter.Modifier.NONE, null, GetLocation ($3)),
+					null),
+				(Attributes) $1, GetLocation ($3));
+		} else {
+			current_property.Set = new Property.SetMethod (current_property, (Modifiers) $2, 
+				ParametersCompiled.CreateImplicitParameter (current_property.TypeExpression, GetLocation ($3)),
+				(Attributes) $1, GetLocation ($3));
+		}
+		
+		current_local_parameters = current_property.Set.ParameterInfo;	
+		lexer.PropertyParsing = false;
+	  }
+	  accessor_body
+	  {
+		if ($5 != null) {		
+			current_property.Set.Block = (ToplevelBlock) $5;
+		
+			if (current_container.Kind == MemberKind.Interface) {
+				report.Error (531, current_property.Set.Block.StartLocation,
+					"`{0}': interface members cannot have a definition", current_property.Set.GetSignatureForError ());
+			}
+			lbag.AddMember (current_property.Set, GetModifierLocations ());
+		} else {
+			lbag.AddMember (current_property.Set, GetModifierLocations (), savedLocation);
+		}
+		
+		current_local_parameters = null;
+		lexer.PropertyParsing = true;
+
+		if (doc_support
+			&& Lexer.doc_state == XmlCommentState.Error)
+			Lexer.doc_state = XmlCommentState.NotAllowed;
+	  }
+	;
+
+accessor_body
+	: block 
+	| SEMICOLON
+	  {
+		savedLocation = GetLocation ($1);
+	  	$$ = null;
+	  }
+	| error
+	  {
+	  	Error_SyntaxError (1043, yyToken, "Invalid accessor body");
+	  	$$ = null;
+	  }
+	;
+
+interface_declaration
+	: opt_attributes
+	  opt_modifiers
+	  opt_partial
+	  INTERFACE
+	  {
+	    Lexer.AutoSemiInsertion = false;
+	  }
+	  type_declaration_name
+	  {
+		lexer.ConstraintsParsing = true;	  
+	    bool is_partial = IsPartial($1) || $3 != null;
+		push_current_container (new Interface (current_container, (MemberName) $6, (Modifiers) $2, (Attributes) $1), is_partial);
+		lbag.AddMember (current_container, GetModifierLocations (), GetLocation ($4));		
+	  }
+	  opt_class_extends
+	  opt_class_implements
+	  opt_type_parameter_constraints_clauses
+	  {
+		lexer.ConstraintsParsing = false;
+
+		if ($10 != null)
+			current_container.SetConstraints ((List<Constraints>) $10);
+
+		if (doc_support) {
+			current_container.PartialContainer.DocComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.Allowed;
+		}
+		
+		lexer.parsing_modifiers = true;
+	  }
+	  OPEN_BRACE
+	  {
+	    Lexer.AutoSemiInsertion = true;
+	  }
+	  opt_interface_member_declarations CLOSE_BRACE
+	  {
+		--lexer.parsing_declaration;	  
+		if (doc_support)
+			Lexer.doc_state = XmlCommentState.Allowed;
+	  }
+	  opt_semicolon 
+	  {
+	    lbag.AppendToMember (current_container, GetLocation ($12), GetLocation ($15));
+		$$ = pop_current_class ();
+	  }
+	| opt_attributes opt_modifiers opt_partial INTERFACE error
+	  {
+		Error_SyntaxError (yyToken);	  
+	  }
+	;
+
+opt_interface_member_declarations
+	: /* empty */
+	| interface_member_declarations
+	;
+
+interface_member_declarations
+	: interface_member_declaration
+	  {
+		lexer.parsing_modifiers = true;
+	  }
+	| interface_member_declarations interface_member_declaration
+	  {
+		lexer.parsing_modifiers = true;
+	  }
+	;
+
+interface_member_declaration
+	: constant_declaration
+	  {
+		report.Error (525, GetLocation ($1), "Interfaces cannot contain fields or constants");
+	  }
+	| field_declaration
+	  {
+		report.Error (525, GetLocation ($1), "Interfaces cannot contain fields or constants");
+	  }
+	| method_declaration
+	| property_declaration
+	| event_declaration
+	| indexer_declaration
+	| operator_declaration
+	  {
+	  	report.Error (567, GetLocation ($1), "Interfaces cannot contain operators");
+	  }
+//	| constructor_declaration
+//	  {
+//	  	report.Error (526, GetLocation ($1), "Interfaces cannot contain contructors");
+//	  }
+	| type_declaration
+	  {
+	  	report.Error (524, GetLocation ($1), "Interfaces cannot declare classes, structs, interfaces, delegates, or enumerations");
+	  }
+	;
+
+operator_declaration
+	: opt_attributes opt_modifiers operator_declarator 
+	  {
+	  }
+	  operator_body
+	  {
+		OperatorDeclaration decl = (OperatorDeclaration) $3;
+		if (decl != null) {
+			var modifiers = (Modifiers) $2;
+			
+//			if (current_container.Kind == MemberKind.Class && 
+//				(modifiers & (Modifiers.NEW | Modifiers.SEALED | Modifiers.STATIC | Modifiers.PRIVATE | Modifiers.VIRTUAL | Modifiers.OVERRIDE)) == 0)
+//					modifiers |= Modifiers.VIRTUAL;			
+		
+			if (current_local_parameters.Count < 1) {
+			
+				report.Error (7037, GetLocation ($1), "Invalid number of parameters for operator.");			
+			
+			} else {
+			
+				Operator op = new Operator (
+					current_type, decl.optype, decl.ret_type, modifiers, 
+					current_local_parameters,
+					(ToplevelBlock) $5, (Attributes) $1, decl.location);
+				
+				if (op.Block == null)
+					op.ParameterInfo.CheckParameters (op);
+
+				if (doc_support) {
+					op.DocComment = tmpComment;
+					Lexer.doc_state = XmlCommentState.Allowed;
+				}
+
+				// Note again, checking is done in semantic analysis
+				if (is_config_enabled) {
+					current_type.AddOperator (op);
+				}
+				is_config_enabled = true;
+
+				lbag.AddMember (op, GetModifierLocations (), lbag.GetLocations (decl));
+				if ($5 == null) { // Semicolon
+					lbag.AppendTo (op, savedLocation);
+				}
+			}
+		}
+		
+		current_local_parameters = null;
+	  }
+	;
+
+operator_body 
+	: block
+	| SEMICOLON { savedLocation = GetLocation ($1); $$ = null; }
+	; 
+
+operator_type
+	: type_expression_or_array
+	| VOID
+	  {
+		report.Error (590, GetLocation ($1), "User-defined operators cannot return void");
+		$$ = new TypeExpression (compiler.BuiltinTypes.Void, GetLocation ($1));
+	  }
+	;
+
+operator_declarator
+	: OPERATOR overloadable_operator OPEN_PARENS
+	  {
+		valid_param_mod = ParameterModifierType.DefaultValue;
+	  }
+	  opt_formal_parameter_list CLOSE_PARENS COLON operator_type 
+	  {
+		CheckIsPlayScript("operator", GetLocation($1)); 	  
+	  
+		valid_param_mod = 0;
+
+		Location loc = GetLocation ($1);
+		Operator.OpType op = (Operator.OpType) $8;
+		current_local_parameters = (ParametersCompiled)$5;
+		
+		int p_count = current_local_parameters.Count;
+		if (p_count == 1) {
+			if (op == Operator.OpType.Addition)
+				op = Operator.OpType.UnaryPlus;
+			else if (op == Operator.OpType.Subtraction)
+				op = Operator.OpType.UnaryNegation;
+		}
+		
+		if (IsUnaryOperator (op)) {
+			if (p_count == 2) {
+				report.Error (1020, loc, "Overloadable binary operator expected");
+			} else if (p_count != 1) {
+				report.Error (1535, loc, "Overloaded unary operator `{0}' takes one parameter",
+					Operator.GetName (op));
+			}
+		} else {
+			if (p_count > 2) {
+				report.Error (1534, loc, "Overloaded binary operator `{0}' takes two parameters",
+					Operator.GetName (op));
+			} else if (p_count != 2) {
+				report.Error (1019, loc, "Overloadable unary operator expected");
+			}
+		}
+		
+		if (doc_support) {
+			tmpComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.NotAllowed;
+		}
+
+		$$ = new OperatorDeclaration (op, (FullNamedExpression) $8, loc);
+		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($2), GetLocation ($3), GetLocation ($6));
+	  }
+	| conversion_operator_declarator
+	;
+
+overloadable_operator
+// Unary operators:
+	: BANG   { $$ = Operator.OpType.LogicalNot; }
+        | TILDE  { $$ = Operator.OpType.OnesComplement; }  
+        | OP_INC { $$ = Operator.OpType.Increment; }
+        | OP_DEC { $$ = Operator.OpType.Decrement; }
+        | TRUE   { $$ = Operator.OpType.True; }
+        | FALSE  { $$ = Operator.OpType.False; }
+// Unary and binary:
+        | PLUS { $$ = Operator.OpType.Addition; }
+        | MINUS { $$ = Operator.OpType.Subtraction; }
+// Binary:
+        | STAR { $$ = Operator.OpType.Multiply; }
+        | DIV {  $$ = Operator.OpType.Division; }
+        | PERCENT { $$ = Operator.OpType.Modulus; }
+        | BITWISE_AND { $$ = Operator.OpType.BitwiseAnd; }
+        | BITWISE_OR { $$ = Operator.OpType.BitwiseOr; }
+        | CARRET { $$ = Operator.OpType.ExclusiveOr; }
+        | OP_SHIFT_LEFT { $$ = Operator.OpType.LeftShift; }
+        | OP_SHIFT_RIGHT { $$ = Operator.OpType.RightShift; }
+        | OP_USHIFT_RIGHT { $$ = Operator.OpType.AsURightShift; }
+        | OP_EQ { $$ = Operator.OpType.Equality; }
+        | OP_NE { $$ = Operator.OpType.Inequality; }
+        | OP_GT { $$ = Operator.OpType.GreaterThan; }
+        | OP_LT { $$ = Operator.OpType.LessThan; }
+        | OP_GE { $$ = Operator.OpType.GreaterThanOrEqual; }
+        | OP_LE { $$ = Operator.OpType.LessThanOrEqual; }
+        | OP_IN { $$ = Operator.OpType.AsIn; }
+	;
+
+conversion_operator_declarator
+	: IMPLICIT OPERATOR type OPEN_PARENS
+	  {
+		valid_param_mod = ParameterModifierType.DefaultValue;
+	  }
+	  opt_formal_parameter_list CLOSE_PARENS
+	  {
+		valid_param_mod = 0;
+
+		Location loc = GetLocation ($2);
+		current_local_parameters = (ParametersCompiled)$6;  
+		  
+		if (doc_support) {
+			tmpComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.NotAllowed;
+		}
+
+		$$ = new OperatorDeclaration (Operator.OpType.Implicit, (FullNamedExpression) $3, loc);
+		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($2), GetLocation ($4), GetLocation ($7));
+	  }
+	| EXPLICIT OPERATOR type OPEN_PARENS
+	  {
+		valid_param_mod = ParameterModifierType.DefaultValue;
+	  }
+	  opt_formal_parameter_list CLOSE_PARENS
+	  {
+		valid_param_mod = 0;
+		
+		Location loc = GetLocation ($2);
+		current_local_parameters = (ParametersCompiled)$6;  
+		  
+		if (doc_support) {
+			tmpComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.NotAllowed;
+		}
+
+		$$ = new OperatorDeclaration (Operator.OpType.Explicit, (FullNamedExpression) $3, loc);
+		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($2), GetLocation ($4), GetLocation ($7));
+	  }
+	| IMPLICIT error 
+	  {
+	  	Error_SyntaxError (yyToken);
+		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
+		$$ = new OperatorDeclaration (Operator.OpType.Implicit, null, GetLocation ($1));
+	  }
+	| EXPLICIT error 
+	  {
+	  	Error_SyntaxError (yyToken);
+		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
+	  	$$ = new OperatorDeclaration (Operator.OpType.Explicit, null, GetLocation ($1));
+	  }
+	;
+
+//constructor_declaration
+//	: constructor_declarator
+//	  constructor_body
+//	  { 
+//		Constructor c = (Constructor) $1;
+//		c.Block = (ToplevelBlock) $2;
+//		
+//		if (doc_support)
+//			c.DocComment = ConsumeStoredComment ();
+//
+//		current_local_parameters = null;
+//		if (doc_support)
+//			Lexer.doc_state = XmlCommentState.Allowed;
+//	  }
+//	;
+//
+//constructor_declarator
+//	: opt_attributes
+//	  opt_modifiers
+//	  FUNCTION
+//	  IDENTIFIER
+//	  {
+//		if (doc_support) {
+//			tmpComment = Lexer.consume_doc_comment ();
+//			Lexer.doc_state = XmlCommentState.Allowed;
+//		}
+//		
+//		valid_param_mod = ParameterModifierType.All;
+//	  }
+//	  OPEN_PARENS opt_formal_parameter_list CLOSE_PARENS opt_constructor_type
+//	  {
+//		valid_param_mod = 0;
+//		current_local_parameters = (ParametersCompiled) $7;
+//		
+//		var lt = (Tokenizer.LocatedToken) $4;
+//		var mods = (Modifiers) $2;
+//		var c = new Constructor (current_type, lt.Value, mods, (Attributes) $1, current_local_parameters, lt.Location);
+//
+//		if (lt.Value != current_container.MemberName.Name) {
+//			report.Error (1520, c.Location, "Class, struct, or interface method must have a return type");
+//		} else if ((mods & Modifiers.STATIC) != 0) {
+//			if ((mods & Modifiers.AccessibilityMask) != 0){
+//				report.Error (515, c.Location,
+//					"`{0}': static constructor cannot have an access modifier",
+//					c.GetSignatureForError ());
+//			}
+//		}
+//
+//		current_type.AddConstructor (c);
+//		lbag.AddMember (c, GetModifierLocations (), GetLocation ($6), GetLocation ($8));
+//		$$ = c;
+//
+//		
+//		 start block here, so possible anonymous methods inside
+//		 constructor initializer can get correct parent block
+//		
+//	  	start_block (lexer.Location);
+//	  }
+//	  opt_constructor_initializer
+//	  {
+//		if ($9 != null) {
+//			var c = (Constructor) $8;
+//			c.Initializer = (ConstructorInitializer) $9;
+//			
+//			if (c.IsStatic) {
+//				report.Error (514, c.Location,
+//					"`{0}': static constructor cannot have an explicit `this' or `base' constructor call",
+//					c.GetSignatureForError ());
+//			}
+//		}
+//
+//		$$ = $8;
+//	  }
+//	;
+//
+//constructor_body
+//	: block_prepared
+//	| SEMICOLON 		{ current_block = null; $$ = null; }
+//	;
+//
+//opt_constructor_type
+//	: /* Empty */
+//	| COLON IDENTIFIER
+//	  {
+//		var lt = (Tokenizer.LocatedToken) $2;
+//		if (lt.Value != "void"){
+//			report.Error (1525, GetLocation ($2), "Unexpected symbol expected 'void'");
+//		}	  
+//	  }
+//	;
+//
+//opt_constructor_initializer
+//	: /* Empty */
+//	| constructor_initializer
+//	;
+//
+//constructor_initializer
+//	: COLON SUPER OPEN_PARENS
+//	  {
+//		++lexer.parsing_block;
+//	  }
+//	  opt_argument_list CLOSE_PARENS
+//	  {
+//	  	--lexer.parsing_block;
+//		$$ = new ConstructorBaseInitializer ((Arguments) $5, GetLocation ($2));
+//		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3), GetLocation ($6));
+//	  }
+//	| COLON THIS OPEN_PARENS
+//	  {
+//		++lexer.parsing_block;
+//	  }
+//	  opt_argument_list CLOSE_PARENS
+//	  {
+//	  	--lexer.parsing_block;
+//		$$ = new ConstructorThisInitializer ((Arguments) $5, GetLocation ($2));
+//		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3), GetLocation ($6));
+//	  }
+//	| COLON error
+//	  {
+//		Error_SyntaxError (yyToken);	  
+//		$$ = new ConstructorThisInitializer (null, GetLocation ($2));
+//		lbag.AddLocation ($$, GetLocation ($1));
+//	  }
+//	| error
+//	  {
+//		Error_SyntaxError (yyToken);
+//		$$ = null;
+//	  }
+//	;
+
+destructor_declaration
+	: opt_attributes opt_modifiers FUNCTION TILDE 
+	  {
+		if (doc_support) {
+			tmpComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.NotAllowed;
+		}
+		
+		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
+	  }
+	  IDENTIFIER OPEN_PARENS CLOSE_PARENS method_body
+	  {
+		var lt = (Tokenizer.LocatedToken) $6;
+		if (lt.Value != current_container.MemberName.Name){
+			report.Error (574, lt.Location, "Name of destructor must match name of class");
+		} else if (current_container.Kind != MemberKind.Class){
+			report.Error (575, lt.Location, "Only class types can contain destructor");
+		}
+		
+		Destructor d = new Destructor (current_type, (Modifiers) $2,
+			ParametersCompiled.EmptyReadOnlyParameters, (Attributes) $1, lt.Location);
+		if (doc_support)
+			d.DocComment = ConsumeStoredComment ();
+		  
+		d.Block = (ToplevelBlock) $9;
+		if (is_config_enabled) {
+			current_type.AddMember (d);
+		}
+		is_config_enabled = true;
+		lbag.AddMember (d, GetModifierLocations (), GetLocation ($4), GetLocation ($7), GetLocation ($8));
+
+		current_local_parameters = null;
+	  }
+	;
+
+event_declaration
+	: opt_attributes
+	  opt_modifiers
+	  EVENT member_declaration_name COLON type 
+	  {
+		current_event_field = new EventField (current_type, (FullNamedExpression) $6, (Modifiers) $2, (MemberName) $4, (Attributes) $1);
+		if (is_config_enabled) {
+			current_type.AddMember (current_event_field);
+		}
+		is_config_enabled = true;
+		
+		if (current_event_field.MemberName.ExplicitInterface != null) {
+			report.Error (71, current_event_field.Location, "`{0}': An explicit interface implementation of an event must use property syntax",
+			current_event_field.GetSignatureForError ());
+		}
+		
+		$$ = current_event_field;
+	  }
+	  opt_event_initializer
+	  opt_event_declarators
+	  SEMICOLON
+	  {
+		if (doc_support) {
+			current_event_field.DocComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.Allowed;
+		}
+		if (current_event_field.Initializer != null) {
+			lbag.AddMember (current_event_field, GetModifierLocations (), GetLocation ($3), savedEventAssignLocation, GetLocation ($10));
+		} else {
+			lbag.AddMember (current_event_field, GetModifierLocations (), GetLocation ($3), GetLocation ($10));
+		}
+		current_event_field = null;
+	  }
+	| opt_attributes
+	  opt_modifiers
+	  EVENT member_declaration_name COLON type 
+	  OPEN_BRACE
+	  {
+		current_event = new EventProperty (current_type, (FullNamedExpression) $6, (Modifiers) $2, (MemberName) $4, (Attributes) $1);
+		if (is_config_enabled) {
+			current_type.AddMember (current_event);
+		}
+		is_config_enabled = true;
+		lbag.AddMember (current_event, GetModifierLocations (), GetLocation ($3), GetLocation ($7));
+		
+		lexer.EventParsing = true;
+	  }
+	  event_accessor_declarations
+	  {
+		if (current_container.Kind == MemberKind.Interface)
+			report.Error (69, GetLocation ($7), "Event in interface cannot have add or remove accessors");
+	  
+		lexer.EventParsing = false;
+	  }
+	  CLOSE_BRACE
+	  {
+		if (doc_support) {
+			current_event.DocComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.Allowed;
+		}
+		
+		lbag.AppendToMember (current_event, GetLocation ($10));
+	  	current_event = null;	
+		current_local_parameters = null;
+	  }
+	;
+	
+opt_event_initializer
+	: /* empty */
+	| ASSIGN
+	  {
+	  	++lexer.parsing_block;
+	  }
+	  event_variable_initializer
+	  {
+	  	--lexer.parsing_block;
+		current_event_field.Initializer = (Expression) $3;
+	  }
+	;
+	
+opt_event_declarators
+	: /* empty */
+	| event_declarators
+	;
+	
+event_declarators
+	: event_declarator
+	  {
+		current_event_field.AddDeclarator ((FieldDeclarator) $1);
+	  }
+	| event_declarators event_declarator
+	  {
+		current_event_field.AddDeclarator ((FieldDeclarator) $2);
+	  }
+	;
+	
+event_declarator
+	: COMMA IDENTIFIER COLON member_type
+	  {
+		var lt = (Tokenizer.LocatedToken) $2;
+	  	$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null, (FullNamedExpression) $4);
+	  	lbag.AddLocation ($$, GetLocation ($1));
+	  }
+	| COMMA IDENTIFIER COLON member_type ASSIGN 
+	  {
+		++lexer.parsing_block;
+	  }
+	  event_variable_initializer
+	  {
+		--lexer.parsing_block;
+		var lt = (Tokenizer.LocatedToken) $2;	  
+	  	$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) $7, (FullNamedExpression) $4);
+	  	lbag.AddLocation ($$, GetLocation ($1), GetLocation ($5));
+	  }
+	;
+	
+event_variable_initializer
+	: {
+		if (current_container.Kind == MemberKind.Interface) {
+			report.Error (68, lexer.Location, "`{0}': event in interface cannot have an initializer",
+				current_event_field.GetSignatureForError ());
+		}
+		
+	  	if ((current_event_field.ModFlags & Modifiers.ABSTRACT) != 0) {
+			report.Error (74, lexer.Location, "`{0}': abstract event cannot have an initializer",
+				current_event_field.GetSignatureForError ());
+	  	}		
+	  }
+	  variable_initializer
+	  {
+		$$ = $2;
+	  }
+	;
+	
+event_accessor_declarations
+	: add_accessor_declaration remove_accessor_declaration
+	| remove_accessor_declaration add_accessor_declaration
+	| add_accessor_declaration
+	  {
+		report.Error (65, lexer.Location, "`{0}': event property must have both add and remove accessors",
+			current_event.GetSignatureForError ());
+	  } 
+	| remove_accessor_declaration
+	  {
+		report.Error (65, lexer.Location, "`{0}': event property must have both add and remove accessors",
+			current_event.GetSignatureForError ());
+	  }	
+	| error
+	  { 
+		report.Error (1055, GetLocation ($1), "An add or remove accessor expected");
+		$$ = null;
+	  }
+	;
+
+add_accessor_declaration
+	: opt_attributes opt_modifiers ADD
+	  {
+	  	if ($2 != ModifierNone) {
+			report.Error (1609, GetLocation ($2), "Modifiers cannot be placed on event accessor declarations");
+	  	}
+	  	
+	  	current_event.Add = new EventProperty.AddDelegateMethod (current_event, (Attributes) $1, GetLocation ($3));
+		current_local_parameters = current_event.Add.ParameterInfo;
+		
+		lbag.AddMember (current_event.Add, GetModifierLocations ());
+		lexer.EventParsing = false;		
+	  }
+	  event_accessor_block
+	  {
+		lexer.EventParsing = true;
+	  
+	  	current_event.Add.Block = (ToplevelBlock) $5;
+		
+		if (current_container.Kind == MemberKind.Interface) {
+			report.Error (531, current_event.Add.Block.StartLocation,
+				"`{0}': interface members cannot have a definition", current_event.Add.GetSignatureForError ());
+		}
+		
+		current_local_parameters = null;
+	  }
+	;
+	
+remove_accessor_declaration
+	: opt_attributes opt_modifiers REMOVE
+	  {
+	  	if ($2 != ModifierNone) {
+			report.Error (1609, GetLocation ($2), "Modifiers cannot be placed on event accessor declarations");
+	  	}
+	  	
+	  	current_event.Remove = new EventProperty.RemoveDelegateMethod (current_event, (Attributes) $1, GetLocation ($3));
+		current_local_parameters = current_event.Remove.ParameterInfo;
+
+		lbag.AddMember (current_event.Remove, GetModifierLocations ());
+		lexer.EventParsing = false;		
+	  }
+	  event_accessor_block
+	  {
+		lexer.EventParsing = true;
+	  
+	  	current_event.Remove.Block = (ToplevelBlock) $5;
+		
+		if (current_container.Kind == MemberKind.Interface) {
+			report.Error (531, current_event.Remove.Block.StartLocation,
+				"`{0}': interface members cannot have a definition", current_event.Remove.GetSignatureForError ());
+		}
+		
+		current_local_parameters = null;
+	  }
+	;
+
+event_accessor_block
+	: opt_semicolon
+	  {
+		report.Error (73, lexer.Location, "An add or remove accessor must have a body");
+		$$ = null;
+	  }
+	| block;
+	;
+
+attributes_without_members
+	: attribute_sections CLOSE_BRACE
+	  {
+		current_type.UnattachedAttributes = (Attributes) $1;
+		report.Error (1519, GetLocation ($1), "An attribute is missing member declaration");
+		lexer.putback ('}');
+	  }
+	;
+	  
+enum_declaration
+	: opt_attributes
+	  opt_modifiers
+	  ENUM type_declaration_name
+	  opt_enum_base
+	  {
+		if (doc_support)
+			enumTypeComment = Lexer.consume_doc_comment ();
+	  }
+	  OPEN_BRACE
+	  {
+		if (doc_support)
+			Lexer.doc_state = XmlCommentState.Allowed;
+
+		MemberName name = (MemberName) $4;
+		if (name.IsGeneric) {
+			report.Error (1675, name.Location, "Enums cannot have type parameters");
+		}
+		
+		push_current_container (new Enum (current_container, (FullNamedExpression) $5, (Modifiers) $2, name, (Attributes) $1), null);
+	  }
+	  opt_enum_member_declarations
+	  {
+	  	// here will be evaluated after CLOSE_BLACE is consumed.
+		if (doc_support)
+			Lexer.doc_state = XmlCommentState.Allowed;
+	  }
+	  CLOSE_BRACE opt_semicolon
+	  {
+	  	CheckIsPlayScript("enum", GetLocation($3));
+	  
+		if (doc_support)
+			current_container.DocComment = enumTypeComment;
+			
+		--lexer.parsing_declaration;
+
+//			if (doc_support)
+//				em.DocComment = ev.DocComment;
+
+		lbag.AddMember (current_container, GetModifierLocations (), GetLocation ($3), GetLocation ($7), GetLocation ($11));
+		$$ = pop_current_class ();
+	  }
+	;
+
+opt_enum_base
+	: /* empty */
+	| COLON type
+	 {
+	 	var te = $2 as TypeExpression;
+		if (te == null || !EnumSpec.IsValidUnderlyingType (te.Type)) {
+			Enum.Error_1008 (GetLocation ($2), report);
+		}
+		$$ = $2;
+	 }
+	| COLON error
+	 {
+	 	Error_TypeExpected (GetLocation ($1));
+		$$ = null;
+	 }
+	;
+
+opt_enum_member_declarations
+	: /* empty */
+	| enum_member_declarations
+	| enum_member_declarations COMMA
+	  {
+	  	lbag.AddLocation ($1, GetLocation ($2));
+	  }
+	;
+
+enum_member_declarations
+	: enum_member_declaration
+	| enum_member_declarations COMMA enum_member_declaration
+	  {
+	  	lbag.AddLocation ($1, GetLocation ($2));
+	  	$$ = $3;
+	  }
+	;
+
+enum_member_declaration
+	: opt_attributes IDENTIFIER
+	  {
+		var lt = (Tokenizer.LocatedToken) $2;
+	  	var em = new EnumMember ((Enum) current_type, new MemberName (lt.Value, lt.Location), (Attributes) $1);
+	  	((Enum) current_type).AddEnumMember (em);
+
+		if (doc_support) {
+			em.DocComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.Allowed;
+		}
+
+		$$ = em;
+	  }
+	| opt_attributes IDENTIFIER
+	  {
+	  	++lexer.parsing_block;
+		if (doc_support) {
+			tmpComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.NotAllowed;
+		}
+	  }
+	  ASSIGN constant_expression
+	  { 
+		--lexer.parsing_block;
+		
+		var lt = (Tokenizer.LocatedToken) $2;
+	  	var em = new EnumMember ((Enum) current_type, new MemberName (lt.Value, lt.Location), (Attributes) $1);
+	  	em.Initializer = new ConstInitializer (em, (Expression) $5, GetLocation ($4));
+	  	((Enum) current_type).AddEnumMember (em);
+		
+		if (doc_support)
+			em.DocComment = ConsumeStoredComment ();
+
+		$$ = em;
+	  }
+	| opt_attributes IDENTIFIER error
+	  {
+		Error_SyntaxError (yyToken);
+	  
+		var lt = (Tokenizer.LocatedToken) $2;
+	  	var em = new EnumMember ((Enum) current_type, new MemberName (lt.Value, lt.Location), (Attributes) $1);
+	  	((Enum) current_type).AddEnumMember (em);
+
+		if (doc_support) {
+			em.DocComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.Allowed;
+		}
+
+		$$ = em;
+	  }
+	| attributes_without_members
+	;
+
+delegate_declaration
+	: opt_attributes
+	  opt_modifiers
+	  DELEGATE
+	  type_declaration_name
+	  OPEN_PARENS
+	  {
+		valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out | ParameterModifierType.Params | ParameterModifierType.DefaultValue;
+	  }
+	  opt_formal_parameter_list CLOSE_PARENS COLON member_type
+	  {
+		valid_param_mod = 0;
+
+		ParametersCompiled p = (ParametersCompiled) $7;
+
+		Delegate del = new Delegate (current_container, (FullNamedExpression) $10, (Modifiers) $2, (MemberName) $4, p, (Attributes) $1);
+
+		p.CheckParameters (del);
+
+		current_container.AddTypeContainer (del);
+
+		current_delegate = del;
+		lexer.ConstraintsParsing = true;
+	  }
+	  opt_type_parameter_constraints_clauses
+	  {
+		lexer.ConstraintsParsing = false;
+	  }
+	  SEMICOLON
+	  {
+	  	CheckIsPlayScript("delegate", GetLocation($3));
+	  	
+		if (doc_support) {
+			current_delegate.DocComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.Allowed;
+		}
+	  
+		if ($12 != null)
+			current_delegate.SetConstraints ((List<Constraints>) $12);
+		lbag.AddMember (current_delegate, GetModifierLocations (), GetLocation ($3), GetLocation ($5), GetLocation ($8), GetLocation ($14));
+
+		$$ = current_delegate;
+
+		current_delegate = null;
+	  }
+	;
+	
+namespace_declaration
+	: opt_attributes 
+	  opt_modifiers 
+	  NAMESPACE 
+	  IDENTIFIER opt_namespace_url SEMICOLON
+	  {
+		var lt = (Tokenizer.LocatedToken) $4;	  
+		MemberName className = new MemberName(lt.Value + "_ns", GetLocation($4));
+		push_current_container(new Class (current_container, className, (Modifiers) $2, (Attributes) $1), GetLocation($3));	  
+		pop_current_class();
+			  
+	  	if (doc_support) {
+			current_delegate.DocComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.Allowed;
+		}
+	  }
+	;
+	
+opt_namespace_url
+   	: /* empty */
+   	| namespace_url
+   	;
+   	
+namespace_url
+	: ASSIGN LITERAL
+	  {
+	  	if (!($2 is StringLiteral))
+	  		syntax_error (GetLocation($2), "string literal expected");
+	  	$$ = $2;
+	  }
+	;
+
+opt_nullable
+	: /* empty */
+	| INTERR_NULLABLE
+	  {
+		if (lang_version < LanguageVersion.ISO_2)
+			FeatureIsNotAvailable (GetLocation ($1), "nullable types");
+	  
+	  	$$ = ComposedTypeSpecifier.CreateNullable (GetLocation ($1));
+	  }
+	;
+
+namespace_or_type_expr
+	: member_name
+//	| qualified_alias_member IDENTIFIER opt_type_argument_list
+//	  {
+//		var lt1 = (Tokenizer.LocatedToken) $1;
+//		var lt2 = (Tokenizer.LocatedToken) $2;
+//		
+//		$$ = new QualifiedAliasMember (lt1.Value, lt2.Value, (TypeArguments) $3, lt1.Location);
+//		lbag.AddLocation ($$, GetLocation ($2));
+//	  }
+	;
+
+member_name
+	: simple_name_expr
+	| namespace_or_type_expr DOT IDENTIFIER opt_type_argument_list
+	  {
+	    // member_name
+		var lt = (Tokenizer.LocatedToken) $3;
+		$$ = new MemberAccess ((Expression) $1, lt.Value, (TypeArguments) $4, lt.Location);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	;
+
+simple_name_expr
+	: IDENTIFIER opt_type_argument_list
+	  {
+	    // simple_name_expr
+		var lt = (Tokenizer.LocatedToken) $1;
+		$$ = new SimpleName (lt.Value, (TypeArguments)$2, lt.Location);
+	  }
+	;
+	
+//
+// Generics arguments  (any type, without attributes)
+//
+opt_type_argument_list
+	: /* empty */
+	| OP_GENERICS_LT type_arguments OP_GENERICS_GT
+	  {
+		if (lang_version < LanguageVersion.ISO_2)
+			FeatureIsNotAvailable (GetLocation ($1), "generics");	  
+	  
+		$$ = $2;
+	  }
+	| OP_GENERICS_LT error
+	  {
+		Error_TypeExpected (lexer.Location);
+		$$ = new TypeArguments ();
+	  }
+	;
+
+type_arguments
+	: type
+	  {
+		TypeArguments type_args = new TypeArguments ();
+		type_args.Add ((FullNamedExpression) $1);
+		$$ = type_args;
+	  }
+	| type_arguments COMMA type
+	  {
+		TypeArguments type_args = (TypeArguments) $1;
+		type_args.Add ((FullNamedExpression) $3);
+		$$ = type_args;
+	  }	  
+	;
+
+//
+// Generics parameters (identifiers only, with attributes), used in type or method declarations
+//
+type_declaration_name
+	: IDENTIFIER
+	  {
+		lexer.parsing_generic_declaration = true;
+	  }
+	  opt_type_parameter_list
+	  {
+		lexer.parsing_generic_declaration = false;
+		var lt = (Tokenizer.LocatedToken) $1;
+		$$ = new MemberName (lt.Value, (TypeParameters)$3, lt.Location);
+	  }
+	;
+
+member_declaration_name
+	: method_declaration_name
+	  {
+	  	MemberName mn = (MemberName)$1;
+	  	if (mn.TypeParameters != null)
+	  		syntax_error (mn.Location, string.Format ("Member `{0}' cannot declare type arguments",
+	  			mn.GetSignatureForError ()));
+	  }
+	;
+
+method_declaration_name
+	: type_declaration_name
+	| explicit_interface IDENTIFIER opt_type_parameter_list
+	  {
+		lexer.parsing_generic_declaration = false;	  
+		var lt = (Tokenizer.LocatedToken) $2;
+		$$ = new MemberName (lt.Value, (TypeParameters) $3, (ATypeNameExpression) $1, lt.Location);
+	  }
+	;
+	
+indexer_declaration_name
+	: THIS
+	  {
+		lexer.parsing_generic_declaration = false;	  
+		$$ = new MemberName (TypeDefinition.DefaultIndexerName, GetLocation ($1));
+	  }
+	| explicit_interface THIS
+	  {
+		lexer.parsing_generic_declaration = false;
+		$$ = new MemberName (TypeDefinition.DefaultIndexerName, null, (ATypeNameExpression) $1, GetLocation ($2));
+	  }
+	;
+
+explicit_interface
+	: IDENTIFIER opt_type_argument_list DOT
+	  {
+		var lt = (Tokenizer.LocatedToken) $1;
+		$$ = new SimpleName (lt.Value, (TypeArguments) $2, lt.Location);
+		lbag.AddLocation ($$, GetLocation ($3));
+	  }
+//	| qualified_alias_member IDENTIFIER opt_type_argument_list DOT
+//	  {
+//		var lt1 = (Tokenizer.LocatedToken) $1;
+//		var lt2 = (Tokenizer.LocatedToken) $2;
+//
+//		$$ = new QualifiedAliasMember (lt1.Value, lt2.Value, (TypeArguments) $3, lt1.Location);
+//		lbag.AddLocation ($$, GetLocation ($4));
+//	  }
+	| explicit_interface IDENTIFIER opt_type_argument_list DOT
+	  {
+		var lt = (Tokenizer.LocatedToken) $2;
+		$$ = new MemberAccess ((ATypeNameExpression) $1, lt.Value, (TypeArguments) $3, lt.Location);
+		lbag.AddLocation ($$, GetLocation ($4));
+	  }
+	;
+	
+opt_type_parameter_list
+	: /* empty */
+	| OP_GENERICS_LT type_parameters OP_GENERICS_GT
+	  {
+		if (lang_version < LanguageVersion.ISO_2)
+			FeatureIsNotAvailable (GetLocation ($1), "generics");
+	  
+		$$ = $2;
+		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3));
+	  }
+	;
+
+type_parameters
+	: type_parameter
+	  {
+		var tparams = new TypeParameters ();
+		tparams.Add ((TypeParameter)$1);
+		$$ = tparams;
+	  }
+	| type_parameters COMMA type_parameter
+	  {
+		var tparams = (TypeParameters) $1;
+		tparams.Add ((TypeParameter)$3);
+		$$ = tparams;
+		lbag.AddLocation ($3, GetLocation ($3));
+	  }	  
+	;
+
+type_parameter
+	: opt_attributes opt_type_parameter_variance IDENTIFIER
+	  {
+		var lt = (Tokenizer.LocatedToken)$3;
+		$$ = new TypeParameter (new MemberName (lt.Value, lt.Location), (Attributes)$1, (Variance) $2);
+  	  }
+  	| error
+  	  {
+  	  	if (GetTokenName (yyToken) == "type")
+			report.Error (81, GetLocation ($1), "Type parameter declaration must be an identifier not a type");
+		else
+			Error_SyntaxError (yyToken);
+			
+  	  	$$ = new TypeParameter (MemberName.Null, null, Variance.None);
+  	  }
+ 	;
+
+//
+// All types where void is allowed
+//
+type_and_void
+	: type_expression_or_array
+	| VOID
+	  {
+		$$ = new TypeExpression (compiler.BuiltinTypes.Void, GetLocation ($1));
+	  }
+	;
+	
+member_type
+	: type_and_void
+	  {
+		lexer.parsing_generic_declaration = true;
+	  }
+	;
+	
+//
+// A type which does not allow `void' to be used
+//
+type
+	: type_expression_or_array
+	| VOID
+	  {
+	  	Expression.Error_VoidInvalidInTheContext (GetLocation ($1), report);
+		$$ = new TypeExpression (compiler.BuiltinTypes.Void, GetLocation ($1));
+	  }	
+	;
+	
+simple_type
+	: type_expression
+	| VOID
+	  {
+	  	Expression.Error_VoidInvalidInTheContext (GetLocation ($1), report);
+		$$ = new TypeExpression (compiler.BuiltinTypes.Void, GetLocation ($1));
+	  }	
+	;
+	
+parameter_type
+	: type_expression_or_array
+	| VOID
+	  {
+	  	report.Error (1536, GetLocation ($1), "Invalid parameter type `void'");
+		$$ = new TypeExpression (compiler.BuiltinTypes.Void, GetLocation ($1));
+	  }	
+	;
+
+type_expression_or_array
+	: type_expression
+	| type_expression rank_specifiers
+	  {
+	  	CheckIsPlayScript("arrays", GetLocation($2));
+		$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
+	  }
+	;
+	
+type_expression
+	: namespace_or_type_expr opt_nullable
+	  {
+		if ($2 != null) {
+			$$ = new ComposedCast ((ATypeNameExpression) $1, (ComposedTypeSpecifier) $2);
+		} else {
+			var sn = $1 as SimpleName;
+			if (sn != null)
+				$$ = ConvertAsType(sn, $1);
+			else
+				$$ = $1;
+		}
+	  }
+	| STAR
+	  {
+	  	$$ = new TypeExpression (compiler.BuiltinTypes.Dynamic, GetLocation ($1));
+	  }
+//	| namespace_or_type_expr pointer_stars
+//	  {
+//		$$ = new ComposedCast ((ATypeNameExpression) $1, (ComposedTypeSpecifier) $2);
+//	  }
+	| builtin_types opt_nullable
+	  {
+		if ($2 != null)
+			$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
+	  }
+//	| builtin_types pointer_stars
+//	  {
+//		$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
+//	  }
+//	| VOID pointer_stars
+//	  {
+//		$$ = new ComposedCast (new TypeExpression (compiler.BuiltinTypes.Void, GetLocation ($1)), (ComposedTypeSpecifier) $2);
+//	  }
+	;
+
+type_list
+	: base_type_name
+	  {
+		var types = new List<FullNamedExpression> (2);
+		types.Add ((FullNamedExpression) $1);
+		$$ = types;
+	  }
+	| type_list COMMA base_type_name
+	  {
+		var types = (List<FullNamedExpression>) $1;
+		types.Add ((FullNamedExpression) $3);
+		$$ = types;
+	  }
+	;
+
+base_type_name
+	: type
+	  {
+		if ($1 is ComposedCast) {
+			report.Error (1521, GetLocation ($1), "Invalid base type `{0}'", ((ComposedCast)$1).GetSignatureForError ());
+		}
+		$$ = $1;
+	  }
+	;
+	
+/*
+ * replaces all the productions for isolating the various
+ * simple types, but we need this to reuse it easily in variable_type
+ */
+builtin_types
+	: /* OBJECT	{ $$ = new TypeExpression (compiler.BuiltinTypes.Object, GetLocation ($1)); }
+	| STRING	{ $$ = new TypeExpression (compiler.BuiltinTypes.String, GetLocation ($1)); }
+	| BOOL		{ $$ = new TypeExpression (compiler.BuiltinTypes.Bool, GetLocation ($1)); }
+	| */ DECIMAL { CheckIsPlayScript("decimal", GetLocation($1)); $$ = new TypeExpression (compiler.BuiltinTypes.Decimal, GetLocation ($1)); }
+	| FLOAT		{ CheckIsPlayScript("float", GetLocation($1)); $$ = new TypeExpression (compiler.BuiltinTypes.Float, GetLocation ($1)); }
+//	| FLOAT2	{ CheckIsPlayScript("float2", GetLocation($1)); $$ = MakeMonoSimdType("Vector4f", GetLocation($1)); }
+//	| FLOAT3	{ CheckIsPlayScript("float3", GetLocation($1)); $$ = MakeMonoSimdType("Vector4f", GetLocation($1)); }
+//	| FLOAT4	{ CheckIsPlayScript("float4", GetLocation($1)); $$ = MakeMonoSimdType("Vector4f", GetLocation($1)); }
+	| DOUBLE	{ CheckIsPlayScript("double", GetLocation($1)); $$ = new TypeExpression (compiler.BuiltinTypes.Double, GetLocation ($1)); }
+//	| DOUBLE2	{ CheckIsPlayScript("double2", GetLocation($1)); $$ = MakeMonoSimdType("Vector2d", GetLocation($1)); }
+//	| DOUBLE3	{ CheckIsPlayScript("double3", GetLocation($1)); $$ = MakeMonoSimdType("Vector4d", GetLocation($1)); }
+//	| DOUBLE4	{ CheckIsPlayScript("double4", GetLocation($1)); $$ = MakeMonoSimdType("Vector4d", GetLocation($1)); }
+	| integral_type
+	;
+
+integral_type
+	: SBYTE		{ CheckIsPlayScript("sbyte", GetLocation($1)); $$ = new TypeExpression (compiler.BuiltinTypes.SByte, GetLocation ($1)); }
+	| BYTE		{ CheckIsPlayScript("byte", GetLocation($1)); $$ = new TypeExpression (compiler.BuiltinTypes.Byte, GetLocation ($1)); }
+	| SHORT		{ CheckIsPlayScript("short", GetLocation($1)); $$ = new TypeExpression (compiler.BuiltinTypes.Short, GetLocation ($1)); }
+	| USHORT	{ CheckIsPlayScript("ushort", GetLocation($1)); $$ = new TypeExpression (compiler.BuiltinTypes.UShort, GetLocation ($1)); }
+	| INT		{ $$ = new TypeExpression (compiler.BuiltinTypes.Int, GetLocation ($1)); }
+	| UINT		{ $$ = new TypeExpression (compiler.BuiltinTypes.UInt, GetLocation ($1)); }
+	| LONG		{ CheckIsPlayScript("long", GetLocation($1)); $$ = new TypeExpression (compiler.BuiltinTypes.Long, GetLocation ($1)); }
+	| ULONG		{ CheckIsPlayScript("ulong", GetLocation($1)); $$ = new TypeExpression (compiler.BuiltinTypes.ULong, GetLocation ($1)); }
+	| CHAR		{ CheckIsPlayScript("char", GetLocation($1)); $$ = new TypeExpression (compiler.BuiltinTypes.Char, GetLocation ($1)); }
+	;
+
+//
+// Expressions, section 7.5
+//
+
+
+primary_expression
+	: primary_expression_or_type
+	| literal
+//	| array_creation_expression
+	| parenthesized_expression
+	| default_value_expression
+	| invocation_expression
+	| element_access
+	| this_access
+	| base_access
+	| post_increment_expression
+	| post_decrement_expression
+//	| object_or_delegate_creation_expression
+//	| anonymous_type_expression
+//	| typeof_expression
+	| sizeof_expression
+	| checked_expression
+	| unchecked_expression
+	| new_expression
+//	| pointer_member_access
+	| anonymous_method_expression
+//	| undocumented_expressions
+	| array_initializer
+	| object_or_collection_initializer
+	;
+
+primary_expression_or_type
+	: IDENTIFIER opt_type_argument_list
+	  {
+	    // primary_expression_or_type
+		var lt = (Tokenizer.LocatedToken) $1;
+		$$ = new SimpleName (lt.Value, (TypeArguments)$2, lt.Location);	  
+	  }
+	| IDENTIFIER GENERATE_COMPLETION {
+		var lt = (Tokenizer.LocatedToken) $1;
+	       $$ = new CompletionSimpleName (MemberName.MakeName (lt.Value, null), lt.Location);
+	  }
+	| member_access
+	;
+
+literal
+	: boolean_literal
+	| LITERAL
+	| UNDEFINED		{ $$ = new AsUndefinedLiteral (GetLocation ($1)); }
+	| NULL			{ $$ = new NullLiteral (GetLocation ($1)); }
+	;
+
+boolean_literal
+	: TRUE			{ $$ = new BoolLiteral (compiler.BuiltinTypes, true, GetLocation ($1)); }
+	| FALSE			{ $$ = new BoolLiteral (compiler.BuiltinTypes, false, GetLocation ($1)); }
+	;
+
+
+//
+// Here is the trick, tokenizer may think that parens is a special but
+// parser is interested in open parens only, so we merge them.
+// Consider: if (a)foo ();
+//
+open_parens_any
+	: OPEN_PARENS
+	| OPEN_PARENS_CAST
+	;
+
+// 
+// Use this production to accept closing parenthesis or 
+// performing completion
+//
+close_parens
+	: CLOSE_PARENS
+	| COMPLETE_COMPLETION
+	;
+
+
+parenthesized_expression
+	: OPEN_PARENS expression CLOSE_PARENS
+	  {
+		$$ = new ParenthesizedExpression ((Expression) $2, GetLocation ($1));
+		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3));
+	  }
+	| OPEN_PARENS expression COMPLETE_COMPLETION
+	  {
+		$$ = new ParenthesizedExpression ((Expression) $2, GetLocation ($1));
+	  }
+	;
+	
+member_access
+	: primary_expression DOT IDENTIFIER opt_type_argument_list
+	  {
+	    // member_access
+		var lt = (Tokenizer.LocatedToken) $3;
+		$$ = new MemberAccess ((Expression) $1, lt.Value, (TypeArguments) $4, lt.Location);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+
+	| primary_expression DOT_AT IDENTIFIER
+	  {
+		var lt = (Tokenizer.LocatedToken) $3;
+		var ma = new MemberAccess ((Expression) $1, lt.Value, null, lt.Location);
+		ma.AccessorType = MemberAccess.Accessor.AsE4xChildAttribute;
+		lbag.AddLocation ($$, GetLocation ($2));
+		$$ = ma;
+	  }
+	| primary_expression DOT_STAR
+	  {
+		var ma = new MemberAccess ((Expression) $1, "any", null, GetLocation($2));
+		ma.AccessorType = MemberAccess.Accessor.AsE4xChildAll;
+		lbag.AddLocation ($$, GetLocation ($2));
+		$$ = ma;
+	  }
+	| primary_expression DOTDOT IDENTIFIER
+	  {
+		var lt = (Tokenizer.LocatedToken) $3;
+		var ma = new MemberAccess ((Expression) $1, lt.Value, null, lt.Location);
+		ma.AccessorType = MemberAccess.Accessor.AsE4xDescendant;
+		lbag.AddLocation ($$, GetLocation ($2));
+		$$ = ma;
+	  }
+	| primary_expression DOTDOT_STAR
+	  {
+		var ma = new MemberAccess ((Expression) $1, "any", null, GetLocation($2));
+		ma.AccessorType = MemberAccess.Accessor.AsE4xDescendantAll;
+		lbag.AddLocation ($$, GetLocation ($2));
+		$$ = ma;
+	  }
+	| primary_expression DOUBLE_COLON IDENTIFIER
+	  {
+		var lt = (Tokenizer.LocatedToken) $3;
+		var ma = new MemberAccess ((Expression) $1, lt.Value, null, lt.Location);
+		ma.AccessorType = MemberAccess.Accessor.AsE4xNamespace;
+		lbag.AddLocation ($$, GetLocation ($2));
+		$$ = ma;
+	  }
+	| primary_expression DOUBLE_COLON OPEN_BRACKET_EXPR expression_list_arguments CLOSE_BRACKET
+	  {
+		var ea = new ElementAccess ((Expression) $1, (Arguments) $4, GetLocation ($3));
+		ea.AccessorType = ElementAccess.Accessor.AsE4xNamespaceAccess;
+		lbag.AddLocation (GetLocation ($3), GetLocation ($5));
+		$$ = ea;
+	  }	  
+	| primary_expression DOT_AT OPEN_BRACKET_EXPR expression_list_arguments CLOSE_BRACKET
+	  {
+		var ea = new ElementAccess ((Expression) $1, (Arguments) $4, GetLocation ($3));
+		ea.AccessorType = ElementAccess.Accessor.AsE4xAttributeAccess;
+		lbag.AddLocation (GetLocation ($3), GetLocation ($5));
+		$$ = ea;
+	  }	  
+	| primary_expression DOT OPEN_PARENS expression CLOSE_PARENS
+	  {
+		var lt = (Tokenizer.LocatedToken) $3;
+		var ma = new AsXmlQueryExpression ((Expression) $1, (Expression) $4, lt.Location);
+		lbag.AddLocation ($$, GetLocation ($2));
+		$$ = ma;
+	  }   
+	| builtin_types DOT IDENTIFIER opt_type_argument_list
+	  {
+		var lt = (Tokenizer.LocatedToken) $3;
+		$$ = new MemberAccess ((Expression) $1, lt.Value, (TypeArguments) $4, lt.Location);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| SUPER DOT IDENTIFIER opt_type_argument_list
+	  {
+		var lt = (Tokenizer.LocatedToken) $3;
+		$$ = new MemberAccess (new BaseThis (GetLocation ($1)), lt.Value, (TypeArguments) $4, lt.Location);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+//	| qualified_alias_member IDENTIFIER opt_type_argument_list
+//	  {
+//		var lt1 = (Tokenizer.LocatedToken) $1;
+//		var lt2 = (Tokenizer.LocatedToken) $2;
+//
+//		$$ = new QualifiedAliasMember (lt1.Value, lt2.Value, (TypeArguments) $3, lt1.Location);
+//		lbag.AddLocation ($$, GetLocation ($2));
+//	  }
+	| primary_expression DOT GENERATE_COMPLETION {
+		$$ = new CompletionMemberAccess ((Expression) $1, null,GetLocation ($3));
+	  }
+	| primary_expression DOT IDENTIFIER GENERATE_COMPLETION {
+		var lt = (Tokenizer.LocatedToken) $3;
+		$$ = new CompletionMemberAccess ((Expression) $1, lt.Value, lt.Location);
+	  }
+	| builtin_types DOT GENERATE_COMPLETION
+	  {
+		$$ = new CompletionMemberAccess ((Expression) $1, null, lexer.Location);
+	  }
+	| builtin_types DOT IDENTIFIER GENERATE_COMPLETION {
+		var lt = (Tokenizer.LocatedToken) $3;
+		$$ = new CompletionMemberAccess ((Expression) $1, lt.Value, lt.Location);
+ 	  }
+	;
+
+invocation_expression
+	: SUPER open_parens_any opt_argument_list close_parens
+	  {
+		if (current_constructor == null)
+ 			report.Error (7014, GetLocation ($1), "Base constructor initializer may only be called in constructor");
+ 		var initializer = new ConstructorBaseInitializer ((Arguments) $3, GetLocation ($1));
+ 		initializer.IsAsExplicitSuperCall = true;
+ 		current_constructor.Initializer = initializer;
+ 		$$ = initializer;
+		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($2), GetLocation ($4));
+	  }
+	| builtin_types open_parens_any opt_argument_list close_parens
+	  {
+		$$ = new Invocation ((Expression) $1, (Arguments) $3);
+		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
+	  }  
+	| primary_expression open_parens_any opt_argument_list close_parens
+	  {
+	    var newExpr = $1 as AsNew;
+	    if (newExpr != null) {
+		    // Convert Invocation(AsNew()) into AsNew(Invocation())
+			var invExpr = new Invocation(newExpr.Expr, (Arguments) $3);
+			newExpr.Expr = invExpr;
+			$$ = newExpr;
+	    } else {
+	    	// Just a normal invocation
+			$$ = new Invocation ((Expression) $1, (Arguments) $3);
+	    }
+		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
+	  }
+	| primary_expression open_parens_any argument_list error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Invocation ((Expression) $1, (Arguments) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	;
+
+object_or_collection_initializer
+    : init_open_brace opt_member_initializer_list init_close_brace_or_complete_completion
+	  {
+	    var expList = $2 as List<Expression>;
+	    if (expList == null) {
+	    	expList = new List<Expression>();
+	    }
+  		var oi = new AsObjectInitializer (expList, GetLocation ($1));
+		if (current_variable != null) {
+			oi.VariableDeclaration = current_variable;
+		}
+		lbag.AddLocation ($$, GetLocation ($3));
+  		$$ = oi;
+	  }
+	| init_open_brace member_initializer_list COMMA init_close_brace
+	  {
+	  	var oi = new AsObjectInitializer ((List<Expression>) $2, GetLocation ($1));
+		if (current_variable != null) {
+			oi.VariableDeclaration = current_variable;
+		}
+	  	lbag.AddLocation ($$, GetLocation ($3), GetLocation ($4));
+	  	$$ = oi;
+	  }
+	;
+
+init_open_brace
+	: OPEN_BRACE_INIT
+	  {
+      	oob_stack.Push (Lexer.AutoSemiInsertion);
+        Lexer.AutoSemiInsertion = false;
+	  }
+	;
+
+init_close_brace
+ 	: CLOSE_BRACE
+ 	  {
+      	Lexer.AutoSemiInsertion = (bool) oob_stack.Pop ();
+      	if (Lexer.AutoSemiInsertion)
+	 	  	Lexer.AllowAutoSemiAfterToken(Token.CLOSE_BRACE, true);
+ 	  }
+ 	;
+ 	
+init_close_brace_or_complete_completion
+	: CLOSE_BRACE
+ 	  {
+      	Lexer.AutoSemiInsertion = (bool) oob_stack.Pop ();
+      	if (Lexer.AutoSemiInsertion)
+	 	  	Lexer.AllowAutoSemiAfterToken(Token.CLOSE_BRACE, true);
+ 	  }
+	| COMPLETE_COMPLETION
+	; 	
+
+opt_member_initializer_list
+	: /* empty */		{ $$ = null; }
+	| member_initializer_list
+	  {
+		$$ = $1;
+	  }
+	;
+
+member_initializer_list
+	: member_initializer
+	  {
+	  	var a = new List<Expression> ();
+	  	a.Add ((Expression) $1);
+	  	$$ = a;
+	  }
+	| member_initializer_list COMMA member_initializer
+	  {
+	  	var a = (List<Expression>)$1;
+	  	a.Add ((Expression) $3);
+	  	$$ = a;
+	  }
+	| member_initializer_list error {
+	  	Error_SyntaxError (yyToken);
+		$$ = $1;
+	  }
+	;
+
+member_initializer
+	: IDENTIFIER COLON initializer_value
+	  {
+	  	var lt = (Tokenizer.LocatedToken) $1;
+	  	$$ = new ElementInitializer (lt.Value, (Expression)$3, lt.Location);
+	  	lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| AWAIT ASSIGN initializer_value
+	  {
+	  	var lt = (Tokenizer.LocatedToken) Error_AwaitAsIdentifier ($1);
+	  	$$ = new ElementInitializer (lt.Value, (Expression)$3, lt.Location);
+	  	lbag.AddLocation ($$, GetLocation ($2));
+	  }	  
+	| LITERAL COLON initializer_value
+	  {
+	  	ILiteralConstant lit = $1 as ILiteralConstant;
+		string nm;	  	
+	  	if (lit is StringLiteral) {
+			nm = ((StringLiteral)lit).Value;
+		} else {
+	  		if (parsing_playscript || !(lit is IntLiteral || lit is DoubleLiteral || lit is BoolLiteral)) {
+			  	report.Error (7019, GetLocation ($1), "Must be identifier or string literal");
+			  	nm = "err";
+			 } else {
+				nm = ((Constant)$1).GetValueAsLiteral();			 
+			 }
+		}
+	  
+	  	$$ = new ElementInitializer (nm, (Expression)$3, GetLocation($1));
+	  	lbag.AddLocation ($$, GetLocation ($2));
+	  } 
+	| GENERATE_COMPLETION 
+	  {
+		$$ = new CompletionElementInitializer (null, GetLocation ($1));
+	  }
+	/* | non_assignment_expression opt_COMPLETE_COMPLETION  {
+		CompletionSimpleName csn = $1 as CompletionSimpleName;
+		if (csn == null)
+			$$ = new CollectionElementInitializer ((Expression)$1);
+		else
+			$$ = new CompletionElementInitializer (csn.Prefix, csn.Location);
+	  } 
+	| OPEN_BRACE expression_list CLOSE_BRACE
+	  {
+		if ($2 == null)
+			$$ = null;
+		else
+	  		$$ = new CollectionElementInitializer ((List<Expression>)$2, GetLocation ($1));
+	  } 
+	| OPEN_BRACE CLOSE_BRACE
+	  {
+	  	report.Error (1920, GetLocation ($1), "An element initializer cannot be empty");
+		$$ = null;
+	  } */  
+	;
+
+initializer_value
+	: expression
+	;
+
+opt_argument_list
+	: /* empty */		{ $$ = null; }
+	| argument_list
+	;
+
+argument_list
+	: argument_or_named_argument
+	  { 
+		Arguments list = new Arguments (4);
+		list.Add ((Argument) $1);
+		$$ = list;
+	  }
+	| argument_list COMMA argument
+	  {
+		Arguments list = (Arguments) $1;
+		if (list [list.Count - 1] is NamedArgument)
+			Error_NamedArgumentExpected ((NamedArgument) list [list.Count - 1]);
+		
+		list.Add ((Argument) $3);
+		$$ = list;
+	  }
+	| argument_list COMMA named_argument
+	  {
+		Arguments list = (Arguments) $1;
+		NamedArgument a = (NamedArgument) $3;
+		for (int i = 0; i < list.Count; ++i) {
+			NamedArgument na = list [i] as NamedArgument;
+			if (na != null && na.Name == a.Name)
+				report.Error (1740, na.Location, "Named argument `{0}' specified multiple times",
+					na.Name);
+		}
+		
+		list.Add (a);
+		$$ = list;
+	  }
+	| argument_list COMMA error
+	  {
+	  	lexer.putback (')'); // TODO: Wrong but what can I do
+		Error_SyntaxError (yyToken);
+		$$ = $1;
+	  }
+	| COMMA error
+	  {
+	  	report.Error (839, GetLocation ($1), "An argument is missing");
+	  	$$ = null;
+	  }
+	;
+
+argument
+	: expression
+	  {
+		$$ = new Argument ((Expression) $1);
+	  }
+	| non_simple_argument
+	;
+
+argument_or_named_argument
+	: argument
+	| named_argument
+	;
+
+non_simple_argument
+	: REF variable_reference 
+	  { 
+		$$ = new Argument ((Expression) $2, Argument.AType.Ref);
+		lbag.AddLocation ($$, GetLocation ($1));
+	  }
+	| OUT variable_reference 
+	  { 
+		$$ = new Argument ((Expression) $2, Argument.AType.Out);
+		lbag.AddLocation ($$, GetLocation ($1));
+	  }
+//	| ARGLIST OPEN_PARENS argument_list CLOSE_PARENS
+//	  {
+//		$$ = new Argument (new Arglist ((Arguments) $3, GetLocation ($1)));
+//		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
+//	  }
+//	| ARGLIST OPEN_PARENS CLOSE_PARENS
+//	  {
+//		$$ = new Argument (new Arglist (GetLocation ($1)));
+//		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($3));
+//	  }	  
+	;
+
+variable_reference
+	: expression
+	;
+
+element_access
+	: primary_expression OPEN_BRACKET_EXPR expression_list_arguments CLOSE_BRACKET	
+	  {
+	    var newExpr = $1 as AsNew;
+	    if (newExpr != null) {
+		    // Convert ElementAccess(AsNew()) into AsNew(ElementAccess())
+			var elemAccessExpr = new ElementAccess(newExpr.Expr, (Arguments) $3, GetLocation ($2));
+			newExpr.Expr = elemAccessExpr;
+			$$ = newExpr;
+	    } else {
+			$$ = new ElementAccess ((Expression) $1, (Arguments) $3, GetLocation ($2));
+		}
+		lbag.AddLocation ($$, GetLocation ($4));
+	  }
+	| primary_expression OPEN_BRACKET_EXPR expression_list_arguments error
+	  {
+		Error_SyntaxError (yyToken);
+		$$ = new ElementAccess ((Expression) $1, (Arguments) $3, GetLocation ($2));
+	  }
+	| primary_expression OPEN_BRACKET_EXPR error
+	  {
+		Error_SyntaxError (yyToken);
+		$$ = new ElementAccess ((Expression) $1, null, GetLocation ($2));
+	  }
+	| builtin_types OPEN_BRACKET_EXPR expression_list_arguments CLOSE_BRACKET	
+	  {
+		$$ = new ElementAccess ((Expression) $1, (Arguments) $3, GetLocation ($2));
+		lbag.AddLocation ($$, GetLocation ($4));
+	  }
+	| builtin_types OPEN_BRACKET_EXPR expression_list_arguments error
+	  {
+		Error_SyntaxError (yyToken);
+		$$ = new ElementAccess ((Expression) $1, (Arguments) $3, GetLocation ($2));
+	  }
+	| builtin_types OPEN_BRACKET_EXPR error
+	  {
+		Error_SyntaxError (yyToken);
+		$$ = new ElementAccess ((Expression) $1, null, GetLocation ($2));
+	  }	  
+	;
+
+expression_list
+	: expression
+	  {
+		var list = new List<Expression> (4);
+		list.Add ((Expression) $1);
+		$$ = list;
+	  }
+	| expression_list COMMA expression
+	  {
+		var list = (List<Expression>) $1;
+		list.Add ((Expression) $3);
+		$$ = list;
+	  }
+	| expression_list error {
+	  	Error_SyntaxError (yyToken);
+		$$ = $1;
+	  }
+	;
+	
+expression_list_arguments
+	: expression_list_argument
+	  {
+		Arguments args = new Arguments (4);
+		args.Add ((Argument) $1);
+		$$ = args;
+	  }
+	| expression_list_arguments COMMA expression_list_argument
+	  {
+		Arguments args = (Arguments) $1;
+		if (args [args.Count - 1] is NamedArgument && !($3 is NamedArgument))
+			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
+	  
+		args.Add ((Argument) $3);
+		$$ = args;	  
+	  }
+	;
+	
+expression_list_argument
+	: expression
+	  {
+	  	$$ = new Argument ((Expression) $1);
+	  }
+	| named_argument
+	;
+
+this_access
+	: THIS
+	  {
+		$$ = new This (GetLocation ($1));
+	  }
+	;
+
+base_access
+	: SUPER OPEN_BRACKET_EXPR expression_list_arguments CLOSE_BRACKET
+	  {
+	  	$$ = new ElementAccess (new BaseThis (GetLocation ($1)), (Arguments) $3, GetLocation ($2));
+		lbag.AddLocation ($$, GetLocation ($4));
+	  }
+	| SUPER OPEN_BRACKET error
+	  {
+	  	Error_SyntaxError (yyToken);
+		$$ = new ElementAccess (null, null, GetLocation ($2));
+	  }
+	;
+
+post_increment_expression
+	: primary_expression OP_INC
+	  {
+		$$ = new UnaryMutator (UnaryMutator.Mode.PostIncrement, (Expression) $1, GetLocation ($2));
+	  }
+	;
+
+post_decrement_expression
+	: primary_expression OP_DEC
+	  {
+		$$ = new UnaryMutator (UnaryMutator.Mode.PostDecrement, (Expression) $1, GetLocation ($2));
+	  }
+	;
+	
+//object_or_delegate_creation_expression
+//	: NEW new_expr_type open_parens_any opt_argument_list CLOSE_PARENS
+//	  {
+//	  	$$ = new New ((FullNamedExpression) $2, (Arguments) $4, GetLocation ($1));
+//		
+//		lbag.AddLocation ($$, GetLocation ($3), GetLocation ($5));
+//	  }
+//	| NEW new_expr_type SEMICOLON
+//	  {
+//		$$ = new New ((FullNamedExpression) $2, null, GetLocation ($1));
+//	  	lexer.putback (';');
+//	  }
+//	| NEW OP_LT type_expression OP_GT array_initializer
+//	  {
+//	    var arrayInit = (AsArrayInitializer) $5;
+//	    arrayInit.VectorType = (FullNamedExpression) $3;
+//	    $$ = arrayInit;
+//	  }
+//	;
+
+//array_creation_expression
+//	: NEW new_expr_type OPEN_BRACKET_EXPR expression_list CLOSE_BRACKET
+//	  opt_rank_specifier
+//	  /* opt_array_initializer */
+//	  {
+//	  	CheckIsPlayScript("arrays", GetLocation($1));
+//		$$ = new ArrayCreation ((FullNamedExpression) $2, (List<Expression>) $4,
+//				new ComposedTypeSpecifier (((List<Expression>) $4).Count, GetLocation ($3)) {
+//	  				Next = (ComposedTypeSpecifier) $6
+//			  	}, (AsArrayInitializer) null /*$7*/, GetLocation ($1));
+//		lbag.AddLocation ($$, GetLocation ($3), GetLocation ($5));
+//	  }
+//	| NEW new_expr_type OPEN_BRACKET CLOSE_BRACKET OPEN_BRACKET_EXPR error CLOSE_BRACKET
+//	  {
+//	  	CheckIsPlayScript("arrays", GetLocation($1));
+//		report.Error (178, GetLocation ($6), "Invalid rank specifier, expecting `,' or `]'");
+//		$$ = new ArrayCreation ((FullNamedExpression) $2, null, GetLocation ($1));
+//	  }
+//	| NEW new_expr_type error
+//	  {
+//		Error_SyntaxError (yyToken);
+//		// It can be any of new expression, create the most common one
+//		$$ = new New ((FullNamedExpression) $2, null, GetLocation ($1));
+//	  }
+//	;
+
+//new_expr_type
+//	: {
+//		++lexer.parsing_type;
+//	  }
+//	  simple_type
+//	  {
+//		--lexer.parsing_type;
+//		$$ = $2;
+//	  }
+//	;
+
+new_expression
+	: NEW namespace_or_type_expr
+	  {
+		$$ = new AsNew ((Expression) $2, GetLocation ($1));
+	  }
+	| NEW builtin_types
+	  {
+		$$ = new AsNew ((Expression) $2, GetLocation ($1));
+	  }	  
+	| NEW OPEN_PARENS expression CLOSE_PARENS
+	  {
+		$$ = new AsNew ((Expression) $3, GetLocation ($1));
+	  }
+	| NEW OP_LT type_expression OP_GT array_initializer
+	  {
+	    var arrayInit = (AsArrayInitializer) $5;
+	    arrayInit.VectorType = (FullNamedExpression) $3;
+	    $$ = arrayInit;
+	  }
+	;
+
+//anonymous_type_expression
+//	: NEW OPEN_BRACE anonymous_type_parameters_opt_comma CLOSE_BRACE
+//	  {
+//		if (lang_version <= LanguageVersion.ISO_2)
+//	  		FeatureIsNotAvailable (GetLocation ($1), "anonymous types");
+//
+//		$$ = new NewAnonymousType ((List<AnonymousTypeParameter>) $3, current_container, GetLocation ($1));
+//		
+//		// TODO: lbag comma location
+//		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
+//	  }
+//	;
+
+//anonymous_type_parameters_opt_comma
+//	: anonymous_type_parameters_opt
+//	| anonymous_type_parameters COMMA
+//	;
+
+//anonymous_type_parameters_opt
+//	: { $$ = null; }
+//	| anonymous_type_parameters
+//	;
+
+//anonymous_type_parameters
+//	: anonymous_type_parameter
+//	  {
+//	  	var a = new List<AnonymousTypeParameter> (4);
+//	  	a.Add ((AnonymousTypeParameter) $1);
+//	  	$$ = a;
+//	  }
+//	| anonymous_type_parameters COMMA anonymous_type_parameter
+//	  {
+//	  	var a = (List<AnonymousTypeParameter>) $1;
+//	  	a.Add ((AnonymousTypeParameter) $3);
+//	  	$$ = a;
+//	  }
+//	;
+
+//anonymous_type_parameter
+//	: IDENTIFIER ASSIGN variable_initializer
+//	  {
+//		var lt = (Tokenizer.LocatedToken)$1;
+//	  	$$ = new AnonymousTypeParameter ((Expression)$3, lt.Value, lt.Location);
+//	  	lbag.AddLocation ($$, GetLocation ($2));
+//	  }
+//	| IDENTIFIER
+//	  {
+//		var lt = (Tokenizer.LocatedToken)$1;
+//	  	$$ = new AnonymousTypeParameter (new SimpleName (lt.Value, lt.Location),
+//	  		lt.Value, lt.Location);
+//	  }
+//	| member_access
+//	  {
+//	  	MemberAccess ma = (MemberAccess) $1;
+//	  	$$ = new AnonymousTypeParameter (ma, ma.Name, ma.Location);
+//	  }
+//	| error
+//	  {
+//		report.Error (746, lexer.Location,
+//			"Invalid anonymous type member declarator. Anonymous type members must be a member assignment, simple name or member access expression");
+//		$$ = null;
+//	  }
+//	;
+
+//opt_rank_specifier
+//	: /* empty */
+//	| rank_specifiers
+//	;
+
+rank_specifiers
+	: rank_specifier
+	| rank_specifier rank_specifiers
+	  {
+	  	((ComposedTypeSpecifier) $1).Next = (ComposedTypeSpecifier) $2;
+	  	$$ = $1;
+	  }
+	;
+
+rank_specifier
+	: OPEN_BRACKET CLOSE_BRACKET
+	  {
+		$$ = ComposedTypeSpecifier.CreateArrayDimension (1, GetLocation ($1));
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| OPEN_BRACKET dim_separators CLOSE_BRACKET
+	  {
+		$$ = ComposedTypeSpecifier.CreateArrayDimension ((int)$2, GetLocation ($1));
+		lbag.AddLocation ($$, GetLocation ($3));
+	  }
+	;
+
+dim_separators
+	: COMMA
+	  {
+		$$ = 2;
+	  }
+	| dim_separators COMMA
+	  {
+		$$ = ((int) $1) + 1;
+	  }
+	;
+
+//opt_array_initializer
+//	: /* empty */
+//	  {
+//		$$ = null;
+//	  }
+//	| array_initializer
+//	  {
+//		$$ = $1;
+//	  }
+//	;
+
+array_initializer
+	: init_open_bracket init_close_bracket
+	  {
+		var ai = new AsArrayInitializer (0, GetLocation ($1));
+		if (current_variable != null) {
+			ai.VariableDeclaration = current_variable;
+		}
+		lbag.AddLocation (ai, GetLocation ($2));
+		$$ = ai;
+	  }
+	| init_open_bracket_expr variable_initializer_list opt_comma init_close_bracket
+	  {
+		var ai = new AsArrayInitializer ((List<Expression>) $2, GetLocation ($1));
+		if (current_variable != null) {
+			ai.VariableDeclaration = current_variable;
+		}
+		if ($3 != null) {
+			lbag.AddLocation (ai, GetLocation ($3), GetLocation ($4));
+		} else {
+			lbag.AddLocation (ai, GetLocation ($4));
+		}
+		$$ = ai;
+	  }
+	;
+	
+init_open_bracket
+	: OPEN_BRACKET
+	  {
+      	oob_stack.Push (Lexer.AutoSemiInsertion);
+        Lexer.AutoSemiInsertion = false;
+	  }
+	;
+
+init_open_bracket_expr
+	: OPEN_BRACKET_EXPR
+	  {
+      	oob_stack.Push (Lexer.AutoSemiInsertion);
+        Lexer.AutoSemiInsertion = false;
+	  }
+	;
+
+init_close_bracket
+ 	: CLOSE_BRACKET
+ 	  {
+      	Lexer.AutoSemiInsertion = (bool) oob_stack.Pop ();
+ 	  }
+ 	;	
+	
+variable_initializer_list
+	: variable_initializer
+	  {
+		var list = new List<Expression> (4);
+		list.Add ((Expression) $1);
+		$$ = list;
+	  }
+	| variable_initializer_list COMMA variable_initializer
+	  {
+		var list = (List<Expression>) $1;
+		list.Add ((Expression) $3);
+		$$ = list;
+	  }
+	;
+
+//typeof_expression
+//	: TYPEOF
+//      {
+//	  	lexer.TypeOfParsing = true;
+//	  }
+//	  open_parens_any typeof_type_expression CLOSE_PARENS
+//	  {
+//		CheckIsPlayScript("typeof", GetLocation($1)); 	  
+//	  	lexer.TypeOfParsing = false;
+//		$$ = new TypeOf ((FullNamedExpression) $4, GetLocation ($1));
+//		lbag.AddLocation ($$, GetLocation ($3), GetLocation ($5));
+//	  }
+//	;
+	
+typeof_type_expression
+	: type_and_void
+	| unbound_type_name
+	| error
+	 {
+	 	Error_TypeExpected (lexer.Location);
+	 	$$ = null;
+	 }
+	;
+	
+unbound_type_name
+	: identifier_inside_body generic_dimension
+	  {  
+		var lt = (Tokenizer.LocatedToken) $1;
+
+		$$ = new SimpleName (lt.Value, (int) $2, lt.Location);
+	  }
+//	| qualified_alias_member identifier_inside_body generic_dimension
+//	  {
+//		var lt1 = (Tokenizer.LocatedToken) $1;
+//		var lt2 = (Tokenizer.LocatedToken) $2;
+//
+//		$$ = new QualifiedAliasMember (lt1.Value, lt2.Value, (int) $3, lt1.Location);
+//		lbag.AddLocation ($$, GetLocation ($2));
+//	  }
+	| unbound_type_name DOT identifier_inside_body
+	  {
+		var lt = (Tokenizer.LocatedToken) $3;
+		
+		$$ = new MemberAccess ((Expression) $1, lt.Value, lt.Location);		
+	  }
+	| unbound_type_name DOT identifier_inside_body generic_dimension
+	  {
+		var lt = (Tokenizer.LocatedToken) $3;
+		
+		$$ = new MemberAccess ((Expression) $1, lt.Value, (int) $4, lt.Location);		
+	  }
+	| namespace_or_type_expr DOT identifier_inside_body generic_dimension
+	  {
+		var tne = (ATypeNameExpression) $1;
+		if (tne.HasTypeArguments)
+			Error_TypeExpected (GetLocation ($4));
+
+		var lt = (Tokenizer.LocatedToken) $3;
+		$$ = new MemberAccess (tne, lt.Value, (int) $4, lt.Location);		
+	  }
+	;
+
+generic_dimension
+	: GENERIC_DIMENSION
+	  {
+		if (lang_version < LanguageVersion.ISO_2)
+			FeatureIsNotAvailable (GetLocation ($1), "generics");
+
+		$$ = $1;
+	  }
+	;
+	
+//qualified_alias_member
+//	: IDENTIFIER DOUBLE_COLON
+//	  {
+//		var lt = (Tokenizer.LocatedToken) $1;
+//		if (lang_version == LanguageVersion.ISO_1)
+//			FeatureIsNotAvailable (lt.Location, "namespace alias qualifier");
+//
+//		$$ = lt;		
+//	  }
+//	;
+
+sizeof_expression
+	: SIZEOF open_parens_any type CLOSE_PARENS
+	  { 
+		CheckIsPlayScript("sizeof", GetLocation($1)); 	  
+		$$ = new SizeOf ((Expression) $3, GetLocation ($1));
+		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
+	  }
+	| SIZEOF open_parens_any type error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new SizeOf ((Expression) $3, GetLocation ($1));
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	;	
+
+checked_expression
+	: CHECKED open_parens_any expression CLOSE_PARENS
+	  {
+		CheckIsPlayScript("checked", GetLocation($1)); 	  
+		$$ = new CheckedExpr ((Expression) $3, GetLocation ($1));
+		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
+	  }
+	| CHECKED error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new CheckedExpr (null, GetLocation ($1));
+	  }
+	;
+
+unchecked_expression
+	: UNCHECKED open_parens_any expression CLOSE_PARENS
+	  {
+		CheckIsPlayScript("unchecked", GetLocation($1)); 	  
+		$$ = new UnCheckedExpr ((Expression) $3, GetLocation ($1));
+		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
+	  }
+	| UNCHECKED error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new UnCheckedExpr (null, GetLocation ($1));
+	  }
+	;
+
+//pointer_member_access
+//	: primary_expression OP_PTR IDENTIFIER opt_type_argument_list
+//	  {
+//		var lt = (Tokenizer.LocatedToken) $3;
+//		$$ = new MemberAccess (new Indirection ((Expression) $1, GetLocation ($2)), lt.Value, (TypeArguments) $4, lt.Location);
+//	  }
+//	;
+
+anonymous_method_expression
+	: FUNCTION OPEN_PARENS
+	  {
+	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
+	  }
+	  opt_formal_parameter_list CLOSE_PARENS COLON member_type
+	  {
+		valid_param_mod = 0;
+		start_anonymous (false, (ParametersCompiled) $4, (TypeExpr) $7, false, GetLocation ($1));
+	  }
+	  block
+	  {
+		$$ = end_anonymous ((ParametersBlock) $9);
+	  }
+	| ASYNC FUNCTION OPEN_PARENS
+	  {
+	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
+	  }
+	  opt_formal_parameter_list CLOSE_PARENS COLON member_type
+	  {
+		valid_param_mod = 0;
+		start_anonymous (false, (ParametersCompiled) $5, (FullNamedExpression) $8, true, GetLocation ($1));
+	  }
+	  block
+	  {
+		$$ = end_anonymous ((ParametersBlock) $10);
+	  }
+	;
+	
+local_function_statement
+	: FUNCTION IDENTIFIER OPEN_PARENS
+	  {
+	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
+	  }
+	  opt_formal_parameter_list CLOSE_PARENS COLON member_type
+	  {
+		valid_param_mod = 0;
+		start_anonymous (false, (ParametersCompiled) $5, (FullNamedExpression) $8, false, GetLocation ($1));
+	  }
+	  block
+	  {
+		var lt = (Tokenizer.LocatedToken) $2;
+		var anonMethod = end_anonymous ((ParametersBlock) $10);
+		var li = new LocalVariable (current_block.ParametersBlock.TopBlock, lt.Value, lt.Location);
+		var type = Delegate.CreateDelegateTypeExpression(compiler.BuiltinTypes, anonMethod.AsParameters, anonMethod.AsReturnType, GetLocation($1));
+		var decl = new BlockVariableDeclaration(type, li);
+		decl.Initializer = anonMethod;
+		current_block.AddLocalName (li);
+		current_block.ParametersBlock.TopBlock.AddScopeStatement (decl);	
+		$$ = new AsLocalFunction(GetLocation($1), lt.Value, anonMethod, decl);
+	  }
+	| ASYNC FUNCTION IDENTIFIER OPEN_PARENS
+	  {
+	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
+	  }
+	  opt_formal_parameter_list CLOSE_PARENS COLON member_type
+	  {
+		valid_param_mod = 0;
+		start_anonymous (false, (ParametersCompiled) $6, (FullNamedExpression) $9, true, GetLocation ($1));
+	  }
+	  block
+	  {
+	    var lt = (Tokenizer.LocatedToken) $3;
+		var anonMethod = end_anonymous ((ParametersBlock) $11);
+		var li = new LocalVariable (current_block.ParametersBlock.TopBlock, lt.Value, lt.Location);
+		var type = Delegate.CreateDelegateTypeExpression(compiler.BuiltinTypes, anonMethod.AsParameters, anonMethod.AsReturnType, GetLocation($1));
+		var decl = new BlockVariableDeclaration(type, li);
+		decl.Initializer = anonMethod;
+		current_block.AddLocalName (li);
+		current_block.ParametersBlock.TopBlock.AddScopeStatement (decl);	
+		$$ = new AsLocalFunction(GetLocation($1), lt.Value, anonMethod, decl);
+	  }
+	;	
+
+//anonymous_method_signature
+//	: OPEN_PARENS
+//	  {
+//	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
+//	  }
+//	  opt_formal_parameter_list CLOSE_PARENS opt_method_return_type
+//	  {
+//		valid_param_mod = 0;
+//	  	$$ = $3;
+//	  }
+//	;
+
+default_value_expression
+	: DEFAULT open_parens_any type CLOSE_PARENS
+	  {
+	  	CheckIsPlayScript("default values", GetLocation($1));
+	  
+		if (lang_version < LanguageVersion.ISO_2)
+			FeatureIsNotAvailable (GetLocation ($1), "default value expression");
+
+		$$ = new DefaultValueExpression ((Expression) $3, GetLocation ($1));
+		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
+	  }
+	;
+
+unary_expression
+	: primary_expression
+	| BANG prefixed_unary_expression
+	  {
+		$$ = new Unary (Unary.Operator.LogicalNot, (Expression) $2, GetLocation ($1));
+	  }
+	| TILDE prefixed_unary_expression
+	  {
+		$$ = new Unary (Unary.Operator.OnesComplement, (Expression) $2, GetLocation ($1));
+	  }
+//	| OPEN_PARENS_CAST type CLOSE_PARENS prefixed_unary_expression
+//	  {
+//		$$ = new Cast ((FullNamedExpression) $2, (Expression) $4, GetLocation ($1));
+//		lbag.AddLocation ($$, GetLocation ($3));
+//	  }
+	| AWAIT prefixed_unary_expression
+	  {
+	  	CheckIsPlayScript("await", GetLocation($1));
+	  	
+		if (!async_block) {
+			 if (current_anonymous_method is LambdaExpression) {
+				report.Error (4034, GetLocation ($1),
+					"The `await' operator can only be used when its containing lambda expression is marked with the `async' modifier");
+			} else if (current_anonymous_method is AnonymousMethodExpression) {
+				report.Error (4035, GetLocation ($1),
+					"The `await' operator can only be used when its containing anonymous method is marked with the `async' modifier");
+			} else {
+				report.Error (4033, GetLocation ($1),
+					"The `await' operator can only be used when its containing method is marked with the `async' modifier");
+			}
+		} else {
+			current_block.Explicit.RegisterAsyncAwait ();
+		}
+		
+		$$ = new Await ((Expression) $2, GetLocation ($1));
+	  }
+	| OP_AT prefixed_unary_expression
+	  {
+		$$ = new Unary (Unary.Operator.AsE4xAttribute, (Expression) $2, GetLocation ($1));
+	  }
+	| TYPEOF prefixed_unary_expression
+	  {
+	  	$$ = new AsTypeOf ((Expression) $2, GetLocation ($1));
+	  }
+	| DELETE prefixed_unary_expression
+	  {
+	  	var expr = $2 as Expression;
+	  	if (!(expr is ElementAccess || expr is MemberAccess)) {
+			report.Error (7022, GetLocation ($1),
+				"delete operator may only be used with element access or member access expressions");
+	  	}
+		$$ = new AsDelete ((Expression) $2, GetLocation ($1));
+	  } 
+	| BANG error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Unary (Unary.Operator.LogicalNot, null, GetLocation ($1));
+	  }
+	| TILDE error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Unary (Unary.Operator.OnesComplement, null, GetLocation ($1));
+	  }
+//	| OPEN_PARENS_CAST type CLOSE_PARENS error
+//	  {
+//		Error_SyntaxError (yyToken);
+//
+//		$$ = new Cast ((FullNamedExpression) $2, null, GetLocation ($1));
+//		lbag.AddLocation ($$, GetLocation ($3));
+//	  }
+	| AWAIT error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Await (null, GetLocation ($1));
+	  }
+	| OP_AT error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Unary (Unary.Operator.AsE4xAttribute, null, GetLocation ($1));
+	  }
+	| TYPEOF error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new AsTypeOf (null, GetLocation ($1));
+	  }	    
+	| DELETE error
+	  {
+		Error_SyntaxError (yyToken);
+		
+		$$ = new AsDelete (null, GetLocation ($1));
+	  }	  
+	;
+
+	//
+	// The idea to split this out is from Rhys' grammar
+	// to solve the problem with casts.
+	//
+prefixed_unary_expression
+	: unary_expression
+	| PLUS prefixed_unary_expression
+	  { 
+	  	$$ = new Unary (Unary.Operator.UnaryPlus, (Expression) $2, GetLocation ($1));
+	  } 
+	| MINUS prefixed_unary_expression 
+	  { 
+		$$ = new Unary (Unary.Operator.UnaryNegation, (Expression) $2, GetLocation ($1));
+	  }
+	| OP_INC prefixed_unary_expression 
+	  {
+		$$ = new UnaryMutator (UnaryMutator.Mode.PreIncrement, (Expression) $2, GetLocation ($1));
+	  }
+	| OP_DEC prefixed_unary_expression 
+	  {
+		$$ = new UnaryMutator (UnaryMutator.Mode.PreDecrement, (Expression) $2, GetLocation ($1));
+	  }
+//	| STAR prefixed_unary_expression
+//	  {
+//		$$ = new Indirection ((Expression) $2, GetLocation ($1));
+//	  }
+	| BITWISE_AND prefixed_unary_expression
+	  {
+		$$ = new Unary (Unary.Operator.AddressOf, (Expression) $2, GetLocation ($1));
+	  }
+	| PLUS error
+	  { 
+		Error_SyntaxError (yyToken);
+
+	  	$$ = new Unary (Unary.Operator.UnaryPlus, null, GetLocation ($1));
+	  } 
+	| MINUS error 
+	  { 
+		Error_SyntaxError (yyToken);
+
+		$$ = new Unary (Unary.Operator.UnaryNegation, null, GetLocation ($1));
+	  }
+	| OP_INC error 
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new UnaryMutator (UnaryMutator.Mode.PreIncrement, null, GetLocation ($1));
+	  }
+	| OP_DEC error 
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new UnaryMutator (UnaryMutator.Mode.PreDecrement, null, GetLocation ($1));
+	  }
+//	| STAR error
+//	  {
+//		Error_SyntaxError (yyToken);
+//
+//		$$ = new Indirection (null, GetLocation ($1));
+//	  }
+	| BITWISE_AND error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Unary (Unary.Operator.AddressOf, null, GetLocation ($1));
+	  }
+	;
+
+multiplicative_expression
+	: prefixed_unary_expression
+	| multiplicative_expression STAR prefixed_unary_expression
+	  {
+		$$ = new Binary (Binary.Operator.Multiply, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| multiplicative_expression DIV prefixed_unary_expression
+	  {
+		$$ = new Binary (Binary.Operator.Division, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| multiplicative_expression PERCENT prefixed_unary_expression 
+	  {
+		$$ = new Binary (Binary.Operator.Modulus, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| multiplicative_expression STAR error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Binary (Binary.Operator.Multiply, (Expression) $1, null);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| multiplicative_expression DIV error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Binary (Binary.Operator.Division, (Expression) $1, null);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| multiplicative_expression PERCENT error 
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Binary (Binary.Operator.Modulus, (Expression) $1, null);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	;
+
+additive_expression
+	: multiplicative_expression
+	| additive_expression PLUS multiplicative_expression 
+	  {
+		$$ = new Binary (Binary.Operator.Addition, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| additive_expression MINUS multiplicative_expression
+	  {
+		$$ = new Binary (Binary.Operator.Subtraction, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+  	  }
+	| additive_expression OP_IN multiplicative_expression
+	  {
+		$$ = new AsIn ((Expression) $1, (Expression) $3, GetLocation ($2));
+	  }	  
+	| additive_expression AS type
+	  {
+		$$ = new As ((Expression) $1, (Expression) $3, GetLocation ($2));
+	  }
+	| additive_expression IS type
+	  {
+		$$ = new Is ((Expression) $1, (Expression) $3, GetLocation ($2));
+	  }	  
+	| additive_expression PLUS error 
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Binary (Binary.Operator.Addition, (Expression) $1, null);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| additive_expression MINUS error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Binary (Binary.Operator.Subtraction, (Expression) $1, null);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| additive_expression OP_IN error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new AsIn ((Expression) $1, null, GetLocation ($2));
+	  }
+	| additive_expression AS error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new As ((Expression) $1, null, GetLocation ($2));
+	  }
+	| additive_expression IS error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Is ((Expression) $1, null, GetLocation ($2));
+	  }
+	;
+
+shift_expression
+	: additive_expression
+	| shift_expression OP_SHIFT_LEFT additive_expression
+	  {
+		$$ = new Binary (Binary.Operator.LeftShift, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| shift_expression OP_SHIFT_RIGHT additive_expression
+	  {
+		$$ = new Binary (Binary.Operator.RightShift, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| shift_expression OP_USHIFT_RIGHT additive_expression
+	  {
+		$$ = new Binary (Binary.Operator.AsURightShift, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| shift_expression OP_SHIFT_LEFT error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Binary (Binary.Operator.LeftShift, (Expression) $1, null);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| shift_expression OP_SHIFT_RIGHT error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Binary (Binary.Operator.RightShift, (Expression) $1, null);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| shift_expression OP_USHIFT_RIGHT error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Binary (Binary.Operator.AsURightShift, (Expression) $1, null);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }	  
+	; 
+
+relational_expression
+	: shift_expression
+	| relational_expression OP_LT shift_expression
+	  {
+		$$ = new Binary (Binary.Operator.LessThan, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| relational_expression OP_GT shift_expression
+	  {
+		$$ = new Binary (Binary.Operator.GreaterThan, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| relational_expression OP_LE shift_expression
+	  {
+		$$ = new Binary (Binary.Operator.LessThanOrEqual, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| relational_expression OP_GE shift_expression
+	  {
+		$$ = new Binary (Binary.Operator.GreaterThanOrEqual, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| relational_expression OP_LT error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Binary (Binary.Operator.LessThan, (Expression) $1, null);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| relational_expression OP_GT error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Binary (Binary.Operator.GreaterThan, (Expression) $1, null);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| relational_expression OP_LE error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Binary (Binary.Operator.LessThanOrEqual, (Expression) $1, null);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| relational_expression OP_GE error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Binary (Binary.Operator.GreaterThanOrEqual, (Expression) $1, null);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	;
+
+equality_expression
+	: relational_expression
+	| equality_expression OP_EQ relational_expression
+	  {
+		$$ = new Binary (Binary.Operator.Equality, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| equality_expression OP_NE relational_expression
+	  {
+		$$ = new Binary (Binary.Operator.Inequality, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| equality_expression OP_REF_EQ relational_expression
+	  {
+		$$ = new Binary (Binary.Operator.AsRefEquality, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| equality_expression OP_REF_NE relational_expression
+	  {
+		$$ = new Binary (Binary.Operator.AsRefInequality, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	; 
+
+and_expression
+	: equality_expression
+	| and_expression BITWISE_AND equality_expression
+	  {
+		$$ = new Binary (Binary.Operator.BitwiseAnd, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| and_expression BITWISE_AND error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Binary (Binary.Operator.BitwiseAnd, (Expression) $1, null);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	;
+
+exclusive_or_expression
+	: and_expression
+	| exclusive_or_expression CARRET and_expression
+	  {
+		$$ = new Binary (Binary.Operator.ExclusiveOr, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| exclusive_or_expression CARRET error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Binary (Binary.Operator.ExclusiveOr, (Expression) $1, null);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	;
+
+inclusive_or_expression
+	: exclusive_or_expression
+	| inclusive_or_expression BITWISE_OR exclusive_or_expression
+	  {
+		$$ = new Binary (Binary.Operator.BitwiseOr, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| inclusive_or_expression BITWISE_OR error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Binary (Binary.Operator.BitwiseOr, (Expression) $1, null);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	;
+
+conditional_and_expression
+	: inclusive_or_expression
+	| conditional_and_expression OP_AND inclusive_or_expression
+	  {
+		$$ = new Binary (Binary.Operator.LogicalAnd, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| conditional_and_expression OP_AND error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Binary (Binary.Operator.LogicalAnd, (Expression) $1, null);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	;
+
+conditional_or_expression
+	: conditional_and_expression
+	| conditional_or_expression OP_OR conditional_and_expression
+	  {
+		$$ = new Binary (Binary.Operator.LogicalOr, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| conditional_or_expression OP_OR error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Binary (Binary.Operator.LogicalOr, (Expression) $1, null);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	;
+	
+null_coalescing_expression
+	: conditional_or_expression
+	| conditional_or_expression OP_COALESCING null_coalescing_expression
+	  {
+	  	CheckIsPlayScript("?? operator", GetLocation($2));
+	  
+		if (lang_version < LanguageVersion.ISO_2)
+			FeatureIsNotAvailable (GetLocation ($2), "null coalescing operator");
+			
+		$$ = new Nullable.NullCoalescingOperator ((Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	;
+
+conditional_expression
+	: null_coalescing_expression
+	| null_coalescing_expression INTERR expression COLON expression
+	  {
+		$$ = new Conditional (new BooleanExpression ((Expression) $1), (Expression) $3, (Expression) $5, GetLocation ($2));
+		lbag.AddLocation ($$, GetLocation ($4));
+	  }
+	| null_coalescing_expression INTERR expression error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Conditional (new BooleanExpression ((Expression) $1), (Expression) $3, null, GetLocation ($2));
+	  }
+	| null_coalescing_expression INTERR expression COLON error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Conditional (new BooleanExpression ((Expression) $1), (Expression) $3, null, GetLocation ($2));
+		lbag.AddLocation ($$, GetLocation ($4));
+	  }
+	;
+
+assignment_expression
+	: prefixed_unary_expression ASSIGN expression
+	  {
+	  	Expression target = (Expression) $1;
+	  	Expression source = (Expression) $3;
+
+		var assign = new SimpleAssign (target, source);
+		lbag.AddLocation (assign, GetLocation ($2));
+	  	
+	  	if (source is AsArrayInitializer) {
+	  		(source as AsArrayInitializer).Assign = assign;
+	  	} else if (source is AsObjectInitializer) {
+	  		(source as AsObjectInitializer).Assign = assign;
+	  	}
+	  	
+	  	$$ = assign;
+	  }
+	| prefixed_unary_expression OP_MULT_ASSIGN expression
+	  {
+		$$ = new CompoundAssign (Binary.Operator.Multiply, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| prefixed_unary_expression OP_DIV_ASSIGN expression
+	  {
+		$$ = new CompoundAssign (Binary.Operator.Division, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| prefixed_unary_expression OP_MOD_ASSIGN expression
+	  {
+		$$ = new CompoundAssign (Binary.Operator.Modulus, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| prefixed_unary_expression OP_ADD_ASSIGN expression
+	  {
+		$$ = new CompoundAssign (Binary.Operator.Addition, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| prefixed_unary_expression OP_SUB_ASSIGN expression
+	  {
+		$$ = new CompoundAssign (Binary.Operator.Subtraction, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| prefixed_unary_expression OP_SHIFT_LEFT_ASSIGN expression
+	  {
+		$$ = new CompoundAssign (Binary.Operator.LeftShift, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| prefixed_unary_expression OP_SHIFT_RIGHT_ASSIGN expression
+	  {
+		$$ = new CompoundAssign (Binary.Operator.RightShift, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| prefixed_unary_expression OP_USHIFT_RIGHT_ASSIGN expression
+	  {
+		$$ = new CompoundAssign (Binary.Operator.AsURightShift, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| prefixed_unary_expression OP_AND_ASSIGN expression
+	  {
+		$$ = new CompoundAssign (Binary.Operator.BitwiseAnd, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| prefixed_unary_expression LOGICAL_AND_ASSIGN expression
+	  {
+		$$ = new CompoundAssign (Binary.Operator.LogicalAnd, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| prefixed_unary_expression OP_OR_ASSIGN expression
+	  {
+		$$ = new CompoundAssign (Binary.Operator.BitwiseOr, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| prefixed_unary_expression LOGICAL_OR_ASSIGN expression
+	  {
+		$$ = new CompoundAssign (Binary.Operator.LogicalOr, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| prefixed_unary_expression OP_XOR_ASSIGN expression
+	  {
+		$$ = new CompoundAssign (Binary.Operator.ExclusiveOr, (Expression) $1, (Expression) $3);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	;
+
+lambda_parameter_list
+	: lambda_parameter
+	  {
+		var pars = new List<Parameter> (4);
+		pars.Add ((Parameter) $1);
+		parameterListCommas.Clear ();
+		$$ = pars;
+	  }
+	| lambda_parameter_list COMMA lambda_parameter
+	  {
+		var pars = (List<Parameter>) $1;
+		Parameter p = (Parameter)$3;
+		if (pars[0].GetType () != p.GetType ()) {
+			report.Error (748, p.Location, "All lambda parameters must be typed either explicitly or implicitly");
+		}
+		
+		pars.Add (p);
+		parameterListCommas.Add (GetLocation ($2));
+
+		$$ = pars;
+	  }
+	;
+
+lambda_parameter
+	: parameter_modifier parameter_type identifier_inside_body
+	  {
+		var lt = (Tokenizer.LocatedToken) $3;
+
+		$$ = new Parameter ((FullNamedExpression) $2, lt.Value, (Parameter.Modifier) $1, null, lt.Location);
+	  }
+	| parameter_type identifier_inside_body
+	  {
+		var lt = (Tokenizer.LocatedToken) $2;
+
+		$$ = new Parameter ((FullNamedExpression) $1, lt.Value, Parameter.Modifier.NONE, null, lt.Location);
+	  }
+	| IDENTIFIER
+	  {
+	  	var lt = (Tokenizer.LocatedToken) $1;
+		$$ = new ImplicitLambdaParameter (lt.Value, lt.Location);
+	  }
+	| AWAIT
+	  {
+	  	var lt = (Tokenizer.LocatedToken) Error_AwaitAsIdentifier ($1);
+		$$ = new ImplicitLambdaParameter (lt.Value, lt.Location);
+	  }
+	;
+
+opt_lambda_parameter_list
+	: /* empty */			{ $$ = ParametersCompiled.EmptyReadOnlyParameters; }
+	| lambda_parameter_list		{ 
+		var pars_list = (List<Parameter>) $1;
+		$$ = new ParametersCompiled (pars_list.ToArray ());
+		lbag.AddLocation ($$, parameterListCommas);
+	  }
+	;
+
+lambda_expression_body
+	: {
+		start_block (Location.Null);
+	  }
+	  expression	// All expressions must handle error or current block won't be restored and breaking ast completely
+	  {
+		Block b = end_block (Location.Null);
+		b.IsCompilerGenerated = true;
+		b.AddStatement (new ContextualReturn ((Expression) $2));
+		$$ = b;
+	  } 
+	| block
+	| error
+	  {
+	  	// Handles only cases like foo = x.FirstOrDefault (l => );
+	  	// where we must restore current_variable
+		Block b = end_block (Location.Null);
+		b.IsCompilerGenerated = true;
+
+		Error_SyntaxError (yyToken);
+		$$ = null;
+	  }
+	;
+
+expression_or_error
+	: expression
+	| error
+	  {
+		Error_SyntaxError (yyToken);
+		$$ = null;
+	  }
+	;
+	
+lambda_expression
+	: IDENTIFIER ARROW 
+	  {
+		var lt = (Tokenizer.LocatedToken) $1;	
+		Parameter p = new ImplicitLambdaParameter (lt.Value, lt.Location);
+		start_anonymous (true, new ParametersCompiled (p), null, false, lt.Location);
+	  }
+	  lambda_expression_body
+	  {
+		CheckIsPlayScript("lambda", GetLocation($1)); 	  
+		$$ = end_anonymous ((ParametersBlock) $4);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| AWAIT ARROW
+	  {
+		var lt = (Tokenizer.LocatedToken) Error_AwaitAsIdentifier ($1);
+		Parameter p = new ImplicitLambdaParameter (lt.Value, lt.Location);
+		start_anonymous (true, new ParametersCompiled (p), null, false, lt.Location);
+	  }
+	  lambda_expression_body
+	  {
+		CheckIsPlayScript("lambda", GetLocation($1)); 	  
+		$$ = end_anonymous ((ParametersBlock) $4);
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| ASYNC identifier_inside_body ARROW
+	  {
+		var lt = (Tokenizer.LocatedToken) $2;
+		Parameter p = new ImplicitLambdaParameter (lt.Value, lt.Location);
+		start_anonymous (true, new ParametersCompiled (p), null, true, lt.Location);
+	  }
+	  lambda_expression_body
+	  {
+		CheckIsPlayScript("lambda", GetLocation($1)); 	  
+		$$ = end_anonymous ((ParametersBlock) $5);
+		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3));
+	  }
+	| OPEN_PARENS_LAMBDA
+	  {
+	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
+	  }
+	  opt_lambda_parameter_list CLOSE_PARENS ARROW 
+	  {
+	  	valid_param_mod = 0;
+		start_anonymous (true, (ParametersCompiled) $3, null, false, GetLocation ($1));
+	  }
+	  lambda_expression_body
+	  {
+		CheckIsPlayScript("lambda", GetLocation($1)); 	  
+		$$ = end_anonymous ((ParametersBlock) $7);
+		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($4), GetLocation ($5));
+	  }
+	| ASYNC OPEN_PARENS_LAMBDA
+	  {
+	  	valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;	  
+	  }
+	  opt_lambda_parameter_list CLOSE_PARENS ARROW 
+	  {
+	  	valid_param_mod = 0;
+		start_anonymous (true, (ParametersCompiled) $4, null, true, GetLocation ($1));
+	  }
+	  lambda_expression_body
+	  {
+		CheckIsPlayScript("lambda", GetLocation($1)); 	  
+		$$ = end_anonymous ((ParametersBlock) $8);
+		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($2), GetLocation ($5), GetLocation ($6));
+	  }
+	;
+
+expression
+	: assignment_expression 
+	| non_assignment_expression
+	;
+	
+non_assignment_expression
+	: conditional_expression
+	| lambda_expression
+	| query_expression
+//	| ARGLIST
+//	  {
+//		$$ = new ArglistAccess (GetLocation ($1));
+//	  }
+	;
+	
+//undocumented_expressions
+//	: REFVALUE OPEN_PARENS non_assignment_expression COMMA type CLOSE_PARENS
+//	  {
+//		$$ = new RefValueExpr ((Expression) $3, (FullNamedExpression) $5, GetLocation ($1));
+//		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4), GetLocation ($6));
+//	  }
+//	| REFTYPE open_parens_any expression CLOSE_PARENS
+//	  {
+//		$$ = new RefTypeExpr ((Expression) $3, GetLocation ($1));
+//		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
+//	  }
+//	| MAKEREF open_parens_any expression CLOSE_PARENS
+//	  {
+//		$$ = new MakeRefExpr ((Expression) $3, GetLocation ($1));
+//		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));	  
+//	  }
+//	;
+
+constant_expression
+	: expression
+	;
+
+boolean_expression
+	: expression
+	  {
+		$$ = new BooleanExpression ((Expression) $1);
+	  }
+	;
+
+//
+// 10 classes
+//
+class_declaration
+	: opt_attributes
+	  opt_modifiers
+	  opt_partial
+	  CLASS
+	  {
+		lexer.AutoSemiInsertion = false;
+	  }
+	  type_declaration_name
+	  {
+		lexer.ConstraintsParsing = true;
+		
+		Class c = new Class (current_container, (MemberName) $6, (Modifiers) $2, (Attributes) $1);
+		if (((c.ModFlags & Modifiers.STATIC) != 0) && lang_version == LanguageVersion.ISO_1) {
+			FeatureIsNotAvailable (c.Location, "static classes");
+		}
+			
+	    bool is_partial = IsPartial($1) || $3 != null;
+		push_current_container (c, is_partial);
+		lbag.AddMember (current_container, GetModifierLocations (), GetLocation ($4));
+	  }
+	  opt_class_extends
+	  opt_class_implements
+	  opt_type_parameter_constraints_clauses
+	  {
+		lexer.ConstraintsParsing = false;
+
+		if ($10 != null)
+			current_container.SetConstraints ((List<Constraints>) $10);
+		lbag.AddMember (current_container, GetModifierLocations (), GetLocation ($4));
+
+		if (doc_support) {
+			current_container.PartialContainer.DocComment = Lexer.consume_doc_comment ();
+			Lexer.doc_state = XmlCommentState.Allowed;
+		}
+		
+		lexer.parsing_modifiers = true;
+		lexer.DynamicParsing = false;
+	  }
+	  OPEN_BRACE
+	  {
+		lexer.AutoSemiInsertion = true;		
+	  }
+	  opt_class_member_declarations CLOSE_BRACE
+	  {
+		lexer.DynamicParsing = true;	  
+		--lexer.parsing_declaration;
+		if (doc_support)
+			Lexer.doc_state = XmlCommentState.Allowed;
+	  }
+	  opt_semicolon 
+	  {
+		if ($17 == null) {
+			lbag.AppendToMember (current_container, GetLocation ($12), GetLocation ($15));
+		} else {
+			lbag.AppendToMember (current_container, GetLocation ($12), GetLocation ($15), GetLocation ($17));
+		}
+		$$ = pop_current_class ();
+	  }
+	;	
+
+opt_partial
+	: /* empty */
+	  { $$ = null; }
+	| PARTIAL
+	  { $$ = $1; StoreModifierLocation (Modifiers.PARTIAL, GetLocation ($1)); } // location
+	;
+
+opt_modifiers
+	: /* empty */
+	  {
+	    mod_locations = null;
+		$$ = ModifierNone;
+		lexer.parsing_modifiers = false;
+	  }
+	| modifiers
+	  {
+		lexer.parsing_modifiers = false;		
+	  }
+	;
+
+modifiers
+	: modifier
+	| modifiers modifier
+	  { 
+		var m1 = (Modifiers) $1;
+		var m2 = (Modifiers) $2;
+
+		if ((m1 & m2) != 0) {
+			report.Error (1004, lexer.Location - ModifiersExtensions.Name (m2).Length,
+				"Duplicate `{0}' modifier", ModifiersExtensions.Name (m2));
+		} else if ((m2 & Modifiers.AccessibilityMask) != 0 && (m1 & Modifiers.AccessibilityMask) != 0 &&
+			((m2 | m1 & Modifiers.AccessibilityMask) != (Modifiers.PROTECTED | Modifiers.INTERNAL))) {
+			report.Error (107, lexer.Location - ModifiersExtensions.Name (m2).Length,
+				"More than one protection modifier specified");
+		}
+		
+		$$ = m1 | m2;
+	  }
+	;
+
+modifier
+	: NEW
+	  {
+		$$ = Modifiers.NEW;
+		StoreModifierLocation ($$, GetLocation ($1));
+		
+		if (current_container.Kind == MemberKind.Namespace)
+			report.Error (1530, GetLocation ($1), "Keyword `new' is not allowed on namespace elements");
+	  }
+	| PUBLIC
+	  {
+		$$ = Modifiers.PUBLIC;
+		StoreModifierLocation ($$, GetLocation ($1));
+	  }
+	| PROTECTED
+	  {
+		$$ = Modifiers.PROTECTED;
+		StoreModifierLocation ($$, GetLocation ($1));
+	  }
+	| INTERNAL
+	  {
+		$$ = Modifiers.INTERNAL;
+		StoreModifierLocation ($$, GetLocation ($1));
+	  }
+	| PRIVATE
+	  {
+		$$ = Modifiers.PRIVATE;
+		StoreModifierLocation ($$, GetLocation ($1));
+	  }
+	| ABSTRACT
+	  {
+		$$ = Modifiers.ABSTRACT;
+		StoreModifierLocation ($$, GetLocation ($1));
+	  }
+	| FINAL
+	  {
+		$$ = (Modifiers)0; // Modifiers.SEALED;  // The semantics for SEALED and FINAL don't quite match.  Ignore FINAL for right now. (BEN)
+		StoreModifierLocation ($$, GetLocation ($1));
+	  }
+	| STATIC
+	  {
+		$$ = Modifiers.STATIC;
+		StoreModifierLocation ($$, GetLocation ($1));
+	  }
+	| READONLY
+	  {
+		$$ = Modifiers.READONLY;
+		StoreModifierLocation ($$, GetLocation ($1));
+	  }
+	| VIRTUAL
+	  {
+		$$ = Modifiers.VIRTUAL;
+		StoreModifierLocation ($$, GetLocation ($1));
+	  }
+	| OVERRIDE
+	  {
+		$$ = Modifiers.OVERRIDE;
+		StoreModifierLocation ($$, GetLocation ($1));
+	  }
+	| NATIVE
+	  {
+		$$ = Modifiers.EXTERN;
+		StoreModifierLocation ($$, GetLocation ($1));
+	  }
+	| VOLATILE
+	  {
+		$$ = Modifiers.VOLATILE;
+		StoreModifierLocation ($$, GetLocation ($1));
+	  }
+	| UNSAFE
+	  {
+		$$ = Modifiers.UNSAFE;
+		StoreModifierLocation ($$, GetLocation ($1));
+		if (!settings.Unsafe)
+			Error_UnsafeCodeNotAllowed (GetLocation ($1));
+	  }
+	| ASYNC
+	  {
+		$$ = Modifiers.ASYNC;
+		StoreModifierLocation ($$, GetLocation ($1));
+	  }
+	| DYNAMIC
+	  {
+	    $$ = Modifiers.AS_DYNAMIC;
+	    StoreModifierLocation ($$, GetLocation ($1));
+	  }
+	| IDENTIFIER_MODIFIER
+	  {
+	    $$ = Modifiers.INTERNAL;
+	    StoreModifierLocation ($$, GetLocation ($1));
+	  }
+	;
+	
+opt_class_extends
+	: /* empty */
+	| EXTENDS base_type_name
+	 {
+		current_type.AddBaseForPart ((FullNamedExpression) $2);
+	 }
+	| EXTENDS base_type_name error
+	  {
+		Error_SyntaxError (yyToken);
+
+		current_type.AddBaseForPart ((FullNamedExpression) $2);
+	  }
+	;
+	
+opt_class_implements
+	: /* empty */
+	| IMPLEMENTS type_list
+	 {
+		current_type.AddBasesForPart ((List<FullNamedExpression>) $2);
+	 }
+	| IMPLEMENTS type_list error
+	  {
+		Error_SyntaxError (yyToken);
+
+		current_type.AddBasesForPart ((List<FullNamedExpression>) $2);
+	  }
+	;	
+
+opt_type_parameter_constraints_clauses
+	: /* empty */
+	| type_parameter_constraints_clauses 
+	  {
+		$$ = $1;
+	  }
+	;
+
+type_parameter_constraints_clauses
+	: type_parameter_constraints_clause
+	  {
+		var constraints = new List<Constraints> (1);
+		constraints.Add ((Constraints) $1);
+		$$ = constraints;
+	  }
+	| type_parameter_constraints_clauses type_parameter_constraints_clause
+	  {
+		var constraints = (List<Constraints>) $1;
+		Constraints new_constraint = (Constraints)$2;
+
+		foreach (Constraints c in constraints) {
+			if (new_constraint.TypeParameter.Value == c.TypeParameter.Value) {
+				report.Error (409, new_constraint.Location,
+					"A constraint clause has already been specified for type parameter `{0}'",
+					new_constraint.TypeParameter.Value);
+			}
+		}
+
+		constraints.Add (new_constraint);
+		$$ = constraints;
+	  }
+	; 
+
+type_parameter_constraints_clause
+	: WHERE IDENTIFIER COLON type_parameter_constraints
+	  {
+		var lt = (Tokenizer.LocatedToken) $2;
+		$$ = new Constraints (new SimpleMemberName (lt.Value, lt.Location), (List<FullNamedExpression>) $4, GetLocation ($1));
+		lbag.AddLocation ($$, GetLocation ($3));
+	  }
+	| WHERE IDENTIFIER error
+	  {
+		Error_SyntaxError (yyToken);
+	  
+		var lt = (Tokenizer.LocatedToken) $2;
+		$$ = new Constraints (new SimpleMemberName (lt.Value, lt.Location), null, GetLocation ($1));
+	  }
+	; 
+
+type_parameter_constraints
+	: type_parameter_constraint
+	  {
+		var constraints = new List<FullNamedExpression> (1);
+		constraints.Add ((FullNamedExpression) $1);
+		$$ = constraints;
+	  }
+	| type_parameter_constraints COMMA type_parameter_constraint
+	  {
+		var constraints = (List<FullNamedExpression>) $1;
+		var prev = constraints [constraints.Count - 1] as SpecialContraintExpr;
+		if (prev != null && (prev.Constraint & SpecialConstraint.Constructor) != 0) {			
+			report.Error (401, GetLocation ($2), "The `new()' constraint must be the last constraint specified");
+		}
+		
+		prev = $3 as SpecialContraintExpr;
+		if (prev != null) {
+			if ((prev.Constraint & (SpecialConstraint.Class | SpecialConstraint.Struct)) != 0) {
+				report.Error (449, prev.Location, "The `class' or `struct' constraint must be the first constraint specified");			
+			} else {
+			 	prev = constraints [0] as SpecialContraintExpr;
+			 	if (prev != null && (prev.Constraint & SpecialConstraint.Struct) != 0) {			
+					report.Error (451, GetLocation ($3), "The `new()' constraint cannot be used with the `struct' constraint");
+				}
+			}
+		}
+
+		constraints.Add ((FullNamedExpression) $3);
+		$$ = constraints;
+	  }
+	;
+
+type_parameter_constraint
+	: type
+	  {
+		if ($1 is ComposedCast)
+			report.Error (706, GetLocation ($1), "Invalid constraint type `{0}'", ((ComposedCast)$1).GetSignatureForError ());
+	  
+	  	$$ = $1;
+	  }
+	| NEW OPEN_PARENS CLOSE_PARENS
+	  {
+		$$ = new SpecialContraintExpr (SpecialConstraint.Constructor, GetLocation ($1));
+		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($3));
+	  }
+	| CLASS
+	  {
+		$$ = new SpecialContraintExpr (SpecialConstraint.Class, GetLocation ($1));
+	  }
+	| STRUCT
+	  {
+		$$ = new SpecialContraintExpr (SpecialConstraint.Struct, GetLocation ($1));
+	  }
+	;
+
+opt_type_parameter_variance
+	: /* empty */
+	  {
+		$$ = Variance.None;
+	  }
+	| type_parameter_variance
+	  {
+		if (lang_version <= LanguageVersion.V_3)
+			FeatureIsNotAvailable (lexer.Location, "generic type variance");
+		
+		$$ = $1;
+	  }
+	;
+
+type_parameter_variance
+	: OUT
+	  {
+		$$ = Variance.Covariant;
+	  }
+	| IN
+	  {
+		$$ = Variance.Contravariant;
+	  }
+	;
+
+//
+// Statements (8.2)
+//
+
+//
+// A block is "contained" on the following places:
+//	method_body
+//	property_declaration as part of the accessor body (get/set)
+//      operator_declaration
+//	constructor_declaration
+//	destructor_declaration
+//	event_declaration as part of add_accessor_declaration or remove_accessor_declaration
+//      
+block
+	: OPEN_BRACE  
+	  {
+		++lexer.parsing_block;
+		lexer.AutoSemiInsertion = true;
+		start_block (GetLocation ($1));
+	  } 
+	  opt_statement_list block_end
+	  {
+  		$$ = $4;
+	  }
+	;
+	
+//
+// An optional config block is "contained" on the following places:
+//	method_body
+//      
+config_block
+	: opt_block_config OPEN_BRACE  
+	  {
+		++lexer.parsing_block;
+		start_block (GetLocation ($2));
+	  } 
+	  opt_statement_list block_end
+	  {
+	    if (is_config_enabled) {
+	      // This block should be included
+  		  $$ = $5;
+  		} else {
+  		  // This block should not be included.. create an empty block
+  		  start_block (GetLocation ($2));
+  		  $$ = end_block (GetLocation ($5));
+  		}
+	  }
+	;
+
+opt_block_config
+	: /* empty */
+	| IDENTIFIER DOUBLE_COLON IDENTIFIER
+	  {
+	    var lt1 = (Tokenizer.LocatedToken) $1;
+	    var lt2 = (Tokenizer.LocatedToken) $3;
+        is_config_enabled = file.IsConditionalDefined (lt1.Value + "_" + lt2.Value);
+	  }
+	;
+
+block_end 
+	: CLOSE_BRACE 
+	  {
+	  	Lexer.AutoSemiInsertion = true;
+	 	--lexer.parsing_block;
+		$$ = end_block (GetLocation ($1));
+	  }
+	| COMPLETE_COMPLETION
+	  {
+	  	Lexer.AutoSemiInsertion = true;
+	 	--lexer.parsing_block;
+		$$ = end_block (lexer.Location);
+	  }
+	;
+
+
+block_prepared
+	: OPEN_BRACE
+	  {
+		++lexer.parsing_block;
+		current_block.StartLocation = GetLocation ($1);
+	  }
+	  opt_statement_list CLOSE_BRACE 
+	  {
+	  	Lexer.AutoSemiInsertion = true;
+		--lexer.parsing_block;
+		$$ = end_block (GetLocation ($4));
+	  }
+	;
+
+opt_statement_list
+	: /* empty */
+	| statement_list 
+	;
+
+statement_list
+	: statement
+	| statement_list statement
+	;
+
+statement
+	: block_variable_declaration
+	  {
+		current_block.AddStatement ((Statement) $1);
+	  }
+	| valid_declaration_statement
+	  {
+		current_block.AddStatement ((Statement) $1);
+	  }
+	| labeled_statement
+	| error
+	  {
+		Error_SyntaxError (yyToken);
+		$$ = null;
+	  }
+	;
+
+//
+// The interactive_statement and its derivatives are only 
+// used to provide a special version of `expression_statement'
+// that has a side effect of assigning the expression to
+// $retval
+//
+interactive_statement_list
+	: interactive_statement
+	| interactive_statement_list interactive_statement
+	;
+
+interactive_statement
+	: block_variable_declaration
+	  {
+		current_block.AddStatement ((Statement) $1);
+	  }
+	| interactive_valid_declaration_statement
+	  {
+		current_block.AddStatement ((Statement) $1);
+	  }
+	| labeled_statement
+	;
+
+valid_declaration_statement
+	: config_block
+	| empty_statement
+	| expression_statement
+	| selection_statement
+	| iteration_statement
+	| jump_statement		  
+	| try_statement
+	| checked_statement
+	| unchecked_statement
+	| lock_statement
+	| using_statement
+	| unsafe_statement
+	| fixed_statement
+//	| delete_statement
+	| local_function_statement
+	;
+
+interactive_valid_declaration_statement
+	: config_block
+	| empty_statement
+    | interactive_expression_statement
+	| selection_statement
+	| iteration_statement
+	| jump_statement		  
+	| try_statement
+	| checked_statement
+	| unchecked_statement
+	| lock_statement
+	| using_statement
+	| unsafe_statement
+	| fixed_statement
+//	| delete_statement
+	| local_function_statement
+	;
+
+embedded_statement
+	: valid_declaration_statement
+	| block_variable_declaration
+	  {
+	  	  if (parsing_playscript) {
+			  report.Error (1023, GetLocation ($1), "An embedded statement may not be a declaration or labeled statement");
+			  $$ = null;
+		  } else {
+		  	  // NOTE: This is actually allowed in PlayScript.  We'll turn it off in ASX though as it's error prone.
+		  	  $$ = $1;
+		  }
+	  }
+	| labeled_statement
+	  {
+		  report.Error (1023, GetLocation ($1), "An embedded statement may not be a declaration or labeled statement");
+		  $$ = null;
+	  }
+	| error
+	  {
+		Error_SyntaxError (yyToken);
+		$$ = new EmptyStatement (GetLocation ($1));
+	  }
+	;
+
+empty_statement
+	: SEMICOLON
+	  {
+	    Lexer.AutoSemiInsertion = true;
+		// Uses lexer.Location because semicolon location is not kept in quick mode
+		$$ = new EmptyStatement (lexer.Location);
+	  }
+	;
+
+labeled_statement
+	: identifier_inside_body COLON 
+	  {
+		var lt = (Tokenizer.LocatedToken) $1;
+		LabeledStatement labeled = new LabeledStatement (lt.Value, current_block, lt.Location);
+		lbag.AddLocation (labeled, GetLocation ($2));
+		current_block.AddLabel (labeled);
+		current_block.AddStatement (labeled);
+	  }
+	  statement
+	;
+
+use_namespace_statement
+	: USE NAMESPACE IDENTIFIER stmnt_end_semicolon
+	  {
+		Lexer.NamespaceParsing = false;
+		var lt = (Tokenizer.LocatedToken) $2;		
+		$$ = new AsUseNamespaceStatement (lt.Value, GetLocation ($1));		
+	  }
+	;
+
+variable_type
+	: variable_type_simple
+	| variable_type_simple rank_specifiers
+	  {
+		if ($1 is VarExpr)
+			$1 = new SimpleName ("var", ((VarExpr) $1).Location);
+	  
+		$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
+	  }
+	;
+
+/* 
+ * The following is from Rhys' grammar:
+ * > Types in local variable declarations must be recognized as 
+ * > expressions to prevent reduce/reduce errors in the grammar.
+ * > The expressions are converted into types during semantic analysis.
+ */
+variable_type_simple
+	: primary_expression_or_type opt_nullable
+	  { 
+		// Ok, the above "primary_expression" is there to get rid of
+		// both reduce/reduce and shift/reduces in the grammar, it should
+		// really just be "type_name".  If you use type_name, a reduce/reduce
+		// creeps up.  If you use namespace_or_type_name (which is all we need
+		// really) two shift/reduces appear.
+		// 
+
+		// So the super-trick is that primary_expression
+		// can only be either a SimpleName or a MemberAccess. 
+		// The MemberAccess case arises when you have a fully qualified type-name like :
+		// Foo.Bar.Blah i;
+		// SimpleName is when you have
+		// Blah i;
+		
+		Expression expr = (Expression) $1;
+		if ($2 == null) {
+			SimpleName sn = expr as SimpleName;
+			if (sn != null)
+				$$ = ConvertAsType(sn, $1);
+			else
+				$$ = $1;
+		} else if (expr is ATypeNameExpression) {
+			$$ = new ComposedCast ((ATypeNameExpression)expr, (ComposedTypeSpecifier) $2);
+		} else {
+			Error_ExpectingTypeName (expr);
+			$$ = null;
+		}
+	  }
+//	| primary_expression_or_type pointer_stars
+//	  {
+//		ATypeNameExpression expr = $1 as ATypeNameExpression;
+//
+//		if (expr != null) {
+//			$$ = new ComposedCast (expr, (ComposedTypeSpecifier) $2);
+//		} else {
+//			Error_ExpectingTypeName ((Expression)$1);
+//			$$ = expr;
+//		}
+//	  }
+	| builtin_types opt_nullable
+	  {
+		if ($2 == null)
+			$$ = $1;
+		else
+			$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
+	  }
+//	| builtin_types pointer_stars
+//	  {
+//		$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
+//	  }
+//	| VOID pointer_stars
+//	  {
+//		$$ = new ComposedCast (new TypeExpression (compiler.BuiltinTypes.Void, GetLocation ($1)), (ComposedTypeSpecifier) $2);
+//	  }	  
+	| VOID
+	  {
+		Expression.Error_VoidInvalidInTheContext (GetLocation ($1), report);
+		$$ = new TypeExpression (compiler.BuiltinTypes.Void, GetLocation ($1));
+	  }
+	;
+	
+//pointer_stars
+//	: pointer_star
+//	| pointer_star pointer_stars
+//	  {
+//	  	((ComposedTypeSpecifier) $1).Next = (ComposedTypeSpecifier) $2;
+//	  	$$ = $1;
+//	  }	  
+//	;
+
+//pointer_star
+//	: STAR
+//	  {
+//		$$ = ComposedTypeSpecifier.CreatePointer (GetLocation ($1));
+//	  }
+//	;
+
+identifier_inside_body
+	: IDENTIFIER
+	| AWAIT
+	  {
+		if (async_block) {
+			report.Error (4003, GetLocation ($1), "`await' cannot be used as an identifier within an async method or lambda expression");
+			$$ = new Tokenizer.LocatedToken ("await", GetLocation ($1));
+		}
+	  }
+	;
+
+stmnt_end_semicolon
+	: SEMICOLON
+	  {
+	  	Lexer.AutoSemiInsertion = true;
+	  }
+	;
+
+block_variable_declaration
+	: VAR identifier_inside_body COLON type 
+	  {
+		var lt = (Tokenizer.LocatedToken) $2;
+		var li = GetOrCreateLocalVariable (current_block, lt.Value, 0, (FullNamedExpression) $4, lt.Location);
+		current_variable = new BlockVariableDeclaration ((FullNamedExpression) $4, li);
+	  }
+	  opt_local_variable_initializer opt_variable_declarators stmnt_end_semicolon
+	  {
+		$$ = current_variable;
+		current_variable = null;
+		lbag.AddLocation ($$, GetLocation ($6));
+	  }
+	| VAR identifier_inside_body 
+	  {
+		var lt = (Tokenizer.LocatedToken) $2;
+		var li = GetOrCreateLocalVariable (current_block, lt.Value, 0, null, lt.Location);
+		current_variable = new BlockVariableDeclaration (new VarExpr (GetLocation($1)), li);
+	  }
+	  opt_local_variable_initializer opt_variable_declarators stmnt_end_semicolon
+	  {
+		$$ = current_variable;
+		current_variable = null;
+		lbag.AddLocation ($$, GetLocation ($4));
+	  }
+	| CONST identifier_inside_body COLON type 
+	  {
+		var lt = (Tokenizer.LocatedToken) $2;
+		var li = GetOrCreateLocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, null, lt.Location);
+		current_variable = new BlockConstantDeclaration ((FullNamedExpression) $4, li);
+	  }
+	  const_variable_initializer opt_const_declarators stmnt_end_semicolon
+	  {
+		$$ = current_variable;
+		current_variable = null;
+		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($7));
+	  }
+	;
+
+opt_local_variable_initializer
+	: /* empty */
+	| ASSIGN block_variable_initializer
+	  {
+		current_variable.Initializer = (Expression) $2;
+		// TODO: lbag
+	  }
+	| error
+	  {
+	  	if (yyToken == Token.OPEN_BRACKET_EXPR) {
+			report.Error (650, lexer.Location,
+				"Syntax error, bad array declarator. To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type");
+		} else {
+			Error_SyntaxError (yyToken);
+		}
+	  }
+	;
+
+opt_variable_declarators
+	: /* empty */
+	| variable_declarators
+	;
+	
+opt_using_or_fixed_variable_declarators
+	: /* empty */
+	| variable_declarators
+	  {
+		foreach (var d in current_variable.Declarators) {
+			if (d.Initializer == null)
+				Error_MissingInitializer (d.Variable.Location);
+		}
+	  }
+	;	
+	
+variable_declarators
+	: variable_declarator
+	| variable_declarators variable_declarator
+	;
+	
+variable_declarator
+	: COMMA identifier_inside_body
+	  {
+		var lt = (Tokenizer.LocatedToken) $2;	  
+		var li = GetOrCreateLocalVariable (current_variable.Variable.Block, lt.Value, 
+			current_variable.Variable.DeclFlags, current_variable.TypeExpression, lt.Location);
+		var d = new BlockVariableDeclaration.Declarator (li, null);
+		current_variable.AddDeclarator (d);
+	  	lbag.AddLocation (d, GetLocation ($1));
+	  }
+	| COMMA identifier_inside_body ASSIGN block_variable_initializer
+	  {
+		var lt = (Tokenizer.LocatedToken) $2;	  
+		var li = GetOrCreateLocalVariable (current_variable.Variable.Block, lt.Value, 
+			current_variable.Variable.DeclFlags, current_variable.TypeExpression, lt.Location);
+		var d = new BlockVariableDeclaration.Declarator (li, (Expression) $4);
+		current_variable.AddDeclarator (d);
+	  	lbag.AddLocation (d, GetLocation ($1), GetLocation ($3));
+	  }
+	| COMMA identifier_inside_body COLON type
+	  {
+		var lt = (Tokenizer.LocatedToken) $2;	  
+		var li = GetOrCreateLocalVariable (current_variable.Variable.Block, lt.Value, 
+			current_variable.Variable.DeclFlags, (FullNamedExpression) $4, lt.Location);
+		var d = new BlockVariableDeclaration.Declarator (li, null, (FullNamedExpression) $4);
+		d.Location = GetLocation($2);
+		current_variable.AddDeclarator (d);
+	  	lbag.AddLocation (d, GetLocation ($1));
+	  }
+	| COMMA identifier_inside_body COLON type ASSIGN block_variable_initializer
+	  {
+		var lt = (Tokenizer.LocatedToken) $2;	  
+		var li = GetOrCreateLocalVariable (current_variable.Variable.Block, lt.Value, 
+			current_variable.Variable.DeclFlags, (FullNamedExpression) $4, lt.Location);
+		var d = new BlockVariableDeclaration.Declarator (li, (Expression) $6, (FullNamedExpression) $4);
+		d.Location = GetLocation($2);
+		current_variable.AddDeclarator (d);
+	  	lbag.AddLocation (d, GetLocation ($1), GetLocation ($5));
+	  }		  
+	;
+	
+const_variable_initializer
+	: /* empty */
+	  {
+		report.Error (145, lexer.Location, "A const field requires a value to be provided");
+	  }
+	| ASSIGN constant_initializer_expr 
+	  {
+		current_variable.Initializer = (Expression) $2;
+	  }
+	;
+	
+opt_const_declarators
+	: /* empty */
+	| const_declarators
+	;
+	
+const_declarators
+	: const_declarator
+	| const_declarators const_declarator
+	;
+	
+const_declarator
+	: COMMA identifier_inside_body ASSIGN constant_initializer_expr
+	  {
+		var lt = (Tokenizer.LocatedToken) $2;	  
+		var li = GetOrCreateLocalVariable (current_block, lt.Value, 
+			LocalVariable.Flags.Constant, current_variable.TypeExpression, lt.Location);
+		var d = new BlockVariableDeclaration.Declarator (li, (Expression) $4);
+		current_variable.AddDeclarator (d);
+	  	lbag.AddLocation (d, GetLocation ($1), GetLocation ($3));
+	  }
+	;
+	
+block_variable_initializer
+	: variable_initializer
+//	| STACKALLOC simple_type OPEN_BRACKET_EXPR expression CLOSE_BRACKET
+//	  {
+//		$$ = new StackAlloc ((Expression) $2, (Expression) $4, GetLocation ($1));
+//		lbag.AddLocation ($$, GetLocation ($3), GetLocation ($5));
+//	  }
+//	| STACKALLOC simple_type
+//	  {
+//		report.Error (1575, GetLocation ($1), "A stackalloc expression requires [] after type");
+//		$$ = new StackAlloc ((Expression) $2, null, GetLocation ($1));		
+//	  }
+	;
+
+expression_statement
+	: statement_expression stmnt_end_semicolon
+	  {
+		$$ = $1;
+		lbag.AddStatement ($$, GetLocation ($2));
+	  }
+	| statement_expression COMPLETE_COMPLETION { $$ = $1; }
+	| statement_expression CLOSE_BRACE
+	  {
+		$$ = $1;
+		report.Error (1002, GetLocation ($2), "; expected");
+		lexer.putback ('}');
+	  }
+	;
+
+interactive_expression_statement
+	: interactive_statement_expression SEMICOLON { $$ = $1; }
+	| interactive_statement_expression COMPLETE_COMPLETION { $$ = $1; }
+	;
+
+	//
+	// We have to do the wrapping here and not in the case above,
+	// because statement_expression is used for example in for_statement
+	//
+statement_expression
+	: expression
+	  {
+		$$ = ConvertExpressionToStatement((Expression)$1);
+	  }
+	;
+
+interactive_statement_expression
+	: expression
+	  {
+		Expression expr = (Expression) $1;
+		ExpressionStatement s;
+
+	        s = new OptionalAssign (new SimpleName ("$retval", lexer.Location), expr, lexer.Location);
+		$$ = new StatementExpression (s);
+	  }
+	| error
+	  {
+		Error_SyntaxError (yyToken);
+		$$ = new EmptyStatement (GetLocation ($1));
+	  }
+	;
+	
+selection_statement
+	: if_statement
+	| switch_statement
+	; 
+
+stmnt_close_parens
+	: CLOSE_PARENS
+	  {
+	  	Lexer.AutoSemiInsertionAfter = 1;
+	  }
+	;
+	
+stmnt_else
+	: ELSE
+	  {
+	  	Lexer.AutoSemiInsertionAfter = 1;
+	  }
+	;	
+
+if_statement
+	: IF open_parens_any boolean_expression stmnt_close_parens 
+	  embedded_statement
+	  { 
+		if ($5 is EmptyStatement)
+			Warning_EmptyStatement (GetLocation ($5));
+		
+		$$ = new If ((BooleanExpression) $3, (Statement) $5, GetLocation ($1));
+		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
+	  }
+	| IF open_parens_any boolean_expression stmnt_close_parens
+	  embedded_statement stmnt_else embedded_statement
+	  {
+		$$ = new If ((BooleanExpression) $3, (Statement) $5, (Statement) $7, GetLocation ($1));
+		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4), GetLocation ($6));
+		
+		if ($5 is EmptyStatement)
+			Warning_EmptyStatement (GetLocation ($5));
+		if ($7 is EmptyStatement)
+			Warning_EmptyStatement (GetLocation ($7));
+	  }
+	| IF open_parens_any boolean_expression error
+	  {
+		Error_SyntaxError (yyToken);
+		
+		$$ = new If ((BooleanExpression) $3, null, GetLocation ($1));
+		lbag.AddStatement ($$, GetLocation ($2));
+	  }
+	;
+
+switch_statement
+	: SWITCH open_parens_any expression CLOSE_PARENS OPEN_BRACE
+	  {
+	    Lexer.AutoSemiInsertion = true;
+		start_block (GetLocation ($5));
+	  }
+	  opt_switch_sections CLOSE_BRACE
+	  {
+		$$ = new Switch ((Expression) $3, (ExplicitBlock) current_block.Explicit, (List<SwitchSection>) $7, GetLocation ($1));	
+		end_block (GetLocation ($8));
+		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4), GetLocation ($5), GetLocation ($8));
+	  }
+	| SWITCH open_parens_any expression error
+	  {
+		Error_SyntaxError (yyToken);
+	  
+		$$ = new Switch ((Expression) $3, null, null, GetLocation ($1));	
+		lbag.AddStatement ($$, GetLocation ($2));
+	  }
+	;
+
+opt_switch_sections
+	: /* empty */ 		
+      {
+		report.Warning (1522, 1, current_block.StartLocation, "Empty switch block"); 
+		$$ = new List<SwitchSection> ();
+	  }
+	| switch_sections
+	;
+
+switch_sections
+	: switch_section 
+	  {
+		var sections = new List<SwitchSection> (4);
+
+		sections.Add ((SwitchSection) $1);
+		$$ = sections;
+	  }
+	| switch_sections switch_section
+	  {
+		var sections = (List<SwitchSection>) $1;
+
+		sections.Add ((SwitchSection) $2);
+		$$ = sections;
+	  }
+	| error
+	  {
+		Error_SyntaxError (yyToken);
+		$$ = new List<SwitchSection> ();
+	  } 
+	;
+
+switch_section
+	: switch_labels
+	  {
+		current_block = current_block.CreateSwitchBlock (lexer.Location);
+	  }
+ 	  statement_list 
+	  {
+		$$ = new SwitchSection ((List<SwitchLabel>) $1, current_block);
+	  }
+	;
+
+switch_labels
+	: switch_label 
+	  {
+		var labels = new List<SwitchLabel> (2);
+
+		labels.Add ((SwitchLabel) $1);
+		$$ = labels;
+	  }
+	| switch_labels switch_label 
+	  {
+		var labels = (List<SwitchLabel>) ($1);
+		labels.Add ((SwitchLabel) $2);
+
+		$$ = labels;
+	  }
+	;
+
+switch_label
+	: CASE constant_expression COLON
+	 {
+	 	$$ = new SwitchLabel ((Expression) $2, GetLocation ($1));
+	 	lbag.AddLocation ($$, GetLocation ($3));
+	  	Lexer.AutoSemiInsertionAfter = 1;	 	
+	 }
+	| CASE constant_expression error
+	  {
+		Error_SyntaxError (yyToken);
+		$$ = new SwitchLabel ((Expression) $2, GetLocation ($1));
+	  }
+	| DEFAULT_COLON
+	  {
+		$$ = new SwitchLabel (null, GetLocation ($1));
+	  	Lexer.AutoSemiInsertionAfter = 1;		
+	  }
+	;
+
+iteration_statement
+	: while_statement
+	| do_statement
+	| for_statement
+	| foreach_statement
+	;
+
+while_statement
+	: WHILE open_parens_any boolean_expression stmnt_close_parens embedded_statement
+	  {
+		if ($5 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
+			Warning_EmptyStatement (GetLocation ($5));
+	  
+		$$ = new While ((BooleanExpression) $3, (Statement) $5, GetLocation ($1));
+		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
+	  }
+	| WHILE open_parens_any boolean_expression error
+	  {
+		Error_SyntaxError (yyToken);
+		
+		$$ = new While ((BooleanExpression) $3, null, GetLocation ($1));
+		lbag.AddStatement ($$, GetLocation ($2));
+	  }
+	;
+
+stmnt_do
+	: DO
+	  {
+	    Lexer.AutoSemiInsertionAfter = 1;
+	  }
+	;
+	
+do_while_stmnt_close_parens
+	: CLOSE_PARENS
+	  {
+	    Lexer.AutoSemiInsertion = true;
+	  }
+	;
+
+do_statement
+	: stmnt_do embedded_statement WHILE open_parens_any boolean_expression do_while_stmnt_close_parens stmnt_end_semicolon
+	  {
+	    Lexer.AutoSemiInsertion = true;
+	    
+		$$ = new Do ((Statement) $2, (BooleanExpression) $5, GetLocation ($1), GetLocation ($3));
+		lbag.AddStatement ($$, GetLocation ($3), GetLocation ($4), GetLocation ($6), GetLocation ($7));
+	  }
+	| stmnt_do embedded_statement error
+	  {
+	    Lexer.AutoSemiInsertion = true;
+	    
+		Error_SyntaxError (yyToken);
+		$$ = new Do ((Statement) $2, null, GetLocation ($1), Location.Null);
+	  }
+	| stmnt_do embedded_statement WHILE open_parens_any boolean_expression error
+	  {
+	    Lexer.AutoSemiInsertion = true;
+
+		Error_SyntaxError (yyToken);
+	  
+		$$ = new Do ((Statement) $2, (BooleanExpression) $5, GetLocation ($1), GetLocation ($3));
+		lbag.AddStatement ($$, GetLocation ($3), GetLocation ($4));
+	  }
+	;
+
+for_statement
+	: FOR open_parens_any
+	  {
+		start_block (GetLocation ($2));
+		current_block.IsCompilerGenerated = true;
+		lexer.ForInParsing = true;
+		$$ = new Tuple<Location,Location>(GetLocation($0), GetLocation($1));
+	  }
+	  for_statement_cont
+	  {
+		lexer.ForInParsing = false;	  
+		$$ = $4;
+	  }
+	;
+	
+// Has to use be extra rule to recover started block
+for_statement_cont
+	: for_initializer IN
+	  {
+	    lexer.ForInParsing = false;
+	  } 
+	  expression stmnt_close_parens embedded_statement
+	  {
+		if ($6 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
+			Warning_EmptyStatement (GetLocation ($6));
+
+		var blockVar = $1 as BlockVariableDeclaration;
+		if (blockVar != null) {
+			if (blockVar == null || blockVar.Initializer != null || blockVar.Declarators != null) {
+				report.Error (7036, GetLocation ($4), "Invalid for each initializer");	
+				$$ = end_block (current_block.StartLocation);
+			} else {
+				var locations = (Tuple<Location,Location>) $0;
+				
+				Foreach f = new Foreach (blockVar.TypeExpression, blockVar.Variable, (Expression) $4, (Statement) $6, current_block, AsForEachType.ForEachKey, locations.Item1);
+				lbag.AddStatement (f, locations.Item2, GetLocation ($2), GetLocation ($5));
+				
+				end_block (GetLocation ($5));
+				$$ = f;
+			}
+		} else {
+			var expList = $1 as List<Expression>;
+			var varRef = ($1 as FullNamedExpression) ?? ((expList != null && expList.Count == 1) ? (expList[0] as FullNamedExpression) : null);
+			if (varRef == null) {
+				report.Error (7041, GetLocation ($1), "Invalid iterator initializer");		
+				$$ = end_block (current_block.StartLocation);
+			} else {
+				var locations = (Tuple<Location,Location>) $0;
+				
+				Foreach f = new Foreach (varRef, (Expression) $4, (Statement) $6, current_block, AsForEachType.ForEachKey, locations.Item1);
+				lbag.AddStatement (f, locations.Item2, GetLocation ($2), GetLocation ($5));
+				
+				end_block (GetLocation ($5));
+				$$ = f;
+			}
+		}
+	  }	
+	| opt_for_initializer SEMICOLON
+	  {
+	    lexer.ForInParsing = false;
+	  
+		var locations = (Tuple<Location,Location>) $0;
+
+		For f = new For (locations.Item1);
+		current_block.AddStatement (f);
+		
+		var expList = $1 as List<Expression>;
+		if (expList != null) 
+			f.Initializer = ExpressionListToStatementList (expList);
+		else
+			f.Initializer = (Statement) $1;
+
+		// Pass the "For" object to the iterator_part4
+		oob_stack.Push (f);
+		
+		$$ = f;
+	  }
+	  for_condition_and_iterator_part
+	  embedded_statement
+	  {
+		var locations = (Tuple<Location,Location>) $4;
+		oob_stack.Pop ();
+		if ($5 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
+			Warning_EmptyStatement (GetLocation ($5));
+	  
+		For f = ((For) $3);
+		f.Statement = (Statement) $5;
+		lbag.AddStatement (f, current_block.StartLocation, GetLocation ($2), GetLocation (locations.Item1), GetLocation (locations.Item2));
+
+		$$ = end_block (GetLocation ($2));
+	  }
+	| error
+	  {
+		Lexer.AutoSemiInsertion = true;
+		Error_SyntaxError (yyToken);
+		$$ = end_block (current_block.StartLocation);
+	  }
+	;
+
+for_condition_and_iterator_part
+	: opt_for_condition SEMICOLON
+	  {
+		For f = (For) oob_stack.Peek ();
+		f.Condition = (BooleanExpression) $1;
+	  }
+	  for_iterator_part {
+		$$ = new Tuple<Location,Location> (GetLocation ($2), (Location) $4);
+	  }
+
+	// Handle errors in the case of opt_for_condition being followed by
+	// a close parenthesis
+	| opt_for_condition close_parens_close_brace {
+		Lexer.AutoSemiInsertion = true;
+		report.Error (1525, GetLocation ($2), "Unexpected symbol `}'");
+		For f = (For) oob_stack.Peek ();
+		f.Condition = (BooleanExpression) $1;
+		$$ = new Tuple<Location,Location> (GetLocation ($2), GetLocation ($2));
+	  }
+	;
+
+for_iterator_part
+	: opt_for_iterator stmnt_close_parens {
+	  	For f = (For) oob_stack.Peek ();
+		f.Iterator = (Statement) $1;
+		$$ = GetLocation ($2);
+	  }
+	| opt_for_iterator CLOSE_BRACE {
+		Lexer.AutoSemiInsertion = true;
+		report.Error (1525, GetLocation ($2), "Unexpected symbol expected ')'");
+		For f = (For) oob_stack.Peek ();
+		f.Iterator = (Statement) $1;
+		$$ = GetLocation ($2);
+	  }
+	; 
+
+close_parens_close_brace 
+	: CLOSE_PARENS
+	| CLOSE_BRACE { lexer.putback ('}'); }
+	;
+
+opt_for_initializer
+	: /* empty */		{ $$ = new EmptyStatement (lexer.Location); }
+	| for_initializer	
+	;
+
+for_initializer
+	: VAR identifier_inside_body COLON type
+	  {
+		var lt = (Tokenizer.LocatedToken) $2;
+		var type = (FullNamedExpression) $4;
+		var li = GetOrCreateLocalVariable (current_block, lt.Value, 0, type, lt.Location);
+		current_variable = new BlockVariableDeclaration (type, li);
+	  }
+	  opt_local_variable_initializer opt_variable_declarators
+	  {
+		$$ = current_variable;
+		current_variable = null;
+	  }
+	| expression_list
+	  {
+		
+	  }
+	;
+
+opt_for_condition
+	: /* empty */		{ $$ = null; }
+	| boolean_expression
+	;
+
+opt_for_iterator
+	: /* empty */		{ $$ = new EmptyStatement (lexer.Location); }
+	| for_iterator
+	;
+
+for_iterator
+	: statement_expression_list
+	;
+
+statement_expression_list
+	: statement_expression
+	| statement_expression_list COMMA statement_expression
+	  {
+	  	var sl = $1 as StatementList;
+	  	if (sl == null) {
+	  		sl = new StatementList ((Statement) $1, (Statement) $3);
+			lbag.AddStatement (sl, GetLocation ($2));
+	  	} else {
+	  		sl.Add ((Statement) $3);
+	  		lbag.AppendTo (sl, GetLocation ($2));
+	  	}
+	  		
+		$$ = sl;
+	  }
+	;
+
+foreach_statement
+	: FOR_EACH 
+	  {
+		lexer.ForInParsing = true;
+	  } 
+	  open_parens_any for_initializer IN
+	  {
+	  	lexer.ForInParsing = false;
+	  } 
+	  expression stmnt_close_parens 
+	  {
+		start_block (GetLocation ($3));
+		current_block.IsCompilerGenerated = true;
+	  } 
+	  embedded_statement
+	  {
+		if ($10 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
+			Warning_EmptyStatement (GetLocation ($10));
+
+		var blockVar = $4 as BlockVariableDeclaration;
+		if (blockVar != null) {
+			if (blockVar == null || blockVar.Initializer != null || blockVar.Declarators != null) {
+				report.Error (7036, GetLocation ($4), "Invalid for each initializer");	
+				$$ = end_block (current_block.StartLocation);
+			} else {
+				Foreach f = new Foreach (blockVar.TypeExpression, blockVar.Variable, (Expression) $7, (Statement) $10, current_block, AsForEachType.ForEachValue, GetLocation ($1));
+				lbag.AddStatement (f, GetLocation ($3), GetLocation ($5), GetLocation ($8));
+				
+				end_block (GetLocation ($5));
+				$$ = f;
+			}
+		} else {
+			var expList = $4 as List<Expression>;
+			var varRef = ($4 as FullNamedExpression) ?? ((expList != null && expList.Count == 1) ? (expList[0] as FullNamedExpression) : null);
+			if (varRef == null) {
+				report.Error (7041, GetLocation ($4), "Invalid iterator initializer");		
+				$$ = end_block (current_block.StartLocation);
+			} else {
+				Foreach f = new Foreach (varRef, (Expression) $7, (Statement) $10, current_block, AsForEachType.ForEachValue, GetLocation ($1));
+				lbag.AddStatement (f, GetLocation ($3), GetLocation ($5), GetLocation ($8));
+				
+				end_block (GetLocation ($5));
+				$$ = f;
+			}
+		}
+	  }
+	;
+
+jump_statement
+	: break_statement
+	| continue_statement
+	| goto_statement
+	| return_statement
+	| throw_statement
+	| yield_statement
+	| use_namespace_statement
+	;
+
+break_statement
+	: BREAK stmnt_end_semicolon
+	  {
+		$$ = new Break (GetLocation ($1));
+		lbag.AddStatement ($$, GetLocation ($2));
+	  }
+	;
+
+continue_statement
+	: CONTINUE stmnt_end_semicolon
+	  {
+		$$ = new Continue (GetLocation ($1));
+		lbag.AddStatement ($$, GetLocation ($2));
+	  }
+	| CONTINUE error
+	  {
+		Error_SyntaxError (yyToken);
+		$$ = new Continue (GetLocation ($1));
+	  }
+	;
+
+goto_statement
+	: GOTO identifier_inside_body stmnt_end_semicolon 
+	  {
+		var lt = (Tokenizer.LocatedToken) $2;
+		$$ = new Goto (lt.Value, GetLocation ($1));
+		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($3));
+	  }
+	| GOTO CASE constant_expression stmnt_end_semicolon
+	  {
+		$$ = new GotoCase ((Expression) $3, GetLocation ($1));
+		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
+	  }
+	| GOTO DEFAULT stmnt_end_semicolon 
+	  {
+		$$ = new GotoDefault (GetLocation ($1));
+		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($3));
+	  }
+	; 
+
+return_statement
+	: RETURN opt_expression stmnt_end_semicolon
+	  {
+		$$ = new Return ((Expression) $2, GetLocation ($1));
+		lbag.AddStatement ($$, GetLocation ($3));
+	  }
+	| RETURN expression error
+	  {
+	    Lexer.AutoSemiInsertion = true;
+		Error_SyntaxError (yyToken);
+		$$ = new Return ((Expression) $2, GetLocation ($1));
+	  }
+	| RETURN error
+	  {
+	    Lexer.AutoSemiInsertion = true;
+		Error_SyntaxError (yyToken);
+		$$ = new Return (null, GetLocation ($1));
+	  }
+	;
+
+throw_statement
+	: THROW opt_expression stmnt_end_semicolon
+	  {
+		$$ = new Throw ((Expression) $2, GetLocation ($1));
+		lbag.AddStatement ($$, GetLocation ($3));
+	  }
+	| THROW error
+	  {
+	    Lexer.AutoSemiInsertion = true;
+		Error_SyntaxError (yyToken);
+		$$ = new Throw (null, GetLocation ($1));
+	  }
+	;
+
+yield_statement 
+	: identifier_inside_body RETURN opt_expression stmnt_end_semicolon
+	  {
+		var lt = (Tokenizer.LocatedToken) $1;
+		string s = lt.Value;
+		if (s != "yield"){
+			report.Error (1003, lt.Location, "; expected");
+		} else if ($3 == null) {
+			report.Error (1627, GetLocation ($4), "Expression expected after yield return");
+		} else if (lang_version == LanguageVersion.ISO_1){
+			FeatureIsNotAvailable (lt.Location, "iterators");
+		}
+		
+		current_block.Explicit.RegisterIteratorYield ();
+		$$ = new Yield ((Expression) $3, lt.Location);
+		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
+	  }
+	| identifier_inside_body RETURN expression error
+	  {
+	    Lexer.AutoSemiInsertion = true;
+	  
+		Error_SyntaxError (yyToken);
+
+		var lt = (Tokenizer.LocatedToken) $1;
+		string s = lt.Value;
+		if (s != "yield"){
+			report.Error (1003, lt.Location, "; expected");
+		} else if ($3 == null) {
+			report.Error (1627, GetLocation ($4), "Expression expected after yield return");
+		} else if (lang_version == LanguageVersion.ISO_1){
+			FeatureIsNotAvailable (lt.Location, "iterators");
+		}
+		
+		current_block.Explicit.RegisterIteratorYield ();
+		$$ = new Yield ((Expression) $3, lt.Location);
+		lbag.AddStatement ($$, GetLocation ($2));
+	  }
+	| identifier_inside_body BREAK stmnt_end_semicolon
+	  {
+		var lt = (Tokenizer.LocatedToken) $1;
+		string s = lt.Value;
+		if (s != "yield"){
+			report.Error (1003, lt.Location, "; expected");
+		} else if (lang_version == LanguageVersion.ISO_1){
+			FeatureIsNotAvailable (lt.Location, "iterators");
+		}
+		
+		current_block.Explicit.RegisterIteratorYield ();
+		$$ = new YieldBreak (lt.Location);
+		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($3));
+	  }
+	;
+
+opt_expression
+	: /* empty */
+	| expression
+	;
+
+try_statement
+	: TRY block catch_clauses
+	  {
+		$$ = new TryCatch ((Block) $2, (List<Catch>) $3, GetLocation ($1), false);
+	  }
+	| TRY block FINALLY block
+	  {
+		$$ = new TryFinally ((Statement) $2, (Block) $4, GetLocation ($1));
+		lbag.AddStatement ($$, GetLocation ($3));
+	  }
+	| TRY block catch_clauses FINALLY block
+	  {
+		$$ = new TryFinally (new TryCatch ((Block) $2, (List<Catch>) $3, Location.Null, true), (Block) $5, GetLocation ($1));
+		lbag.AddStatement ($$, GetLocation ($4));
+	  }
+	| TRY block error
+	  {
+		Error_SyntaxError (1524, yyToken);
+		$$ = new TryCatch ((Block) $2, null, GetLocation ($1), false);
+	  }
+	;
+
+catch_clauses
+	: catch_clause 
+	  {
+		var l = new List<Catch> (2);
+
+		l.Add ((Catch) $1);
+		$$ = l;
+	  }
+	| catch_clauses catch_clause
+	  {
+		var l = (List<Catch>) $1;
+		
+		Catch c = (Catch) $2;
+		if (l [l.Count - 1].IsGeneral) {
+			report.Error (1017, c.loc, "Try statement already has an empty catch block");
+		}
+		
+		l.Add (c);
+		$$ = l;
+	  }
+	;
+
+opt_identifier
+	: /* empty */
+	| identifier_inside_body
+	;
+
+catch_clause 
+	: CATCH block
+	  {
+		$$ = new Catch ((Block) $2, GetLocation ($1));
+	  }
+	| CATCH open_parens_any IDENTIFIER COLON type CLOSE_PARENS
+	  {
+		start_block (GetLocation ($2));
+		var c = new Catch (current_block, GetLocation ($1));
+		c.TypeExpression = (FullNamedExpression) $5;
+
+		var lt = (Tokenizer.LocatedToken) $3;
+		c.Variable = new LocalVariable (current_block, lt.Value, lt.Location);
+		c.Variable.TypeExpr = c.TypeExpression;
+		current_block.AddLocalName (c.Variable);
+		
+		lbag.AddLocation (c, GetLocation ($2), GetLocation ($6));
+		$$ = c;
+	  }
+	  block_prepared
+	  {
+		$$ = $7;
+	  }
+	| CATCH open_parens_any error
+	  {
+	  	if (yyToken == Token.CLOSE_PARENS) {
+			report.Error (1015, lexer.Location,
+				"A type that derives from `System.Exception', `object', or `string' expected");
+		} else {
+			Error_SyntaxError (yyToken);
+		}
+		
+		$$ = new Catch (null, GetLocation ($1));
+	  }
+	| CATCH open_parens_any type opt_identifier CLOSE_PARENS error
+	  {
+		Error_SyntaxError (yyToken);
+
+		// Required otherwise missing block could not be detected because
+		// start_block is run early
+		var c = new Catch (null, GetLocation ($1));
+		c.TypeExpression = (FullNamedExpression) $3;
+
+		if ($4 != null) {
+			var lt = (Tokenizer.LocatedToken) $4;
+			c.Variable = new LocalVariable (current_block, lt.Value, lt.Location);
+		}
+
+		lbag.AddLocation (c, GetLocation ($2), GetLocation ($5));
+
+		$$ = c;
+	  }
+	;
+
+checked_statement
+	: CHECKED block
+	  {
+		$$ = new Checked ((Block) $2, GetLocation ($1));
+	  }
+	;
+
+unchecked_statement
+	: UNCHECKED block
+	  {
+		$$ = new Unchecked ((Block) $2, GetLocation ($1));
+	  }
+	;
+
+unsafe_statement
+	: UNSAFE
+	  {
+		if (!settings.Unsafe)
+			Error_UnsafeCodeNotAllowed (GetLocation ($1));
+	  } block {
+		$$ = new Unsafe ((Block) $3, GetLocation ($1));
+	  }
+	;
+
+lock_statement
+	: LOCK open_parens_any expression CLOSE_PARENS embedded_statement
+	  {
+		if ($5 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
+			Warning_EmptyStatement (GetLocation ($5));
+	  
+		$$ = new Lock ((Expression) $3, (Statement) $5, GetLocation ($1));
+		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
+	  }
+	| LOCK open_parens_any expression error
+	  {
+		Error_SyntaxError (yyToken);
+
+		$$ = new Lock ((Expression) $3, null, GetLocation ($1));
+		lbag.AddStatement ($$, GetLocation ($2));
+	  }
+	;
+
+fixed_statement
+	: FIXED open_parens_any type identifier_inside_body
+	  {
+	    start_block (GetLocation ($2));
+	    
+		current_block.IsCompilerGenerated = true;
+		var lt = (Tokenizer.LocatedToken) $4;
+		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.FixedVariable | LocalVariable.Flags.Used, lt.Location);
+		current_block.AddLocalName (li);
+		current_variable = new Fixed.VariableDeclaration ((FullNamedExpression) $3, li);
+	  }
+	  using_or_fixed_variable_initializer opt_using_or_fixed_variable_declarators CLOSE_PARENS
+	  {
+		$$ = current_variable;
+		current_variable = null;
+	  }
+	  embedded_statement
+	  {
+		if ($10 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
+			Warning_EmptyStatement (GetLocation ($10));
+	  
+		Fixed f = new Fixed ((Fixed.VariableDeclaration) $9, (Statement) $10, GetLocation ($1));
+		current_block.AddStatement (f);
+		lbag.AddStatement (f, GetLocation ($2), GetLocation ($8));
+		$$ = end_block (GetLocation ($8));
+	  }
+	;
+
+using_statement
+	: USING open_parens_any variable_type identifier_inside_body
+	  {
+	    start_block (GetLocation ($2));
+	    
+		current_block.IsCompilerGenerated = true;
+		var lt = (Tokenizer.LocatedToken) $4;
+		var li = new LocalVariable (current_block, lt.Value, LocalVariable.Flags.UsingVariable | LocalVariable.Flags.Used, lt.Location);
+		current_block.AddLocalName (li);
+		current_variable = new Using.VariableDeclaration ((FullNamedExpression) $3, li);
+	  }
+	  using_initialization CLOSE_PARENS
+	  {
+		$$ = current_variable;	  
+		current_variable = null;
+	  }
+	  embedded_statement
+	  {
+	  	CheckIsPlayScript("using", GetLocation($2));
+	  	
+		if ($9 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
+			Warning_EmptyStatement (GetLocation ($9));
+	  
+		Using u = new Using ((Using.VariableDeclaration) $8, (Statement) $9, GetLocation ($1));
+		lbag.AddStatement (u, GetLocation ($2), GetLocation ($7));
+		current_block.AddStatement (u);
+		$$ = end_block (GetLocation ($7));
+	  }
+	| USING open_parens_any expression CLOSE_PARENS embedded_statement
+	  {
+	  	CheckIsPlayScript("using", GetLocation($2));
+
+		if ($5 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
+			Warning_EmptyStatement (GetLocation ($5));
+	  
+		$$ = new Using ((Expression) $3, (Statement) $5, GetLocation ($1));
+		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
+	  }
+	| USING open_parens_any expression error
+	  {
+	  	CheckIsPlayScript("using", GetLocation($2));
+	  
+		Error_SyntaxError (yyToken);
+		
+		$$ = new Using ((Expression) $3, null, GetLocation ($1));
+		lbag.AddStatement ($$, GetLocation ($2));
+	  }
+	;
+	
+using_initialization
+	: using_or_fixed_variable_initializer opt_using_or_fixed_variable_declarators
+	| error
+	  {
+		// It has to be here for the parent to safely restore artificial block
+	  	Error_SyntaxError (yyToken);
+	  }
+	;
+	
+using_or_fixed_variable_initializer
+	: /* empty */
+	  {
+		Error_MissingInitializer (lexer.Location);
+	  }
+	| ASSIGN variable_initializer
+	  {
+		current_variable.Initializer = (Expression) $2;
+		lbag.AppendTo (current_variable, GetLocation ($1));
+		$$ = current_variable;
+	  }
+	;
+
+//delete_statement
+//	: DELETE element_access SEMICOLON
+//	  {
+//		$$ = new StatementExpression (new AsDelete ((Expression) $2, GetLocation ($1)));
+//		lbag.AddStatement ($$, GetLocation ($2));
+//	  }
+//	| DELETE member_access SEMICOLON
+//	  {
+//		$$ = new StatementExpression (new AsDelete ((Expression) $2, GetLocation ($1)));	
+//		lbag.AddStatement ($$, GetLocation ($2));
+//	  }
+//	;
+
+// LINQ
+
+query_expression
+	: first_from_clause query_body 
+	  {
+		lexer.query_parsing = false;
+			
+		Linq.AQueryClause from = $1 as Linq.AQueryClause;
+			
+		from.Tail.Next = (Linq.AQueryClause)$2;
+		$$ = from;
+		
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+	  }
+	| nested_from_clause query_body
+	  {
+		Linq.AQueryClause from = $1 as Linq.AQueryClause;
+			
+		from.Tail.Next = (Linq.AQueryClause)$2;
+		$$ = from;
+		
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+	  }	
+
+	// Bubble up COMPLETE_COMPLETION productions
+	| first_from_clause COMPLETE_COMPLETION {
+	        lexer.query_parsing = false;
+		$$ = $1;
+
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+	  }
+	| nested_from_clause COMPLETE_COMPLETION {
+	        $$ = $1;
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+	  }
+	;
+	
+first_from_clause
+	: FROM_FIRST identifier_inside_body IN expression
+	  {
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  
+		var lt = (Tokenizer.LocatedToken) $2;
+		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
+		$$ = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)$4, rv, GetLocation ($1)));
+	  }
+	| FROM_FIRST type identifier_inside_body IN expression
+	  {
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  
+		var lt = (Tokenizer.LocatedToken) $3;
+		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
+		$$ = new Linq.QueryExpression (
+			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)$5, rv, GetLocation ($1)) {
+				IdentifierType = (FullNamedExpression)$2
+			}
+		);
+	  }
+	;
+
+nested_from_clause
+	: FROM identifier_inside_body IN expression
+	  {
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  
+		var lt = (Tokenizer.LocatedToken) $2;
+		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
+		$$ = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)$4, rv, GetLocation ($1)));
+	  }
+	| FROM type identifier_inside_body IN expression
+	  {
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  
+		var lt = (Tokenizer.LocatedToken) $3;
+		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
+		$$ = new Linq.QueryExpression (
+			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)$5, rv, GetLocation ($1)) {
+				IdentifierType = (FullNamedExpression)$2
+			}
+		);
+	  }
+	;
+	
+from_clause
+	: FROM identifier_inside_body IN
+	  {
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  }
+	  expression_or_error
+	  {
+		var lt = (Tokenizer.LocatedToken) $2;
+		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
+		$$ = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)$5, GetLocation ($1));
+		
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+		
+		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
+	  }	  
+	| FROM type identifier_inside_body IN
+	  {
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  }
+	  expression_or_error
+	  {
+		var lt = (Tokenizer.LocatedToken) $3;
+		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
+
+		$$ = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)$6, GetLocation ($1)) {
+			IdentifierType = (FullNamedExpression)$2
+		};
+		
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+		
+		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
+	  }
+	;	
+
+query_body
+	: query_body_clauses select_or_group_clause opt_query_continuation 
+	  {
+	  	Linq.AQueryClause head = (Linq.AQueryClause)$2;
+		
+		if ($3 != null)
+			head.Next = (Linq.AQueryClause)$3;
+				
+		if ($1 != null) {
+			Linq.AQueryClause clause = (Linq.AQueryClause)$1;
+			clause.Tail.Next = head;
+			head = clause;
+		}
+		
+		$$ = head;
+	  }
+	| select_or_group_clause opt_query_continuation
+	  {
+	  	Linq.AQueryClause head = (Linq.AQueryClause)$2;
+
+		if ($1 != null) {
+			Linq.AQueryClause clause = (Linq.AQueryClause)$1;
+			clause.Tail.Next = head;
+			head = clause;
+		}
+		
+		$$ = head;
+	  }
+	| query_body_clauses COMPLETE_COMPLETION
+	| query_body_clauses error
+	  {
+		report.Error (742, GetLocation ($2), "Unexpected symbol `{0}'. A query body must end with select or group clause", GetSymbolName (yyToken));
+		$$ = $1;
+	  }
+	| error
+	  {
+		Error_SyntaxError (yyToken);
+		$$ = null;
+	  }
+	;
+	
+select_or_group_clause
+	: SELECT
+	  {
+	  	current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  }
+	  expression_or_error
+	  {
+		$$ = new Linq.Select ((Linq.QueryBlock)current_block, (Expression)$3, GetLocation ($1));
+
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+	  }
+	| GROUP
+	  {
+	  	if (linq_clause_blocks == null)
+	  		linq_clause_blocks = new Stack<Linq.QueryBlock> ();
+	  		
+	  	current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  	linq_clause_blocks.Push ((Linq.QueryBlock)current_block);
+	  }
+	  expression_or_error
+	  {
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+	  
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  }
+	  BY expression_or_error
+	  {
+		$$ = new Linq.GroupBy ((Linq.QueryBlock)current_block, (Expression)$3, linq_clause_blocks.Pop (), (Expression)$6, GetLocation ($1));
+		lbag.AddLocation ($$, GetLocation ($5));
+		
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+	  }
+	;
+	
+query_body_clauses
+	: query_body_clause
+	| query_body_clauses query_body_clause
+	  {
+		((Linq.AQueryClause)$1).Tail.Next = (Linq.AQueryClause)$2;
+		$$ = $1;
+	  }
+	;
+	
+query_body_clause
+	: from_clause
+	| let_clause 
+	| where_clause
+	| join_clause
+	| orderby_clause
+	;
+	
+let_clause
+	: LET identifier_inside_body ASSIGN 
+	  {
+	  	current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  }
+	  expression_or_error
+	  {
+		var lt = (Tokenizer.LocatedToken) $2;
+		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
+	  	$$ = new Linq.Let ((Linq.QueryBlock) current_block, sn, (Expression)$5, GetLocation ($1));
+		lbag.AddLocation ($$, GetLocation ($3));
+	  	
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+		
+		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
+	  }
+	;
+
+where_clause
+	: WHERE
+	  {
+	  	current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  }
+	  expression_or_error
+	  {
+		$$ = new Linq.Where ((Linq.QueryBlock)current_block, (Expression)$3, GetLocation ($1));
+
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+	  }
+	;
+	
+join_clause
+	: JOIN identifier_inside_body IN
+	  {
+		if (linq_clause_blocks == null)
+			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
+	  		
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
+	  }
+	  expression_or_error ON
+	  {
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
+	  }
+	  expression_or_error EQUALS
+	  {
+		current_block.AddStatement (new ContextualReturn ((Expression) $8));
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  }
+	  expression_or_error opt_join_into
+	  {
+		current_block.AddStatement (new ContextualReturn ((Expression) $11));
+		current_block.SetEndLocation (lexer.Location);
+	  
+		var outer_selector = linq_clause_blocks.Pop ();
+		var block = linq_clause_blocks.Pop ();
+
+		var lt = (Tokenizer.LocatedToken) $2;	
+		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
+		Linq.RangeVariable into;
+		
+		if ($12 == null) {
+			into = sn;
+	  		$$ = new Linq.Join (block, sn, (Expression)$5, outer_selector, (Linq.QueryBlock) current_block, GetLocation ($1));
+			lbag.AddLocation ($$, GetLocation ($3), GetLocation ($6), GetLocation ($9));
+		} else {
+			//
+			// Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions
+			//
+			var parent = block.Parent;
+			while (parent is Linq.QueryBlock) {
+				parent = parent.Parent;
+			}
+			current_block.Parent = parent;
+			
+			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
+		
+			lt = (Tokenizer.LocatedToken) $12;
+			into = new Linq.RangeVariable (lt.Value, lt.Location);
+
+			$$ = new Linq.GroupJoin (block, sn, (Expression)$5, outer_selector, (Linq.QueryBlock) current_block, into, GetLocation ($1));	
+			lbag.AddLocation ($$, GetLocation ($3), GetLocation ($6), GetLocation ($9), GetLocation ($12));
+		}
+
+		current_block = block.Parent;
+		((Linq.QueryBlock)current_block).AddRangeVariable (into);
+	  }
+	| JOIN type identifier_inside_body IN
+	  {
+		if (linq_clause_blocks == null)
+			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
+	  		
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
+	  }
+	  expression_or_error ON
+	  {
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
+	  }
+	  expression_or_error EQUALS
+	  {
+		current_block.AddStatement (new ContextualReturn ((Expression) $9));
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  }
+	  expression_or_error opt_join_into
+	  {
+		current_block.AddStatement (new ContextualReturn ((Expression) $12));
+		current_block.SetEndLocation (lexer.Location);
+	  
+		var outer_selector = linq_clause_blocks.Pop ();
+		var block = linq_clause_blocks.Pop ();
+		
+		var lt = (Tokenizer.LocatedToken) $3;
+		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
+		Linq.RangeVariable into;
+		
+		if ($13 == null) {
+			into = sn;		
+	  		$$ = new Linq.Join (block, sn, (Expression)$6, outer_selector, (Linq.QueryBlock) current_block, GetLocation ($1)) {
+	  			IdentifierType = (FullNamedExpression)$2
+	  		};
+		} else {
+			//
+			// Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions
+			//
+			var parent = block.Parent;
+			while (parent is Linq.QueryBlock) {
+				parent = parent.Parent;
+			}
+			current_block.Parent = parent;
+		
+			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
+		
+			lt = (Tokenizer.LocatedToken) $13;
+			into = new Linq.RangeVariable (lt.Value, lt.Location); // TODO:
+			
+			$$ = new Linq.GroupJoin (block, sn, (Expression)$6, outer_selector, (Linq.QueryBlock) current_block, into, GetLocation ($1)) {
+	  			IdentifierType = (FullNamedExpression)$2
+	  		};			
+		}
+		
+		current_block = block.Parent;
+		((Linq.QueryBlock)current_block).AddRangeVariable (into);		
+	  }
+	;
+	
+opt_join_into
+	: /* empty */
+	| INTO identifier_inside_body
+	  {
+		$$ = $2;
+	  }
+	;
+	
+orderby_clause
+	: ORDERBY
+	  {
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  }
+	  orderings
+	  {
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+	  
+		$$ = $3;
+	  }
+	;
+	
+orderings
+	: order_by
+	| order_by COMMA
+	  {
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+	  
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+	  }
+	  orderings_then_by
+	  {
+		((Linq.AQueryClause)$1).Next = (Linq.AQueryClause)$4;
+		$$ = $1;
+	  }
+	;
+	
+orderings_then_by
+	: then_by
+	| orderings_then_by COMMA
+	 {
+		current_block.SetEndLocation (lexer.Location);
+		current_block = current_block.Parent;
+	  
+		current_block = new Linq.QueryBlock ((Linq.QueryBlock) current_block, lexer.Location);	 
+	 }
+	 then_by
+	 {
+		((Linq.AQueryClause)$1).Tail.Next = (Linq.AQueryClause)$4;
+		$$ = $1;
+	 }
+	;	
+	
+order_by
+	: expression
+	  {
+		$$ = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)$1);	
+	  }
+	| expression ASCENDING
+	  {
+		$$ = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)$1);	
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| expression DESCENDING
+	  {
+		$$ = new Linq.OrderByDescending ((Linq.QueryBlock) current_block, (Expression)$1);	
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	;
+
+then_by
+	: expression
+	  {
+		$$ = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)$1);	
+	  }
+	| expression ASCENDING
+	  {
+		$$ = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)$1);	
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }
+	| expression DESCENDING
+	  {
+		$$ = new Linq.ThenByDescending ((Linq.QueryBlock) current_block, (Expression)$1);	
+		lbag.AddLocation ($$, GetLocation ($2));
+	  }	
+	;
+
+
+opt_query_continuation
+	: /* empty */
+	| INTO identifier_inside_body
+	  {
+		// query continuation block is not linked with query block but with block
+		// before. This means each query can use same range variable names for
+		// different identifiers.
+
+		current_block.SetEndLocation (GetLocation ($1));
+		current_block = current_block.Parent;
+	
+		current_block = new Linq.QueryBlock (current_block, lexer.Location);
+		
+		if (linq_clause_blocks == null)
+			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
+	  		
+		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);		
+	  }
+	  query_body
+	  {
+		var current_block = linq_clause_blocks.Pop ();	  
+		var lt = (Tokenizer.LocatedToken) $2;
+		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
+  		$$ = new Linq.QueryStartClause ((Linq.QueryBlock)current_block, null, rv, GetLocation ($1)) {
+  			next = (Linq.AQueryClause)$4
+  		};
+	  }
+	;
+	
+//
+// Support for using the compiler as an interactive parser
+//
+// The INTERACTIVE_PARSER token is first sent to parse our
+// productions;  If the result is a Statement, the parsing
+// is repeated, this time with INTERACTIVE_PARSE_WITH_BLOCK
+// to setup the blocks in advance.
+//
+// This setup is here so that in the future we can add 
+// support for other constructs (type parsing, namespaces, etc)
+// that do not require a block to be setup in advance
+//
+
+interactive_parsing
+	: EVAL_STATEMENT_PARSER EOF 
+	| EVAL_USING_DECLARATIONS_UNIT_PARSER package_directives opt_COMPLETE_COMPLETION
+	| EVAL_STATEMENT_PARSER
+	 { 
+		current_container = current_type = new Class (current_container, new MemberName ("<InteractiveExpressionClass>"), Modifiers.PUBLIC, null);
+
+		// (ref object retval)
+		Parameter [] mpar = new Parameter [1];
+		mpar [0] = new Parameter (new TypeExpression (compiler.BuiltinTypes.Object, Location.Null), "$retval", Parameter.Modifier.REF, null, Location.Null);
+
+		ParametersCompiled pars = new ParametersCompiled (mpar);
+		var mods = Modifiers.PUBLIC | Modifiers.STATIC;
+		if (settings.Unsafe)
+			mods |= Modifiers.UNSAFE;
+
+		current_local_parameters = pars;
+		Method method = new Method (
+			current_type,
+			new TypeExpression (compiler.BuiltinTypes.Void, Location.Null),
+			mods,
+			new MemberName ("Host"),
+			pars,
+			null /* attributes */);
+			
+		current_type.AddMember (method);
+
+		// Always set to true when in ineractive mode
+		is_config_enabled = true; 
+		
+		oob_stack.Push (method);
+		++lexer.parsing_block;
+		start_block (lexer.Location);
+	  }		
+	  interactive_statement_list opt_COMPLETE_COMPLETION
+	  {
+		--lexer.parsing_block;
+		Method method = (Method) oob_stack.Pop ();
+
+		method.Block = (ToplevelBlock) end_block(lexer.Location);
+
+		InteractiveResult = (Class) pop_current_class ();
+		current_local_parameters = null;
+	  } 
+	| EVAL_COMPILATION_UNIT_PARSER interactive_compilation_unit
+	;
+
+interactive_compilation_unit
+	: opt_extern_alias_directives opt_package_directives
+	| opt_extern_alias_directives opt_package_directives package_declaration
+	;
+
+opt_COMPLETE_COMPLETION
+	: /* nothing */
+	| COMPLETE_COMPLETION
+	;
+
+//close_brace_or_complete_completion
+//	: CLOSE_BRACE
+//	| COMPLETE_COMPLETION
+//	;
+	
+//
+// XML documentation code references micro parser
+//
+documentation_parsing
+	: DOC_SEE doc_cref
+	  {
+		module.DocumentationBuilder.ParsedName = (MemberName) $2;
+	  }
+	;
+
+doc_cref
+	: doc_type_declaration_name opt_doc_method_sig
+	  {
+		module.DocumentationBuilder.ParsedParameters = (List<DocumentationParameter>)$2;
+	  }
+	| builtin_types opt_doc_method_sig
+	  {
+		module.DocumentationBuilder.ParsedBuiltinType = (TypeExpression)$1;
+		module.DocumentationBuilder.ParsedParameters = (List<DocumentationParameter>)$2;
+		$$ = null;
+	  }
+	| builtin_types DOT IDENTIFIER opt_doc_method_sig
+	  {
+		module.DocumentationBuilder.ParsedBuiltinType = (TypeExpression)$1;
+		module.DocumentationBuilder.ParsedParameters = (List<DocumentationParameter>)$4;
+		var lt = (Tokenizer.LocatedToken) $3;
+		$$ = new MemberName (lt.Value);
+	  }
+	| doc_type_declaration_name DOT THIS
+	  {
+		$$ = new MemberName ((MemberName) $1, MemberCache.IndexerNameAlias, Location.Null);
+	  }
+	| doc_type_declaration_name DOT THIS OPEN_BRACKET
+	  {
+		valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
+	  }
+	  opt_doc_parameters CLOSE_BRACKET
+	  {
+		module.DocumentationBuilder.ParsedParameters = (List<DocumentationParameter>)$6;
+		$$ = new MemberName ((MemberName) $1, MemberCache.IndexerNameAlias, Location.Null);
+	  }
+	| EXPLICIT OPERATOR type opt_doc_method_sig
+	  {
+		var p = (List<DocumentationParameter>)$4 ?? new List<DocumentationParameter> (1);
+		p.Add (new DocumentationParameter ((FullNamedExpression) $3));
+		module.DocumentationBuilder.ParsedParameters = p;
+		module.DocumentationBuilder.ParsedOperator = Operator.OpType.Explicit;
+		$$ = null;
+	  }
+	| IMPLICIT OPERATOR type opt_doc_method_sig
+	  {
+		var p = (List<DocumentationParameter>)$4 ?? new List<DocumentationParameter> (1);
+		p.Add (new DocumentationParameter ((FullNamedExpression) $3));
+		module.DocumentationBuilder.ParsedParameters = p;
+		module.DocumentationBuilder.ParsedOperator = Operator.OpType.Implicit;
+		$$ = null;
+	  }	  
+	| OPERATOR overloadable_operator opt_doc_method_sig
+	  {
+		var p = (List<DocumentationParameter>)$3 ?? new List<DocumentationParameter> (1);
+		module.DocumentationBuilder.ParsedParameters = p;
+		module.DocumentationBuilder.ParsedOperator = (Operator.OpType) $2;
+		$$ = null;
+	  }
+	;
+	
+doc_type_declaration_name
+	: type_declaration_name
+	| doc_type_declaration_name DOT type_declaration_name
+	  {
+		$$ = new MemberName (((MemberName) $1), (MemberName) $3);
+	  }
+	;
+	
+opt_doc_method_sig
+	: /* empty */
+	| OPEN_PARENS
+	  {
+		valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
+	  }
+	  opt_doc_parameters CLOSE_PARENS
+	  {
+		$$ = $3;
+	  }
+	;
+	
+opt_doc_parameters
+	: /* empty */
+	  {
+		$$ = new List<DocumentationParameter> (0);
+	  }
+	| doc_parameters
+	;
+	
+doc_parameters
+	: doc_parameter
+	  {
+		var parameters = new List<DocumentationParameter> ();
+		parameters.Add ((DocumentationParameter) $1);
+		$$ = parameters;
+	  }
+	| doc_parameters COMMA doc_parameter
+	  {
+		var parameters = $1 as List<DocumentationParameter>;
+		parameters.Add ((DocumentationParameter) $3);
+		$$ = parameters;
+	  }
+	;
+	
+doc_parameter
+	: opt_parameter_modifier parameter_type
+	  {
+		if ($1 != null)
+			$$ = new DocumentationParameter ((Parameter.Modifier) $1, (FullNamedExpression) $2);
+		else
+			$$ = new DocumentationParameter ((FullNamedExpression) $2);
+	  }
+	;
+	
+%%
+
+// <summary>
+//  A class used to hold info about an operator declarator
+// </summary>
+class OperatorDeclaration {
+	public readonly Operator.OpType optype;
+	public readonly FullNamedExpression ret_type;
+	public readonly Location location;
+
+	public OperatorDeclaration (Operator.OpType op, FullNamedExpression ret_type, Location location)
+	{
+		optype = op;
+		this.ret_type = ret_type;
+		this.location = location;
+	}
+}
+
+void Error_ExpectingTypeName (Expression expr)
+{
+	if (expr is Invocation){
+		report.Error (1002, expr.Location, "Expecting `;'");
+	} else {
+		expr.Error_InvalidExpressionStatement (report);
+	}
+}
+
+void Error_ParameterModifierNotValid (string modifier, Location loc)
+{
+	report.Error (631, loc, "The parameter modifier `{0}' is not valid in this context",
+			              modifier);
+}
+
+void Error_DuplicateParameterModifier (Location loc, Parameter.Modifier mod)
+{
+	report.Error (1107, loc, "Duplicate parameter modifier `{0}'",
+  		Parameter.GetModifierSignature (mod));
+}
+
+void Error_TypeExpected (Location loc)
+{
+	report.Error (1031, loc, "Type expected");
+}
+
+void Error_UnsafeCodeNotAllowed (Location loc)
+{
+	report.Error (227, loc, "Unsafe code requires the `unsafe' command line option to be specified");
+}
+
+void Warning_EmptyStatement (Location loc)
+{
+	report.Warning (642, 3, loc, "Possible mistaken empty statement");
+}
+
+void Error_NamedArgumentExpected (NamedArgument a)
+{
+	report.Error (1738, a.Location, "Named arguments must appear after the positional arguments");
+}
+
+void Error_MissingInitializer (Location loc)
+{
+	report.Error (210, loc, "You must provide an initializer in a fixed or using statement declaration");
+}
+
+object Error_AwaitAsIdentifier (object token)
+{
+	if (async_block) {
+		report.Error (4003, GetLocation (token), "`await' cannot be used as an identifier within an async method or lambda expression");
+		return new Tokenizer.LocatedToken ("await", GetLocation (token));
+	}
+
+	return token;
+}
+
+void push_current_container (TypeDefinition tc, object partial_token)
+{
+	if (module.Evaluator != null){
+		tc.Definition.Modifiers = tc.ModFlags = (tc.ModFlags & ~Modifiers.AccessibilityMask) | Modifiers.PUBLIC;
+		if (undo == null)
+			undo = new Undo ();
+
+		undo.AddTypeContainer (current_container, tc);
+	}
+	
+	if (is_config_enabled) {
+		if (partial_token != null)
+			current_container.AddPartial (tc);
+		else
+			current_container.AddTypeContainer (tc);
+	}
+	
+	is_config_enabled = true;
+		
+	++lexer.parsing_declaration;
+	current_container = tc;
+	current_type = tc;
+}
+
+TypeContainer pop_current_class ()
+{
+	var retval = current_container;
+
+	current_container = current_container.Parent;
+	current_type = current_type.Parent as TypeDefinition;
+
+	return retval;
+}
+
+[System.Diagnostics.Conditional ("FULL_AST")]
+void StoreModifierLocation (object token, Location loc)
+{
+	if (lbag == null)
+		return;
+
+	if (mod_locations == null)
+  		mod_locations = new List<Tuple<Modifiers, Location>> ();
+
+	mod_locations.Add (Tuple.Create ((Modifiers) token, loc));
+}
+
+List<Tuple<Modifiers, Location>> GetModifierLocations ()
+{
+	var result = mod_locations;
+	mod_locations = null;
+	return result;
+}
+
+string CheckAttributeTarget (string a, Location l)
+{
+	switch (a) {
+	case "assembly" : case "module" : case "field" : case "method" : case "param" : case "property" : case "type" :
+			return a;
+	}
+
+	report.Warning (658, 1, l,
+		 "`{0}' is invalid attribute target. All attributes in this attribute section will be ignored", a);
+	return string.Empty;
+}
+
+bool IsPartial (object a)
+{
+	var attrs = a as Attributes;
+	if (attrs == null)
+		return false;
+	foreach (var attr in attrs.Attrs) {
+		if (attr.TypeExpression.Name == "Partial")
+			return true;
+	}
+	return false;
+}
+
+static bool IsUnaryOperator (Operator.OpType op)
+{
+	switch (op) {
+		
+	case Operator.OpType.LogicalNot: 
+	case Operator.OpType.OnesComplement: 
+	case Operator.OpType.Increment:
+	case Operator.OpType.Decrement:
+	case Operator.OpType.True: 
+	case Operator.OpType.False: 
+	case Operator.OpType.UnaryPlus: 
+	case Operator.OpType.UnaryNegation:
+		return true;
+	}
+	return false;
+}
+
+void syntax_error (Location l, string msg)
+{
+	report.Error (1003, l, "Syntax error, " + msg);
+}
+
+Tokenizer lexer;
+
+public Tokenizer Lexer {
+	get {
+		return lexer;
+	}
+}		   
+
+public PlayScriptParser (SeekableStreamReader reader, CompilationSourceFile file, ParserSession session)
+	: this (reader, file, file.Compiler.Report, session)
+{
+}
+
+public PlayScriptParser (SeekableStreamReader reader, CompilationSourceFile file, Report report, ParserSession session)
+{
+	this.file = file;
+	current_container = current_namespace = file;
+	
+	this.module = file.Module;
+	this.compiler = file.Compiler;
+	this.settings = compiler.Settings;
+	this.report = report;
+	
+	lang_version = settings.Version;
+	yacc_verbose_flag = settings.VerboseParserFlag;
+	doc_support = settings.DocumentationFile != null;
+	lexer = new Tokenizer (reader, file, session);
+	oob_stack = new Stack<object> ();
+	lbag = session.LocationsBag;
+	use_global_stacks = session.UseJayGlobalArrays;
+	parameters_bucket = session.ParametersStack;
+}
+
+public void parse ()
+{
+	eof_token = Token.EOF;
+	
+	try {
+		if (yacc_verbose_flag > 1)
+			yyparse (lexer, new yydebug.yyDebugSimple ());
+		else
+			yyparse (lexer);
+			
+		Tokenizer tokenizer = lexer as Tokenizer;
+		tokenizer.cleanup ();		
+	} catch (Exception e){
+	  	if (e is yyParser.yyUnexpectedEof) {
+			Error_SyntaxError (yyToken);
+			UnexpectedEOF = true;
+			return;
+		}
+			
+		if (e is yyParser.yyException) {
+			if (report.Errors == 0)
+				report.Error (-25, lexer.Location, "Parsing error");
+		} else {
+			// Used by compiler-tester to test internal errors
+			if (yacc_verbose_flag > 0 || e is FatalException)
+				throw;
+		
+			report.Error (589, lexer.Location, "Internal compiler error during parsing" + e);
+		}
+	}
+}
+
+void CheckToken (int error, int yyToken, string msg, Location loc)
+{
+	if (yyToken >= Token.FIRST_KEYWORD && yyToken <= Token.LAST_KEYWORD)
+		report.Error (error, loc, "{0}: `{1}' is a keyword", msg, GetTokenName (yyToken));
+	else
+		report.Error (error, loc, msg);
+}
+
+string ConsumeStoredComment ()
+{
+	string s = tmpComment;
+	tmpComment = null;
+	Lexer.doc_state = XmlCommentState.Allowed;
+	return s;
+}
+
+void FeatureIsNotAvailable (Location loc, string feature)
+{
+	report.FeatureIsNotAvailable (compiler, loc, feature);
+}
+
+Location GetLocation (object obj)
+{
+	var lt = obj as Tokenizer.LocatedToken;
+	if (lt != null)
+		return lt.Location;
+		
+	var mn = obj as MemberName;
+	if (mn != null)
+		return mn.Location;
+		
+	var expr = obj as Expression;
+	if (expr != null)
+		return expr.Location;
+
+	return lexer.Location;
+}
+
+void start_block (Location loc)
+{
+	if (current_block == null) {
+		current_block = new ToplevelBlock (compiler, current_local_parameters, loc);
+		parsing_anonymous_method = false;
+	} else if (parsing_anonymous_method) {
+		current_block = new ParametersBlock (current_block, current_local_parameters, loc);
+		parsing_anonymous_method = false;
+	} else {
+		current_block = new ExplicitBlock (current_block, loc, Location.Null);
+	}
+}
+
+Block
+end_block (Location loc)
+{
+	Block retval = current_block.Explicit;
+	retval.SetEndLocation (loc);
+	current_block = retval.Parent;
+	return retval;
+}
+
+void start_anonymous (bool isLambda, ParametersCompiled parameters, FullNamedExpression retType, bool isAsync, Location loc)
+{
+	oob_stack.Push (current_anonymous_method);
+	oob_stack.Push (current_local_parameters);
+	oob_stack.Push (current_variable);
+	oob_stack.Push (async_block);
+	oob_stack.Push (Lexer.AutoSemiInsertion);
+
+	current_local_parameters = parameters;
+	if (isLambda) {
+		if (lang_version <= LanguageVersion.ISO_2)
+			FeatureIsNotAvailable (loc, "lambda expressions");
+
+		current_anonymous_method = new LambdaExpression (loc);
+	} else {
+		if (lang_version == LanguageVersion.ISO_1)
+			FeatureIsNotAvailable (loc, "anonymous methods");
+			
+		current_anonymous_method = new AnonymousMethodExpression (loc, parameters, retType);
+	}
+
+	async_block = isAsync;
+	// Force the next block to be created as a ToplevelBlock
+	parsing_anonymous_method = true;
+}
+
+/*
+ * Completes the anonymous method processing, if lambda_expr is null, this
+ * means that we have a Statement instead of an Expression embedded 
+ */
+AnonymousMethodExpression end_anonymous (ParametersBlock anon_block)
+{
+	AnonymousMethodExpression retval;
+
+	if (async_block)
+		anon_block.IsAsync = true;
+
+	current_anonymous_method.Block = anon_block;
+	retval = current_anonymous_method;
+
+	Lexer.AutoSemiInsertion = (bool) oob_stack.Pop ();
+	async_block = (bool) oob_stack.Pop ();
+	current_variable = (BlockVariableDeclaration) oob_stack.Pop ();
+	current_local_parameters = (ParametersCompiled) oob_stack.Pop ();
+	current_anonymous_method = (AnonymousMethodExpression) oob_stack.Pop ();
+
+	return retval;
+}
+
+void Error_SyntaxError (int token)
+{
+	Error_SyntaxError (0, token);
+}
+
+void Error_SyntaxError (int error_code, int token)
+{
+	Error_SyntaxError (error_code, token, "Unexpected symbol");
+}
+
+void Error_SyntaxError (int error_code, int token, string msg)
+{
+	Lexer.CompleteOnEOF = false;
+
+	// An error message has been reported by tokenizer
+	if (token == Token.ERROR)
+		return;
+	
+	// Avoid duplicit error message after unterminated string literals
+	if (token == Token.LITERAL && lexer.Location.Column == 0)
+		return;
+
+	string symbol = GetSymbolName (token);
+	string expecting = GetExpecting ();
+	var loc = lexer.Location - symbol.Length;
+	
+	if (error_code == 0) {
+		if (expecting == "`identifier'") {
+			if (token > Token.FIRST_KEYWORD && token < Token.LAST_KEYWORD) {
+				report.Error (1041, loc, "Identifier expected, `{0}' is a keyword", symbol);
+				return;
+			}
+			
+			error_code = 1001;
+			expecting = "identifier";
+		} else if (expecting == "`)'") {
+			error_code = 1026;
+		} else {
+			error_code = 1525;
+		}
+	}
+	
+	if (string.IsNullOrEmpty (expecting))
+		report.Error (error_code, loc, "{1} `{0}'", symbol, msg);
+	else
+		report.Error (error_code, loc, "{2} `{0}', expecting {1}", symbol, expecting, msg);	  
+}
+
+void CheckIsPlayScript(string elem, Location loc) 
+{
+	if (!parsing_playscript) {
+		report.Error (7035, loc, "`{0}' only supported in PlayScript", elem);
+	}
+
+}
+
+object ConvertAsType(SimpleName sn, object e)
+{
+	if (sn.Name == "Object") 
+		return new TypeExpression (compiler.BuiltinTypes.Dynamic, GetLocation (e));
+	else if (sn.Name == "Boolean") 
+		return new TypeExpression (compiler.BuiltinTypes.Bool, GetLocation (e));
+	else if (sn.Name == "Number")
+		return new TypeExpression (compiler.BuiltinTypes.Double, GetLocation (e));
+	else if (sn.Name == "String")
+		return new TypeExpression (compiler.BuiltinTypes.String, GetLocation (e));
+	else if (sn.Name == "void")
+		return new TypeExpression (compiler.BuiltinTypes.Void, GetLocation (e));
+	else if (sn.Name == "Function")
+		return new TypeExpression (compiler.BuiltinTypes.Delegate, GetLocation (e));
+	else if (sn.Name == "Class")
+		return new TypeExpression (compiler.BuiltinTypes.Type, GetLocation (e));
+	else
+		return e;
+}
+
+Statement ExpressionListToStatementList(List<Expression> list)
+{
+	if (list.Count == 1) {
+		return ConvertExpressionToStatement(list[0]);
+	} else if (list.Count > 1) {
+		var sl = new StatementList(ConvertExpressionToStatement(list[0]), ConvertExpressionToStatement(list[1]));
+		for (var i = 2; i < list.Count; i++) {
+			sl.Add(ConvertExpressionToStatement(list[i]));
+		}
+		return sl;
+	}
+	
+	return new StatementErrorExpression (EmptyExpression.MissingValue);
+}
+
+Statement ConvertExpressionToStatement(Expression ex)
+{
+	Statement ret;
+	ExpressionStatement s = ex as ExpressionStatement;
+	if (s == null) {
+		if (Lexer.ParsingPlayScript) {
+			ex.Error_InvalidExpressionStatement (report);
+			ret = new StatementErrorExpression (ex);
+		} else {
+			ret = new AsNonAssignStatementExpression (ex);
+		}
+	} else {
+		ret = new StatementExpression (s);
+	}
+	return ret;
+}
+
+Expression MakeMonoSimdType(string typeName, Location loc)
+{
+	return new MemberAccess(new MemberAccess(new SimpleName("Mono", loc), "Simd", loc), typeName, loc);
+}
+
+LocalVariable GetOrCreateLocalVariable(Block block, string name, LocalVariable.Flags flags, FullNamedExpression typeExpr, Location loc)
+{
+	INamedBlockVariable existing = null;
+	LocalVariable li = null;
+
+	if (!parsing_playscript) {
+		if (block.ParametersBlock.TopBlock.GetLocalName (name, block, ref existing)) {
+			if (existing is LocalVariable) {
+				li = existing as LocalVariable;
+				if (li.TypeExpr != null && existing.TypeExpr != null && li.TypeExpr.Equals (existing.TypeExpr)) {
+					report.Warning (7138, 1, loc, "Variable is declared more than once.");
+					li.DeclFlags |= LocalVariable.Flags.AsIgnoreMultiple;
+					return li;
+				}
+			}
+		}
+	}
+	
+	li = new LocalVariable(block, name, flags, loc);
+	li.TypeExpr = typeExpr;
+
+	block.AddLocalName (li);
+	
+	return li;
+}
+
+string GetExpecting ()
+{
+	int [] tokens = yyExpectingTokens (yyExpectingState);
+	var names = new List<string> (tokens.Length);
+	bool has_type = false;
+	bool has_identifier = false;
+	for (int i = 0; i < tokens.Length; i++){
+		int token = tokens [i];
+		has_identifier |= token == Token.IDENTIFIER;
+		
+		string name = GetTokenName (token);
+		if (name == "<internal>")
+			continue;
+			
+		has_type |= name == "type";
+		if (names.Contains (name))
+			continue;
+		
+		names.Add (name);
+	}
+
+	//
+	// Too many tokens to enumerate
+	//
+	if (names.Count > 8)
+		return null;
+
+	if (has_type && has_identifier)
+		names.Remove ("identifier");
+
+	if (names.Count == 1)
+		return "`" + GetTokenName (tokens [0]) + "'";
+	
+	StringBuilder sb = new StringBuilder ();
+	names.Sort ();
+	int count = names.Count;
+	for (int i = 0; i < count; i++){
+		bool last = i + 1 == count;
+		if (last)
+			sb.Append ("or ");
+		sb.Append ('`');
+		sb.Append (names [i]);
+		sb.Append (last ? "'" : count < 3 ? "' " : "', ");
+	}
+	return sb.ToString ();
+}
+
+
+string GetSymbolName (int token)
+{
+	switch (token){
+	case Token.LITERAL:
+		return "Literal " + ((Constant)lexer.Value).GetValue ().ToString ();
+	case Token.IDENTIFIER:
+	case Token.IDENTIFIER_MODIFIER:
+	case Token.IDENTIFIER_CONFIG:
+		return "Identifier " + ((Tokenizer.LocatedToken)lexer.Value).Value ?? "";
+	case Token.BOOL:
+		return "bool";
+	case Token.BOOLEAN:
+		return "boolean";
+	case Token.BYTE:
+		return "byte";
+	case Token.CHAR:
+		return "char";
+	case Token.VOID:
+		return "void";
+	case Token.DECIMAL:
+		return "decimal";
+	case Token.DOUBLE:
+		return "double";
+	case Token.DOUBLE2:
+		return "double2";
+	case Token.DOUBLE3:
+		return "double3";
+	case Token.DOUBLE4:
+		return "double4";
+	case Token.DYNAMIC:
+		return "dynamic";
+	case Token.FLOAT:
+		return "float";
+	case Token.FLOAT2:
+		return "float2";
+	case Token.FLOAT3:
+		return "float3";
+	case Token.FLOAT4:
+		return "float4";
+	case Token.INT:
+		return "int";
+	case Token.LONG:
+		return "long";
+	case Token.SBYTE:
+		return "sbyte";
+	case Token.SHORT:
+		return "short";
+	case Token.STRING:
+		return "string";
+	case Token.UINT:
+		return "uint";
+	case Token.ULONG:
+		return "ulong";
+	case Token.USHORT:
+		return "ushort";
+	case Token.OBJECT:
+		return "object";
+		
+	case Token.PLUS:
+		return "+";
+	case Token.UMINUS:
+	case Token.MINUS:
+		return "-";
+	case Token.BANG:
+		return "!";
+	case Token.BITWISE_AND:
+		return "&";
+	case Token.BITWISE_OR:
+		return "|";
+	case Token.LOGICAL_AND_ASSIGN:
+		return "&&=";
+	case Token.LOGICAL_OR_ASSIGN:
+		return "||=";
+	case Token.STAR:
+		return "*";
+	case Token.PERCENT:
+		return "%";
+	case Token.DIV:
+		return "/";
+	case Token.CARRET:
+		return "^";
+	case Token.OP_INC:
+		return "++";
+	case Token.OP_DEC:
+		return "--";
+	case Token.OP_SHIFT_LEFT:
+		return "<<";
+	case Token.OP_SHIFT_RIGHT:
+		return ">>";
+	case Token.OP_USHIFT_RIGHT:
+		return ">>>";
+	case Token.OP_LT:
+		return "<";
+	case Token.OP_GT:
+		return ">";
+	case Token.OP_LE:
+		return "<=";
+	case Token.OP_GE:
+		return ">=";
+	case Token.OP_EQ:
+		return "==";
+	case Token.OP_REF_EQ:
+		return "===";
+	case Token.OP_NE:
+		return "!=";
+	case Token.OP_AND:
+		return "&&";
+	case Token.OP_OR:
+		return "||";
+	case Token.OP_PTR:
+		return "->";
+	case Token.OP_IN:
+		return "in";
+	case Token.OP_COALESCING:	
+		return "??";
+	case Token.OP_MULT_ASSIGN:
+		return "*=";
+	case Token.OP_DIV_ASSIGN:
+		return "/=";
+	case Token.OP_MOD_ASSIGN:
+		return "%=";
+	case Token.OP_ADD_ASSIGN:
+		return "+=";
+	case Token.OP_SUB_ASSIGN:
+		return "-=";
+	case Token.OP_SHIFT_LEFT_ASSIGN:
+		return "<<=";
+	case Token.OP_SHIFT_RIGHT_ASSIGN:
+		return ">>=";
+	case Token.OP_USHIFT_RIGHT_ASSIGN:
+		return ">>>=";
+	case Token.OP_AND_ASSIGN:
+		return "&=";
+	case Token.OP_XOR_ASSIGN:
+		return "^=";
+	case Token.OP_OR_ASSIGN:
+		return "|=";
+	}
+
+	return GetTokenName (token);
+}
+
+static string GetTokenName (int token)
+{
+	switch (token){
+	case Token.ABSTRACT:
+		return "abstract";
+	case Token.AS:
+		return "as";
+	case Token.ADD:
+		return "add";
+	case Token.ASYNC:
+		return "async";
+	case Token.SUPER:
+		return "super";
+	case Token.BREAK:
+		return "break";
+	case Token.CASE:
+		return "case";
+	case Token.CATCH:
+		return "catch";
+	case Token.CHECKED:
+		return "checked";
+	case Token.CLASS:
+		return "class";
+	case Token.CONST:
+		return "const";
+	case Token.CONTINUE:
+		return "continue";
+	case Token.DEFAULT:
+		return "default";
+	case Token.DELEGATE:
+		return "delegate";
+	case Token.DELETE:
+		return "delete";
+	case Token.DO:
+		return "do";
+	case Token.EACH:
+		return "each";
+	case Token.ELSE:
+		return "else";
+	case Token.ENUM:
+		return "enum";
+	case Token.EVENT:
+		return "event";
+	case Token.EXPLICIT:
+		return "explicit";
+	case Token.EXTENDS:
+		return "extends";
+	case Token.EXTERN:
+		return "extern";
+	case Token.FALSE:
+		return "false";
+	case Token.FINAL:
+		return "final";
+	case Token.FINALLY:
+		return "finally";
+	case Token.FIXED:
+		return "fixed";
+	case Token.FOR:
+		return "for";
+	case Token.FOR_EACH:
+		return "for each";
+	case Token.FUNCTION:
+		return "function";
+	case Token.FUNCTION_GET:
+		return "function get";
+	case Token.FUNCTION_SET:
+		return "function set";
+	case Token.GOTO:
+		return "goto";
+	case Token.IF:
+		return "if";
+	case Token.IMPLEMENTS:
+		return "implements";
+	case Token.IMPLICIT:
+		return "implicit";
+	case Token.IMPORT:
+		return "import";
+	case Token.IN:
+		return "in";
+	case Token.INDEXER:
+		return "indexer";
+	case Token.INSTANCEOF:
+		return "instanceof";
+	case Token.INTERFACE:
+		return "interface";
+	case Token.INTERNAL:
+		return "internal";
+	case Token.IS:
+		return "is";
+	case Token.LOCK:
+		return "lock";
+	case Token.NAMESPACE:
+		return "namespace";
+	case Token.NATIVE:
+		return "native";
+	case Token.NEW:
+		return "new";
+	case Token.NULL:
+		return "null";
+	case Token.OPERATOR:
+		return "operator";
+	case Token.OUT:
+		return "out";
+	case Token.OVERRIDE:
+		return "override";
+	case Token.OVERLOAD:
+		return "overload";
+	case Token.PARAMS:
+		return "params";
+	case Token.PRIVATE:
+		return "private";
+	case Token.PROPERTY:
+		return "property";
+	case Token.PROTECTED:
+		return "protected";
+	case Token.PUBLIC:
+		return "public";
+	case Token.READONLY:
+		return "readonly";
+	case Token.REF:
+		return "ref";
+	case Token.RETURN:
+		return "return";
+	case Token.REMOVE:
+		return "remove";
+	case Token.SIZEOF:
+		return "sizeof";
+	case Token.STACKALLOC:
+		return "stackalloc";
+	case Token.STATIC:
+		return "static";
+	case Token.STRUCT:
+		return "struct";
+	case Token.SWITCH:
+		return "switch";
+	case Token.THIS:
+		return "this";
+	case Token.THROW:
+		return "throw";
+	case Token.TRUE:
+		return "true";
+	case Token.TRY:
+		return "try";
+	case Token.TYPEOF:
+		return "typeof";
+	case Token.UNCHECKED:
+		return "unchecked";
+	case Token.UNDEFINED:
+		return "undefined";
+	case Token.UNSAFE:
+		return "unsafe";
+	case Token.USE:
+		return "use";
+	case Token.USING:
+		return "using";
+	case Token.VAR:
+		return "var";
+	case Token.VIRTUAL:
+		return "virtual";
+	case Token.VOLATILE:
+		return "volatile";
+	case Token.WHERE:
+		return "where";
+	case Token.WHILE:
+		return "while";
+//	case Token.ARGLIST:
+//		return "__arglist";
+//	case Token.REFVALUE:
+//		return "__refvalue";
+//	case Token.REFTYPE:
+//		return "__reftype";
+//	case Token.MAKEREF:
+//		return "__makeref";
+	case Token.PARTIAL:
+		return "partial";
+	case Token.ARROW:
+		return "=>";
+	case Token.FROM:
+	case Token.FROM_FIRST:
+		return "from";
+	case Token.JOIN:
+		return "join";
+	case Token.ON:
+		return "on";
+	case Token.EQUALS:
+		return "equals";
+	case Token.SELECT:
+		return "select";
+	case Token.GROUP:
+		return "group";
+	case Token.BY:
+		return "by";
+	case Token.LET:
+		return "let";
+	case Token.ORDERBY:
+		return "orderby";
+	case Token.ASCENDING:
+		return "ascending";
+	case Token.DESCENDING:
+		return "descending";
+	case Token.INTO:
+		return "into";
+	case Token.GET:
+		return "get";
+	case Token.SET:
+		return "set";
+	case Token.OPEN_BRACE:
+	case Token.OPEN_BRACE_INIT:
+		return "{";
+	case Token.CLOSE_BRACE:
+		return "}";
+	case Token.OPEN_BRACKET:
+	case Token.OPEN_BRACKET_EXPR:
+		return "[";
+	case Token.CLOSE_BRACKET:
+		return "]";
+	case Token.OPEN_PARENS_CAST:
+	case Token.OPEN_PARENS_LAMBDA:
+	case Token.OPEN_PARENS:
+		return "(";
+	case Token.CLOSE_PARENS:
+		return ")";
+	case Token.DOT:
+		return ".";
+	case Token.DOT_AT:
+		return ".@";
+	case Token.DOT_STAR:
+		return ".*";
+	case Token.DOTDOT:
+		return "..";
+	case Token.DOTDOT_AT:
+		return "..@";
+	case Token.DOTDOT_STAR:
+		return "..*";
+	case Token.DOTDOTDOT:
+		return "...";
+	case Token.COMMA:
+		return ",";
+	case Token.DEFAULT_COLON:
+		return "default:";
+	case Token.COLON:
+		return ":";
+	case Token.SEMICOLON:
+		return ";";
+	case Token.TILDE:
+		return "~";
+		
+	case Token.PLUS:
+	case Token.UMINUS:
+	case Token.MINUS:
+	case Token.BANG:
+	case Token.OP_LT:
+	case Token.OP_GT:
+	case Token.BITWISE_AND:
+	case Token.BITWISE_OR:
+	case Token.STAR:
+	case Token.PERCENT:
+	case Token.DIV:
+	case Token.CARRET:
+	case Token.OP_INC:
+	case Token.OP_DEC:
+	case Token.OP_SHIFT_LEFT:
+	case Token.OP_SHIFT_RIGHT:
+	case Token.OP_LE:
+	case Token.OP_GE:
+	case Token.OP_EQ:
+	case Token.OP_NE:
+	case Token.OP_AND:
+	case Token.OP_OR:
+	case Token.OP_PTR:
+	case Token.OP_COALESCING:	
+	case Token.OP_MULT_ASSIGN:
+	case Token.OP_DIV_ASSIGN:
+	case Token.OP_MOD_ASSIGN:
+	case Token.OP_ADD_ASSIGN:
+	case Token.OP_SUB_ASSIGN:
+	case Token.OP_SHIFT_LEFT_ASSIGN:
+	case Token.OP_SHIFT_RIGHT_ASSIGN:
+	case Token.OP_AND_ASSIGN:
+	case Token.OP_XOR_ASSIGN:
+	case Token.OP_OR_ASSIGN:
+	case Token.OP_AT:
+		return "<operator>";
+
+	case Token.BOOL:
+	case Token.BYTE:
+	case Token.CHAR:
+	case Token.VOID:
+	case Token.DECIMAL:
+	case Token.DOUBLE:
+	case Token.FLOAT:
+	case Token.INT:
+	case Token.LONG:
+	case Token.SBYTE:
+	case Token.SHORT:
+	case Token.STRING:
+	case Token.UINT:
+	case Token.ULONG:
+	case Token.USHORT:
+	case Token.OBJECT:
+		return "type";
+	
+	case Token.ASSIGN:
+		return "=";
+	case Token.OP_GENERICS_LT:
+	case Token.GENERIC_DIMENSION:
+		return ".<";
+	case Token.OP_GENERICS_GT:
+		return ">";
+	case Token.INTERR:
+	case Token.INTERR_NULLABLE:
+		return "?";
+	case Token.DOUBLE_COLON:
+		return "::";
+	case Token.LITERAL:
+		return "value";
+	case Token.IDENTIFIER:
+	case Token.AWAIT:
+		return "identifier";
+
+	case Token.EOF:
+		return "end-of-file";
+
+		// All of these are internal.
+	case Token.NONE:
+	case Token.ERROR:
+	case Token.FIRST_KEYWORD:
+	case Token.EVAL_COMPILATION_UNIT_PARSER:
+	case Token.EVAL_USING_DECLARATIONS_UNIT_PARSER:
+	case Token.EVAL_STATEMENT_PARSER:
+	case Token.LAST_KEYWORD:
+	case Token.GENERATE_COMPLETION:
+	case Token.COMPLETE_COMPLETION:
+		return "<internal>";
+
+		// A bit more robust.
+	default:
+		return yyNames [token];
+        }
+}
+
+/* end end end */
+}
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/ps-tokenizer.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/ps-tokenizer.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/ps-tokenizer.cs	1969-12-31 16:00:00.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/ps-tokenizer.cs	2013-04-23 21:04:54.000000000 -0700
@@ -0,0 +1,4490 @@
+//
+// cs-tokenizer.cs: The Tokenizer for the PlayScript compiler
+//                  This also implements the preprocessor
+//
+// Author: Miguel de Icaza (miguel@gnu.org)
+//         Marek Safar (marek.safar@gmail.com)
+//         Ben Cooley (bcooley@zynga.com)
+//
+// Dual licensed under the terms of the MIT X11 or GNU GPL
+//
+// Copyright 2001, 2002 Ximian, Inc (http://www.ximian.com)
+// Copyright 2004-2008 Novell, Inc
+// Copyright 2011 Xamarin, Inc (http://www.xamarin.com)
+//
+
+using System;
+using System.Text;
+using System.Collections.Generic;
+using System.Globalization;
+using System.Diagnostics;
+using System.Collections;
+using Mono.CSharpPs;
+
+namespace Mono.PlayScript
+{
+	/// <summary>
+	///    Tokenizer for C# source code. 
+	/// </summary>
+
+	public class Tokenizer : yyParser.yyInput
+	{
+		class KeywordEntry<T>
+		{
+			public readonly T Token;
+			public KeywordEntry<T> Next;
+			public readonly char[] Value;
+
+			public KeywordEntry (string value, T token)
+			{
+				this.Value = value.ToCharArray ();
+				this.Token = token;
+			}
+		}
+
+		sealed class IdentifiersComparer : IEqualityComparer<char[]>
+		{
+			readonly int length;
+
+			public IdentifiersComparer (int length)
+			{
+				this.length = length;
+			}
+
+			public bool Equals (char[] x, char[] y)
+			{
+				for (int i = 0; i < length; ++i)
+					if (x [i] != y [i])
+						return false;
+
+				return true;
+			}
+
+			public int GetHashCode (char[] obj)
+			{
+				int h = 0;
+				for (int i = 0; i < length; ++i)
+					h = (h << 5) - h + obj [i];
+
+				return h;
+			}
+		}
+
+		//
+		// This class has to be used by parser only, it reuses token
+		// details after each file parse completion
+		//
+		public class LocatedToken
+		{
+			public int row, column;
+			public string value;
+			public SourceFile file;
+
+			public LocatedToken ()
+			{
+			}
+
+			public LocatedToken (string value, Location loc)
+			{
+				this.value = value;
+				file = loc.SourceFile;
+				row = loc.Row;
+				column = loc.Column;
+			}
+
+			public override string ToString ()
+			{
+				return string.Format ("Token '{0}' at {1},{2}", Value, row, column);
+			}
+			
+			public Location Location {
+				get { return new Location (file, row, column); }
+			}
+
+			public string Value {
+				get { return value; }
+			}
+		}
+
+		public class LocatedTokenBuffer
+		{
+			readonly LocatedToken[] buffer;
+			public int pos;
+
+			public LocatedTokenBuffer ()
+			{
+				buffer = new LocatedToken[0];
+			}
+
+			public LocatedTokenBuffer (LocatedToken[] buffer)
+			{
+				this.buffer = buffer ?? new LocatedToken[0];
+			}
+
+			public LocatedToken Create (SourceFile file, int row, int column)
+			{
+				return Create (null, file, row, column);
+			}
+			
+			public LocatedToken Create (string value, SourceFile file, int row, int column)
+			{
+				//
+				// TODO: I am not very happy about the logic but it's the best
+				// what I could come up with for now.
+				// Ideally we should be using just tiny buffer (256 elements) which
+				// is enough to hold all details for currect stack and recycle elements
+				// poped from the stack but there is a trick needed to recycle
+				// them properly.
+				//
+				LocatedToken entry;
+				if (pos >= buffer.Length) {
+					entry = new LocatedToken ();
+				} else {
+					entry = buffer [pos];
+					if (entry == null) {
+						entry = new LocatedToken ();
+						buffer [pos] = entry;
+					}
+
+					++pos;
+				}
+				entry.value = value;
+				entry.file = file;
+				entry.row = row;
+				entry.column = column;
+				return entry;
+			}
+
+			//
+			// Used for token not required by expression evaluator
+			//
+			[Conditional ("FULL_AST")]
+			public void CreateOptional (SourceFile file, int row, int col, ref object token)
+			{
+				token = Create (file, row, col);
+			}
+		}
+
+		public enum PreprocessorDirective
+		{
+			Invalid = 0,
+
+			Region = 1,
+			Endregion = 2,
+			If = 3 | RequiresArgument,
+			Endif = 4,
+			Elif = 5 | RequiresArgument,
+			Else = 6,
+			Define = 7 | RequiresArgument,
+			Undef = 8 | RequiresArgument,
+			Error = 9,
+			Warning = 10,
+			Pragma = 11 | CustomArgumentsParsing,
+			Line = 12 | CustomArgumentsParsing,
+
+			CustomArgumentsParsing = 1 << 10,
+			RequiresArgument = 1 << 11
+		}
+
+		readonly SeekableStreamReader reader;
+		readonly CompilationSourceFile source_file;
+		public CompilationSourceFile SourceFile { get { return source_file; } }
+		readonly CompilerContext context;
+
+		SourceFile current_source;
+		Location hidden_block_start;
+		int ref_line = 1;
+		int line = 1;
+		int col = 0;
+		int previous_col;
+		int prev_token;
+		int prev_token_line;
+		int current_token;
+		int current_token_line;
+		int putback_token = -1;
+		int parse_regex_xml = 0;
+		int parse_colon = 0;
+		bool allow_auto_semi = true;
+		int allow_auto_semi_after = 0;
+		bool has_temp_auto_semi_after_tokens = false;
+		List<int> temp_auto_semi_after_tokens = new List<int>();
+		readonly int tab_size;
+		bool parsing_playscript = false;
+		bool handle_namespace = true;
+		bool handle_get_set = false;
+		bool handle_dynamic = true;
+		bool handle_each = false;
+		bool handle_remove_add = false;
+		bool handle_where = false;
+		bool handle_typeof = false;
+		bool handle_for_in = false;
+		bool lambda_arguments_parsing;
+		List<Location> escaped_identifiers;
+		int parsing_generic_less_than;
+		readonly bool doc_processing;
+		readonly LocatedTokenBuffer ltb;
+
+		private static BitArray allowed_auto_semi_tokens = new BitArray(750, false);  
+		private static BitArray disallowed_next_auto_semi_tokens = new BitArray(750, false);  
+
+		//
+		// Used mainly for parser optimizations. Some expressions for instance
+		// can appear only in block (including initializer, base initializer)
+		// scope only
+		//
+		public int parsing_block;
+		internal bool query_parsing;
+		
+		// 
+		// When parsing type only, useful for ambiguous nullable types
+		//
+		public int parsing_type;
+		
+		//
+		// Set when parsing generic declaration (type or method header)
+		//
+		public bool parsing_generic_declaration;
+		public bool parsing_generic_declaration_doc;
+		
+		//
+		// The value indicates that we have not reach any declaration or
+		// namespace yet
+		//
+		public int parsing_declaration;
+
+		public bool parsing_attribute_section;
+
+		public bool parsing_modifiers;
+
+		//
+		// The special characters to inject on streams to run the unit parser
+		// in the special expression mode. Using private characters from
+		// Plane Sixteen (U+100000 to U+10FFFD)
+		//
+		// This character is only tested just before the tokenizer is about to report
+		// an error;   So on the regular operation mode, this addition will have no
+		// impact on the tokenizer's performance.
+		//
+		
+		public const int EvalStatementParserCharacter = 0x100000;
+		public const int EvalCompilationUnitParserCharacter = 0x100001;
+		public const int EvalUsingDeclarationsParserCharacter = 0x100002;
+		public const int DocumentationXref = 0x100003;
+		
+		//
+		// XML documentation buffer. The save point is used to divide
+		// comments on types and comments on members.
+		//
+		StringBuilder xml_comment_buffer;
+
+		//
+		// See comment on XmlCommentState enumeration.
+		//
+		XmlCommentState xml_doc_state = XmlCommentState.Allowed;
+
+		//
+		// Whether tokens have been seen on this line
+		//
+		bool tokens_seen = false;
+
+		//
+		// Set to true once the GENERATE_COMPLETION token has bee
+		// returned.   This helps produce one GENERATE_COMPLETION,
+		// as many COMPLETE_COMPLETION as necessary to complete the
+		// AST tree and one final EOF.
+		//
+		bool generated;
+		
+		//
+		// Whether a token has been seen on the file
+		// This is needed because `define' is not allowed to be used
+		// after a token has been seen.
+		//
+		bool any_token_seen;
+
+		//
+		// Class variables
+		// 
+		static readonly KeywordEntry<int>[][] keywords;
+		static readonly KeywordEntry<PreprocessorDirective>[][] keywords_preprocessor;
+		static readonly HashSet<string> keyword_strings;
+		static readonly NumberStyles styles;
+		static readonly NumberFormatInfo csharp_format_info;
+
+		// Pragma arguments
+		static readonly char[] pragma_warning = "warning".ToCharArray ();
+		static readonly char[] pragma_warning_disable = "disable".ToCharArray ();
+		static readonly char[] pragma_warning_restore = "restore".ToCharArray ();
+		static readonly char[] pragma_checksum = "checksum".ToCharArray ();
+		static readonly char[] line_hidden = "hidden".ToCharArray ();
+		static readonly char[] line_default = "default".ToCharArray ();
+
+		static readonly char[] simple_whitespaces = new char[] { ' ', '\t' };
+		bool startsLine = true;
+		internal SpecialsBag sbag;
+
+		public bool ParsingPlayScript {
+			get { return parsing_playscript; }
+			set { parsing_playscript = value; }
+		}
+
+		public bool NamespaceParsing {
+			get { return handle_namespace; }
+			set { handle_namespace = value; }
+		}
+
+		public bool PropertyParsing {
+			get { return handle_get_set; }
+			set { handle_get_set = value; }
+		}
+
+		public bool EventParsing {
+			get { return handle_remove_add; }
+			set { handle_remove_add = value; }
+		}
+
+		public bool ConstraintsParsing {
+			get { return handle_where; }
+			set { handle_where = value; }
+		}
+
+		public bool TypeOfParsing {
+			get { return handle_typeof; }
+			set { handle_typeof = value; }
+		}
+
+		public bool ForInParsing {
+			get { return handle_for_in; }
+			set { handle_for_in = value; }
+		}
+
+		public bool DynamicParsing {
+			get { return handle_dynamic; }
+			set { handle_dynamic = value; }
+		}
+
+		public bool AutoSemiInsertion {
+			get { return allow_auto_semi; }
+			set { 
+				allow_auto_semi = value; 
+				allow_auto_semi_after = 0; 
+			}
+		}
+
+		public int AutoSemiInsertionAfter 
+		{
+			get { return allow_auto_semi_after; }
+			set { 
+				allow_auto_semi = true;
+				allow_auto_semi_after = value + 1;
+			}
+		}
+
+		public void AllowAutoSemiAfterToken (int token, bool allow)
+		{
+			allowed_auto_semi_tokens.Set (token, allow);
+			if (true) {
+				has_temp_auto_semi_after_tokens = true;
+				temp_auto_semi_after_tokens.Add (token);
+			}
+		}
+
+		public bool RegexXmlParsing {
+			get { return parse_regex_xml > 0; }
+		}
+
+		public XmlCommentState doc_state {
+			get { return xml_doc_state; }
+			set {
+				if (value == XmlCommentState.Allowed) {
+					check_incorrect_doc_comment ();
+					reset_doc_comment ();
+				}
+				xml_doc_state = value;
+			}
+		}
+
+		//
+		// This is used to trigger completion generation on the parser
+		public bool CompleteOnEOF;
+		
+		void AddEscapedIdentifier (Location loc)
+		{
+			if (escaped_identifiers == null)
+				escaped_identifiers = new List<Location> ();
+
+			escaped_identifiers.Add (loc);
+		}
+
+		public bool IsEscapedIdentifier (ATypeNameExpression name)
+		{
+			return escaped_identifiers != null && escaped_identifiers.Contains (name.Location);
+		}
+
+		//
+		// Values for the associated token returned
+		//
+		internal int putback_char; 	// Used by repl only
+		object val;
+
+		//
+		// Pre-processor
+		//
+		const int TAKING        = 1;
+		const int ELSE_SEEN     = 4;
+		const int PARENT_TAKING = 8;
+		const int REGION        = 16;		
+
+		//
+		// pre-processor if stack state:
+		//
+		Stack<int> ifstack;
+
+		public const int MaxIdentifierLength = 512;
+		public const int MaxNumberLength = 512;
+
+		readonly char[] id_builder;
+		readonly Dictionary<char[], string>[] identifiers;
+		readonly char[] number_builder;
+		int number_pos;
+
+		char[] value_builder = new char[64];
+
+		public int Line {
+			get {
+				return ref_line;
+			}
+			set {
+				ref_line = value;
+			}
+		}
+
+		public int Column {
+			get {
+				return col;
+			}
+			set {
+				col = value;
+			}
+		}
+
+		//
+		// This is used when the tokenizer needs to save
+		// the current position as it needs to do some parsing
+		// on its own to deamiguate a token in behalf of the
+		// parser.
+		//
+		Stack<Position> position_stack = new Stack<Position> (2);
+
+		class Position {
+			public int position;
+			public int line;
+			public int ref_line;
+			public int col;
+			public Location hidden;
+			public int putback_char;
+			public int previous_col;
+			public Stack<int> ifstack;
+			public int parsing_generic_less_than;
+			public int parse_regex_xml;
+			public int parse_colon;
+			public bool allow_auto_semi;
+			public int allow_auto_semi_after;
+			public object val;
+			public int prev_token;
+			public int prev_token_line;
+			public int current_token;
+			public int current_token_line;
+			public int putback_token;
+
+			public Position (Tokenizer t)
+			{
+				position = t.reader.Position;
+				line = t.line;
+				ref_line = t.ref_line;
+				col = t.col;
+				hidden = t.hidden_block_start;
+				putback_char = t.putback_char;
+				previous_col = t.previous_col;
+				if (t.ifstack != null && t.ifstack.Count != 0) {
+					// There is no simple way to clone Stack<T> all
+					// methods reverse the order
+					var clone = t.ifstack.ToArray ();
+					Array.Reverse (clone);
+					ifstack = new Stack<int> (clone);
+				}
+				parsing_generic_less_than = t.parsing_generic_less_than;
+				parse_regex_xml = t.parse_regex_xml;
+				parse_colon = t.parse_colon;
+				allow_auto_semi = t.allow_auto_semi;
+				allow_auto_semi_after = t.allow_auto_semi_after;
+				prev_token = t.prev_token;
+				prev_token_line = t.prev_token_line;
+				current_token = t.current_token;
+				current_token_line = t.current_token_line;
+				putback_token = t.putback_token;
+				val = t.val;
+			}
+		}
+
+		public Tokenizer (SeekableStreamReader input, CompilationSourceFile file, ParserSession session)
+		{
+			this.source_file = file;
+			this.parsing_playscript = file.SourceFile.PsExtended;
+			this.context = file.Compiler;
+			this.current_source = file.SourceFile;
+			this.identifiers = session.Identifiers;
+			this.id_builder = session.IDBuilder;
+			this.number_builder = session.NumberBuilder;
+			this.ltb = new LocatedTokenBuffer (session.AsLocatedTokens);
+
+			reader = input;
+
+			putback_char = -1;
+
+			xml_comment_buffer = new StringBuilder ();
+			doc_processing = context.Settings.DocumentationFile != null;
+
+			tab_size = context.Settings.TabSize;
+		}
+		
+		public void PushPosition ()
+		{
+			position_stack.Push (new Position (this));
+		}
+
+		public void PopPosition ()
+		{
+			Position p = position_stack.Pop ();
+
+			reader.Position = p.position;
+			ref_line = p.ref_line;
+			line = p.line;
+			col = p.col;
+			hidden_block_start = p.hidden;
+			putback_char = p.putback_char;
+			previous_col = p.previous_col;
+			ifstack = p.ifstack;
+			parsing_generic_less_than = p.parsing_generic_less_than;
+			parse_regex_xml = p.parse_regex_xml;
+			parse_colon = p.parse_colon;
+			prev_token = p.prev_token;
+			prev_token_line = p.prev_token_line;
+			allow_auto_semi = p.allow_auto_semi;
+			allow_auto_semi_after = p.allow_auto_semi_after;
+			current_token = p.current_token;
+			current_token_line = p.current_token_line;
+			putback_token = p.putback_token;
+			val = p.val;
+		}
+
+		// Do not reset the position, ignore it.
+		public void DiscardPosition ()
+		{
+			position_stack.Pop ();
+		}
+		
+		static void AddKeyword (string kw, int token)
+		{
+			keyword_strings.Add (kw);
+
+			AddKeyword (keywords, kw, token);
+		}
+
+		static void AddPreprocessorKeyword (string kw, PreprocessorDirective directive)
+		{
+			AddKeyword (keywords_preprocessor, kw, directive);
+		}
+
+		static void AddKeyword<T> (KeywordEntry<T>[][] keywords, string kw, T token)
+		{
+			int length = kw.Length;
+			if (keywords[length] == null) {
+				keywords[length] = new KeywordEntry<T>['z' - '_' + 1];
+			}
+
+			int char_index = kw[0] - '_';
+			var kwe = keywords[length][char_index];
+			if (kwe == null) {
+				keywords[length][char_index] = new KeywordEntry<T> (kw, token);
+				return;
+			}
+
+			while (kwe.Next != null) {
+				kwe = kwe.Next;
+			}
+
+			kwe.Next = new KeywordEntry<T> (kw, token);
+		}
+
+		static void AddAllowedAutoSemiTokens(int[] tokens) {
+			var len = tokens.Length;
+			for (var i = 0; i < len; i++) {
+				allowed_auto_semi_tokens.Set (tokens[i], true);
+			}
+		}
+
+		static void AddDisallowedNextAutoSemiTokens(int[] tokens) {
+			var len = tokens.Length;
+			for (var i = 0; i < len; i++) {
+				disallowed_next_auto_semi_tokens.Set (tokens[i], true);
+			}
+		}
+
+		//
+		// Class initializer
+		// 
+		static Tokenizer ()
+		{
+			keyword_strings = new HashSet<string> ();
+
+			// 13 is the length of the longest keyword for now
+			keywords = new KeywordEntry<int>[13][];
+
+			AddKeyword ("abstract", Token.ABSTRACT);
+			AddKeyword ("as", Token.AS);
+			AddKeyword ("add", Token.ADD);
+			AddKeyword ("bool", Token.BOOL);
+			AddKeyword ("boolean", Token.BOOLEAN);
+			AddKeyword ("break", Token.BREAK);
+			AddKeyword ("byte", Token.BYTE);
+			AddKeyword ("case", Token.CASE);
+			AddKeyword ("catch", Token.CATCH);
+			AddKeyword ("char", Token.CHAR);
+			AddKeyword ("checked", Token.CHECKED);
+			AddKeyword ("class", Token.CLASS);
+			AddKeyword ("const", Token.CONST);
+			AddKeyword ("continue", Token.CONTINUE);
+			AddKeyword ("decimal", Token.DECIMAL);
+			AddKeyword ("default", Token.DEFAULT);
+			AddKeyword ("delegate", Token.DELEGATE);
+			AddKeyword ("delete", Token.DELETE);
+			AddKeyword ("do", Token.DO);
+			AddKeyword ("double", Token.DOUBLE);
+			AddKeyword ("double2", Token.DOUBLE2);
+			AddKeyword ("double3", Token.DOUBLE3);
+			AddKeyword ("double4", Token.DOUBLE4);
+			AddKeyword ("dynamic", Token.DYNAMIC);
+			AddKeyword ("each", Token.EACH);
+			AddKeyword ("else", Token.ELSE);
+			AddKeyword ("enum", Token.ENUM);
+			AddKeyword ("event", Token.EVENT);
+			AddKeyword ("explicit", Token.EXPLICIT);
+			AddKeyword ("extends", Token.EXTENDS);
+			AddKeyword ("extern", Token.EXTERN);
+			AddKeyword ("false", Token.FALSE);
+			AddKeyword ("final", Token.FINAL);
+			AddKeyword ("finally", Token.FINALLY);
+			AddKeyword ("fixed", Token.FIXED);
+			AddKeyword ("float", Token.FLOAT);
+			AddKeyword ("float2", Token.FLOAT2);
+			AddKeyword ("float3", Token.FLOAT3);
+			AddKeyword ("float4", Token.FLOAT4);
+			AddKeyword ("for", Token.FOR);
+			AddKeyword ("function", Token.FUNCTION);
+			AddKeyword ("goto", Token.GOTO);
+			AddKeyword ("get", Token.GET);
+			AddKeyword ("if", Token.IF);
+			AddKeyword ("implements", Token.IMPLEMENTS);
+			AddKeyword ("implicit", Token.IMPLICIT);
+			AddKeyword ("import", Token.IMPORT);
+			AddKeyword ("in", Token.IN);
+			AddKeyword ("indexer", Token.INDEXER);
+			AddKeyword ("instanceof", Token.INSTANCEOF);
+			AddKeyword ("int", Token.INT);
+			AddKeyword ("interface", Token.INTERFACE);
+			AddKeyword ("internal", Token.INTERNAL);
+			AddKeyword ("is", Token.IS);
+			AddKeyword ("lock", Token.LOCK);
+			AddKeyword ("long", Token.LONG);
+			AddKeyword ("namespace", Token.NAMESPACE);
+			AddKeyword ("native", Token.NATIVE);
+			AddKeyword ("new", Token.NEW);
+			AddKeyword ("null", Token.NULL);
+			AddKeyword ("object", Token.OBJECT);
+			AddKeyword ("operator", Token.OPERATOR);
+			AddKeyword ("out", Token.OUT);
+			AddKeyword ("override", Token.OVERRIDE);
+			AddKeyword ("overload", Token.OVERLOAD);
+			AddKeyword ("package", Token.PACKAGE);
+			AddKeyword ("params", Token.PARAMS);
+			AddKeyword ("property", Token.PROPERTY);
+			AddKeyword ("private", Token.PRIVATE);
+			AddKeyword ("protected", Token.PROTECTED);
+			AddKeyword ("public", Token.PUBLIC);
+			AddKeyword ("readonly", Token.READONLY);
+			AddKeyword ("ref", Token.REF);
+			AddKeyword ("remove", Token.REMOVE);
+			AddKeyword ("return", Token.RETURN);
+			AddKeyword ("sbyte", Token.SBYTE);
+			AddKeyword ("set", Token.SET);
+			AddKeyword ("short", Token.SHORT);
+			AddKeyword ("sizeof", Token.SIZEOF);
+			AddKeyword ("stackalloc", Token.STACKALLOC);
+			AddKeyword ("static", Token.STATIC);
+			AddKeyword ("string", Token.STRING);
+			AddKeyword ("struct", Token.STRUCT);
+			AddKeyword ("super", Token.SUPER);
+			AddKeyword ("switch", Token.SWITCH);
+			AddKeyword ("this", Token.THIS);
+			AddKeyword ("throw", Token.THROW);
+			AddKeyword ("true", Token.TRUE);
+			AddKeyword ("try", Token.TRY);
+			AddKeyword ("typeof", Token.TYPEOF);
+			AddKeyword ("uint", Token.UINT);
+			AddKeyword ("ulong", Token.ULONG);
+			AddKeyword ("unchecked", Token.UNCHECKED);
+			AddKeyword ("undefined", Token.UNDEFINED);
+			AddKeyword ("unsafe", Token.UNSAFE);
+			AddKeyword ("use", Token.USE);
+			AddKeyword ("ushort", Token.USHORT);
+			AddKeyword ("using", Token.USING);
+			AddKeyword ("var", Token.VAR);
+			AddKeyword ("virtual", Token.VIRTUAL);
+			AddKeyword ("void", Token.VOID);
+			AddKeyword ("volatile", Token.VOLATILE);
+			AddKeyword ("while", Token.WHILE);
+			AddKeyword ("partial", Token.PARTIAL);
+			AddKeyword ("where", Token.WHERE);
+
+			// LINQ keywords
+			AddKeyword ("from", Token.FROM);
+			AddKeyword ("join", Token.JOIN);
+			AddKeyword ("on", Token.ON);
+			AddKeyword ("equals", Token.EQUALS);
+			AddKeyword ("select", Token.SELECT);
+			AddKeyword ("group", Token.GROUP);
+			AddKeyword ("by", Token.BY);
+			AddKeyword ("let", Token.LET);
+			AddKeyword ("orderby", Token.ORDERBY);
+			AddKeyword ("ascending", Token.ASCENDING);
+			AddKeyword ("descending", Token.DESCENDING);
+			AddKeyword ("into", Token.INTO);
+
+			// Contextual async keywords
+			AddKeyword ("async", Token.ASYNC);
+			AddKeyword ("await", Token.AWAIT);
+
+			keywords_preprocessor = new KeywordEntry<PreprocessorDirective>[10][];
+
+			AddPreprocessorKeyword ("region", PreprocessorDirective.Region);
+			AddPreprocessorKeyword ("endregion", PreprocessorDirective.Endregion);
+			AddPreprocessorKeyword ("if", PreprocessorDirective.If);
+			AddPreprocessorKeyword ("endif", PreprocessorDirective.Endif);
+			AddPreprocessorKeyword ("elif", PreprocessorDirective.Elif);
+			AddPreprocessorKeyword ("else", PreprocessorDirective.Else);
+			AddPreprocessorKeyword ("define", PreprocessorDirective.Define);
+			AddPreprocessorKeyword ("undef", PreprocessorDirective.Undef);
+			AddPreprocessorKeyword ("error", PreprocessorDirective.Error);
+			AddPreprocessorKeyword ("warning", PreprocessorDirective.Warning);
+			AddPreprocessorKeyword ("pragma", PreprocessorDirective.Pragma);
+			AddPreprocessorKeyword ("line", PreprocessorDirective.Line);
+
+			// Semicolons will be auto-inserted after these tokens by default (unless manually disabled by the parser).
+			AddAllowedAutoSemiTokens(new int [] {
+				Token.CLOSE_BRACKET,
+				Token.CLOSE_PARENS,
+				Token.IDENTIFIER,
+				Token.LITERAL,
+				Token.OP_INC,
+				Token.OP_DEC,
+				Token.TRUE,
+				Token.FALSE,
+				Token.UNDEFINED,
+				Token.NULL,
+				Token.CHAR,
+				Token.INT,
+				Token.UINT,
+				Token.OBJECT,
+				Token.DECIMAL,
+				Token.BYTE,
+				Token.SBYTE,
+				Token.LONG,
+				Token.ULONG,
+				Token.VOID,
+				Token.DOUBLE,
+				Token.DOUBLE2,
+				Token.DOUBLE3,
+				Token.DOUBLE4,
+				Token.FLOAT,
+				Token.FLOAT2,
+				Token.FLOAT3,
+				Token.FLOAT4,
+				Token.STRING,
+				Token.BOOL,
+				Token.BOOLEAN,
+				Token.SHORT,
+				Token.USHORT,
+				Token.BREAK,
+				Token.CONTINUE,
+				Token.RETURN,
+				Token.STAR
+			});
+
+			AddDisallowedNextAutoSemiTokens(new int [] {
+				Token.ADD,
+				Token.MINUS,
+				Token.DIV,
+				Token.PERCENT,
+				Token.STAR,
+				Token.DOT,
+				Token.DOT_AT,
+				Token.DOT_STAR,
+				Token.DOTDOT,
+				Token.DOTDOT_AT,
+				Token.DOTDOT_STAR,
+				Token.OP_SHIFT_LEFT,
+				Token.OP_SHIFT_RIGHT,
+				Token.OP_USHIFT_RIGHT,
+				Token.LOGICAL_AND_ASSIGN,
+				Token.LOGICAL_OR_ASSIGN,
+				Token.CLOSE_BRACKET,
+				Token.CLOSE_PARENS,
+				Token.OP_ADD_ASSIGN,
+				Token.OP_AT,
+				Token.OP_IN,
+				Token.AS,
+				Token.IN,
+				Token.ARROW,
+				Token.ASSIGN,
+				Token.COLON,
+				Token.COMMA,
+				Token.OP_ADD_ASSIGN,
+				Token.OP_SUB_ASSIGN,
+				Token.OP_MOD_ASSIGN,
+				Token.OP_MULT_ASSIGN,
+				Token.OP_DIV_ASSIGN,
+				Token.OP_COALESCING,
+				Token.OP_AND_ASSIGN,
+				Token.OP_OR_ASSIGN,
+				Token.OP_XOR_ASSIGN,
+				Token.OP_SHIFT_LEFT_ASSIGN,
+				Token.OP_SHIFT_RIGHT_ASSIGN,
+				Token.OP_USHIFT_RIGHT_ASSIGN,
+				Token.OP_EQ,
+				Token.OP_NE,
+				Token.OP_REF_EQ,
+				Token.OP_REF_NE,
+				Token.OP_LT,
+				Token.OP_GT,
+				Token.OP_GE,
+				Token.OP_LE,
+				Token.OP_AND,
+				Token.OP_OR,
+				Token.BITWISE_AND,
+				Token.BITWISE_OR,
+				Token.CARRET,
+				Token.INTERR,
+
+			});
+
+			csharp_format_info = NumberFormatInfo.InvariantInfo;
+			styles = NumberStyles.Float;
+		}
+
+		int GetKeyword (char[] id, int id_len)
+		{
+			//
+			// Keywords are stored in an array of arrays grouped by their
+			// length and then by the first character
+			//
+			if (id_len >= keywords.Length || keywords [id_len] == null)
+				return -1;
+
+			int first_index = id [0] - '_';
+			if (first_index > 'z' - '_')
+				return -1;
+
+			var kwe = keywords [id_len] [first_index];
+			if (kwe == null)
+				return -1;
+
+			int res;
+			do {
+				res = kwe.Token;
+				for (int i = 1; i < id_len; ++i) {
+					if (id [i] != kwe.Value [i]) {
+						res = 0;
+						kwe = kwe.Next;
+						break;
+					}
+				}
+			} while (res == 0 && kwe != null);
+
+			if (res == 0)
+				return -1;
+
+			int next_token;
+			switch (res) {
+			case Token.FOR:
+				this.handle_each = true;
+				next_token = peek_token ();
+				if (next_token == Token.EACH) {
+					token ();
+					res = Token.FOR_EACH;
+				}
+				this.handle_each = false;
+				break;
+			case Token.FUNCTION:
+				parsing_modifiers = false;
+				allow_auto_semi = false;
+				allow_auto_semi_after = 0;
+				bool is_get_set = false;
+				PushPosition();
+				var fn_token = token ();
+				if (fn_token == Token.IDENTIFIER)
+				{
+					var get_set = (string)((LocatedToken)val).Value;
+					if (get_set == "get" || get_set == "set") {
+						fn_token = token ();
+						if (fn_token == Token.IDENTIFIER) {
+							res = (get_set == "get") ? Token.FUNCTION_GET : Token.FUNCTION_SET;
+						}
+					}
+				}
+				PopPosition ();
+				if (res != Token.FUNCTION) 
+					token ();
+				break;
+			case Token.GET:
+			case Token.SET:
+				if (!handle_get_set)
+					res = -1;
+				break;
+			case Token.IF:
+			case Token.WHILE:
+			case Token.DO:
+			case Token.TRY:
+			case Token.CATCH:
+			case Token.SWITCH:
+			case Token.CASE:
+				allow_auto_semi = false;
+				allow_auto_semi_after = 0;
+				break;
+			case Token.DYNAMIC:
+				if (!handle_dynamic)
+					res = -1;
+				break;
+			case Token.EACH:
+				if (!handle_each)
+					res = -1;
+				break;
+			case Token.REMOVE:
+			case Token.ADD:
+				if (!handle_remove_add || !parsing_playscript)
+					res = -1;
+				break;
+			case Token.EXTERN:
+				if (parsing_declaration != 0 || !parsing_playscript)
+					res = -1;
+				break;
+			case Token.DEFAULT:
+				if (peek_token () == Token.COLON) {
+					token ();
+					res = Token.DEFAULT_COLON;
+				}
+				break;
+			case Token.WHERE:
+				if (!handle_where && !query_parsing || !parsing_playscript)
+					res = -1;
+				break;
+			case Token.FROM:
+				//
+				// A query expression is any expression that starts with `from identifier'
+				// followed by any token except ; , =
+				// 
+				if (!parsing_playscript) {
+					res = -1;
+				} else if (!query_parsing) {
+					if (lambda_arguments_parsing) {
+						res = -1;
+						break;
+					}
+
+					PushPosition ();
+					// HACK: to disable generics micro-parser, because PushPosition does not
+					// store identifiers array
+					parsing_generic_less_than = 1;
+					switch (xtoken ()) {
+					case Token.IDENTIFIER:
+					case Token.INT:
+					case Token.BOOL:
+					case Token.BYTE:
+					case Token.CHAR:
+					case Token.DECIMAL:
+					case Token.FLOAT:
+					case Token.LONG:
+					case Token.OBJECT:
+					case Token.STRING:
+					case Token.UINT:
+					case Token.ULONG:
+						next_token = xtoken ();
+						if (next_token == Token.SEMICOLON || next_token == Token.COMMA || next_token == Token.EQUALS)
+							goto default;
+						
+						res = Token.FROM_FIRST;
+						query_parsing = true;
+						if (context.Settings.Version <= LanguageVersion.ISO_2)
+							Report.FeatureIsNotAvailable (context, Location, "query expressions");
+						break;
+					case Token.VOID:
+						Expression.Error_VoidInvalidInTheContext (Location, Report);
+						break;
+					default:
+						PopPosition ();
+						// HACK: A token is not a keyword so we need to restore identifiers buffer
+						// which has been overwritten before we grabbed the identifier
+						id_builder [0] = 'f'; id_builder [1] = 'r'; id_builder [2] = 'o'; id_builder [3] = 'm';
+						return -1;
+					}
+					PopPosition ();
+				}
+				break;
+			case Token.JOIN:
+			case Token.ON:
+			case Token.EQUALS:
+			case Token.SELECT:
+			case Token.GROUP:
+			case Token.BY:
+			case Token.LET:
+			case Token.ORDERBY:
+			case Token.ASCENDING:
+			case Token.DESCENDING:
+			case Token.INTO:
+				if (!query_parsing || !parsing_playscript)
+					res = -1;
+				break;
+
+			case Token.IN:
+				if (!handle_for_in)
+					res = Token.OP_IN;
+				break;
+
+			case Token.USE:
+				handle_namespace = true;
+				break;
+			case Token.USING:
+				// TODO: some explanation needed
+				check_incorrect_doc_comment ();
+				break;
+			case Token.NAMESPACE:
+				// TODO: some explanation needed
+				if (!handle_namespace)
+					res = -1;
+				else 
+					check_incorrect_doc_comment ();
+				break;
+				
+			case Token.PARTIAL:
+				if (parsing_block > 0 || !parsing_playscript) {
+					res = -1;
+					break;
+				}
+
+				// Save current position and parse next token.
+				PushPosition ();
+
+				next_token = token ();
+				bool ok = (next_token == Token.CLASS) ||
+					(next_token == Token.STRUCT) ||
+					(next_token == Token.INTERFACE) ||
+					(next_token == Token.VOID);
+
+				PopPosition ();
+
+				if (ok) {
+					if (next_token == Token.VOID) {
+						if (context.Settings.Version <= LanguageVersion.ISO_2)
+							Report.FeatureIsNotAvailable (context, Location, "partial methods");
+					} else if (context.Settings.Version == LanguageVersion.ISO_1)
+						Report.FeatureIsNotAvailable (context, Location, "partial types");
+
+					return res;
+				}
+
+				if (next_token < Token.LAST_KEYWORD) {
+					Report.Error (267, Location,
+						"The `partial' modifier can be used only immediately before `class', `struct', `interface', or `void' keyword");
+					return token ();
+				}					
+
+				res = -1;
+				break;
+
+			case Token.ASYNC:
+				if (!parsing_playscript) {
+					return -1;
+				} else if (parsing_modifiers) {
+					//
+					// Skip attributes section or constructor called async
+					//
+					if (parsing_attribute_section || peek_token () == Token.OPEN_PARENS) {
+						res = -1;
+					} else {
+						// async is keyword
+					}
+				} else if (parsing_block > 0) {
+					switch (peek_token ()) {
+					case Token.DELEGATE:
+					case Token.OPEN_PARENS_LAMBDA:
+						// async is keyword
+						break;
+					case Token.IDENTIFIER:
+						PushPosition ();
+						xtoken ();
+						if (xtoken () != Token.ARROW)
+							res = -1;
+
+						PopPosition ();
+						break;
+					default:
+						res = -1;
+						break;
+					}
+				} else {
+					res = -1;
+				}
+
+				if (res == Token.ASYNC && context.Settings.Version <= LanguageVersion.V_4) {
+					Report.FeatureIsNotAvailable (context, Location, "asynchronous functions");
+				}
+				
+				break;
+
+			case Token.AWAIT:
+				if (parsing_block == 0 || !parsing_playscript)
+					res = -1;
+
+				break;
+
+				// PLAYSCRIPT Extension Type keywords
+			case Token.BOOL:
+			case Token.CHAR:
+			case Token.BYTE:
+			case Token.SBYTE:
+			case Token.DECIMAL:
+			case Token.OBJECT:
+			case Token.STRING:
+			case Token.LONG:
+			case Token.ULONG:
+			case Token.SHORT:
+			case Token.USHORT:
+			case Token.FLOAT:
+			case Token.FLOAT2:
+			case Token.FLOAT3:
+			case Token.FLOAT4:
+			case Token.DOUBLE:
+			case Token.DOUBLE2:
+			case Token.DOUBLE3:
+			case Token.DOUBLE4:
+				if (!parsing_playscript)
+					res = -1;
+
+				break;
+
+				// PLAYSCRIPT Extension keywords
+			case Token.CHECKED:
+			case Token.EXPLICIT:
+			case Token.IMPLICIT:
+			case Token.OVERLOAD:
+			case Token.LOCK:
+			case Token.OUT:
+			case Token.PARAMS:
+			case Token.READONLY:
+			case Token.REF:
+			case Token.UNCHECKED:
+			case Token.UNSAFE:
+			case Token.FIXED:
+			case Token.GOTO:
+				if (!parsing_playscript)
+					res = -1;
+
+				break;
+
+			case Token.EVENT:
+			case Token.INDEXER:
+			case Token.OPERATOR:
+			case Token.PROPERTY:
+				if (!parsing_playscript)
+					res = -1;
+				else
+					parsing_modifiers = false;
+				
+				break;
+
+			case Token.STRUCT:
+			case Token.DELEGATE:
+			case Token.ENUM:
+				if (!parsing_playscript)
+					res = -1;
+				else
+					parsing_modifiers = handle_namespace = false;
+				
+				break;
+
+			case Token.CLASS:
+			case Token.INTERFACE:
+				parsing_modifiers = handle_namespace = false;
+				break;
+
+			}
+
+
+			return res;
+		}
+
+		static PreprocessorDirective GetPreprocessorDirective (char[] id, int id_len)
+		{
+			//
+			// Keywords are stored in an array of arrays grouped by their
+			// length and then by the first character
+			//
+			if (id_len >= keywords_preprocessor.Length || keywords_preprocessor[id_len] == null)
+				return PreprocessorDirective.Invalid;
+
+			int first_index = id[0] - '_';
+			if (first_index > 'z' - '_')
+				return PreprocessorDirective.Invalid;
+
+			var kwe = keywords_preprocessor[id_len][first_index];
+			if (kwe == null)
+				return PreprocessorDirective.Invalid;
+
+			PreprocessorDirective res = PreprocessorDirective.Invalid;
+			do {
+				res = kwe.Token;
+				for (int i = 1; i < id_len; ++i) {
+					if (id[i] != kwe.Value[i]) {
+						res = 0;
+						kwe = kwe.Next;
+						break;
+					}
+				}
+			} while (res == PreprocessorDirective.Invalid && kwe != null);
+
+			return res;
+		}
+
+		public Location Location {
+			get {
+				return new Location (current_source, ref_line, col);
+			}
+		}
+
+		static bool is_identifier_start_character (int c)
+		{
+			return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_' || c == '$' || Char.IsLetter ((char)c);
+		}
+
+		static bool is_identifier_part_character (char c)
+		{
+			if (c >= 'a' && c <= 'z')
+				return true;
+
+			if (c >= 'A' && c <= 'Z')
+				return true;
+
+			if (c == '_' || c == '$' || (c >= '0' && c <= '9'))
+				return true;
+
+			if (c < 0x80)
+				return false;
+
+			return Char.IsLetter (c) || Char.GetUnicodeCategory (c) == UnicodeCategory.ConnectorPunctuation;
+		}
+
+		public static bool IsKeyword (string s)
+		{
+			return keyword_strings.Contains (s);
+		}
+
+		//
+		// Open parens micro parser. Detects both lambda and cast ambiguity.
+		//	
+		int TokenizeOpenParens ()
+		{
+			int ptoken;
+			current_token = -1;
+			current_token_line = 0;
+
+			int bracket_level = 0;
+			bool is_type = false;
+			bool can_be_type = false;
+			
+			while (true) {
+				ptoken = current_token;
+				token ();
+
+				switch (current_token) {
+				case Token.CLOSE_PARENS:
+					token ();
+					
+					//
+					// Expression inside parens is lambda, (int i) => 
+					//
+					if (current_token == Token.ARROW)
+						return Token.OPEN_PARENS_LAMBDA;
+
+//					//
+//					// Expression inside parens is single type, (int[])
+//					//
+//					if (is_type)
+//						return Token.OPEN_PARENS_CAST;
+//
+//					//
+//					// Expression is possible cast, look at next token, (T)null
+//					//
+//					if (can_be_type) {
+//						switch (current_token) {
+//						case Token.OPEN_PARENS:
+//						case Token.BANG:
+//						case Token.TILDE:
+//						case Token.IDENTIFIER:
+//						case Token.LITERAL:
+//						case Token.SUPER:
+//						case Token.CHECKED:
+//						case Token.DELEGATE:
+//						case Token.FALSE:
+//						case Token.FIXED:
+//						case Token.NEW:
+//						case Token.NULL:
+//						case Token.SIZEOF:
+//						case Token.THIS:
+//						case Token.THROW:
+//						case Token.TRUE:
+//						case Token.TYPEOF:
+//						case Token.UNCHECKED:
+//						case Token.UNSAFE:
+//						case Token.DEFAULT:
+//						case Token.AWAIT:
+//
+//						//
+//						// These can be part of a member access
+//						//
+//						case Token.INT:
+//						case Token.UINT:
+//						case Token.SHORT:
+//						case Token.USHORT:
+//						case Token.LONG:
+//						case Token.ULONG:
+//						case Token.DOUBLE:
+//						case Token.FLOAT:
+//						case Token.CHAR:
+//						case Token.BYTE:
+//						case Token.DECIMAL:
+//						case Token.BOOL:
+//							return Token.OPEN_PARENS_CAST;
+//						}
+//					}
+					return Token.OPEN_PARENS;
+					
+				case Token.DOT:
+				case Token.DOUBLE_COLON:
+					if (ptoken != Token.IDENTIFIER && ptoken != Token.OP_GENERICS_GT)
+						goto default;
+
+					continue;
+
+				case Token.IDENTIFIER:
+					switch (ptoken) {
+					case Token.DOT:
+						if (bracket_level == 0) {
+							is_type = false;
+							can_be_type = true;
+						}
+
+						continue;
+					case Token.OP_GENERICS_LT:
+					case Token.COMMA:
+					case Token.DOUBLE_COLON:
+					case -1:
+						if (bracket_level == 0)
+							can_be_type = true;
+						continue;
+					default:
+						can_be_type = is_type = false;
+						continue;
+					}
+
+				case Token.OBJECT:
+				case Token.STRING:
+				case Token.BOOL:
+				case Token.DECIMAL:
+				case Token.FLOAT:
+				case Token.DOUBLE:
+				case Token.SBYTE:
+				case Token.BYTE:
+				case Token.SHORT:
+				case Token.USHORT:
+				case Token.INT:
+				case Token.UINT:
+				case Token.LONG:
+				case Token.ULONG:
+				case Token.CHAR:
+				case Token.VOID:
+					if (bracket_level == 0)
+						is_type = true;
+					continue;
+
+				case Token.COMMA:
+					if (bracket_level == 0) {
+						bracket_level = 100;
+						can_be_type = is_type = false;
+					}
+					continue;
+
+				case Token.OP_GENERICS_LT:
+				case Token.OPEN_BRACKET:
+					if (bracket_level++ == 0)
+						is_type = true;
+					continue;
+
+				case Token.OP_GENERICS_GT:
+				case Token.CLOSE_BRACKET:
+					--bracket_level;
+					continue;
+
+				case Token.INTERR_NULLABLE:
+				case Token.STAR:
+					if (bracket_level == 0)
+						is_type = true;
+					continue;
+
+				case Token.REF:
+				case Token.OUT:
+					can_be_type = is_type = false;
+					continue;
+
+				default:
+					return Token.OPEN_PARENS;
+				}
+			}
+		}
+
+		public static bool IsValidIdentifier (string s)
+		{
+			if (s == null || s.Length == 0)
+				return false;
+
+			if (!is_identifier_start_character (s [0]))
+				return false;
+			
+			for (int i = 1; i < s.Length; i ++)
+				if (! is_identifier_part_character (s [i]))
+					return false;
+			
+			return true;
+		}
+
+		bool parse_less_than ()
+		{
+		start:
+			int the_token = token ();
+			if (the_token == Token.OPEN_BRACKET) {
+				do {
+					the_token = token ();
+				} while (the_token != Token.CLOSE_BRACKET);
+				the_token = token ();
+			} else if (the_token == Token.IN || the_token == Token.OUT) {
+				the_token = token ();
+			}
+			switch (the_token) {
+			case Token.IDENTIFIER:
+			case Token.OBJECT:
+			case Token.STRING:
+			case Token.BOOL:
+			case Token.DECIMAL:
+			case Token.FLOAT:
+			case Token.DOUBLE:
+			case Token.SBYTE:
+			case Token.BYTE:
+			case Token.SHORT:
+			case Token.USHORT:
+			case Token.INT:
+			case Token.UINT:
+			case Token.LONG:
+			case Token.ULONG:
+			case Token.CHAR:
+			case Token.VOID:
+				break;
+			case Token.OP_GENERICS_GT:
+			case Token.IN:
+			case Token.OUT:
+				return true;
+
+			default:
+				return false;
+			}
+		again:
+			the_token = token ();
+
+			if (the_token == Token.OP_GENERICS_GT)
+				return true;
+			else if (the_token == Token.COMMA || the_token == Token.DOT || the_token == Token.DOUBLE_COLON)
+				goto start;
+			else if (the_token == Token.INTERR_NULLABLE || the_token == Token.STAR)
+				goto again;
+			else if (the_token == Token.OP_GENERICS_LT) {
+				if (!parse_less_than ())
+					return false;
+				goto again;
+			} else if (the_token == Token.OPEN_BRACKET) {
+			rank_specifiers:
+				the_token = token ();
+				if (the_token == Token.CLOSE_BRACKET)
+					goto again;
+				else if (the_token == Token.COMMA)
+					goto rank_specifiers;
+				return false;
+			}
+
+			return false;
+		}
+
+		bool parse_generic_dimension (out int dimension)
+		{
+			dimension = 1;
+
+		again:
+			int the_token = token ();
+			if (the_token == Token.OP_GENERICS_GT)
+				return true;
+			else if (the_token == Token.COMMA) {
+				dimension++;
+				goto again;
+			}
+
+			return false;
+		}
+		
+		public int peek_token ()
+		{
+			int the_token;
+
+			PushPosition ();
+			the_token = token ();
+			PopPosition ();
+			
+			return the_token;
+		}
+					
+		//
+		// Tonizes `?' using custom disambiguous rules to return one
+		// of following tokens: INTERR_NULLABLE, OP_COALESCING, INTERR
+		//
+		// Tricky expression look like:
+		//
+		// Foo ? a = x ? b : c;
+		//
+		int TokenizePossibleNullableType ()
+		{
+			if (parsing_block == 0 || parsing_type > 0)
+				return Token.INTERR_NULLABLE;
+
+			int d = peek_char ();
+			if (d == '?') {
+				get_char ();
+				return Token.OP_COALESCING;
+			}
+
+			switch (current_token) {
+			case Token.CLOSE_PARENS:
+			case Token.TRUE:
+			case Token.FALSE:
+			case Token.NULL:
+			case Token.LITERAL:
+				return Token.INTERR;
+			}
+
+			if (d != ' ') {
+				if (d == ',' || d == ';' || d == '>')
+					return Token.INTERR_NULLABLE;
+				if (d == '*' || (d >= '0' && d <= '9'))
+					return Token.INTERR;
+			}
+
+			PushPosition ();
+//			current_token = Token.NONE;  // Doesn't work with auto semi-insertion - needs prev token history always
+			int next_token;
+			switch (xtoken ()) {
+			case Token.LITERAL:
+			case Token.TRUE:
+			case Token.FALSE:
+			case Token.NULL:
+			case Token.THIS:
+			case Token.NEW:
+				next_token = Token.INTERR;
+				break;
+				
+			case Token.SEMICOLON:
+			case Token.COMMA:
+			case Token.CLOSE_PARENS:
+			case Token.OPEN_BRACKET:
+			case Token.OP_GENERICS_GT:
+			case Token.INTERR:
+				next_token = Token.INTERR_NULLABLE;
+				break;
+				
+			default:
+				next_token = -1;
+				break;
+			}
+
+			if (next_token == -1) {
+				switch (xtoken ()) {
+				case Token.COMMA:
+				case Token.SEMICOLON:
+				case Token.OPEN_BRACE:
+				case Token.CLOSE_PARENS:
+				case Token.IN:
+					next_token = Token.INTERR_NULLABLE;
+					break;
+					
+				case Token.COLON:
+					next_token = Token.INTERR;
+					break;							
+					
+				default:
+					int ntoken;
+					int interrs = 1;
+					int colons = 0;
+					int braces = 0;
+					//
+					// All shorcuts failed, do it hard way
+					//
+					while ((ntoken = xtoken ()) != Token.EOF) {
+						if (ntoken == Token.OPEN_BRACE) {
+							++braces;
+							continue;
+						}
+
+						if (ntoken == Token.CLOSE_BRACE) {
+							--braces;
+							continue;
+						}
+
+						if (braces != 0)
+							continue;
+
+						if (ntoken == Token.SEMICOLON)
+							break;
+						
+						if (ntoken == Token.COLON) {
+							if (++colons == interrs)
+								break;
+							continue;
+						}
+						
+						if (ntoken == Token.INTERR) {
+							++interrs;
+							continue;
+						}
+					}
+					
+					next_token = colons != interrs && braces == 0 ? Token.INTERR_NULLABLE : Token.INTERR;
+					break;
+				}
+			}
+			
+			PopPosition ();
+			return next_token;
+		}
+
+		bool decimal_digits (int c)
+		{
+			int d;
+			bool seen_digits = false;
+			
+			if (c != -1){
+				if (number_pos == MaxNumberLength)
+					Error_NumericConstantTooLong ();
+				number_builder [number_pos++] = (char) c;
+			}
+			
+			//
+			// We use peek_char2, because decimal_digits needs to do a 
+			// 2-character look-ahead (5.ToString for example).
+			//
+			while ((d = peek_char2 ()) != -1){
+				if (d >= '0' && d <= '9'){
+					if (number_pos == MaxNumberLength)
+						Error_NumericConstantTooLong ();
+					number_builder [number_pos++] = (char) d;
+					get_char ();
+					seen_digits = true;
+				} else
+					break;
+			}
+			
+			return seen_digits;
+		}
+
+		static bool is_hex (int e)
+		{
+			return (e >= '0' && e <= '9') || (e >= 'A' && e <= 'F') || (e >= 'a' && e <= 'f');
+		}
+
+		static TypeCode real_type_suffix (int c)
+		{
+			switch (c){
+			case 'F': case 'f':
+				return TypeCode.Single;
+			case 'D': case 'd':
+				return TypeCode.Double;
+			case 'M': case 'm':
+				return TypeCode.Decimal;
+			default:
+				return TypeCode.Empty;
+			}
+		}
+
+		ILiteralConstant integer_type_suffix (ulong ul, int c, Location loc)
+		{
+			bool is_unsigned = false;
+			bool is_long = false;
+
+			if (c != -1){
+				bool scanning = true;
+				do {
+					switch (c){
+					case 'U': case 'u':
+						if (is_unsigned)
+							scanning = false;
+						is_unsigned = true;
+						get_char ();
+						break;
+
+					case 'l':
+						if (!is_unsigned){
+							//
+							// if we have not seen anything in between
+							// report this error
+							//
+							Report.Warning (78, 4, Location, "The 'l' suffix is easily confused with the digit '1' (use 'L' for clarity)");
+						}
+
+						goto case 'L';
+
+					case 'L': 
+						if (is_long)
+							scanning = false;
+						is_long = true;
+						get_char ();
+						break;
+						
+					default:
+						scanning = false;
+						break;
+					}
+					c = peek_char ();
+				} while (scanning);
+			}
+
+			if (is_long && is_unsigned){
+				return new ULongLiteral (context.BuiltinTypes, ul, loc);
+			}
+			
+			if (is_unsigned){
+				// uint if possible, or ulong else.
+
+				if ((ul & 0xffffffff00000000) == 0)
+					return new UIntLiteral (context.BuiltinTypes, (uint) ul, loc);
+				else
+					return new ULongLiteral (context.BuiltinTypes, ul, loc);
+			} else if (is_long){
+				// long if possible, ulong otherwise
+				if ((ul & 0x8000000000000000) != 0)
+					return new ULongLiteral (context.BuiltinTypes, ul, loc);
+				else
+					return new LongLiteral (context.BuiltinTypes, (long) ul, loc);
+			} else {
+				// int, uint, long or ulong in that order
+				if ((ul & 0xffffffff00000000) == 0){
+					uint ui = (uint) ul;
+					
+					if ((ui & 0x80000000) != 0)
+						return new UIntLiteral (context.BuiltinTypes, ui, loc);
+					else
+						return new IntLiteral (context.BuiltinTypes, (int) ui, loc);
+				} else {
+					if ((ul & 0x8000000000000000) != 0)
+						return new ULongLiteral (context.BuiltinTypes, ul, loc);
+					else
+						return new LongLiteral (context.BuiltinTypes, (long) ul, loc);
+				}
+			}
+		}
+				
+		//
+		// given `c' as the next char in the input decide whether
+		// we need to convert to a special type, and then choose
+		// the best representation for the integer
+		//
+		ILiteralConstant adjust_int (int c, Location loc)
+		{
+			try {
+				if (number_pos > 9){
+					ulong ul = (uint) (number_builder [0] - '0');
+
+					for (int i = 1; i < number_pos; i++){
+						ul = checked ((ul * 10) + ((uint)(number_builder [i] - '0')));
+					}
+
+					return integer_type_suffix (ul, c, loc);
+				} else {
+					uint ui = (uint) (number_builder [0] - '0');
+
+					for (int i = 1; i < number_pos; i++){
+						ui = checked ((ui * 10) + ((uint)(number_builder [i] - '0')));
+					}
+
+					return integer_type_suffix (ui, c, loc);
+				}
+			} catch (OverflowException) {
+				Error_NumericConstantTooLong ();
+				return new IntLiteral (context.BuiltinTypes, 0, loc);
+			}
+			catch (FormatException) {
+				Report.Error (1013, Location, "Invalid number");
+				return new IntLiteral (context.BuiltinTypes, 0, loc);
+			}
+		}
+		
+		ILiteralConstant adjust_real (TypeCode t, Location loc)
+		{
+			string s = new string (number_builder, 0, number_pos);
+			const string error_details = "Floating-point constant is outside the range of type `{0}'";
+
+			switch (t){
+			case TypeCode.Decimal:
+				try {
+					return new DecimalLiteral (context.BuiltinTypes, decimal.Parse (s, styles, csharp_format_info), loc);
+				} catch (OverflowException) {
+					Report.Error (594, Location, error_details, "decimal");
+					return new DecimalLiteral (context.BuiltinTypes, 0, loc);
+				}
+			case TypeCode.Single:
+				try {
+					return new FloatLiteral (context.BuiltinTypes, float.Parse (s, styles, csharp_format_info), loc);
+				} catch (OverflowException) {
+					Report.Error (594, Location, error_details, "float");
+					return new FloatLiteral (context.BuiltinTypes, 0, loc);
+				}
+			default:
+				try {
+					return new DoubleLiteral (context.BuiltinTypes, double.Parse (s, styles, csharp_format_info), loc);
+				} catch (OverflowException) {
+					Report.Error (594, loc, error_details, "double");
+					return new DoubleLiteral (context.BuiltinTypes, 0, loc);
+				}
+			}
+		}
+
+		ILiteralConstant handle_hex (Location loc)
+		{
+			int d;
+			ulong ul;
+			
+			get_char ();
+			while ((d = peek_char ()) != -1){
+				if (is_hex (d)){
+					number_builder [number_pos++] = (char) d;
+					get_char ();
+				} else
+					break;
+			}
+			
+			string s = new String (number_builder, 0, number_pos);
+
+			try {
+				if (number_pos <= 8)
+					ul = System.UInt32.Parse (s, NumberStyles.HexNumber);
+				else
+					ul = System.UInt64.Parse (s, NumberStyles.HexNumber);
+
+				return integer_type_suffix (ul, peek_char (), loc);
+			} catch (OverflowException){
+				Error_NumericConstantTooLong ();
+				return new IntLiteral (context.BuiltinTypes, 0, loc);
+			}
+			catch (FormatException) {
+				Report.Error (1013, Location, "Invalid number");
+				return new IntLiteral (context.BuiltinTypes, 0, loc);
+			}
+		}
+
+		//
+		// Invoked if we know we have .digits or digits
+		//
+		int is_number (int c)
+		{
+			ILiteralConstant res;
+
+#if FULL_AST
+			int read_start = reader.Position - 1;
+			if (c == '.') {
+				//
+				// Caller did peek_char
+				//
+				--read_start;
+			}
+#endif
+			number_pos = 0;
+			var loc = Location;
+
+			if (c >= '0' && c <= '9'){
+				if (c == '0'){
+					int peek = peek_char ();
+
+					if (peek == 'x' || peek == 'X') {
+						val = res = handle_hex (loc);
+#if FULL_AST
+						res.ParsedValue = reader.ReadChars (read_start, reader.Position - 1);
+#endif
+
+						return Token.LITERAL;
+					}
+				}
+				decimal_digits (c);
+				c = get_char ();
+			}
+
+			//
+			// We need to handle the case of
+			// "1.1" vs "1.string" (LITERAL_FLOAT vs NUMBER DOT IDENTIFIER)
+			//
+			bool is_real = false;
+			if (c == '.'){
+				if (decimal_digits ('.')){
+					is_real = true;
+					c = get_char ();
+				} else {
+					putback ('.');
+					number_pos--;
+					val = res = adjust_int (-1, loc);
+
+#if FULL_AST
+					res.ParsedValue = reader.ReadChars (read_start, reader.Position - 1);
+#endif
+					return Token.LITERAL;
+				}
+			}
+			
+			if (c == 'e' || c == 'E'){
+				is_real = true;
+				if (number_pos == MaxNumberLength)
+					Error_NumericConstantTooLong ();
+				number_builder [number_pos++] = (char) c;
+				c = get_char ();
+				
+				if (c == '+'){
+					if (number_pos == MaxNumberLength)
+						Error_NumericConstantTooLong ();
+					number_builder [number_pos++] = '+';
+					c = -1;
+				} else if (c == '-') {
+					if (number_pos == MaxNumberLength)
+						Error_NumericConstantTooLong ();
+					number_builder [number_pos++] = '-';
+					c = -1;
+				} else {
+					if (number_pos == MaxNumberLength)
+						Error_NumericConstantTooLong ();
+					number_builder [number_pos++] = '+';
+				}
+					
+				decimal_digits (c);
+				c = get_char ();
+			}
+
+			var type = real_type_suffix (c);
+			if (type == TypeCode.Empty && !is_real) {
+				putback (c);
+				res = adjust_int (c, loc);
+			} else {
+				is_real = true;
+
+				if (type == TypeCode.Empty) {
+					putback (c);
+				}
+
+				res = adjust_real (type, loc);
+			}
+
+			val = res;
+
+#if FULL_AST
+			var chars = reader.ReadChars (read_start, reader.Position - (type == TypeCode.Empty && c > 0 ? 1 : 0));
+			if (chars[chars.Length - 1] == '\r')
+				Array.Resize (ref chars, chars.Length - 1);
+			res.ParsedValue = chars;
+#endif
+
+			return Token.LITERAL;
+		}
+
+		//
+		// Accepts exactly count (4 or 8) hex, no more no less
+		//
+		int getHex (int count, out int surrogate, out bool error)
+		{
+			int i;
+			int total = 0;
+			int c;
+			int top = count != -1 ? count : 4;
+			
+			get_char ();
+			error = false;
+			surrogate = 0;
+			for (i = 0; i < top; i++){
+				c = get_char ();
+
+				if (c >= '0' && c <= '9')
+					c = (int) c - (int) '0';
+				else if (c >= 'A' && c <= 'F')
+					c = (int) c - (int) 'A' + 10;
+				else if (c >= 'a' && c <= 'f')
+					c = (int) c - (int) 'a' + 10;
+				else {
+					error = true;
+					return 0;
+				}
+				
+				total = (total * 16) + c;
+				if (count == -1){
+					int p = peek_char ();
+					if (p == -1)
+						break;
+					if (!is_hex ((char)p))
+						break;
+				}
+			}
+
+			if (top == 8) {
+				if (total > 0x0010FFFF) {
+					error = true;
+					return 0;
+				}
+
+				if (total >= 0x00010000) {
+					surrogate = ((total - 0x00010000) % 0x0400 + 0xDC00);					
+					total = ((total - 0x00010000) / 0x0400 + 0xD800);
+				}
+			}
+
+			return total;
+		}
+
+		int escape (int c, out int surrogate)
+		{
+			bool error;
+			int d;
+			int v;
+
+			d = peek_char ();
+			if (c != '\\') {
+				surrogate = 0;
+				return c;
+			}
+			
+			switch (d){
+			case 'a':
+				v = '\a'; break;
+			case 'b':
+				v = '\b'; break;
+			case 'n':
+				v = '\n'; break;
+			case 't':
+				v = '\t'; break;
+			case 'v':
+				v = '\v'; break;
+			case 'r':
+				v = '\r'; break;
+			case '\\':
+				v = '\\'; break;
+			case '/':
+				v = '/'; break;
+			case 'f':
+				v = '\f'; break;
+			case '0':
+				v = 0; break;
+			case '"':
+				v = '"'; break;
+			case '\'':
+				v = '\''; break;
+			case 'x':
+				v = getHex (-1, out surrogate, out error);
+				if (error)
+					goto default;
+				return v;
+			case 'u':
+			case 'U':
+				return EscapeUnicode (d, out surrogate);
+			default:
+				surrogate = 0;
+				Report.Error (1009, Location, "Unrecognized escape sequence `\\{0}'", ((char)d).ToString ());
+				return d;
+			}
+
+			get_char ();
+			surrogate = 0;
+			return v;
+		}
+
+		int EscapeUnicode (int ch, out int surrogate)
+		{
+			bool error;
+			if (ch == 'U') {
+				ch = getHex (8, out surrogate, out error);
+			} else {
+				ch = getHex (4, out surrogate, out error);
+			}
+
+			if (error)
+				Report.Error (1009, Location, "Unrecognized escape sequence");
+
+			return ch;
+		}
+
+		int get_char ()
+		{
+			int x;
+			if (putback_char != -1) {
+				x = putback_char;
+				putback_char = -1;
+			} else {
+				x = reader.Read ();
+			}
+			
+			if (x == '\r') {
+				if (peek_char () == '\n') {
+					putback_char = -1;
+					advance_line (SpecialsBag.NewLine.Windows);
+				} else {
+					advance_line (SpecialsBag.NewLine.Unix);
+				}
+				x = '\n';
+			} else if (x == '\n') {
+				advance_line (SpecialsBag.NewLine.Unix);
+
+			} else {
+				col++;
+			}
+			return x;
+		}
+
+		void advance_line (SpecialsBag.NewLine newLine)
+		{
+			sbag.AddNewLine (line, col, newLine);
+			line++;
+			ref_line++;
+			previous_col = col;
+			col = 0;
+			startsLine = true;
+		}
+
+		int peek_char ()
+		{
+			if (putback_char == -1)
+				putback_char = reader.Read ();
+			return putback_char;
+		}
+
+		int peek_char2 ()
+		{
+			if (putback_char != -1)
+				return putback_char;
+			return reader.Peek ();
+		}
+		
+		public void putback (int c)
+		{
+			if (putback_char != -1) {
+				throw new InternalErrorException (string.Format ("Secondary putback [{0}] putting back [{1}] is not allowed", (char)putback_char, (char) c), Location);
+			}
+
+			if (c == '\n' || col == 0) {
+				// It won't happen though.
+				line--;
+				ref_line--;
+				col = previous_col;
+			}
+			else
+				col--;
+			putback_char = c;
+		}
+
+		public bool advance ()
+		{
+			return peek_char () != -1 || CompleteOnEOF;
+		}
+
+		public Object Value {
+			get {
+				return val;
+			}
+		}
+
+		public Object value ()
+		{
+			return val;
+		}
+
+		public int token ()
+		{
+			prev_token = current_token;
+			prev_token_line = current_token_line;
+			
+			current_token = xtoken (true);
+			current_token_line = line;
+
+			return current_token;
+		}
+
+		public void token_putback (int token)
+		{
+			if (putback_token != -1)
+				throw new Exception("Can't put back token twice.'");
+			putback_token = token;
+		}
+
+		int TokenizePreprocessorIdentifier (out int c)
+		{
+			// skip over white space
+			do {
+				c = get_char ();
+			} while (c == ' ' || c == '\t');
+
+
+			int pos = 0;
+			while (c != -1 && c >= 'a' && c <= 'z') {
+				id_builder[pos++] = (char) c;
+				c = get_char ();
+				if (c == '\\') {
+					int peek = peek_char ();
+					if (peek == 'U' || peek == 'u') {
+						int surrogate;
+						c = EscapeUnicode (c, out surrogate);
+						if (surrogate != 0) {
+							if (is_identifier_part_character ((char) c)) {
+								id_builder[pos++] = (char) c;
+							}
+							c = surrogate;
+						}
+					}
+				}
+			}
+
+			return pos;
+		}
+
+		PreprocessorDirective get_cmd_arg (out string arg)
+		{
+			int c;		
+
+			tokens_seen = false;
+			arg = "";
+
+			var cmd = GetPreprocessorDirective (id_builder, TokenizePreprocessorIdentifier (out c));
+
+			if ((cmd & PreprocessorDirective.CustomArgumentsParsing) != 0)
+				return cmd;
+
+			// skip over white space
+			while (c == ' ' || c == '\t')
+				c = get_char ();
+
+			int has_identifier_argument = (int)(cmd & PreprocessorDirective.RequiresArgument);
+			int pos = 0;
+
+			while (c != -1 && c != '\n') {
+				if (c == '\\' && has_identifier_argument >= 0) {
+					if (has_identifier_argument != 0) {
+						has_identifier_argument = 1;
+
+						int peek = peek_char ();
+						if (peek == 'U' || peek == 'u') {
+							int surrogate;
+							c = EscapeUnicode (c, out surrogate);
+							if (surrogate != 0) {
+								if (is_identifier_part_character ((char) c)) {
+									if (pos == value_builder.Length)
+										Array.Resize (ref value_builder, pos * 2);
+
+									value_builder[pos++] = (char) c;
+								}
+								c = surrogate;
+							}
+						}
+					} else {
+						has_identifier_argument = -1;
+					}
+				} else if (c == '/' && peek_char () == '/') {
+					//
+					// Eat single-line comments
+					//
+					get_char ();
+					do {
+						c = get_char ();
+					} while (c != -1 && c != '\n');
+
+					break;
+				}
+
+				if (pos == value_builder.Length)
+					Array.Resize (ref value_builder, pos * 2);
+
+				value_builder[pos++] = (char) c;
+				c = get_char ();
+			}
+
+			if (pos != 0) {
+				if (pos > MaxIdentifierLength)
+					arg = new string (value_builder, 0, pos);
+				else
+					arg = InternIdentifier (value_builder, pos);
+
+				// Eat any trailing whitespaces
+				arg = arg.Trim (simple_whitespaces);
+			}
+
+			return cmd;
+		}
+
+		//
+		// Handles the #line directive
+		//
+		bool PreProcessLine ()
+		{
+			Location loc = Location;
+
+			int c;
+
+			int length = TokenizePreprocessorIdentifier (out c);
+			if (length == line_default.Length) {
+				if (!IsTokenIdentifierEqual (line_default))
+					return false;
+
+				current_source = source_file.SourceFile;
+				if (!hidden_block_start.IsNull) {
+					current_source.RegisterHiddenScope (hidden_block_start, loc);
+					hidden_block_start = Location.Null;
+				}
+
+				ref_line = line;
+				return true;
+			}
+
+			if (length == line_hidden.Length) {
+				if (!IsTokenIdentifierEqual (line_hidden))
+					return false;
+
+				if (hidden_block_start.IsNull)
+					hidden_block_start = loc;
+
+				return true;
+			}
+
+			if (length != 0 || c < '0' || c > '9') {
+				//
+				// Eat any remaining characters to continue parsing on next line
+				//
+				while (c != -1 && c != '\n') {
+					c = get_char ();
+				}
+
+				return false;
+			}
+
+			int new_line = TokenizeNumber (c);
+			if (new_line < 1) {
+				//
+				// Eat any remaining characters to continue parsing on next line
+				//
+				while (c != -1 && c != '\n') {
+					c = get_char ();
+				}
+
+				return new_line != 0;
+			}
+
+			c = get_char ();
+			if (c == ' ') {
+				// skip over white space
+				do {
+					c = get_char ();
+				} while (c == ' ' || c == '\t');
+			} else if (c == '"') {
+				c = 0;
+			}
+
+			if (c != '\n' && c != '/' && c != '"') {
+				//
+				// Eat any remaining characters to continue parsing on next line
+				//
+				while (c != -1 && c != '\n') {
+					c = get_char ();
+				}
+
+				Report.Error (1578, loc, "Filename, single-line comment or end-of-line expected");
+				return true;
+			}
+
+			string new_file_name = null;
+			if (c == '"') {
+				new_file_name = TokenizeFileName (ref c);
+
+				// skip over white space
+				while (c == ' ' || c == '\t') {
+					c = get_char ();
+				}
+			}
+
+			if (c == '\n') {
+			} else if (c == '/') {
+				ReadSingleLineComment ();
+			} else {
+				//
+				// Eat any remaining characters to continue parsing on next line
+				//
+				while (c != -1 && c != '\n') {
+					c = get_char ();
+				}
+
+				Error_EndLineExpected ();
+				return true;
+			}
+
+			if (new_file_name != null) {
+				current_source = context.LookupFile (source_file, new_file_name);
+				source_file.AddIncludeFile (current_source);
+			}
+
+			if (!hidden_block_start.IsNull) {
+				current_source.RegisterHiddenScope (hidden_block_start, loc);
+				hidden_block_start = Location.Null;
+			}
+
+			ref_line = new_line;
+			return true;
+		}
+
+		//
+		// Handles #define and #undef
+		//
+		void PreProcessDefinition (bool is_define, string ident, bool caller_is_taking)
+		{
+			if (ident.Length == 0 || ident == "true" || ident == "false"){
+				Report.Error (1001, Location, "Missing identifier to pre-processor directive");
+				return;
+			}
+
+			if (ident.IndexOfAny (simple_whitespaces) != -1){
+				Error_EndLineExpected ();
+				return;
+			}
+
+			if (!is_identifier_start_character (ident [0]))
+				Report.Error (1001, Location, "Identifier expected: {0}", ident);
+			
+			foreach (char c in ident.Substring (1)){
+				if (!is_identifier_part_character (c)){
+					Report.Error (1001, Location, "Identifier expected: {0}",  ident);
+					return;
+				}
+			}
+
+			if (!caller_is_taking)
+				return;
+
+			if (is_define) {
+				//
+				// #define ident
+				//
+				if (context.Settings.IsConditionalSymbolDefined (ident))
+					return;
+
+				source_file.AddDefine (ident);
+			} else {
+				//
+				// #undef ident
+				//
+				source_file.AddUndefine (ident);
+			}
+		}
+
+		byte read_hex (out bool error)
+		{
+			int total;
+			int c = get_char ();
+
+			if ((c >= '0') && (c <= '9'))
+				total = (int) c - (int) '0';
+			else if ((c >= 'A') && (c <= 'F'))
+				total = (int) c - (int) 'A' + 10;
+			else if ((c >= 'a') && (c <= 'f'))
+				total = (int) c - (int) 'a' + 10;
+			else {
+				error = true;
+				return 0;
+			}
+
+			total *= 16;
+			c = get_char ();
+
+			if ((c >= '0') && (c <= '9'))
+				total += (int) c - (int) '0';
+			else if ((c >= 'A') && (c <= 'F'))
+				total += (int) c - (int) 'A' + 10;
+			else if ((c >= 'a') && (c <= 'f'))
+				total += (int) c - (int) 'a' + 10;
+			else {
+				error = true;
+				return 0;
+			}
+
+			error = false;
+			return (byte) total;
+		}
+
+		//
+		// Parses #pragma checksum
+		//
+		bool ParsePragmaChecksum ()
+		{
+			//
+			// The syntax is ` "foo.txt" "{guid}" "hash"'
+			//
+			// guid is predefined hash algorithm guid {406ea660-64cf-4c82-b6f0-42d48172a799} for md5
+			//
+			int c = get_char ();
+
+			if (c != '"')
+				return false;
+
+			string file_name = TokenizeFileName (ref c);
+
+			// TODO: Any white-spaces count
+			if (c != ' ')
+				return false;
+
+			SourceFile file = context.LookupFile (source_file, file_name);
+
+			if (get_char () != '"' || get_char () != '{')
+				return false;
+
+			bool error;
+			byte[] guid_bytes = new byte [16];
+			int i = 0;
+
+			for (; i < 4; i++) {
+				guid_bytes [i] = read_hex (out error);
+				if (error)
+					return false;
+			}
+
+			if (get_char () != '-')
+				return false;
+
+			for (; i < 10; i++) {
+				guid_bytes [i] = read_hex (out error);
+				if (error)
+					return false;
+
+				guid_bytes [i++] = read_hex (out error);
+				if (error)
+					return false;
+
+				if (get_char () != '-')
+					return false;
+			}
+
+			for (; i < 16; i++) {
+				guid_bytes [i] = read_hex (out error);
+				if (error)
+					return false;
+			}
+
+			if (get_char () != '}' || get_char () != '"')
+				return false;
+
+			// TODO: Any white-spaces count
+			c = get_char ();
+			if (c != ' ')
+				return false;
+
+			if (get_char () != '"')
+				return false;
+
+			// Any length of checksum
+			List<byte> checksum_bytes = new List<byte> (16);
+
+			var checksum_location = Location;
+			c = peek_char ();
+			while (c != '"' && c != -1) {
+				checksum_bytes.Add (read_hex (out error));
+				if (error)
+					return false;
+
+				c = peek_char ();
+			}
+
+			if (c == '/') {
+				ReadSingleLineComment ();
+			} else if (get_char () != '"') {
+				return false;
+			}
+
+			if (context.Settings.GenerateDebugInfo) {
+				var chsum = checksum_bytes.ToArray ();
+
+				if (file.HasChecksum) {
+					if (!ArrayComparer.IsEqual (file.Checksum, chsum)) {
+						// TODO: Report.SymbolRelatedToPreviousError
+						Report.Warning (1697, 1, checksum_location, "Different checksum values specified for file `{0}'", file.Name);
+					}
+				}
+
+				file.SetChecksum (guid_bytes, chsum);
+			current_source.AutoGenerated = true;
+			}
+
+			return true;
+		}
+
+		bool IsTokenIdentifierEqual (char[] identifier)
+		{
+			for (int i = 0; i < identifier.Length; ++i) {
+				if (identifier[i] != id_builder[i])
+					return false;
+			}
+
+			return true;
+		}
+
+		int TokenizeNumber (int value)
+		{
+			number_pos = 0;
+
+			decimal_digits (value);
+			uint ui = (uint) (number_builder[0] - '0');
+
+			try {
+				for (int i = 1; i < number_pos; i++) {
+					ui = checked ((ui * 10) + ((uint) (number_builder[i] - '0')));
+				}
+
+				return (int) ui;
+			} catch (OverflowException) {
+				Error_NumericConstantTooLong ();
+				return -1;
+			}
+		}
+
+		string TokenizeFileName (ref int c)
+		{
+			var string_builder = new StringBuilder ();
+			while (c != -1 && c != '\n') {
+				c = get_char ();
+				if (c == '"') {
+					c = get_char ();
+					break;
+				}
+
+				string_builder.Append ((char) c);
+			}
+
+			if (string_builder.Length == 0) {
+				Report.Warning (1709, 1, Location, "Filename specified for preprocessor directive is empty");
+			}
+
+		
+			return string_builder.ToString ();
+		}
+
+		int TokenizePragmaNumber (ref int c)
+		{
+			number_pos = 0;
+
+			int number;
+
+			if (c >= '0' && c <= '9') {
+				number = TokenizeNumber (c);
+
+				c = get_char ();
+
+				// skip over white space
+				while (c == ' ' || c == '\t')
+					c = get_char ();
+
+				if (c == ',') {
+					c = get_char ();
+				}
+
+				// skip over white space
+				while (c == ' ' || c == '\t')
+					c = get_char ();
+			} else {
+				number = -1;
+				if (c == '/') {
+					ReadSingleLineComment ();
+				} else {
+					Report.Warning (1692, 1, Location, "Invalid number");
+
+					// Read everything till the end of the line or file
+					do {
+						c = get_char ();
+					} while (c != -1 && c != '\n');
+				}
+			}
+
+			return number;
+		}
+
+		
+		void ReadSingleLineComment ()
+		{
+			if (peek_char () != '/')
+				Report.Warning (1696, 1, Location, "Single-line comment or end-of-line expected");
+			if (position_stack.Count == 0)
+				sbag.StartComment (SpecialsBag.CommentType.Single, startsLine, line, col - 1);
+			// Read everything till the end of the line or file
+			int c;
+			do {
+				c = get_char ();
+				if (position_stack.Count == 0)
+					sbag.PushCommentChar (c);
+				var pc = peek_char ();
+				if ((pc == '\n' || pc == -1) && position_stack.Count == 0) 
+					sbag.EndComment (line, col + 1);
+			} while (c != -1 && c != '\n');
+		}
+
+		/// <summary>
+		/// Handles #pragma directive
+		/// </summary>
+		void ParsePragmaDirective (string arg)
+		{
+			int c;
+			int length = TokenizePreprocessorIdentifier (out c);
+			if (length == pragma_warning.Length && IsTokenIdentifierEqual (pragma_warning)) {
+				length = TokenizePreprocessorIdentifier (out c);
+
+				//
+				// #pragma warning disable
+				// #pragma warning restore
+				//
+				if (length == pragma_warning_disable.Length) {
+					bool disable = IsTokenIdentifierEqual (pragma_warning_disable);
+					if (disable || IsTokenIdentifierEqual (pragma_warning_restore)) {
+						// skip over white space
+						while (c == ' ' || c == '\t')
+							c = get_char ();
+
+						var loc = Location;
+
+						if (c == '\n' || c == '/') {
+							if (c == '/')
+								ReadSingleLineComment ();
+
+							//
+							// Disable/Restore all warnings
+							//
+							if (disable) {
+								Report.RegisterWarningRegion (loc).WarningDisable (loc.Row);
+							} else {
+								Report.RegisterWarningRegion (loc).WarningEnable (loc.Row);
+							}
+						} else {
+							//
+							// Disable/Restore a warning or group of warnings
+							//
+							int code;
+							do {
+								code = TokenizePragmaNumber (ref c);
+								if (code > 0) {
+									if (disable) {
+										Report.RegisterWarningRegion (loc).WarningDisable (loc, code, context.Report);
+									} else {
+										Report.RegisterWarningRegion (loc).WarningEnable (loc, code, context);
+									}
+								}
+							} while (code >= 0 && c != '\n' && c != -1);
+						}
+
+						return;
+					}
+				}
+
+				Report.Warning (1634, 1, Location, "Expected disable or restore");
+				return;
+			}
+
+			//
+			// #pragma checksum
+			//
+			if (length == pragma_checksum.Length && IsTokenIdentifierEqual (pragma_checksum)) {
+				if (c != ' ' || !ParsePragmaChecksum ()) {
+					Report.Warning (1695, 1, Location,
+						"Invalid #pragma checksum syntax. Expected \"filename\" \"{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\" \"XXXX...\"");
+				}
+
+				return;
+			}
+
+			Report.Warning (1633, 1, Location, "Unrecognized #pragma directive");
+		}
+
+		bool eval_val (string s)
+		{
+			if (s == "true")
+				return true;
+			if (s == "false")
+				return false;
+
+			return source_file.IsConditionalDefined (s);
+		}
+
+		bool pp_primary (ref string s)
+		{
+			s = s.Trim ();
+			int len = s.Length;
+
+			if (len > 0){
+				char c = s [0];
+				
+				if (c == '('){
+					s = s.Substring (1);
+					bool val = pp_expr (ref s, false);
+					if (s.Length > 0 && s [0] == ')'){
+						s = s.Substring (1);
+						return val;
+					}
+					Error_InvalidDirective ();
+					return false;
+				}
+				
+				if (is_identifier_start_character (c)){
+					int j = 1;
+
+					while (j < len){
+						c = s [j];
+						
+						if (is_identifier_part_character (c)){
+							j++;
+							continue;
+						}
+						bool v = eval_val (s.Substring (0, j));
+						s = s.Substring (j);
+						return v;
+					}
+					bool vv = eval_val (s);
+					s = "";
+					return vv;
+				}
+			}
+			Error_InvalidDirective ();
+			return false;
+		}
+		
+		bool pp_unary (ref string s)
+		{
+			s = s.Trim ();
+			int len = s.Length;
+
+			if (len > 0){
+				if (s [0] == '!'){
+					if (len > 1 && s [1] == '='){
+						Error_InvalidDirective ();
+						return false;
+					}
+					s = s.Substring (1);
+					return ! pp_primary (ref s);
+				} else
+					return pp_primary (ref s);
+			} else {
+				Error_InvalidDirective ();
+				return false;
+			}
+		}
+		
+		bool pp_eq (ref string s)
+		{
+			bool va = pp_unary (ref s);
+
+			s = s.Trim ();
+			int len = s.Length;
+			if (len > 0){
+				if (s [0] == '='){
+					if (len > 2 && s [1] == '='){
+						s = s.Substring (2);
+						return va == pp_unary (ref s);
+					} else {
+						Error_InvalidDirective ();
+						return false;
+					}
+				} else if (s [0] == '!' && len > 1 && s [1] == '='){
+					s = s.Substring (2);
+
+					return va != pp_unary (ref s);
+
+				} 
+			}
+
+			return va;
+				
+		}
+		
+		bool pp_and (ref string s)
+		{
+			bool va = pp_eq (ref s);
+
+			s = s.Trim ();
+			int len = s.Length;
+			if (len > 0){
+				if (s [0] == '&'){
+					if (len > 2 && s [1] == '&'){
+						s = s.Substring (2);
+						return (va & pp_and (ref s));
+					} else {
+						Error_InvalidDirective ();
+						return false;
+					}
+				} 
+			}
+			return va;
+		}
+		
+		//
+		// Evaluates an expression for `#if' or `#elif'
+		//
+		bool pp_expr (ref string s, bool isTerm)
+		{
+			bool va = pp_and (ref s);
+			s = s.Trim ();
+			int len = s.Length;
+			if (len > 0){
+				char c = s [0];
+				
+				if (c == '|'){
+					if (len > 2 && s [1] == '|'){
+						s = s.Substring (2);
+						return va | pp_expr (ref s, isTerm);
+					} else {
+						Error_InvalidDirective ();
+						return false;
+					}
+				}
+				if (isTerm) {
+					Error_EndLineExpected ();
+					return false;
+				}
+			}
+			
+			return va;
+		}
+
+		bool eval (string s)
+		{
+			bool v = pp_expr (ref s, true);
+			s = s.Trim ();
+			if (s.Length != 0){
+				return false;
+			}
+
+			return v;
+		}
+
+		void Error_NumericConstantTooLong ()
+		{
+			Report.Error (1021, Location, "Integral constant is too large");			
+		}
+		
+		void Error_InvalidDirective ()
+		{
+			Report.Error (1517, Location, "Invalid preprocessor directive");
+		}
+
+		void Error_UnexpectedDirective (string extra)
+		{
+			Report.Error (
+				1028, Location,
+				"Unexpected processor directive ({0})", extra);
+		}
+
+		void Error_TokensSeen ()
+		{
+			Report.Error (1032, Location,
+				"Cannot define or undefine preprocessor symbols after first token in file");
+		}
+
+		void Eror_WrongPreprocessorLocation ()
+		{
+			Report.Error (1040, Location,
+				"Preprocessor directives must appear as the first non-whitespace character on a line");
+		}
+
+		void Error_EndLineExpected ()
+		{
+			Report.Error (1025, Location, "Single-line comment or end-of-line expected");
+		}
+
+		//
+		// Raises a warning when tokenizer found documentation comment
+		// on unexpected place
+		//
+		void WarningMisplacedComment (Location loc)
+		{
+			if (doc_state != XmlCommentState.Error) {
+				doc_state = XmlCommentState.Error;
+				Report.Warning (1587, 2, loc, "XML comment is not placed on a valid language element");
+			}
+		}
+		
+		//
+		// if true, then the code continues processing the code
+		// if false, the code stays in a loop until another directive is
+		// reached.
+		// When caller_is_taking is false we ignore all directives except the ones
+		// which can help us to identify where the #if block ends
+		bool ParsePreprocessingDirective (bool caller_is_taking)
+		{
+			string arg;
+			bool region_directive = false;
+
+			var directive = get_cmd_arg (out arg);
+
+			//
+			// The first group of pre-processing instructions is always processed
+			//
+			switch (directive) {
+			case PreprocessorDirective.Region:
+				region_directive = true;
+				arg = "true";
+				goto case PreprocessorDirective.If;
+
+			case PreprocessorDirective.Endregion:
+				if (ifstack == null || ifstack.Count == 0){
+					Error_UnexpectedDirective ("no #region for this #endregion");
+					return true;
+				}
+				int pop = ifstack.Pop ();
+					
+				if ((pop & REGION) == 0)
+					Report.Error (1027, Location, "Expected `#endif' directive");
+					
+				return caller_is_taking;
+				
+			case PreprocessorDirective.If:
+				if (ifstack == null)
+					ifstack = new Stack<int> (2);
+
+				int flags = region_directive ? REGION : 0;
+				if (ifstack.Count == 0){
+					flags |= PARENT_TAKING;
+				} else {
+					int state = ifstack.Peek ();
+					if ((state & TAKING) != 0) {
+						flags |= PARENT_TAKING;
+					}
+				}
+
+				if (eval (arg) && caller_is_taking) {
+					ifstack.Push (flags | TAKING);
+					return true;
+				}
+				ifstack.Push (flags);
+				return false;
+
+			case PreprocessorDirective.Endif:
+				if (ifstack == null || ifstack.Count == 0){
+					Error_UnexpectedDirective ("no #if for this #endif");
+					return true;
+				} else {
+					pop = ifstack.Pop ();
+					
+					if ((pop & REGION) != 0)
+						Report.Error (1038, Location, "#endregion directive expected");
+					
+					if (arg.Length != 0) {
+						Error_EndLineExpected ();
+					}
+					
+					if (ifstack.Count == 0)
+						return true;
+
+					int state = ifstack.Peek ();
+					return (state & TAKING) != 0;
+				}
+
+			case PreprocessorDirective.Elif:
+				if (ifstack == null || ifstack.Count == 0){
+					Error_UnexpectedDirective ("no #if for this #elif");
+					return true;
+				} else {
+					int state = ifstack.Pop ();
+
+					if ((state & REGION) != 0) {
+						Report.Error (1038, Location, "#endregion directive expected");
+						return true;
+					}
+
+					if ((state & ELSE_SEEN) != 0){
+						Error_UnexpectedDirective ("#elif not valid after #else");
+						return true;
+					}
+
+					if ((state & TAKING) != 0) {
+						ifstack.Push (0);
+						return false;
+					}
+
+					if (eval (arg) && ((state & PARENT_TAKING) != 0)){
+						ifstack.Push (state | TAKING);
+						return true;
+					}
+
+					ifstack.Push (state);
+					return false;
+				}
+
+			case PreprocessorDirective.Else:
+				if (ifstack == null || ifstack.Count == 0){
+					Error_UnexpectedDirective ("no #if for this #else");
+					return true;
+				} else {
+					int state = ifstack.Peek ();
+
+					if ((state & REGION) != 0) {
+						Report.Error (1038, Location, "#endregion directive expected");
+						return true;
+					}
+
+					if ((state & ELSE_SEEN) != 0){
+						Error_UnexpectedDirective ("#else within #else");
+						return true;
+					}
+
+					ifstack.Pop ();
+
+					if (arg.Length != 0) {
+						Error_EndLineExpected ();
+						return true;
+					}
+
+					bool ret = false;
+					if ((state & PARENT_TAKING) != 0) {
+						ret = (state & TAKING) == 0;
+					
+						if (ret)
+							state |= TAKING;
+						else
+							state &= ~TAKING;
+					}
+	
+					ifstack.Push (state | ELSE_SEEN);
+					
+					return ret;
+				}
+			case PreprocessorDirective.Define:
+				if (any_token_seen){
+					Error_TokensSeen ();
+					return caller_is_taking;
+				}
+				PreProcessDefinition (true, arg, caller_is_taking);
+				return caller_is_taking;
+
+			case PreprocessorDirective.Undef:
+				if (any_token_seen){
+					Error_TokensSeen ();
+					return caller_is_taking;
+				}
+				PreProcessDefinition (false, arg, caller_is_taking);
+				return caller_is_taking;
+
+			case PreprocessorDirective.Invalid:
+				Report.Error (1024, Location, "Wrong preprocessor directive");
+				return true;
+			}
+
+			//
+			// These are only processed if we are in a `taking' block
+			//
+			if (!caller_is_taking)
+				return false;
+					
+			switch (directive){
+			case PreprocessorDirective.Error:
+				Report.Error (1029, Location, "#error: '{0}'", arg);
+				return true;
+
+			case PreprocessorDirective.Warning:
+				Report.Warning (1030, 1, Location, "#warning: `{0}'", arg);
+				return true;
+
+			case PreprocessorDirective.Pragma:
+				if (context.Settings.Version == LanguageVersion.ISO_1) {
+					Report.FeatureIsNotAvailable (context, Location, "#pragma");
+				}
+
+				ParsePragmaDirective (arg);
+				return true;
+
+			case PreprocessorDirective.Line:
+				Location loc = Location;
+				if (!PreProcessLine ())
+					Report.Error (1576, loc, "The line number specified for #line directive is missing or invalid");
+
+				return caller_is_taking;
+			}
+
+			throw new NotImplementedException (directive.ToString ());
+		}
+
+		private int consume_string (bool quoted, char quoteChar = '"')
+		{
+			int c;
+			int pos = 0;
+			Location start_location = Location;
+			if (quoted)
+				start_location = start_location - 1;
+
+#if FULL_AST
+			int reader_pos = reader.Position;
+#endif
+
+			while (true) {
+				c = get_char ();
+				if (c == quoteChar) {
+					if (quoted && peek_char () == quoteChar) {
+						if (pos == value_builder.Length)
+							Array.Resize (ref value_builder, pos * 2);
+
+						value_builder[pos++] = (char) c;
+						get_char ();
+						continue;
+					}
+
+					string s;
+					if (pos == 0)
+						s = string.Empty;
+					else if (pos <= 4)
+						s = InternIdentifier (value_builder, pos);
+					else
+						s = new string (value_builder, 0, pos);
+
+					ILiteralConstant res = new StringLiteral (context.BuiltinTypes, s, start_location);
+					val = res;
+#if FULL_AST
+					res.ParsedValue = quoted ?
+						reader.ReadChars (reader_pos - 2, reader.Position - 1) :
+						reader.ReadChars (reader_pos - 1, reader.Position);
+#endif
+
+					return Token.LITERAL;
+				}
+
+				if (c == '\n') {
+					if (!quoted) {
+						Report.Error (1010, Location, "Newline in constant");
+						val = new StringLiteral (context.BuiltinTypes, new string (value_builder, 0, pos), start_location);
+						return Token.LITERAL;
+					}
+				} else if (c == '\\' && !quoted) {
+					int surrogate;
+					c = escape (c, out surrogate);
+					if (c == -1)
+						return Token.ERROR;
+					if (surrogate != 0) {
+						if (pos == value_builder.Length)
+							Array.Resize (ref value_builder, pos * 2);
+
+						value_builder[pos++] = (char) c;
+						c = surrogate;
+					}
+				} else if (c == -1) {
+					Report.Error (1039, Location, "Unterminated string literal");
+					return Token.EOF;
+				}
+
+				if (pos == value_builder.Length)
+					Array.Resize (ref value_builder, pos * 2);
+
+				value_builder[pos++] = (char) c;
+			}
+		}
+
+		private int consume_regex ()
+		{
+			int c;
+			int pos = 0;
+			Location start_location = Location;
+
+#if FULL_AST
+			int reader_pos = reader.Position;
+#endif
+
+			StringBuilder opt_builder = null;
+
+			while (true) {
+				c = get_char ();
+				if (c == '\\') {
+					if (pos == value_builder.Length)
+						Array.Resize (ref value_builder, pos * 2);
+					value_builder[pos++] = (char) c;
+					c = get_char ();
+					// c will be added automatically at the end of this block
+				} else if (c == '/') {
+
+					c = peek_char();
+					while (c == 'g' || c == 'i' || c == 'm' || c == 's' || c == 'x') {
+						if (opt_builder == null)
+							opt_builder = new StringBuilder();
+						opt_builder.Append((char) get_char ());
+						c = peek_char ();
+					}
+
+					string s;
+					if (pos == 0)
+						s = string.Empty;
+					else
+						s = new string (value_builder, 0, pos);
+
+					ILiteralConstant res = new RegexLiteral (context.BuiltinTypes, s, 
+					                                         opt_builder != null ? opt_builder.ToString() : null, 
+					                                         start_location);
+					val = res;
+
+					return Token.LITERAL;
+				}
+
+				if (c == '\n') {
+					Report.Error (7027, Location, "Newline in regex constant");
+					val = new StringLiteral (context.BuiltinTypes, new string (value_builder, 0, pos), start_location);
+					return Token.LITERAL;
+				} /* else if (c == '\\') {
+					c = get_char();
+					if (c != -1) {
+						if (pos == value_builder.Length)
+							Array.Resize (ref value_builder, pos * 2);
+						value_builder[pos++] = (char) c;
+					}
+				} */
+
+				if (c == -1) {
+					Report.Error (7028, Location, "Unterminated regex literal");
+					return Token.EOF;
+				}
+
+				if (pos == value_builder.Length)
+					Array.Resize (ref value_builder, pos * 2);
+
+				value_builder[pos++] = (char) c;
+			}
+		}
+
+		private int consume_xml ()
+		{
+			int c;
+			int pos = 0;
+			Location start_location = Location;
+			
+#if FULL_AST
+			int reader_pos = reader.Position;
+#endif
+			
+			if (pos == value_builder.Length)
+				Array.Resize (ref value_builder, pos * 2);
+			value_builder[pos++] = (char) '<';
+
+			while (true) {
+
+				c = get_char ();
+				if (c == '>') {
+
+					if (pos == value_builder.Length)
+						Array.Resize (ref value_builder, pos * 2);
+					value_builder[pos++] = (char) c;
+
+					c = peek_char();
+					while (c == ' ' || c == '\t') {
+						c = get_char ();
+						if (pos == value_builder.Length)
+							Array.Resize (ref value_builder, pos * 2);
+						value_builder[pos++] = (char) c;
+					}
+
+					// TODO: This is a pretty ghetto way to identify the end of the xml literal.  Probably will
+					// work most of the time, but is not a general solution.  FIXME
+					if (c == ';' || c == '.' || c == ',' || c == ')' || c == '}' || c == ']') {
+
+						string s;
+						if (pos == 0)
+							s = string.Empty;
+						else
+							s = new string (value_builder, 0, pos);
+						
+						ILiteralConstant res = new XmlLiteral (context.BuiltinTypes, s, start_location);
+						val = res;
+
+						return Token.LITERAL;
+					}
+				}
+				
+				if (c == -1) {
+					Report.Error (7029, Location, "Unterminated xml literal");
+					return Token.EOF;
+				}
+				
+				if (pos == value_builder.Length)
+					Array.Resize (ref value_builder, pos * 2);
+				value_builder[pos++] = (char) c;
+			}
+		}
+
+		private int consume_identifier (bool parse_token, int s)
+		{
+			int res = consume_identifier (parse_token, s, false);
+
+			if (doc_state == XmlCommentState.Allowed)
+				doc_state = XmlCommentState.NotAllowed;
+			startsLine = false;
+			return res;
+		}
+
+		int consume_identifier (bool parse_token, int c, bool quoted) 
+		{
+			//
+			// This method is very performance sensitive. It accounts
+			// for approximately 25% of all parser time
+			//
+
+			int pos = 0;
+			int column = col;
+			if (quoted)
+				--column;
+
+			if (c == '\\') {
+				int surrogate;
+				c = escape (c, out surrogate);
+				if (surrogate != 0) {
+					id_builder [pos++] = (char) c;
+					c = surrogate;
+				}
+			}
+
+			id_builder [pos++] = (char) c;
+
+			bool is_config_ident = false;
+
+			try {
+				while (true) {
+					c = reader.Read ();
+
+					if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_' || (c >= '0' && c <= '9') || c == '$') {
+						id_builder [pos++] = (char) c;
+						continue;
+					}
+
+					if (parsing_block == 0 && c == ':' && !is_config_ident) {
+						var colonPos = reader.Position;
+						c = reader.Read ();
+						if (c == ':') { 
+							c = reader.Read ();
+							if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_' || c == '$') {
+								is_config_ident = true;
+								id_builder [pos++] = ':';
+								id_builder [pos++] = ':';
+								id_builder [pos++] = (char) c;
+								continue;
+							} 
+						}
+						if (!is_config_ident) {
+							reader.Position = colonPos;
+							c = ':';
+						}
+					}
+
+					if (c < 0x80) {
+						if (c == '\\') {
+							int surrogate;
+							c = escape (c, out surrogate);
+							if (is_identifier_part_character ((char) c))
+								id_builder[pos++] = (char) c;
+
+							if (surrogate != 0) {
+								c = surrogate;
+							}
+
+							continue;
+						}
+					} else if (Char.IsLetter ((char) c) || Char.GetUnicodeCategory ((char) c) == UnicodeCategory.ConnectorPunctuation) {
+						id_builder [pos++] = (char) c;
+						continue;
+					}
+
+					putback_char = c;
+					break;
+				}
+			} catch (IndexOutOfRangeException) {
+				Report.Error (645, Location, "Identifier too long (limit is 512 chars)");
+				--pos;
+				col += pos;
+			}
+
+			col += pos - 1;
+
+			//
+			// Optimization: avoids doing the keyword lookup
+			// on uppercase letters
+			//
+			if (!quoted && !is_config_ident && id_builder [0] >= '_') {
+				int keyword = GetKeyword (id_builder, pos);
+				if (keyword != -1) {
+					val = ltb.Create (keyword == Token.AWAIT ? "await" : null, current_source, ref_line, column);
+					if (keyword == Token.ELSE && do_auto_semi_insertion(parse_token, line, -1, keyword)) 
+						return Token.SEMICOLON;
+					return keyword;
+				}
+			}
+
+			string s = InternIdentifier (id_builder, pos);
+
+			val = ltb.Create (s, current_source, ref_line, column);
+			if (quoted && parsing_attribute_section)
+				AddEscapedIdentifier (((LocatedToken) val).Location);
+
+			return is_config_ident ? Token.IDENTIFIER_CONFIG : 
+				((parsing_modifiers && !parsing_attribute_section) ? Token.IDENTIFIER_MODIFIER : Token.IDENTIFIER);
+		}
+
+		string InternIdentifier (char[] charBuffer, int length)
+		{
+			//
+			// Keep identifiers in an array of hashtables to avoid needless
+			// allocations
+			//
+			var identifiers_group = identifiers[length];
+			string s;
+			if (identifiers_group != null) {
+				if (identifiers_group.TryGetValue (charBuffer, out s)) {
+					return s;
+				}
+			} else {
+				// TODO: this should be number of files dependant
+				// corlib compilation peaks at 1000 and System.Core at 150
+				int capacity = length > 20 ? 10 : 100;
+				identifiers_group = new Dictionary<char[], string> (capacity, new IdentifiersComparer (length));
+				identifiers[length] = identifiers_group;
+			}
+
+			char[] chars = new char[length];
+			Array.Copy (charBuffer, chars, length);
+
+			s = new string (charBuffer, 0, length);
+			identifiers_group.Add (chars, s);
+			return s;
+		}
+		
+		public int xtoken (bool parse_token = false)
+		{
+			int d, c, next;
+
+			// Allow next token to be pushed back if we insert semicolons
+			if (putback_token != -1) {
+				next = putback_token;
+				putback_token = -1;
+				return next;
+			}
+
+			// Decrement parse regex counter (allows regex literals to follow 1 token after 
+			// symbols '=', ':', '(', '[', and ',')
+			if (parse_regex_xml > 0)
+				parse_regex_xml--;
+
+			// Decrement parse colon counter (allows us to disambiguate ident:*=value from *= operator)
+			if (parse_colon > 0)
+				parse_colon--;
+
+			// Decrement allow auto semi counter (allows us to allow semicolon insertion only after next x symbols)
+			if (allow_auto_semi_after > 0)
+				allow_auto_semi_after--;
+
+			// Whether we have seen comments on the current line
+			bool comments_seen = false;
+			while ((c = get_char ()) != -1) {
+				switch (c) {
+				case '\t':
+					col = ((col - 1 + tab_size) / tab_size) * tab_size;
+					continue;
+
+				case ' ':
+				case '\f':
+				case '\v':
+				case 0xa0:
+				case 0:
+				case 0xFEFF:	// Ignore BOM anywhere in the file
+					continue;
+
+/*				This is required for compatibility with .NET
+				case 0xEF:
+					if (peek_char () == 0xBB) {
+						PushPosition ();
+						get_char ();
+						if (get_char () == 0xBF)
+							continue;
+						PopPosition ();
+					}
+					break;
+*/
+				case '\\':
+					tokens_seen = true;
+					return consume_identifier (parse_token, c);
+
+				case '{':
+					val = ltb.Create (current_source, ref_line, col);
+					if (current_token == Token.OPEN_PARENS || 
+					  current_token == Token.ASSIGN ||
+					  current_token == Token.COMMA ||
+					  current_token == Token.COLON ||
+					  current_token == Token.OPEN_BRACKET ||
+					  current_token == Token.OPEN_BRACKET_EXPR ||
+					  current_token == Token.RETURN) {
+						bool isInit = true;
+						PushPosition();
+						next = token ();
+						if (next != Token.CLOSE_BRACE) {
+							if (next != Token.IDENTIFIER && next != Token.LITERAL) {
+								isInit = false;
+							} else {
+								next = token ();
+								if (next != Token.COLON) {
+									isInit = false;
+								}
+							}
+						}
+						PopPosition();
+						if (isInit) 
+							return Token.OPEN_BRACE_INIT;
+					}
+					return Token.OPEN_BRACE;
+				case '}':
+					if (do_auto_semi_insertion (parse_token, line, c, -1))
+						return Token.SEMICOLON;
+					val = ltb.Create (current_source, ref_line, col);
+					return Token.CLOSE_BRACE;
+				case '[':
+					// To block doccomment inside attribute declaration.
+					if (doc_state == XmlCommentState.Allowed)
+						doc_state = XmlCommentState.NotAllowed;
+
+					val = ltb.Create (current_source, ref_line, col);
+
+					parse_regex_xml = 2;  // regex literals may be included in array initializers.
+
+					if (parsing_block == 0 || lambda_arguments_parsing)
+						return Token.OPEN_BRACKET;
+
+					next = peek_char ();
+					switch (next) {
+					case ']':
+					case ',':
+						return Token.OPEN_BRACKET;
+
+					case ' ':
+					case '\f':
+					case '\v':
+					case '\r':
+					case '\n':
+					case '/':
+						next = peek_token ();
+						if (next == Token.COMMA || next == Token.CLOSE_BRACKET)
+							return Token.OPEN_BRACKET;
+
+						return Token.OPEN_BRACKET_EXPR;
+					default:
+						return Token.OPEN_BRACKET_EXPR;
+					}
+				case ']':
+					ltb.CreateOptional (current_source, ref_line, col, ref val);
+					return Token.CLOSE_BRACKET;
+				case '(':
+					val = ltb.Create (current_source, ref_line, col);
+					parse_regex_xml = 2; // regex literals may follow open parens (method param, expressions).
+					//
+					// An expression versions of parens can appear in block context only
+					//
+					if (parsing_block != 0 && !lambda_arguments_parsing) {
+						
+						//
+						// Optmize most common case where we know that parens
+						// is not special
+						//
+						switch (current_token) {
+						case Token.IDENTIFIER:
+						case Token.IF:
+						case Token.FOR:
+						case Token.FOR_EACH:
+						case Token.TYPEOF:
+						case Token.WHILE:
+						case Token.USING:
+						case Token.DEFAULT:
+						case Token.DELEGATE:
+						case Token.OP_GENERICS_GT:
+							return Token.OPEN_PARENS;
+						}
+
+						// Optimize using peek
+						int xx = peek_char ();
+						switch (xx) {
+						case '(':
+						case '\'':
+						case '"':
+						case '0':
+						case '1':
+							return Token.OPEN_PARENS;
+						}
+
+						lambda_arguments_parsing = true;
+						PushPosition ();
+						d = TokenizeOpenParens ();
+						PopPosition ();
+						lambda_arguments_parsing = false;
+						return d;
+					}
+
+					return Token.OPEN_PARENS;
+				case ')':
+//					d = peek_char ();
+//					if (d == '.') {
+//						get_char ();
+//						return Token.CLOSE_PARENS_DOT;
+//					}
+					ltb.CreateOptional (current_source, ref_line, col, ref val);
+					return Token.CLOSE_PARENS;
+				case ',':
+					ltb.CreateOptional (current_source, ref_line, col, ref val);
+					parse_regex_xml = 2; // Regex literals may follow commas, (method param, initializer element)
+					return Token.COMMA;
+				case ';':
+					ltb.CreateOptional (current_source, ref_line, col, ref val);
+					return Token.SEMICOLON;
+				case '~':
+					val = ltb.Create (current_source, ref_line, col);
+					return Token.TILDE;
+				case '?':
+					val = ltb.Create (current_source, ref_line, col);
+					return TokenizePossibleNullableType ();
+
+				case '<':
+					val = ltb.Create (current_source, ref_line, col);
+					d = peek_char ();
+
+					if (d == '=') {
+						get_char ();
+						return Token.OP_LE;
+					}
+
+					if (d == '<') {
+						get_char ();
+						d = peek_char ();
+
+						if (d == '=') {
+							get_char ();
+							return Token.OP_SHIFT_LEFT_ASSIGN;
+						}
+						return Token.OP_SHIFT_LEFT;
+					}
+
+					if (parse_regex_xml > 0 && char.IsLetter ((char)d)) {
+						return consume_xml();
+					}
+
+					return Token.OP_LT;
+
+				case '>':
+					val = ltb.Create (current_source, ref_line, col);
+					d = peek_char ();
+
+					if (parsing_generic_less_than > 1 || (parsing_generic_less_than == 1 && d != '>')) {
+						parsing_generic_less_than--;
+						return Token.OP_GENERICS_GT;
+					}
+
+					if (d == '=') {
+						get_char ();
+						return Token.OP_GE;
+					}
+
+					if (d == '>') {
+						get_char ();
+						d = peek_char ();
+
+						if (d == '=') {
+							get_char ();
+							return Token.OP_SHIFT_RIGHT_ASSIGN;
+						}
+
+						if (d == '>') {
+							get_char ();
+							d = peek_char ();
+
+							if (d == '=') {
+								get_char ();
+								return Token.OP_USHIFT_RIGHT_ASSIGN;
+							}
+
+							return Token.OP_USHIFT_RIGHT;
+						}
+						return Token.OP_SHIFT_RIGHT;
+					}
+
+					return Token.OP_GT;
+
+				case '+':
+					val = ltb.Create (current_source, ref_line, col);
+					d = peek_char ();
+					if (d == '+') {
+						d = Token.OP_INC;
+					} else if (d == '=') {
+						d = Token.OP_ADD_ASSIGN;
+					} else {
+						return Token.PLUS;
+					}
+					get_char ();
+					return d;
+
+				case '-':
+					val = ltb.Create (current_source, ref_line, col);
+					d = peek_char ();
+					if (d == '-') {
+						d = Token.OP_DEC;
+					} else if (d == '=')
+						d = Token.OP_SUB_ASSIGN;
+					else if (d == '>')
+						d = Token.OP_PTR;
+					else {
+						return Token.MINUS;
+					}
+					get_char ();
+					return d;
+
+				case '!':
+					val = ltb.Create (current_source, ref_line, col);
+					if (peek_char () == '=') {
+						get_char ();
+						if (peek_char () == '=') {
+							get_char ();
+							return Token.OP_REF_NE;
+						}
+						return Token.OP_NE;
+					}
+					return Token.BANG;
+
+				case '=':
+					val = ltb.Create (current_source, ref_line, col);
+					d = peek_char ();
+					if (d == '=') {
+						parse_regex_xml = 2; // Regex literals may follow equality test operators.
+						get_char ();
+						d = peek_char ();
+						if (d == '=') {
+							get_char ();
+							return Token.OP_REF_EQ;
+						}
+						return Token.OP_EQ;
+					}
+					if (d == '>' && parsing_playscript) {
+						get_char ();
+						return Token.ARROW;
+					}
+
+					parse_regex_xml = 2; // Regex literals may follow assignment op '='
+					return Token.ASSIGN;
+
+				case '&':
+					val = ltb.Create (current_source, ref_line, col);
+					d = peek_char ();
+					if (d == '&') {
+						get_char ();
+						d = peek_char ();
+						if (d == '=') {
+							get_char ();
+							return Token.LOGICAL_AND_ASSIGN;
+						}
+						return Token.OP_AND;
+					}
+					if (d == '=') {
+						get_char ();
+						return Token.OP_AND_ASSIGN;
+					}
+					return Token.BITWISE_AND;
+
+				case '|':
+					val = ltb.Create (current_source, ref_line, col);
+					d = peek_char ();
+					if (d == '|') {
+						get_char ();
+						d = peek_char ();
+						if (d == '=') {
+							get_char ();
+							return Token.LOGICAL_OR_ASSIGN;
+						}
+						return Token.OP_OR;
+					}
+					if (d == '=') {
+						get_char ();
+						return Token.OP_OR_ASSIGN;
+					}
+					return Token.BITWISE_OR;
+
+				case '*':
+					val = ltb.Create (current_source, ref_line, col);
+					if (peek_char () == '=' && parse_colon == 0) {
+						get_char ();
+						return Token.OP_MULT_ASSIGN;
+					}
+					return Token.STAR;
+
+				case '/':
+					d = peek_char ();
+					if (d == '=') {
+						val = ltb.Create (current_source, ref_line, col);
+						get_char ();
+						return Token.OP_DIV_ASSIGN;
+					}
+
+					// Handle double-slash comments.
+					if (d == '/') {
+						get_char ();
+						if (doc_processing) {
+							if (peek_char () == '/') {
+								get_char ();
+								// Don't allow ////.
+								if ((d = peek_char ()) != '/') {
+									if (position_stack.Count == 0)
+										sbag.PushCommentChar (d);
+									if (doc_state == XmlCommentState.Allowed)
+										handle_one_line_xml_comment ();
+									else if (doc_state == XmlCommentState.NotAllowed)
+										WarningMisplacedComment (Location - 3);
+								}
+							} else {
+								if (xml_comment_buffer.Length > 0)
+									doc_state = XmlCommentState.NotAllowed;
+							}
+						} else {
+							bool isDoc = peek_char () == '/';
+							if (position_stack.Count == 0)
+								sbag.StartComment (isDoc ? SpecialsBag.CommentType.Documentation : SpecialsBag.CommentType.Single, startsLine, line, col - 1);
+							if (isDoc)
+								get_char ();
+						}
+
+						d = peek_char ();
+						int endLine = line, endCol = col;
+						while ((d = get_char ()) != -1 && (d != '\n') && d != '\r') {
+							if (position_stack.Count == 0)
+								sbag.PushCommentChar (d);
+							endLine = line;
+							endCol = col;
+						}
+						if (position_stack.Count == 0)
+							sbag.EndComment (endLine, endCol + 1);
+
+						any_token_seen |= tokens_seen;
+						tokens_seen = false;
+						comments_seen = false;
+						continue;
+					} else if (d == '*') {
+						if (position_stack.Count == 0)
+							sbag.StartComment (SpecialsBag.CommentType.Multi, startsLine, line, col);
+						get_char ();
+						// Handle /*@asx conditional comment
+						if (peek_char () == '@') {
+							PushPosition();
+							get_char ();
+							if (peek_char() == 'a') {
+								get_char ();
+								if (peek_char () == 's') {
+									get_char ();
+									if (peek_char () == 'x') {
+										get_char ();
+										DiscardPosition();
+										continue;
+									}
+								}
+							}
+							PopPosition();
+						}
+						bool docAppend = false;
+						if (doc_processing && peek_char () == '*') {
+							int ch = get_char ();
+							// But when it is /**/, just do nothing.
+							if (peek_char () == '/') {
+								ch = get_char ();
+								if (position_stack.Count == 0) {
+									sbag.EndComment (line, col + 1);
+								}
+								continue;
+							} else {
+								if (position_stack.Count == 0)
+									sbag.PushCommentChar (ch);
+							}
+							if (doc_state == XmlCommentState.Allowed)
+								docAppend = true;
+							else if (doc_state == XmlCommentState.NotAllowed) {
+								WarningMisplacedComment (Location - 2);
+							}
+						}
+
+						int current_comment_start = 0;
+						if (docAppend) {
+							current_comment_start = xml_comment_buffer.Length;
+							xml_comment_buffer.Append (Environment.NewLine);
+						}
+
+						while ((d = get_char ()) != -1){
+							if (d == '*' && peek_char () == '/'){
+								get_char ();
+								if (position_stack.Count == 0)
+									sbag.EndComment (line, col + 1);
+								comments_seen = true;
+								break;
+							} else {
+								if (position_stack.Count == 0)
+									sbag.PushCommentChar (d);
+							}
+							if (docAppend)
+								xml_comment_buffer.Append ((char) d);
+							
+							if (d == '\n'){
+								any_token_seen |= tokens_seen;
+								tokens_seen = false;
+								// 
+								// Reset 'comments_seen' just to be consistent.
+								// It doesn't matter either way, here.
+								//
+								comments_seen = false;
+							}
+						}
+						
+						if (!comments_seen)
+							Report.Error (1035, Location, "End-of-file found, '*/' expected");
+
+						if (docAppend)
+							update_formatted_doc_comment (current_comment_start);
+						continue;
+					} else if (parse_regex_xml > 0) {
+						// A regex literal may follow an '=', '==', '===' '(' ',' ':' or '['. 
+						return consume_regex();
+					}
+					val = ltb.Create (current_source, ref_line, col);
+					return Token.DIV;
+
+				case '%':
+					val = ltb.Create (current_source, ref_line, col);
+					if (peek_char () == '=') {
+						get_char ();
+						return Token.OP_MOD_ASSIGN;
+					}
+					return Token.PERCENT;
+
+				case '^':
+					val = ltb.Create (current_source, ref_line, col);
+					if (peek_char () == '=') {
+						get_char ();
+						return Token.OP_XOR_ASSIGN;
+					}
+					return Token.CARRET;
+
+				case ':':
+					val = ltb.Create (current_source, ref_line, col);
+					if (peek_char () == ':') {
+						get_char ();
+						return Token.DOUBLE_COLON;
+					}
+					parse_regex_xml = 2;  // Regex literals may follow colons in object initializers.
+					parse_colon = 2;  // Don't parse *= after a colon 
+					return Token.COLON;
+
+				case '0': case '1': case '2': case '3': case '4':
+				case '5': case '6': case '7': case '8': case '9':
+					tokens_seen = true;
+					return is_number (c);
+
+				case '\n': // white space
+					if (do_auto_semi_insertion (parse_token, line - 1, c, -1))
+						return Token.SEMICOLON;
+					any_token_seen |= tokens_seen;
+					tokens_seen = false;
+					comments_seen = false;
+					continue;
+
+				case '.':
+					tokens_seen = true;
+					d = peek_char ();
+					if (d >= '0' && d <= '9') 
+						return is_number (c);
+
+					if (d == '@') {
+						get_char ();
+						return Token.DOT_AT;
+					}
+
+					if (d == '*') {
+						get_char ();
+						return Token.DOT_STAR;
+					}
+
+//					if (d == '(') {
+//						get_char ();
+//						return Token.DOT_OPEN_PARENS;
+//					}
+
+					if (d == '.') {
+						get_char ();
+						d = peek_char ();
+						if (d == '.') {
+							get_char ();
+							return Token.DOTDOTDOT;
+						}
+						if (d == '@') {
+							get_char ();
+							return Token.DOTDOT_AT;
+						}
+						if (d == '*') {
+							get_char ();
+							return Token.DOTDOT_STAR;
+						}
+						return Token.DOTDOT;
+					}
+
+					ltb.CreateOptional (current_source, ref_line, col, ref val);
+					if (d != '<') {
+						return Token.DOT;
+					}
+					get_char ();
+					parsing_generic_less_than++;
+					int dim;
+					PushPosition ();
+					if (parse_generic_dimension (out dim)) {
+						val = dim;
+						DiscardPosition ();
+						return Token.GENERIC_DIMENSION;
+					}
+					PopPosition ();
+					return Token.OP_GENERICS_LT;
+				
+				case '#':
+					if (tokens_seen || comments_seen) {
+						Eror_WrongPreprocessorLocation ();
+						return Token.ERROR;
+					}
+					
+					if (ParsePreprocessingDirective (true))
+						continue;
+					sbag.StartComment (SpecialsBag.CommentType.InactiveCode, false, line, 1);
+					bool directive_expected = false;
+					while ((c = get_char ()) != -1) {
+						if (col == 1) {
+							directive_expected = true;
+						} else if (!directive_expected) {
+							// TODO: Implement comment support for disabled code and uncomment this code
+//							if (c == '#') {
+//								Eror_WrongPreprocessorLocation ();
+//								return Token.ERROR;
+//							}
+							sbag.PushCommentChar (c);
+							continue;
+						}
+
+						if (c == ' ' || c == '\t' || c == '\n' || c == '\f' || c == '\v') {
+							sbag.PushCommentChar (c);
+							continue;
+						}
+
+						if (c == '#') {
+							if (ParsePreprocessingDirective (false))
+								break;
+						}
+						sbag.PushCommentChar (c);
+						directive_expected = false;
+					}
+					sbag.EndComment (line, col);
+					if (c != -1) {
+						tokens_seen = false;
+						continue;
+					}
+
+					return Token.EOF;
+				
+				case '"':
+					return consume_string (false, '"');
+				case '\'':
+					return consume_string (false, '\'');
+
+//				case '\'':
+//					return TokenizeBackslash ();
+				
+				case '@':
+					if (!parsing_playscript)
+						return Token.OP_AT;
+
+					c = get_char ();
+					if (c == '"') {
+						tokens_seen = true;
+						return consume_string (true);
+					}
+
+					// Handle end @asx*/ conditional comment
+					PushPosition();
+					if (c == 'a') {
+						if (peek_char () == 's') {
+							get_char ();
+							if (peek_char () == 'x') {
+								get_char ();
+								if (peek_char () == '*') {
+									get_char ();
+									if (peek_char () == '/') {
+										get_char ();
+										DiscardPosition();
+										continue;
+									}
+								}
+							}
+						}
+					}
+					PopPosition();
+
+					if (is_identifier_start_character (c)){
+						return consume_identifier (parse_token, c, true);
+					}
+
+					Report.Error (1646, Location, "Keyword, identifier, or string expected after verbatim specifier: @");
+					return Token.ERROR;
+
+				case EvalStatementParserCharacter:
+					return Token.EVAL_STATEMENT_PARSER;
+				case EvalCompilationUnitParserCharacter:
+					return Token.EVAL_COMPILATION_UNIT_PARSER;
+				case EvalUsingDeclarationsParserCharacter:
+					return Token.EVAL_USING_DECLARATIONS_UNIT_PARSER;
+				case DocumentationXref:
+					return Token.DOC_SEE;
+				}
+
+				if (is_identifier_start_character (c)) {
+					tokens_seen = true;
+					return consume_identifier (parse_token, c);
+				}
+
+				if (char.IsWhiteSpace ((char) c))
+					continue;
+
+				Report.Error (1056, Location, "Unexpected character `{0}'", ((char) c).ToString ());
+			}
+
+			if (CompleteOnEOF){
+				if (generated)
+					return Token.COMPLETE_COMPLETION;
+				
+				generated = true;
+				return Token.GENERATE_COMPLETION;
+			}
+			
+
+			return Token.EOF;
+		}
+
+//		int TokenizeBackslash ()
+//		{
+//#if FULL_AST
+//			int read_start = reader.Position;
+//#endif
+//			Location start_location = Location;
+//			int c = get_char ();
+//			tokens_seen = true;
+//			if (c == '\'') {
+//				val = new CharLiteral (context.BuiltinTypes, (char) c, start_location);
+//				Report.Error (1011, start_location, "Empty character literal");
+//				return Token.LITERAL;
+//			}
+//
+//			if (c == '\n') {
+//				Report.Error (1010, start_location, "Newline in constant");
+//				return Token.ERROR;
+//			}
+//
+//			int d;
+//			c = escape (c, out d);
+//			if (c == -1)
+//				return Token.ERROR;
+//			if (d != 0)
+//				throw new NotImplementedException ();
+//
+//			ILiteralConstant res = new CharLiteral (context.BuiltinTypes, (char) c, start_location);
+//			val = res;
+//			c = get_char ();
+//
+//			if (c != '\'') {
+//				Report.Error (1012, start_location, "Too many characters in character literal");
+//
+//				// Try to recover, read until newline or next "'"
+//				while ((c = get_char ()) != -1) {
+//					if (c == '\n' || c == '\'')
+//						break;
+//				}
+//			}
+//
+//#if FULL_AST
+//			res.ParsedValue = reader.ReadChars (read_start - 1, reader.Position);
+//#endif
+//
+//			return Token.LITERAL;
+//		}
+
+
+		//
+		// Handles one line xml comment
+		//
+		private void handle_one_line_xml_comment ()
+		{
+			int c;
+			while ((c = peek_char ()) == ' ')
+				get_char (); // skip heading whitespaces.
+			while ((c = peek_char ()) != -1 && c != '\n' && c != '\r') {
+				xml_comment_buffer.Append ((char) get_char ());
+			}
+			if (c == '\r' || c == '\n')
+				xml_comment_buffer.Append (Environment.NewLine);
+		}
+
+		//
+		// Remove heading "*" in Javadoc-like xml documentation.
+		//
+		private void update_formatted_doc_comment (int current_comment_start)
+		{
+			int length = xml_comment_buffer.Length - current_comment_start;
+			string [] lines = xml_comment_buffer.ToString (
+				current_comment_start,
+				length).Replace ("\r", "").Split ('\n');
+			
+			// The first line starts with /**, thus it is not target
+			// for the format check.
+			for (int i = 1; i < lines.Length; i++) {
+				string s = lines [i];
+				int idx = s.IndexOf ('*');
+				string head = null;
+				if (idx < 0) {
+					if (i < lines.Length - 1)
+						return;
+					head = s;
+				} else
+					head = s.Substring (0, idx);
+				foreach (char c in head)
+					if (c != ' ')
+						return;
+				lines [i] = s.Substring (idx + 1);
+			}
+			xml_comment_buffer.Remove (current_comment_start, length);
+			xml_comment_buffer.Insert (current_comment_start, String.Join (Environment.NewLine, lines));
+		}
+
+		//
+		// Checks if there was incorrect doc comments and raise
+		// warnings.
+		//
+		public void check_incorrect_doc_comment ()
+		{
+			if (xml_comment_buffer.Length > 0)
+				WarningMisplacedComment (Location);
+		}
+
+		//
+		// Consumes the saved xml comment lines (if any)
+		// as for current target member or type.
+		//
+		public string consume_doc_comment ()
+		{
+			if (xml_comment_buffer.Length > 0) {
+				string ret = xml_comment_buffer.ToString ();
+				reset_doc_comment ();
+				return ret;
+			}
+			return null;
+		}
+
+		Report Report {
+			get { return context.Report; }
+		}
+
+		void reset_doc_comment ()
+		{
+			xml_comment_buffer.Length = 0;
+		}
+
+		bool do_auto_semi_insertion (bool parse_token, int line, int c, int t)
+		{
+			bool insert_semi = false;
+			if (parse_token && prev_token_line == line && prev_token != Token.SEMICOLON && !parsing_playscript && allow_auto_semi && 
+			    allow_auto_semi_after == 0 && allowed_auto_semi_tokens[prev_token]) {
+				PushPosition ();
+				int next = xtoken ();
+				PopPosition ();
+				if (!disallowed_next_auto_semi_tokens[next]) {
+					if (c != -1)
+						putback (c);
+					else
+						token_putback (t);
+					warn_semi_inserted (Location);
+					insert_semi = true;
+				}
+			}
+			if (parse_token && has_temp_auto_semi_after_tokens)
+				clear_temp_auto_semi_tokens ();
+			return insert_semi;
+		}
+
+		void warn_semi_inserted (Location loc) 
+		{
+			Report.Warning (7093, 1, loc, "Semicolon automatically inserted on unterminated line.");
+		}
+
+		void clear_temp_auto_semi_tokens ()
+		{
+			var len = temp_auto_semi_after_tokens.Count;
+			for (var i = 0; i < len; i++) {
+				int token = temp_auto_semi_after_tokens[i];
+				allowed_auto_semi_tokens.Set (token, false);
+			}
+			has_temp_auto_semi_after_tokens = false;
+		}
+
+		public void cleanup ()
+		{
+			if (ifstack != null && ifstack.Count >= 1) {
+				int state = ifstack.Pop ();
+				if ((state & REGION) != 0)
+					Report.Error (1038, Location, "#endregion directive expected");
+				else 
+					Report.Error (1027, Location, "Expected `#endif' directive");
+			}
+		}
+	}
+
+	//
+	// Indicates whether it accepts XML documentation or not.
+	//
+	public enum XmlCommentState {
+		// comment is allowed in this state.
+		Allowed,
+		// comment is not allowed in this state.
+		NotAllowed,
+		// once comments appeared when it is NotAllowed, then the
+		// state is changed to it, until the state is changed to
+		// .Allowed.
+		Error
+	}
+}
+
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/reflection.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/reflection.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/reflection.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/reflection.cs	2013-04-23 21:04:54.000000000 -0700
@@ -17,7 +17,7 @@ using System.Runtime.CompilerServices;
 using System.Reflection.Emit;
 using System.Security;
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 #if STATIC
 	public class ReflectionImporter
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/report.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/report.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/report.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/report.cs	2013-04-23 21:04:54.000000000 -0700
@@ -14,7 +14,7 @@ using System.Text;
 using System.Collections.Generic;
 using System.Diagnostics;
 
-namespace Mono.CSharp {
+namespace Mono.CSharpPs {
 
 	//
 	// Errors and warnings manager
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/settings.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/settings.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/settings.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/settings.cs	2013-04-23 21:04:54.000000000 -0700
@@ -19,7 +19,7 @@ using System.Text;
 using System.Globalization;
 using System;
 
-namespace Mono.CSharp {
+namespace Mono.CSharpPs {
 
 	public enum LanguageVersion
 	{
@@ -42,7 +42,8 @@ namespace Mono.CSharp {
 
 	public enum Target
 	{
-		Library, Exe, Module, WinExe
+		Library = 1, Exe = 2, Module = 4, WinExe = 8, JavaScript = 16, Cpp = 32, 
+		IsTextTarget = 48
 	}
 
 	public enum Platform
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/statement.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/statement.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/statement.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/statement.cs	2013-04-23 21:04:54.000000000 -0700
@@ -20,7 +20,7 @@ using IKVM.Reflection.Emit;
 using System.Reflection.Emit;
 #endif
 
-namespace Mono.CSharp {
+namespace Mono.CSharpPs {
 	
 	public abstract class Statement {
 		public Location loc;
@@ -1408,6 +1408,7 @@ namespace Mono.CSharp {
 		bool IsDeclared { get; }
 		bool IsParameter { get; }
 		Location Location { get; }
+		FullNamedExpression TypeExpr { get; set; }
 	}
 
 	public class BlockVariableDeclaration : Statement
@@ -1415,20 +1416,24 @@ namespace Mono.CSharp {
 		public class Declarator
 		{
 			LocalVariable li;
+			FullNamedExpression type_expr;
 			Expression initializer;
+			Location loc;
 
-			public Declarator (LocalVariable li, Expression initializer)
+			public Declarator (LocalVariable li, Expression initializer, FullNamedExpression type_expr = null)
 			{
 				if (li.Type != null)
 					throw new ArgumentException ("Expected null variable type");
 
 				this.li = li;
+				this.type_expr = type_expr;
 				this.initializer = initializer;
 			}
 
 			public Declarator (Declarator clone, Expression initializer)
 			{
 				this.li = clone.li;
+				this.type_expr = clone.type_expr;
 				this.initializer = initializer;
 			}
 
@@ -1449,6 +1454,24 @@ namespace Mono.CSharp {
 				}
 			}
 
+			public FullNamedExpression TypeExpression {
+				get { 
+					return type_expr; 
+				}
+				set {
+					type_expr = value;
+				}
+			}
+
+			public Location Location {
+				get {
+					return loc;
+				}
+				set {
+					loc = value;
+				}
+			}
+
 			#endregion
 		}
 
@@ -1734,8 +1757,10 @@ namespace Mono.CSharp {
 			UsingVariable = 1 << 7,
 //			DefinitelyAssigned = 1 << 8,
 			IsLocked = 1 << 9,
+			AsIgnoreMultiple = 1 << 10,  // ActionScript: Should ignore multiple decls
 
-			ReadonlyMask = ForeachVariable | FixedVariable | UsingVariable
+			ReadonlyMask = ForeachVariable | FixedVariable | UsingVariable,
+			CreateBuilderMask = CompilerGenerated | AsIgnoreMultiple
 		}
 
 		TypeSpec type;
@@ -1750,6 +1775,9 @@ namespace Mono.CSharp {
 
 		LocalBuilder builder;
 
+		// PlayScript - We need a copy of the type expression here to handle default initialization.
+		FullNamedExpression typeExpr;
+
 		public LocalVariable (Block block, string name, Location loc)
 		{
 			this.block = block;
@@ -1794,6 +1822,16 @@ namespace Mono.CSharp {
 			}
 		}
 
+		// ActionScript - Needs type expression to detect when two local declarations are the same declaration.
+		public FullNamedExpression TypeExpr {
+			get { 
+				return typeExpr; 
+			}
+			set { 
+				typeExpr = value; 
+			}
+		}
+
 		//
 		// Hoisted local variable variant
 		//
@@ -1878,6 +1916,15 @@ namespace Mono.CSharp {
 			}
 		}
 
+		public Flags DeclFlags {
+			get {
+				return flags;
+			}
+			set {
+				flags = value;
+			}
+		}
+
 		#endregion
 
 		public void CreateBuilder (EmitContext ec)
@@ -2694,6 +2741,8 @@ namespace Mono.CSharp {
 			public VariableInfo VariableInfo;
 			bool is_locked;
 
+			private FullNamedExpression typeExpr;
+
 			public ParameterInfo (ParametersBlock block, int index)
 			{
 				this.block = block;
@@ -2753,6 +2802,16 @@ namespace Mono.CSharp {
 				}
 			}
 
+			// ActionScript - Needs type expression to detect when two local declarations are the same declaration.
+			public FullNamedExpression TypeExpr {
+				get {
+					return typeExpr;
+				}
+				set {
+					typeExpr = value;
+				}
+			}
+
 			#endregion
 
 			public Expression CreateReferenceExpression (ResolveContext rc, Location loc)
@@ -5886,6 +5945,24 @@ namespace Mono.CSharp {
 	}
 
 	/// <summary>
+	/// PlayScript ForEach type.
+	/// </summary>/
+	public enum AsForEachType {
+		/// <summary>
+		/// Generate a normal cs foreach statement.
+		/// </summary>
+		CSharpForEach,
+		/// <summary>
+		/// Generate an PlayScript for (var a in collection) statement.  Yields keys.
+		/// </summary>
+		ForEachKey,
+		/// <summary>
+		/// Generate an PlayScript for each (var a in collection) statement.  Yields values.
+		/// </summary>
+		ForEachValue
+	}
+
+	/// <summary>
 	///   Implementation of the foreach C# statement
 	/// </summary>
 	public class Foreach : Statement
@@ -6376,11 +6453,13 @@ namespace Mono.CSharp {
 			#endregion
 		}
 
+		FullNamedExpression varRef;
 		Expression type;
 		LocalVariable variable;
 		Expression expr;
 		Statement statement;
 		Block body;
+		AsForEachType asForEachType = AsForEachType.CSharpForEach;
 
 		public Foreach (Expression type, LocalVariable var, Expression expr, Statement stmt, Block body, Location l)
 		{
@@ -6392,6 +6471,22 @@ namespace Mono.CSharp {
 			loc = l;
 		}
 
+		public Foreach (Expression type, LocalVariable var, Expression expr, Statement stmt, Block body, AsForEachType asType, Location l) 
+			: this(type, var, expr, stmt, body, l)
+		{
+			asForEachType = asType;
+		}
+
+		public Foreach (FullNamedExpression varRef, Expression expr, Statement stmt, Block body, AsForEachType asType, Location l)
+		{
+			this.varRef = varRef;
+			this.expr = expr;
+			this.statement = stmt;
+			this.body = body;
+			asForEachType = asType;
+			loc = l;
+		}
+
 		public Expression Expr {
 			get { return expr; }
 		}
@@ -6400,6 +6495,10 @@ namespace Mono.CSharp {
 			get { return statement; }
 		}
 
+		public FullNamedExpression VariableRef {
+			get { return varRef; }
+		}
+
 		public Expression TypeExpression {
 			get { return type; }
 		}
@@ -6408,6 +6507,10 @@ namespace Mono.CSharp {
 			get { return variable; }
 		}
 
+		public AsForEachType AsForEachType {
+			get { return asForEachType; }
+		}
+
 		public override bool Resolve (BlockContext ec)
 		{
 			expr = expr.Resolve (ec);
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/support.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/support.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/support.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/support.cs	2013-04-23 21:04:54.000000000 -0700
@@ -17,7 +17,7 @@ using System.IO;
 using System.Text;
 using System.Collections.Generic;
 
-namespace Mono.CSharp {
+namespace Mono.CSharpPs {
 
 	sealed class ReferenceEquality<T> : IEqualityComparer<T> where T : class
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/symbolwriter.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/symbolwriter.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/symbolwriter.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/symbolwriter.cs	2013-04-23 21:04:54.000000000 -0700
@@ -22,7 +22,7 @@ using System.Reflection.Emit;
 
 using Mono.CompilerServices.SymbolWriter;
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	static class SymbolWriter
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/typemanager.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/typemanager.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/typemanager.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/typemanager.cs	2013-04-23 21:04:54.000000000 -0700
@@ -18,7 +18,7 @@ using System.Collections.Generic;
 using System.Text;
 using System.IO;
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	//
 	// All compiler built-in types (they have to exist otherwise the compiler will not work)
@@ -67,12 +67,14 @@ namespace Mono.CSharp
 
 		// Predefined operators tables
 		public readonly Binary.PredefinedOperator[] OperatorsBinaryStandard;
+		public readonly Binary.PredefinedOperator[] AsOperatorsBinaryStandard; // PlayScript - Include BOOL conversions for logical ops
 		public readonly Binary.PredefinedOperator[] OperatorsBinaryEquality;
 		public readonly Binary.PredefinedOperator[] OperatorsBinaryUnsafe;
 		public readonly TypeSpec[][] OperatorsUnary;
 		public readonly TypeSpec[] OperatorsUnaryMutator;
 
 		public readonly TypeSpec[] BinaryPromotionsTypes;
+		public readonly TypeSpec[] AsBinaryPromotionsTypes;  // PlayScript binary promotion types - includes BOOL.
 		public readonly TypeSpec[] SwitchUserTypes;
 
 		readonly BuiltinTypeSpec[] types;
@@ -119,12 +121,15 @@ namespace Mono.CSharp
 			Dynamic = new BuiltinTypeSpec ("dynamic", BuiltinTypeSpec.Type.Dynamic);
 
 			OperatorsBinaryStandard = Binary.CreateStandardOperatorsTable (this);
+			AsOperatorsBinaryStandard = Binary.CreateAsStandardOperatorsTable (this);
 			OperatorsBinaryEquality = Binary.CreateEqualityOperatorsTable (this);
 			OperatorsBinaryUnsafe = Binary.CreatePointerOperatorsTable (this);
 			OperatorsUnary = Unary.CreatePredefinedOperatorsTable (this);
 			OperatorsUnaryMutator = UnaryMutator.CreatePredefinedOperatorsTable (this);
 
 			BinaryPromotionsTypes = ConstantFold.CreateBinaryPromotionsTypes (this);
+			// PlayScript binary promotion types (includes bool).
+			AsBinaryPromotionsTypes = ConstantFold.CreateAsBinaryPromotionsTypes (this);
 			SwitchUserTypes = Switch.CreateSwitchUserTypes (this);
 
 			types = new BuiltinTypeSpec[] {
@@ -188,6 +193,10 @@ namespace Mono.CSharp
 		public readonly PredefinedType IListGeneric;
 		public readonly PredefinedType ICollectionGeneric;
 		public readonly PredefinedType IEnumerableGeneric;
+		public readonly PredefinedType IDictionaryGeneric;
+		public readonly PredefinedType IList;
+		public readonly PredefinedType ICollection;
+		public readonly PredefinedType IDictionary;
 		public readonly PredefinedType Nullable;
 		public readonly PredefinedType Activator;
 		public readonly PredefinedType Interlocked;
@@ -197,7 +206,9 @@ namespace Mono.CSharp
 		public readonly PredefinedType RuntimeMethodHandle;
 		public readonly PredefinedType SecurityAction;
 		public readonly PredefinedType Dictionary;
+		public readonly PredefinedType KeyValuePair;
 		public readonly PredefinedType Hashtable;
+		public readonly PredefinedType List;
 
 		//
 		// C# 3.0
@@ -226,12 +237,35 @@ namespace Mono.CSharp
 		public readonly PredefinedType AsyncTaskMethodBuilder;
 		public readonly PredefinedType AsyncTaskMethodBuilderGeneric;
 		public readonly PredefinedType Action;
+		public readonly PredefinedType Func;
 		public readonly PredefinedType Task;
 		public readonly PredefinedType TaskGeneric;
 		public readonly PredefinedType IAsyncStateMachine;
 		public readonly PredefinedType INotifyCompletion;
 		public readonly PredefinedType ICriticalNotifyCompletion;
 
+		//
+		// Actionscript
+		//
+		public readonly PredefinedType AsObject;
+		public readonly PredefinedType AsVector;
+		public readonly PredefinedType AsArray;
+		public readonly PredefinedType AsError;
+		public readonly PredefinedType AsFunction;
+		public readonly PredefinedType AsUndefined;
+		public readonly PredefinedType AsCallSite;
+		public readonly PredefinedType AsCallSiteGeneric;
+		public readonly PredefinedType AsExpressionType;
+		public readonly PredefinedType AsBinder;
+		public readonly PredefinedType AsBinderFlags;
+		public readonly PredefinedType AsRegExp;
+		public readonly PredefinedType AsXml;
+
+		// PlayScript dynamic binder AOT mode support..
+		private bool checkedAsDynamicMode = false;
+		private bool isAsDynamicMode = false;
+		private bool isAsAotMode = false;
+
 		public PredefinedTypes (ModuleContainer module)
 		{
 			TypedReference = new PredefinedType (module, MemberKind.Struct, "System", "TypedReference");
@@ -248,6 +282,10 @@ namespace Mono.CSharp
 			IListGeneric = new PredefinedType (module, MemberKind.Interface, "System.Collections.Generic", "IList", 1);
 			ICollectionGeneric = new PredefinedType (module, MemberKind.Interface, "System.Collections.Generic", "ICollection", 1);
 			IEnumerableGeneric = new PredefinedType (module, MemberKind.Interface, "System.Collections.Generic", "IEnumerable", 1);
+			IDictionaryGeneric = new PredefinedType (module, MemberKind.Interface, "System.Collections.Generic", "IDictionary", 2);
+			IList = new PredefinedType (module, MemberKind.Interface, "System.Collections", "IList");
+			ICollection = new PredefinedType (module, MemberKind.Interface, "System.Collections", "ICollection");
+			IDictionary = new PredefinedType (module, MemberKind.Interface, "System.Collections", "IDictionary");
 			Nullable = new PredefinedType (module, MemberKind.Struct, "System", "Nullable", 1);
 			Activator = new PredefinedType (module, MemberKind.Class, "System", "Activator");
 			Interlocked = new PredefinedType (module, MemberKind.Class, "System.Threading", "Interlocked");
@@ -257,7 +295,9 @@ namespace Mono.CSharp
 			RuntimeMethodHandle = new PredefinedType (module, MemberKind.Struct, "System", "RuntimeMethodHandle");
 			SecurityAction = new PredefinedType (module, MemberKind.Enum, "System.Security.Permissions", "SecurityAction");
 			Dictionary = new PredefinedType (module, MemberKind.Class, "System.Collections.Generic", "Dictionary", 2);
+			KeyValuePair = new PredefinedType (module, MemberKind.Struct, "System.Collections.Generic", "KeyValuePair", 2);
 			Hashtable = new PredefinedType (module, MemberKind.Class, "System.Collections", "Hashtable");
+			List = new PredefinedType (module, MemberKind.Class, "System.Collections.Generic", "List", 1);
 
 			Expression = new PredefinedType (module, MemberKind.Class, "System.Linq.Expressions", "Expression");
 			ExpressionGeneric = new PredefinedType (module, MemberKind.Class, "System.Linq.Expressions", "Expression", 1);
@@ -274,6 +314,7 @@ namespace Mono.CSharp
 			BinderFlags = new PredefinedType (module, MemberKind.Enum, "Microsoft.CSharp.RuntimeBinder", "CSharpBinderFlags");
 
 			Action = new PredefinedType (module, MemberKind.Delegate, "System", "Action");
+			Func = new PredefinedType (module, MemberKind.Delegate, "System", "Func");
 			AsyncVoidMethodBuilder = new PredefinedType (module, MemberKind.Struct, "System.Runtime.CompilerServices", "AsyncVoidMethodBuilder");
 			AsyncTaskMethodBuilder = new PredefinedType (module, MemberKind.Struct, "System.Runtime.CompilerServices", "AsyncTaskMethodBuilder");
 			AsyncTaskMethodBuilderGeneric = new PredefinedType (module, MemberKind.Struct, "System.Runtime.CompilerServices", "AsyncTaskMethodBuilder", 1);
@@ -283,6 +324,20 @@ namespace Mono.CSharp
 			INotifyCompletion = new PredefinedType (module, MemberKind.Interface, "System.Runtime.CompilerServices", "INotifyCompletion");
 			ICriticalNotifyCompletion = new PredefinedType (module, MemberKind.Interface, "System.Runtime.CompilerServices", "ICriticalNotifyCompletion");
 
+			AsObject = new PredefinedType (module, MemberKind.Class, "PlayScript.Expando", "ExpandoObject");
+			AsArray = new PredefinedType (module, MemberKind.Class, PsConsts.PsRootNamespace, "Array");
+			AsVector = new PredefinedType (module, MemberKind.Class, PsConsts.PsRootNamespace, "Vector", 1);
+			AsError = new PredefinedType (module, MemberKind.Class, PsConsts.PsRootNamespace, "Error");
+			AsFunction = new PredefinedType (module, MemberKind.Class, PsConsts.PsRootNamespace, "Function");
+			AsUndefined = new PredefinedType (module, MemberKind.Class, "PlayScript", "Undefined");
+			AsCallSite = new PredefinedType (module, MemberKind.Class, "PlayScript", "CallSite");
+			AsCallSiteGeneric = new PredefinedType (module, MemberKind.Class, "PlayScript", "CallSite", 1);
+			AsExpressionType = new PredefinedType (module, MemberKind.Enum, "PlayScript", "ExpressionType");
+			AsBinder = new PredefinedType (module, MemberKind.Class, "PlayScript.RuntimeBinder", "Binder");
+			AsBinderFlags = new PredefinedType (module, MemberKind.Enum, "PlayScript.RuntimeBinder", "CSharpBinderFlags");
+			AsRegExp = new PredefinedType (module, MemberKind.Class, PsConsts.PsRootNamespace, "RegExp");
+			AsXml = new PredefinedType (module, MemberKind.Class, PsConsts.PsRootNamespace, "XML");
+
 			//
 			// Define types which are used for comparison. It does not matter
 			// if they don't exist as no error report is needed
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/typespec.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/typespec.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/typespec.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/typespec.cs	2013-04-23 21:04:54.000000000 -0700
@@ -22,7 +22,7 @@ using MetaType = System.Type;
 using System.Reflection;
 #endif
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	//
 	// Inflated or non-inflated representation of any type. 
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/visit.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/visit.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Parser/mcs/visit.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Parser/mcs/visit.cs	2013-04-23 21:04:54.000000000 -0700
@@ -13,7 +13,7 @@
 using System;
 using System.Diagnostics;
 
-namespace Mono.CSharp
+namespace Mono.CSharpPs
 {
 	public abstract class StructuralVisitor
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Properties/AssemblyInfo.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Properties/AssemblyInfo.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Properties/AssemblyInfo.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Properties/AssemblyInfo.cs	2013-04-23 21:04:54.000000000 -0700
@@ -9,5 +9,5 @@ using System.Runtime.InteropServices;
 // General Information about an assembly is controlled through the following 
 // set of attributes. Change these attribute values to modify the information
 // associated with an assembly.
-[assembly: AssemblyTitle("ICSharpCode.NRefactory.CSharp")]
+[assembly: AssemblyTitle("ICSharpCode.NRefactory.PlayScript")]
 [assembly: AssemblyDescription("C# parser and semantic analysis")]
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Properties/GlobalAssemblyInfo.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Properties/GlobalAssemblyInfo.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Properties/GlobalAssemblyInfo.cs	1969-12-31 16:00:00.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Properties/GlobalAssemblyInfo.cs	2013-04-23 21:04:54.000000000 -0700
@@ -0,0 +1,26 @@
+﻿#region Using directives
+
+using System;
+using System.Reflection;
+using System.Runtime.InteropServices;
+
+#endregion
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyCompany("ICSharpCode")]
+[assembly: AssemblyProduct("SharpDevelop/MonoDevelop")]
+[assembly: AssemblyCopyright("Copyright 2010-2013 AlphaSierraPapa")]
+
+// This sets the default COM visibility of types in the assembly to invisible.
+// If you need to expose a type to COM, use [ComVisible(true)] on that type.
+[assembly: ComVisible(false)]
+
+// We keep the AssemblyVersion at 5.0.0.0 for all versions of NRefactory 5.
+// This eliminates the need for binding redirects.
+[assembly: AssemblyVersion("5.0.0.0")]
+
+// [AssemblyFileVersion] is the version of the NuGet package,
+// should follow http://semver.org/ rules
+[assembly: AssemblyFileVersion("5.3.0")]
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/QueryExpressionExpander.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/QueryExpressionExpander.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/QueryExpressionExpander.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/QueryExpressionExpander.cs	2013-04-23 21:04:54.000000000 -0700
@@ -6,7 +6,7 @@ using System.Linq;
 using System.Text;
 using ICSharpCode.NRefactory.PatternMatching;
 
-namespace ICSharpCode.NRefactory.CSharp {
+namespace ICSharpCode.NRefactory.PlayScript {
 	public class QueryExpressionExpansionResult {
 		public AstNode AstNode { get; private set; }
 
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/BaseRefactoringContext.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/BaseRefactoringContext.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/BaseRefactoringContext.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/BaseRefactoringContext.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,18 +27,18 @@
 using System;
 using System.Linq;
 using System.Threading;
-using ICSharpCode.NRefactory.CSharp.Resolver;
-using ICSharpCode.NRefactory.CSharp.TypeSystem;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
+using ICSharpCode.NRefactory.PlayScript.TypeSystem;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 using ICSharpCode.NRefactory.Editor;
 using System.ComponentModel.Design;
-using ICSharpCode.NRefactory.CSharp.Analysis;
+using ICSharpCode.NRefactory.PlayScript.Analysis;
 using ICSharpCode.NRefactory.Utils;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	public abstract class BaseRefactoringContext : IServiceProvider
 	{
@@ -84,7 +84,7 @@ namespace ICSharpCode.NRefactory.CSharp.
 			get { return resolver.Compilation; }
 		}
 
-		public BaseRefactoringContext (ICSharpCode.NRefactory.CSharp.Resolver.CSharpAstResolver resolver, System.Threading.CancellationToken cancellationToken)
+		public BaseRefactoringContext (ICSharpCode.NRefactory.PlayScript.Resolver.CSharpAstResolver resolver, System.Threading.CancellationToken cancellationToken)
 		{
 			this.resolver = resolver;
 			this.cancellationToken = cancellationToken;
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,7 +25,7 @@
 // THE SOFTWARE.
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// A code action provides a code transformation with a description.
@@ -49,7 +49,7 @@ namespace ICSharpCode.NRefactory.CSharp.
 		}
 
 		/// <summary>
-		/// Initializes a new instance of the <see cref="ICSharpCode.NRefactory.CSharp.Refactoring.CodeAction"/> class.
+		/// Initializes a new instance of the <see cref="ICSharpCode.NRefactory.PlayScript.Refactoring.CodeAction"/> class.
 		/// </summary>
 		/// <param name='description'>
 		/// The description.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/AddAnotherAccessorAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/AddAnotherAccessorAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/AddAnotherAccessorAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/AddAnotherAccessorAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 using System.Threading;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// Add another accessor to a property declaration that has only one.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/AddCatchTypeAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/AddCatchTypeAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/AddCatchTypeAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/AddCatchTypeAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -23,10 +23,10 @@
 // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
-using ICSharpCode.NRefactory.CSharp;
+using ICSharpCode.NRefactory.PlayScript;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Add type to general catch clause",
 	               Description = "Adds an exception type specifier to general catch clauses.")]
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/AddUsingAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/AddUsingAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/AddUsingAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/AddUsingAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -22,11 +22,11 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// 1) When a type cannot be resolved, offers to add a using declaration
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CheckIfParameterIsNullAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CheckIfParameterIsNullAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CheckIfParameterIsNullAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CheckIfParameterIsNullAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@
 using ICSharpCode.NRefactory.PatternMatching;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// Creates a 'if (param == null) throw new System.ArgumentNullException ();' contruct for a parameter.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertAnonymousDelegateToLambdaAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertAnonymousDelegateToLambdaAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertAnonymousDelegateToLambdaAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertAnonymousDelegateToLambdaAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Convert anonymous delegate to lambda block",
 	               Description = "Converts an anonymous delegate into a lambda in block form.")]
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertAsToCastAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertAsToCastAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertAsToCastAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertAsToCastAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// Converts an 'as' expression to a cast expression
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertCastToAsAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertCastToAsAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertCastToAsAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertCastToAsAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// Converts a cast expression to an 'as' expression
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertConditionalToIfAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertConditionalToIfAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertConditionalToIfAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertConditionalToIfAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction ("Convert '?:' to 'if'", Description = "Convert '?:' operator to 'if' statement.")]
 	public class ConvertConditionalToIfAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertDecToHexAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertDecToHexAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertDecToHexAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertDecToHexAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 using System.Threading;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// Convert a dec numer to hex. For example: 16 -> 0x10
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertExplicitToImplicitImplementationAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertExplicitToImplicitImplementationAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertExplicitToImplicitImplementationAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertExplicitToImplicitImplementationAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System.Linq;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction ("Convert explicit to implict implementation",
 					Description = " Convert explicit implementation of an interface method to implicit implementation")]
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertForeachToForAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertForeachToForAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertForeachToForAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertForeachToForAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,7 +29,7 @@ using ICSharpCode.NRefactory.TypeSystem;
 using System.Threading;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// Converts a foreach loop to for.
@@ -40,7 +40,7 @@ namespace ICSharpCode.NRefactory.CSharp.
 		static string[] VariableNames = new string[] { "i", "j", "k", "l", "n", "m", "x", "y", "z"};
 		static string[] CollectionNames = new string[] { "list" };
 
-		static string GetName(ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver state, string[] variableNames)
+		static string GetName(ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver state, string[] variableNames)
 		{
 			for (int i = 0; i < 1000; i++) {
 				foreach (var vn in variableNames) {
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertHexToDecAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertHexToDecAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertHexToDecAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertHexToDecAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 using System.Threading;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// Convert a hex numer to dec. For example: 0x10 -> 16
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertIfToConditionalAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertIfToConditionalAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertIfToConditionalAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertIfToConditionalAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System;
 using System.Linq;
 using ICSharpCode.NRefactory.PatternMatching;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction ("Convert 'if' to '?:'", Description = "Convert 'if' statement to '?:' operator.")]
 	public class ConvertIfToConditionalAction : SpecializedCodeAction <IfElseStatement>
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertIfToSwitchAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertIfToSwitchAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertIfToSwitchAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertIfToSwitchAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -30,7 +30,7 @@ using System.Collections.Generic;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.PatternMatching;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction ("Convert 'if' to 'switch'", Description = "Convert 'if' statement to 'switch' statement")]
 	public class ConvertIfToSwitchAction : SpecializedCodeAction<IfElseStatement>
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertImplicitToExplicitImplementationAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertImplicitToExplicitImplementationAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertImplicitToExplicitImplementationAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertImplicitToExplicitImplementationAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction ("Convert implict to explicit implementation",
 					Description = " Convert implict implementation of an interface method to explicit implementation")]
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertLambdaBodyExpressionToStatementAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertLambdaBodyExpressionToStatementAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertLambdaBodyExpressionToStatementAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertLambdaBodyExpressionToStatementAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction ("Converts expression of lambda body to statement",
 					Description = "Converts expression of lambda body to statement")]
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertLambdaBodyStatementToExpressionAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertLambdaBodyStatementToExpressionAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertLambdaBodyStatementToExpressionAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertLambdaBodyStatementToExpressionAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction ("Converts statement of lambda body to expression",
 					Description = "Converts statement of lambda body to expression")]
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertLambdaToAnonymousDelegateAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertLambdaToAnonymousDelegateAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertLambdaToAnonymousDelegateAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertLambdaToAnonymousDelegateAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,11 +24,11 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 using System;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using System.Collections.Generic;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Convert lambda to anonymous delegate",
 	               Description = "Converts a lambda to an anonymous delegate.")]
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertSwitchToIfAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertSwitchToIfAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertSwitchToIfAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertSwitchToIfAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction ("Convert 'switch' to 'if'", Description = "Convert 'switch' statement to 'if' statement")]
 	public class ConvertSwitchToIfAction : SpecializedCodeAction<SwitchStatement>
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertToInitializer/AccessPath.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertToInitializer/AccessPath.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertToInitializer/AccessPath.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertToInitializer/AccessPath.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,13 +24,13 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 using System;
-using ICSharpCode.NRefactory.CSharp.Refactoring;
+using ICSharpCode.NRefactory.PlayScript.Refactoring;
 using ICSharpCode.NRefactory.TypeSystem;
 using System.Collections.Generic;
 using ICSharpCode.NRefactory.Semantics;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	class AccessPath
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertToInitializer/ConvertInitializerToExplicitInitializationsAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertToInitializer/ConvertInitializerToExplicitInitializationsAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertToInitializer/ConvertInitializerToExplicitInitializationsAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertToInitializer/ConvertInitializerToExplicitInitializationsAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Convert to explicit initializers",
 	               Description = "Converts an object or collection initializer to explicit initializations.")]
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertToInitializer/ConvertToInitializerAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertToInitializer/ConvertToInitializerAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertToInitializer/ConvertToInitializerAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertToInitializer/ConvertToInitializerAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 using System.Collections.Generic;
 using ICSharpCode.NRefactory.Semantics;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Convert to initializer",
 	               Description = "Converts a set of assignments and .Add() calls to an initializer.")]
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertToInitializer/StatementsToInitializerConverter.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertToInitializer/StatementsToInitializerConverter.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ConvertToInitializer/StatementsToInitializerConverter.cs	2013-03-14 23:31:36.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ConvertToInitializer/StatementsToInitializerConverter.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,16 +24,16 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 using System;
-using ICSharpCode.NRefactory.CSharp.Refactoring;
+using ICSharpCode.NRefactory.PlayScript.Refactoring;
 using System.Collections.Generic;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.Semantics;
 using System.Linq;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using System.Threading;
 using System.Diagnostics;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	public class StatementsToInitializerConverter
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreateBackingStoreAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreateBackingStoreAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreateBackingStoreAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreateBackingStoreAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 using System;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Create backing store for auto property", Description = "Creates a backing field for an auto property.")]
 	public class CreateBackingStoreAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreateClassDeclarationAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreateClassDeclarationAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreateClassDeclarationAction.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreateClassDeclarationAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,7 +29,7 @@ using ICSharpCode.NRefactory.Semantics;
 using System.Linq;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Create class", Description = "Creates a class declaration out of an object creation.")]
 	public class CreateClassDeclarationAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreateConstructorDeclarationAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreateConstructorDeclarationAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreateConstructorDeclarationAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreateConstructorDeclarationAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,9 +25,9 @@
 // THE SOFTWARE.
 
 using System.Collections.Generic;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Create constructor", Description = "Creates a constructor declaration out of an object creation.")]
 	public class CreateConstructorDeclarationAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreateCustomEventImplementationAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreateCustomEventImplementationAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreateCustomEventImplementationAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreateCustomEventImplementationAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction ("Create custom event implementation", Description = "Create custom event implementation.")]
 	public class CreateCustomEventImplementationAction : SpecializedCodeAction<VariableInitializer>
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreateDelegateAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreateDelegateAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreateDelegateAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreateDelegateAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System.Collections.Generic;
 using ICSharpCode.NRefactory.Semantics;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Create delegate", Description = "Creates a delegate declaration out of an event declaration.")]
 	public class CreateDelegateAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreateEnumValue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreateEnumValue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreateEnumValue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreateEnumValue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,10 +29,10 @@ using System.Linq;
 using ICSharpCode.NRefactory.TypeSystem;
 using System.Threading;
 using System.Collections.Generic;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Semantics;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Create enum value", Description = "Creates an enum value for a undefined enum value.")]
 	public class CreateEnumValue : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreateEventInvocatorAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreateEventInvocatorAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreateEventInvocatorAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreateEventInvocatorAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,7 +29,7 @@ using System.Collections.Generic;
 using ICSharpCode.NRefactory.TypeSystem;
 using System.Threading;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Create event invocator", Description = "Creates a standard OnXXX event method.")]
 	public class CreateEventInvocatorAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreateFieldAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreateFieldAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreateFieldAction.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreateFieldAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -30,10 +30,10 @@ using System.Linq;
 using ICSharpCode.NRefactory.TypeSystem;
 using System.Threading;
 using System.Collections.Generic;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Semantics;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Create field", Description = "Creates a field for a undefined variable.")]
 	public class CreateFieldAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreateIndexerAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreateIndexerAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreateIndexerAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreateIndexerAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,7 +29,7 @@ using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using System.Text;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Create indexer", Description = "Creates an indexer declaration out of an indexer expression.")]
 	public class CreateIndexerAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreateLocalVariableAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreateLocalVariableAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreateLocalVariableAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreateLocalVariableAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,7 +25,7 @@
 // THE SOFTWARE.
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Create local variable", Description = "Creates a local variable for a undefined variable.")]
 	public class CreateLocalVariableAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreateMethodDeclarationAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreateMethodDeclarationAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreateMethodDeclarationAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreateMethodDeclarationAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -30,7 +30,7 @@ using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using System.Text;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Create method", Description = "Creates a method declaration out of an invocation.")]
 	public class CreateMethodDeclarationAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreateOverloadWithoutParameterAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreateOverloadWithoutParameterAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreateOverloadWithoutParameterAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreateOverloadWithoutParameterAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,7 +29,7 @@ using System.Linq;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction ("Create overload without parameter", Description = "Create overload without the selected parameter.")]
 	public class CreateOverloadWithoutParameterAction : SpecializedCodeAction<ParameterDeclaration>
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreatePropertyAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreatePropertyAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/CreatePropertyAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/CreatePropertyAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System.Collections.Generic;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Create property", Description = "Creates a property for a undefined variable.")]
 	public class CreatePropertyAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/DeclareLocalVariableAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/DeclareLocalVariableAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/DeclareLocalVariableAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/DeclareLocalVariableAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,11 +28,11 @@ using System.Threading;
 using System.Collections.Generic;
 using System.Linq;
 using ICSharpCode.NRefactory.Semantics;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.PatternMatching;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Declare local variable", Description = "Declare a local variable out of a selected expression.")]
 	public class DeclareLocalVariableAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ExtensionMethodInvocationToStaticMethodInvocationAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ExtensionMethodInvocationToStaticMethodInvocationAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ExtensionMethodInvocationToStaticMethodInvocationAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ExtensionMethodInvocationToStaticMethodInvocationAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,10 +24,10 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 using System.Collections.Generic;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Invoke using static method syntax",
 	               Description = "Converts the call into static method call syntax.")]
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ExtractAnonymousMethodAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ExtractAnonymousMethodAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ExtractAnonymousMethodAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ExtractAnonymousMethodAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,9 +26,9 @@
 
 using System.Collections.Generic;
 using System.Linq;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction ("Extract anonymous method",
 					Description = "Extract anonymous method to method of the containing type")]
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ExtractFieldAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ExtractFieldAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ExtractFieldAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ExtractFieldAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,9 +27,10 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 using ICSharpCode.NRefactory.PatternMatching;
-using Mono.CSharp;
+using Mono.CSharpPs;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Extract field", Description = "Extracts a field from a local variable declaration.")]
 	public class ExtractFieldAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ExtractMethod/ExtractMethodAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ExtractMethod/ExtractMethodAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ExtractMethod/ExtractMethodAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ExtractMethod/ExtractMethodAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,13 +27,13 @@ using System;
 using System.Collections.Generic;
 using ICSharpCode.NRefactory.Semantics;
 using System.Linq;
-using ICSharpCode.NRefactory.CSharp.Resolver;
-using ICSharpCode.NRefactory.CSharp.Analysis;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Analysis;
 using System.Threading;
 using ICSharpCode.NRefactory.TypeSystem;
 using System.Threading.Tasks;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring.ExtractMethod
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring.ExtractMethod
 {
 	[ContextAction("Extract method", Description = "Creates a new method out of selected text.")]
 	public class ExtractMethodAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ExtractMethod/StaticVisitor.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ExtractMethod/StaticVisitor.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ExtractMethod/StaticVisitor.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ExtractMethod/StaticVisitor.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,9 +27,9 @@
 using System;
 using ICSharpCode.NRefactory.Semantics;
 using System.Linq;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring.ExtractMethod
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring.ExtractMethod
 {
 	class StaticVisitor : DepthFirstAstVisitor
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ExtractMethod/VariableLookupVisitor.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ExtractMethod/VariableLookupVisitor.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ExtractMethod/VariableLookupVisitor.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ExtractMethod/VariableLookupVisitor.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System.Collections.Generic;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring.ExtractMethod
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring.ExtractMethod
 {
 	class VariableLookupVisitor : DepthFirstAstVisitor
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ExtractMethod/VariableUsageAnalyzation.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ExtractMethod/VariableUsageAnalyzation.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ExtractMethod/VariableUsageAnalyzation.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ExtractMethod/VariableUsageAnalyzation.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,7 +29,7 @@ using ICSharpCode.NRefactory.TypeSystem;
 using System.Linq;
 using ICSharpCode.NRefactory.Semantics;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring.ExtractMethod
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring.ExtractMethod
 {
 	
 	public enum VariableState {
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/FlipOperatorArgumentsAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/FlipOperatorArgumentsAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/FlipOperatorArgumentsAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/FlipOperatorArgumentsAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@ using System;
 using System.Threading;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Swaps left and right arguments.", Description = "Swaps left and right arguments.")]
 	public class FlipOperatorArgumentsAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/GenerateGetterAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/GenerateGetterAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/GenerateGetterAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/GenerateGetterAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -30,7 +30,7 @@ using System.Linq;
 using System.Threading;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Generate getter", Description = "Generates a getter for a field.")]
 	public class GenerateGetterAction : ICodeActionProvider
@@ -65,9 +65,9 @@ namespace ICSharpCode.NRefactory.CSharp.
 		
 		static PropertyDeclaration GeneratePropertyDeclaration (RefactoringContext context, FieldDeclaration field, VariableInitializer initializer)
 		{
-			var mod = ICSharpCode.NRefactory.CSharp.Modifiers.Public;
-			if (field.HasModifier (ICSharpCode.NRefactory.CSharp.Modifiers.Static))
-				mod |= ICSharpCode.NRefactory.CSharp.Modifiers.Static;
+			var mod = ICSharpCode.NRefactory.PlayScript.Modifiers.Public;
+			if (field.HasModifier (ICSharpCode.NRefactory.PlayScript.Modifiers.Static))
+				mod |= ICSharpCode.NRefactory.PlayScript.Modifiers.Static;
 			
 			return new PropertyDeclaration () {
 				Modifiers = mod,
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/GeneratePropertyAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/GeneratePropertyAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/GeneratePropertyAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/GeneratePropertyAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -30,7 +30,7 @@ using System.Threading;
 using System.Collections.Generic;
 using ICSharpCode.NRefactory.Semantics;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Generate property", Description = "Generates a getter and setter for a field.")]
 	public class GeneratePropertyAction : ICodeActionProvider
@@ -70,9 +70,9 @@ namespace ICSharpCode.NRefactory.CSharp.
 		
 		static PropertyDeclaration GeneratePropertyDeclaration (RefactoringContext context, FieldDeclaration field, string fieldName)
 		{
-			var mod = ICSharpCode.NRefactory.CSharp.Modifiers.Public;
-			if (field.HasModifier (ICSharpCode.NRefactory.CSharp.Modifiers.Static))
-				mod |= ICSharpCode.NRefactory.CSharp.Modifiers.Static;
+			var mod = ICSharpCode.NRefactory.PlayScript.Modifiers.Public;
+			if (field.HasModifier (ICSharpCode.NRefactory.PlayScript.Modifiers.Static))
+				mod |= ICSharpCode.NRefactory.PlayScript.Modifiers.Static;
 			
 			return new PropertyDeclaration () {
 				Modifiers = mod,
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/GenerateSwitchLabelsAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/GenerateSwitchLabelsAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/GenerateSwitchLabelsAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/GenerateSwitchLabelsAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using ICSharpCode.NRefactory.TypeSystem;
 using System.Threading;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Generate switch labels", Description = "Creates switch lables for enumerations.")]
 	public class GenerateSwitchLabelsAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ImplementAbstractMembersAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ImplementAbstractMembersAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ImplementAbstractMembersAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ImplementAbstractMembersAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,7 +29,7 @@ using System.Threading;
 using System.Collections.Generic;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Implement abstract members", Description = "Implements abstract members from an abstract class.")]
 	public class ImplementAbstractMembersAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ImplementInterfaceAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ImplementInterfaceAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ImplementInterfaceAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ImplementInterfaceAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,7 +29,7 @@ using System.Threading;
 using System.Collections.Generic;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Implement interface", Description = "Creates an interface implementation.")]
 	public class ImplementInterfaceAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ImplementInterfaceExplicitAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ImplementInterfaceExplicitAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ImplementInterfaceExplicitAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ImplementInterfaceExplicitAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -30,7 +30,7 @@ using System.Threading;
 using System.Collections.Generic;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Implement interface explicit", Description = "Creates an interface implementation.")]
 	public class ImplementInterfaceExplicitAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/InlineLocalVariableAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/InlineLocalVariableAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/InlineLocalVariableAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/InlineLocalVariableAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,9 +28,9 @@ using System.Threading;
 using System.Collections.Generic;
 using System.Linq;
 using ICSharpCode.NRefactory.Semantics;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Inline local variable", Description = "Inlines a local variable.")]
 	public class InlineLocalVariableAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/InsertAnonymousMethodSignatureAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/InsertAnonymousMethodSignatureAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/InsertAnonymousMethodSignatureAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/InsertAnonymousMethodSignatureAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -30,7 +30,7 @@ using System.Text;
 using System.Threading;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Insert anonymous method signature", Description = "Inserts a signature to parameterless anonymous methods.")]
 	public class InsertAnonymousMethodSignatureAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/IntroduceConstantAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/IntroduceConstantAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/IntroduceConstantAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/IntroduceConstantAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System;
 
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Introduce constant", Description = "Creates a constant for a non constant primitive expression.")]
 	public class IntroduceConstantAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/IntroduceFormatItemAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/IntroduceFormatItemAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/IntroduceFormatItemAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/IntroduceFormatItemAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -30,7 +30,7 @@ using System.Collections.Generic;
 using System.Linq;
 using System.Threading;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// Introduce format item. Works on strings that contain selections.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/InvertIfAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/InvertIfAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/InvertIfAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/InvertIfAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@ using System;
 using System.Threading;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Invert if", Description = "Inverts an 'if ... else' expression.")]
 	public class InvertIfAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/IterateViaForeachAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/IterateViaForeachAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/IterateViaForeachAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/IterateViaForeachAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -23,13 +23,13 @@
 // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
-using ICSharpCode.NRefactory.CSharp.Refactoring;
+using ICSharpCode.NRefactory.PlayScript.Refactoring;
 using ICSharpCode.NRefactory.TypeSystem;
 using System.Collections.Generic;
 using ICSharpCode.NRefactory.Semantics;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Iterate via foreach", Description = "Iterates an IEnumerable with a foreach loop.")]
 	public class IterateViaForeachAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/JoinDeclarationAndAssignmentAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/JoinDeclarationAndAssignmentAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/JoinDeclarationAndAssignmentAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/JoinDeclarationAndAssignmentAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@
 using System.Linq;
 using ICSharpCode.NRefactory.PatternMatching;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction ("Join local variable declaration and assignment",
 					Description = "Join local variable declaration and assignment.")]
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/JoinStringAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/JoinStringAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/JoinStringAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/JoinStringAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction ("Join string literal", Description = "Join string literals.")]
 	public class JoinStringAction : SpecializedCodeAction<BinaryOperatorExpression>
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/MergeNestedIfAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/MergeNestedIfAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/MergeNestedIfAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/MergeNestedIfAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction ("Merge nested 'if'", Description = "Merge two nested 'if' statements.")]
 	public class MergeNestedIfAction : SpecializedCodeAction<IfElseStatement>
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/MoveToOuterScopeAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/MoveToOuterScopeAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/MoveToOuterScopeAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/MoveToOuterScopeAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,12 +25,12 @@
 // THE SOFTWARE.
 using System.Collections.Generic;
 using System;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using System.Linq;
 using ICSharpCode.NRefactory.Semantics;
 using System.Threading;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	
 	[ContextAction("Move to outer scope", Description = "Moves a declaration to the parent scope.")]
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/NegateRelationalExpressionAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/NegateRelationalExpressionAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/NegateRelationalExpressionAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/NegateRelationalExpressionAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction ("Negate an relational expression", Description = "Negate an relational expression.")]
 	public class NegateRelationalExpressionAction : SpecializedCodeAction<BinaryOperatorExpression>
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/PutInsideUsingAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/PutInsideUsingAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/PutInsideUsingAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/PutInsideUsingAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,12 +26,12 @@
 
 using System.Collections.Generic;
 using System.Linq;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.PatternMatching;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction ("put inside 'using'", Description = "put IDisposable inside 'using' construct")]
 	public class PutInsideUsingAction : SpecializedCodeAction <VariableInitializer>
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/RemoveBackingStoreAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/RemoveBackingStoreAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/RemoveBackingStoreAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/RemoveBackingStoreAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,13 +25,13 @@
 // THE SOFTWARE.
 using System;
 using System.Linq;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using System.Threading;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Remove backing store for property", Description = "Removes the backing store of a property and creates an auto property.")]
 	public class RemoveBackingStoreAction : ICodeActionProvider
@@ -81,7 +81,7 @@ namespace ICSharpCode.NRefactory.CSharp.
 			// automatic properties always need getter & setter
 			if (propertyDeclaration == null || propertyDeclaration.Getter.IsNull || propertyDeclaration.Setter.IsNull || propertyDeclaration.Getter.Body.IsNull || propertyDeclaration.Setter.Body.IsNull)
 				return null;
-			if (!context.Supports(csharp3) || propertyDeclaration.HasModifier (ICSharpCode.NRefactory.CSharp.Modifiers.Abstract) || ((TypeDeclaration)propertyDeclaration.Parent).ClassType == ClassType.Interface)
+			if (!context.Supports(csharp3) || propertyDeclaration.HasModifier (ICSharpCode.NRefactory.PlayScript.Modifiers.Abstract) || ((TypeDeclaration)propertyDeclaration.Parent).ClassType == ClassType.Interface)
 				return null;
 			var getterField = ScanGetter (context, propertyDeclaration);
 			if (getterField == null)
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/RemoveBracesAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/RemoveBracesAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/RemoveBracesAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/RemoveBracesAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System.Linq;
 using System.Threading;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Remove braces", Description = "Removes redundant braces around a statement.")]
 	public class RemoveBracesAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/RemoveRedundantCatchTypeAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/RemoveRedundantCatchTypeAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/RemoveRedundantCatchTypeAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/RemoveRedundantCatchTypeAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -23,15 +23,15 @@
 // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
-using ICSharpCode.NRefactory.CSharp.Refactoring;
+using ICSharpCode.NRefactory.PlayScript.Refactoring;
 using ICSharpCode.NRefactory.TypeSystem;
 using System;
 using ICSharpCode.NRefactory.Semantics;
 using System.Threading;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {	
 	[ContextAction("Remove redundant type",
 	               Description = "Removes a redundant exception type specifier from catch clauses.")]
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/RemoveRegionAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/RemoveRegionAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/RemoveRegionAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/RemoveRegionAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System.Linq;
 using System.Threading;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Remove region", Description = "Removes a pre processor #region/#endregion directive.")]
 	public class RemoveRegionAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ReplaceEmptyStringAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ReplaceEmptyStringAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/ReplaceEmptyStringAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/ReplaceEmptyStringAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@ using System;
 using System.Threading;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Use string.Empty", Description = "Replaces \"\" with string.Empty")]
 	public class ReplaceEmptyStringAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/SortUsingsAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/SortUsingsAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/SortUsingsAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/SortUsingsAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -31,7 +31,7 @@ using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Sort usings", Description = "Sorts usings by their origin and then alphabetically.")]
 	public class SortUsingsAction: ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/SpecializedCodeAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/SpecializedCodeAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/SpecializedCodeAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/SpecializedCodeAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -1,6 +1,6 @@
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// A specialized code action creates a code action assoziated with one special type of ast nodes.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/SplitDeclarationAndAssignmentAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/SplitDeclarationAndAssignmentAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/SplitDeclarationAndAssignmentAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/SplitDeclarationAndAssignmentAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -30,7 +30,7 @@ using System.Threading;
 using System.Collections.Generic;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Split local variable declaration and assignment", Description = "Splits local variable declaration and assignment.")]
 	public class SplitDeclarationAndAssignmentAction : ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/SplitDeclarationListAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/SplitDeclarationListAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/SplitDeclarationListAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/SplitDeclarationListAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction ("Split declaration list", 
 		Description = "Split variable declaration with multiple variables into declarations with a single variable")] 
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/SplitStringAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/SplitStringAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/SplitStringAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/SplitStringAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@ using System;
 using System.Threading;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Split string literal", Description = "Splits string literal into two.")]
 	public class SplitStringAction: ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/StaticMethodInvocationToExtensionMethodInvocationAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/StaticMethodInvocationToExtensionMethodInvocationAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/StaticMethodInvocationToExtensionMethodInvocationAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/StaticMethodInvocationToExtensionMethodInvocationAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -23,12 +23,12 @@
 // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using System.Linq;
 using System.Collections.Generic;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	
 	[ContextAction("Invoke using extension method syntax",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/UseExplicitTypeAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/UseExplicitTypeAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/UseExplicitTypeAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/UseExplicitTypeAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -30,7 +30,7 @@ using ICSharpCode.NRefactory.TypeSystem;
 using System.Threading;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Use explicit type", Description = "Converts local variable declaration to be explicit typed.")]
 	public class UseExplicitTypeAction: ICodeActionProvider
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/UseStringFormatAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/UseStringFormatAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/UseStringFormatAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/UseStringFormatAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,7 +29,7 @@ using System.Text;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.PatternMatching;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction ("Use string.Format()",
 					Description = "Convert concatenation of strings and objects to string.Format()")]
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/UseVarKeywordAction.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/UseVarKeywordAction.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeActions/UseVarKeywordAction.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeActions/UseVarKeywordAction.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,11 +29,11 @@ using ICSharpCode.NRefactory.PatternMatc
 using System.Threading;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[ContextAction("Use 'var' keyword",
 	               Description = "Converts local variable declaration to be implicit typed.",
-	               BoundToIssue = typeof (ICSharpCode.NRefactory.CSharp.Refactoring.UseVarKeywordIssue))]
+	               BoundToIssue = typeof (ICSharpCode.NRefactory.PlayScript.Refactoring.UseVarKeywordIssue))]
 	public class UseVarKeywordAction : ICodeActionProvider
 	{
 		public IEnumerable<CodeAction> GetActions(RefactoringContext context)
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// A code issue marks a region of text with an issue and can provide solution actions for this issue.
@@ -67,7 +67,7 @@ namespace ICSharpCode.NRefactory.CSharp.
 		}
 
 		/// <summary>
-		/// Initializes a new instance of the <see cref="ICSharpCode.NRefactory.CSharp.Refactoring.CodeIssue"/> class.
+		/// Initializes a new instance of the <see cref="ICSharpCode.NRefactory.PlayScript.Refactoring.CodeIssue"/> class.
 		/// </summary>
 		/// <param name='description'>
 		/// The desription of the issue.
@@ -93,7 +93,7 @@ namespace ICSharpCode.NRefactory.CSharp.
 		}
 		
 		/// <summary>
-		/// Initializes a new instance of the <see cref="ICSharpCode.NRefactory.CSharp.Refactoring.CodeIssue"/> class.
+		/// Initializes a new instance of the <see cref="ICSharpCode.NRefactory.PlayScript.Refactoring.CodeIssue"/> class.
 		/// </summary>
 		/// <param name='description'>
 		/// The desription of the issue.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/AccessToClosureIssues/AccessToClosureIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/AccessToClosureIssues/AccessToClosureIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/AccessToClosureIssues/AccessToClosureIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/AccessToClosureIssues/AccessToClosureIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,11 +26,11 @@
 
 using System.Collections.Generic;
 using System.Linq;
-using ICSharpCode.NRefactory.CSharp.Analysis;
+using ICSharpCode.NRefactory.PlayScript.Analysis;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	public abstract class AccessToClosureIssue : ICodeIssueProvider
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/AccessToClosureIssues/AccessToDisposedClosureIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/AccessToClosureIssues/AccessToDisposedClosureIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/AccessToClosureIssues/AccessToDisposedClosureIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/AccessToClosureIssues/AccessToDisposedClosureIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,10 +26,10 @@
 
 using System.Collections.Generic;
 using System.Linq;
-using ICSharpCode.NRefactory.CSharp.Analysis;
+using ICSharpCode.NRefactory.PlayScript.Analysis;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 
 //	[IssueDescription ("Access to disposed closure variable",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/AccessToClosureIssues/AccessToModifiedClosureIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/AccessToClosureIssues/AccessToModifiedClosureIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/AccessToClosureIssues/AccessToModifiedClosureIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/AccessToClosureIssues/AccessToModifiedClosureIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 //	[IssueDescription ("Access to modified closure variable",
 //					   Description = "Access to closure variable from anonymous method when the variable is modified " +
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/AccessToClosureIssues/LocalVariableNamePicker.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/AccessToClosureIssues/LocalVariableNamePicker.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/AccessToClosureIssues/LocalVariableNamePicker.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/AccessToClosureIssues/LocalVariableNamePicker.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@
 using System.Collections.Generic;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	public static class LocalVariableNamePicker
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/AssignmentMadeToSameVariableIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/AssignmentMadeToSameVariableIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/AssignmentMadeToSameVariableIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/AssignmentMadeToSameVariableIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -31,7 +31,7 @@ using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.PatternMatching;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("CS1717:Assignment made to same variable",
 					   Description = "CS1717:Assignment made to same variable.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/BitwiseOperationOnNonFlagsEnumIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/BitwiseOperationOnNonFlagsEnumIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/BitwiseOperationOnNonFlagsEnumIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/BitwiseOperationOnNonFlagsEnumIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System.Collections.Generic;
 using System.Linq;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Bitwise Operations on enum without [Flags] attribute",
 					   Description = "Bitwise Operations on enum not marked with [Flags] attribute",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/CallToObjectEqualsViaBaseIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/CallToObjectEqualsViaBaseIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/CallToObjectEqualsViaBaseIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/CallToObjectEqualsViaBaseIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,7 +29,7 @@ using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.Semantics;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription("Call to base.Equals resolves to Object.Equals, which is reference equality",
 	                  Description = "Finds potentially erroneous calls to Object.Equals.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/CallToVirtualFunctionFromConstructorIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/CallToVirtualFunctionFromConstructorIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/CallToVirtualFunctionFromConstructorIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/CallToVirtualFunctionFromConstructorIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -23,11 +23,11 @@
 // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
-using ICSharpCode.NRefactory.CSharp.Refactoring;
+using ICSharpCode.NRefactory.PlayScript.Refactoring;
 using System.Collections.Generic;
 using ICSharpCode.NRefactory.Semantics;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription("Constructors should not call virtual members",
 	                  Description = "Warns about calls to virtual member functions occuring in the constructor.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/CastExpressionOfIncompatibleTypeIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/CastExpressionOfIncompatibleTypeIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/CastExpressionOfIncompatibleTypeIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/CastExpressionOfIncompatibleTypeIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,10 +26,10 @@
 
 using System.Collections.Generic;
 using ICSharpCode.NRefactory.TypeSystem;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Semantics;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Type cast expression of incompatible type",
 					   Description = "Type cast expression of incompatible type",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/CompareBooleanWithTrueOrFalseIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/CompareBooleanWithTrueOrFalseIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/CompareBooleanWithTrueOrFalseIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/CompareBooleanWithTrueOrFalseIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,7 +29,7 @@ using System.Linq;
 using ICSharpCode.NRefactory.PatternMatching;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Comparison of boolean with 'true' or 'false'",
 					   Description = "Comparison of a boolean value with 'true' or 'false' constant.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/CompareFloatWithEqualityOperatorIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/CompareFloatWithEqualityOperatorIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/CompareFloatWithEqualityOperatorIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/CompareFloatWithEqualityOperatorIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System.Collections.Generic;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Compare floating point numbers with equality operator",
 					   Description = "Comparison of floating point numbers with equality operator.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/CompilerErrors/CS0127ReturnMustNotBeFollowedByAnyExpression.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/CompilerErrors/CS0127ReturnMustNotBeFollowedByAnyExpression.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/CompilerErrors/CS0127ReturnMustNotBeFollowedByAnyExpression.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/CompilerErrors/CS0127ReturnMustNotBeFollowedByAnyExpression.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System.Collections.Generic;
 using System.Linq;
 using ICSharpCode.NRefactory.PatternMatching;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription("CS0127: A method with a void return type cannot return a value.",
 	                  Description = "Since 'function' returns void, a return keyword must not be followed by an object expression",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ConditionalToNullCoalescingIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ConditionalToNullCoalescingIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ConditionalToNullCoalescingIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ConditionalToNullCoalescingIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System.Collections.Generic;
 using System.Linq;
 using ICSharpCode.NRefactory.PatternMatching;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// Checks for "a != null ? a : other"<expr>
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ConstantConditionIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ConstantConditionIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ConstantConditionIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ConstantConditionIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Condition is always 'true' or always 'false'",
 					   Description = "Condition is always 'true' or always 'false'.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/DoubleNegationIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/DoubleNegationIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/DoubleNegationIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/DoubleNegationIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Double negation is meaningless",
 						Description = "Double negation is meaningless.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ExceptionRethrowIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ExceptionRethrowIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ExceptionRethrowIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ExceptionRethrowIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System.Collections.Generic;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.Semantics;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription("A throw statement throws the caught exception by passing it explicitly",
 	                  Description = "Finds throws that throws the caught exception and therefore should be empty.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ExplicitConversionInForEachIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ExplicitConversionInForEachIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ExplicitConversionInForEachIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ExplicitConversionInForEachIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -18,11 +18,11 @@
 
 using System;
 using System.Collections.Generic;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription("Incorrect element type in foreach over generic collection",
 	                  Description= "Detects hidden explicit conversions in foreach loops.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ExpressionIsAlwaysOfProvidedTypeIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ExpressionIsAlwaysOfProvidedTypeIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ExpressionIsAlwaysOfProvidedTypeIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ExpressionIsAlwaysOfProvidedTypeIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,11 +25,11 @@
 // THE SOFTWARE.
 
 using System.Collections.Generic;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("CS0183:Given expression is always of the provided type",
 					   Description = "CS0183:Given expression is always of the provided type.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ExpressionIsNeverOfProvidedTypeIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ExpressionIsNeverOfProvidedTypeIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ExpressionIsNeverOfProvidedTypeIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ExpressionIsNeverOfProvidedTypeIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,11 +26,11 @@
 
 using System.Collections.Generic;
 using System.Linq;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("CS0184:Given expression is never of the provided type",
 					   Description = "CS0184:Given expression is never of the provided type.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ForControlVariableNotModifiedIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ForControlVariableNotModifiedIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ForControlVariableNotModifiedIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ForControlVariableNotModifiedIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,7 +29,7 @@ using System.Linq;
 using ICSharpCode.NRefactory.PatternMatching;
 using ICSharpCode.NRefactory.Semantics;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("'for' loop control variable is never modified",
 					   Description = "'for' loop control variable is never modified.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/FormatStringIssues/FormatStringHelper.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/FormatStringIssues/FormatStringHelper.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/FormatStringIssues/FormatStringHelper.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/FormatStringIssues/FormatStringHelper.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,11 +25,11 @@
 // THE SOFTWARE.
 using System;
 using System.Collections.Generic;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using System.Linq;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	class FormatStringHelper
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/FormatStringIssues/FormatStringIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/FormatStringIssues/FormatStringIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/FormatStringIssues/FormatStringIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/FormatStringIssues/FormatStringIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,11 +25,11 @@
 // THE SOFTWARE.
 using System;
 using System.Collections.Generic;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using System.Linq;
 using ICSharpCode.NRefactory.Utils;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription("Format string syntax error",
 	                  Description = "Finds issues with format strings.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/GatherVisitorBase.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/GatherVisitorBase.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/GatherVisitorBase.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/GatherVisitorBase.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,10 +24,10 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 using System;
-using ICSharpCode.NRefactory.CSharp.Refactoring;
+using ICSharpCode.NRefactory.PlayScript.Refactoring;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// A base class for writing issue provider visitor implementations.
@@ -39,7 +39,7 @@ namespace ICSharpCode.NRefactory.CSharp
 		public readonly List<CodeIssue> FoundIssues = new List<CodeIssue> ();
 
 		/// <summary>
-		/// Initializes a new instance of the <see cref="ICSharpCode.NRefactory.CSharp.GatherVisitorBase"/> class.
+		/// Initializes a new instance of the <see cref="ICSharpCode.NRefactory.PlayScript.GatherVisitorBase"/> class.
 		/// </summary>
 		/// <param name='ctx'>
 		/// The refactoring context.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/IdenticalConditionalBranchIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/IdenticalConditionalBranchIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/IdenticalConditionalBranchIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/IdenticalConditionalBranchIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@
 using System.Collections.Generic;
 using ICSharpCode.NRefactory.PatternMatching;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 
 	[IssueDescription ("'?:' expression has identical true and false branches",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/InconsistentNamingIssue/AffectedEntity.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/InconsistentNamingIssue/AffectedEntity.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/InconsistentNamingIssue/AffectedEntity.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/InconsistentNamingIssue/AffectedEntity.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,7 +25,7 @@
 // THE SOFTWARE.
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[Flags]
 	public enum AffectedEntity
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/InconsistentNamingIssue/DefaultRules.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/InconsistentNamingIssue/DefaultRules.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/InconsistentNamingIssue/DefaultRules.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/InconsistentNamingIssue/DefaultRules.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 using System;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	public static class DefaultRules
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/InconsistentNamingIssue/InconsistentNamingIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/InconsistentNamingIssue/InconsistentNamingIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/InconsistentNamingIssue/InconsistentNamingIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/InconsistentNamingIssue/InconsistentNamingIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,7 +29,7 @@ using System.Linq;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription("Inconsistent Naming",
 	       Description = "Name doesn't match the defined style for this entity.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/InconsistentNamingIssue/NamingConventionService.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/InconsistentNamingIssue/NamingConventionService.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/InconsistentNamingIssue/NamingConventionService.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/InconsistentNamingIssue/NamingConventionService.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	public abstract class NamingConventionService
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/InconsistentNamingIssue/NamingRule.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/InconsistentNamingIssue/NamingRule.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/InconsistentNamingIssue/NamingRule.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/InconsistentNamingIssue/NamingRule.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,7 +29,7 @@ using System.Linq;
 using System.Text;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	public class NamingRule : IEquatable<NamingRule>
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/InconsistentNamingIssue/NamingStyle.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/InconsistentNamingIssue/NamingStyle.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/InconsistentNamingIssue/NamingStyle.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/InconsistentNamingIssue/NamingStyle.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	public enum NamingStyle {
 		None,
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/InconsistentNamingIssue/WordParser.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/InconsistentNamingIssue/WordParser.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/InconsistentNamingIssue/WordParser.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/InconsistentNamingIssue/WordParser.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 using System;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public static class WordParser
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/IncorrectCallToObjectGetHashCodeIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/IncorrectCallToObjectGetHashCodeIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/IncorrectCallToObjectGetHashCodeIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/IncorrectCallToObjectGetHashCodeIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@ using System.Collections.Generic;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.Semantics;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription("Call resolves to Object.GetHashCode, which is reference based",
 	                   Description = "Finds calls to Object.GetHashCode inside overridden GetHashCode.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/IncorrectExceptionParameterOrderingIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/IncorrectExceptionParameterOrderingIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/IncorrectExceptionParameterOrderingIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/IncorrectExceptionParameterOrderingIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -23,12 +23,12 @@
 // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
-using ICSharpCode.NRefactory.CSharp.Refactoring;
+using ICSharpCode.NRefactory.PlayScript.Refactoring;
 using System.Collections.Generic;
 using ICSharpCode.NRefactory.Semantics;
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription("Incorrect ordering of exception constructor parameters",
 	       Description = "Warns about the constructor parameter ordering of some confusing exception types.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/IssueCategories.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/IssueCategories.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/IssueCategories.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/IssueCategories.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,7 +25,7 @@
 // THE SOFTWARE.
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	public class IssueCategories
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/MethodNeverReturnsIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/MethodNeverReturnsIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/MethodNeverReturnsIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/MethodNeverReturnsIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,9 +25,9 @@
 // THE SOFTWARE.
 
 using System.Collections.Generic;
-using ICSharpCode.NRefactory.CSharp.Analysis;
+using ICSharpCode.NRefactory.PlayScript.Analysis;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Method never returns",
 		Description = "Method does not reach its end or a 'return' statement by any of possible execution paths.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/MethodOverloadHidesOptionalParameterIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/MethodOverloadHidesOptionalParameterIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/MethodOverloadHidesOptionalParameterIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/MethodOverloadHidesOptionalParameterIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,7 +29,7 @@ using System.Linq;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Method with optional parameter is hidden by overload",
 					   Description = "Method with optional parameter is hidden by overload",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/MissingStringComparisonIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/MissingStringComparisonIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/MissingStringComparisonIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/MissingStringComparisonIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -31,7 +31,7 @@ using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription("Missing StringComparison argument",
 	                  Description = "Warns when a culture-aware comparison is used by default.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/MultipleEnumerationIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/MultipleEnumerationIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/MultipleEnumerationIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/MultipleEnumerationIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,11 +27,11 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Possible multiple enumeration of IEnumerable",
 					   Description = "Possible multiple enumeration of IEnumerable.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/NegativeRelationalExpressionIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/NegativeRelationalExpressionIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/NegativeRelationalExpressionIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/NegativeRelationalExpressionIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@
 using System.Collections.Generic;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Simplify negative relational expression",
 					   Description = "Simplify negative relational expression",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/NotImplementedExceptionIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/NotImplementedExceptionIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/NotImplementedExceptionIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/NotImplementedExceptionIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using ICSharpCode.NRefactory.PatternMatc
 using System.Collections.Generic;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// This inspector just shows that there is a not implemented exception. It doesn't offer a fix.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/OptionalParameterCouldBeSkippedIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/OptionalParameterCouldBeSkippedIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/OptionalParameterCouldBeSkippedIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/OptionalParameterCouldBeSkippedIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,13 +24,13 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 using System.Collections.Generic;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using System.Linq;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription("Optional argument has default value and can be skipped",
 	                  Description = "Finds calls to functions where optional parameters are used and the passed argument is the same as the default.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/HasMemberCriterion.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/HasMemberCriterion.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/HasMemberCriterion.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/HasMemberCriterion.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using ICSharpCode.NRefactory.TypeSystem;
 using System.Linq;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	public class HasMemberCriterion : ITypeCriterion
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/ITypeCriterion.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/ITypeCriterion.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/ITypeCriterion.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/ITypeCriterion.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,7 +25,7 @@
 // THE SOFTWARE.
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	public interface ITypeCriterion
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/IsArrayTypeCriterion.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/IsArrayTypeCriterion.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/IsArrayTypeCriterion.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/IsArrayTypeCriterion.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 using System;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	public class IsArrayTypeCriterion : ITypeCriterion
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/IsTypeCriterion.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/IsTypeCriterion.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/IsTypeCriterion.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/IsTypeCriterion.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@ using System;
 using ICSharpCode.NRefactory.TypeSystem;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	public class IsTypeCriterion : ITypeCriterion
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/ParameterCanBeDemotedIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/ParameterCanBeDemotedIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/ParameterCanBeDemotedIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/ParameterCanBeDemotedIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,11 +28,11 @@ using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.Semantics;
 using System.Linq;
 using System;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 using System.Diagnostics;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription("A parameter can be demoted to base class",
 	                   Description = "Finds parameters that can be demoted to a base class.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/SupportsIndexingCriterion.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/SupportsIndexingCriterion.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/SupportsIndexingCriterion.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/SupportsIndexingCriterion.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,9 +29,9 @@ using System.Collections.Generic;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 using System.Linq;
 using ICSharpCode.NRefactory.Semantics;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	public class SupportsIndexingCriterion : ITypeCriterion
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/TypeCriteriaCollector.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/TypeCriteriaCollector.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/TypeCriteriaCollector.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ParameterCanBeDemotedIssue/TypeCriteriaCollector.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,10 +27,10 @@ using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.Semantics;
 using System.Collections.Generic;
 using System.Linq;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	public class TypeCriteriaCollector : DepthFirstAstVisitor
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantArrayInitializerCommaIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantArrayInitializerCommaIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantArrayInitializerCommaIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantArrayInitializerCommaIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Redundant comma in array initializer",
 						Description = "Redundant comma in array initializer.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantAssignmentIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantAssignmentIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantAssignmentIssue.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantAssignmentIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System.Collections.Generic;
 using System.Linq;
 using ICSharpCode.NRefactory.Semantics;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Redundant assignment",
 					   Description = "Value assigned to a variable or parameter is not used in all execution path.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantAttributeParenthesesIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantAttributeParenthesesIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantAttributeParenthesesIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantAttributeParenthesesIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Parentheses are redundant if attribute has no arguments",
 						Description = "Parentheses are redundant if attribute has no arguments.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantCaseLabelIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantCaseLabelIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantCaseLabelIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantCaseLabelIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Redundant 'case' label",
 						Description = "Redundant 'case' label",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantCatchIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantCatchIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantCatchIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantCatchIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 using System;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription("A catch clause containing a single empty throw is redundant",
 	                  Description = "Warns about catch clauses that only rethrows the exception.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantElseIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantElseIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantElseIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantElseIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Redundant 'else' keyword",
 						Description = "Redundant 'else' keyword.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantFieldInitializerIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantFieldInitializerIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantFieldInitializerIssue.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantFieldInitializerIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System.Collections.Generic;
 using ICSharpCode.NRefactory.PatternMatching;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Initializing field with default value is redundant",
 						Description = "Initializing field with default value is redundant.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantInternalIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantInternalIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantInternalIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantInternalIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,7 +29,7 @@ using ICSharpCode.NRefactory.PatternMatc
 using System.Collections.Generic;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// Finds redundant internal modifiers.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantNamespaceUsageIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantNamespaceUsageIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantNamespaceUsageIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantNamespaceUsageIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -31,7 +31,7 @@ using System.Linq;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// Finds redundant namespace usages.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantObjectCreationArgumentListIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantObjectCreationArgumentListIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantObjectCreationArgumentListIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantObjectCreationArgumentListIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Redundant empty argument list on object creation expression",
 					   Description = "When object creation uses object or collection initializer, empty argument list is redundant.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantObjectOrCollectionInitializerIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantObjectOrCollectionInitializerIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantObjectOrCollectionInitializerIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantObjectOrCollectionInitializerIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Redundant empty object or collection initializer",
 					   Description = "Redundant empty object or collection initializer.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantPrivateIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantPrivateIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantPrivateIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantPrivateIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,7 +29,7 @@ using ICSharpCode.NRefactory.PatternMatc
 using System.Collections.Generic;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// Finds redundant internal modifiers.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantThisIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantThisIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantThisIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantThisIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,11 +29,11 @@ using ICSharpCode.NRefactory.PatternMatc
 using System.Collections.Generic;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.Semantics;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using System.Linq;
 
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// Finds redundant namespace usages.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantToStringIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantToStringIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantToStringIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantToStringIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,12 +26,12 @@
 using System;
 using System.Collections.Generic;
 using ICSharpCode.NRefactory.TypeSystem;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Semantics;
 using System.Linq;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription("Redundant call to ToString()",
 	                  Description = "Finds calls to ToString() which would occur anyway.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantTypeCastIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantTypeCastIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantTypeCastIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantTypeCastIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,9 +28,9 @@ using System.Collections.Generic;
 using System.Linq;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Redundant type cast",
 						Description = "Redundant type cast.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantUsingIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantUsingIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantUsingIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantUsingIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,10 +29,10 @@ using ICSharpCode.NRefactory.PatternMatc
 using System.Collections.Generic;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.Semantics;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// Finds redundant using declarations.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantWhereWithPredicateIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantWhereWithPredicateIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/RedundantWhereWithPredicateIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/RedundantWhereWithPredicateIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -4,7 +4,7 @@ using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.PatternMatching;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription("Any()/First()/etc. should be used with predicate and Where() removed",
 	                  Description= "Detects redundant Where() with predicate calls followed by Any().",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ReferenceEqualsCalledWithValueTypeIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ReferenceEqualsCalledWithValueTypeIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ReferenceEqualsCalledWithValueTypeIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ReferenceEqualsCalledWithValueTypeIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,7 +29,7 @@ using System.Linq;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("'Object.ReferenceEquals' is always false because it is called with value type",
 					   Description = "'Object.ReferenceEquals' is always false because it is called with value type.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ReferenceToStaticMemberViaDerivedTypeIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ReferenceToStaticMemberViaDerivedTypeIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ReferenceToStaticMemberViaDerivedTypeIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ReferenceToStaticMemberViaDerivedTypeIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@ using System.Collections.Generic;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription("Call to static member via a derived class",
 	                   Description = "Suggests using the class declaring a static function when calling it.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ResultOfAsyncCallShouldNotBeIgnoredIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ResultOfAsyncCallShouldNotBeIgnoredIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ResultOfAsyncCallShouldNotBeIgnoredIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ResultOfAsyncCallShouldNotBeIgnoredIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -21,7 +21,7 @@ using System.Collections.Generic;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription("Result of async call is ignored",
 	                  Description = "Warns when the task returned by an async call is ignored, which causes exceptions" +
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/SimplifyAnonymousMethodToDelegateIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/SimplifyAnonymousMethodToDelegateIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/SimplifyAnonymousMethodToDelegateIssue.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/SimplifyAnonymousMethodToDelegateIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System.Collections.Generic;
 using System.Linq;
 using ICSharpCode.NRefactory.PatternMatching;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription("Simplify anonymous method to delegate",
 	                  Description = "Shows anonymous methods that can be simplified.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/StaticFieldInGenericTypeIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/StaticFieldInGenericTypeIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/StaticFieldInGenericTypeIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/StaticFieldInGenericTypeIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System.Collections.Generic;
 using ICSharpCode.NRefactory.TypeSystem;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription("Static field in generic type",
 	                   Description = "Warns about static fields in generic types.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/StringIsNullOrEmptyIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/StringIsNullOrEmptyIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/StringIsNullOrEmptyIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/StringIsNullOrEmptyIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System.Collections.Generic;
 using System.Linq;
 using ICSharpCode.NRefactory.PatternMatching;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// Checks for str == null &amp;&amp; str == " "
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ThreadStaticOnInstanceFieldIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ThreadStaticOnInstanceFieldIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ThreadStaticOnInstanceFieldIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ThreadStaticOnInstanceFieldIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using System;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.Semantics;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription("The ThreadStatic attribute does nothing on instance fields",
 	                  Description = "Finds usages of ThreadStatic on instance fields.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/TypeParameterNotUsedIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/TypeParameterNotUsedIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/TypeParameterNotUsedIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/TypeParameterNotUsedIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,11 +26,11 @@
 
 using System.Collections.Generic;
 using System.Linq;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Unused type parameter",
 					   Description = "Type parameter is never used.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/UnreachableCodeIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/UnreachableCodeIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/UnreachableCodeIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/UnreachableCodeIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,9 +26,9 @@
 
 using System;
 using System.Collections.Generic;
-using ICSharpCode.NRefactory.CSharp.Analysis;
+using ICSharpCode.NRefactory.PlayScript.Analysis;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Code is unreachable",
 						Description = "Code is unreachable.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/UseVarKeywordIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/UseVarKeywordIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/UseVarKeywordIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/UseVarKeywordIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -30,7 +30,7 @@ using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.Semantics;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// Checks for places where the 'var' keyword can be used. Note that the action is actually done with a context
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ValueParameterUnusedIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ValueParameterUnusedIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/ValueParameterUnusedIssue.cs	2013-03-14 23:31:36.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/ValueParameterUnusedIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,11 +26,11 @@
 using System.Collections.Generic;
 using System.Linq;
 using ICSharpCode.NRefactory.TypeSystem;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using System.Threading;
 using ICSharpCode.NRefactory.Semantics;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription("The value parameter is not used in a context where is should be",
 	       Description = "Warns about property or indexer setters and event adders or removers that do not use the value parameter.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/VariableDeclaredInWideScopeIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/VariableDeclaredInWideScopeIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/VariableDeclaredInWideScopeIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/VariableDeclaredInWideScopeIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,7 +29,7 @@ using System;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription("The variable can be declared in a nested scope",
 	                   Description = "Highlights variables that can be declared in a nested scope.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/VariableHidesMemberIssue/LocalVariableHidesMemberIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/VariableHidesMemberIssue/LocalVariableHidesMemberIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/VariableHidesMemberIssue/LocalVariableHidesMemberIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/VariableHidesMemberIssue/LocalVariableHidesMemberIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 
 using ICSharpCode.NRefactory.Semantics;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Local variable hides a member",
 					   Description = "Local variable has the same name as a member and hides it.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/VariableHidesMemberIssue/ParameterHidesMemberIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/VariableHidesMemberIssue/ParameterHidesMemberIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/VariableHidesMemberIssue/ParameterHidesMemberIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/VariableHidesMemberIssue/ParameterHidesMemberIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Parameter hides a member",
 					   Description = "Parameter has the same name as a member and hides it.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/VariableHidesMemberIssue/VariableHidesMemberIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/VariableHidesMemberIssue/VariableHidesMemberIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/VariableHidesMemberIssue/VariableHidesMemberIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/VariableHidesMemberIssue/VariableHidesMemberIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,7 +29,7 @@ using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	public abstract class VariableHidesMemberIssue : ICodeIssueProvider
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/VariableNotUsedIssues/LocalVariableNotUsedIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/VariableNotUsedIssues/LocalVariableNotUsedIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/VariableNotUsedIssues/LocalVariableNotUsedIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/VariableNotUsedIssues/LocalVariableNotUsedIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,7 +28,7 @@ using ICSharpCode.NRefactory.Semantics;
 using System.Linq;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Unused local variable",
 					   Description = "Local variable is never used.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/VariableNotUsedIssues/ParameterNotUsedIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/VariableNotUsedIssues/ParameterNotUsedIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/VariableNotUsedIssues/ParameterNotUsedIssue.cs	2013-03-14 23:31:36.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/VariableNotUsedIssues/ParameterNotUsedIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -28,10 +28,10 @@ using ICSharpCode.NRefactory.Semantics;
 using System.Linq;
 using ICSharpCode.NRefactory.TypeSystem;
 using System.Collections.Generic;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Unused parameter",
 	                   Description = "Parameter is never used.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/VariableOnlyAssignedIssues/ParameterOnlyAssignedIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/VariableOnlyAssignedIssues/ParameterOnlyAssignedIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/VariableOnlyAssignedIssues/ParameterOnlyAssignedIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/VariableOnlyAssignedIssues/ParameterOnlyAssignedIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,7 +25,7 @@
 // THE SOFTWARE.
 using ICSharpCode.NRefactory.Semantics;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	[IssueDescription ("Parameter is only assigned",
 					   Description = "Parameter is assigned but its value is never used.",
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/VariableOnlyAssignedIssues/VariableOnlyAssignedIssue.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/VariableOnlyAssignedIssues/VariableOnlyAssignedIssue.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/CodeIssues/VariableOnlyAssignedIssues/VariableOnlyAssignedIssue.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/CodeIssues/VariableOnlyAssignedIssues/VariableOnlyAssignedIssue.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@
 using System.Collections.Generic;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	public abstract class VariableOnlyAssignedIssue : ICodeIssueProvider
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/ContextActionAttribute.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/ContextActionAttribute.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/ContextActionAttribute.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/ContextActionAttribute.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,7 +25,7 @@
 // THE SOFTWARE.
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	[AttributeUsage(AttributeTargets.Class)]
 	public class ContextActionAttribute : System.Attribute
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/DocumentScript.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/DocumentScript.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/DocumentScript.cs	2013-03-14 23:31:36.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/DocumentScript.cs	2013-04-23 21:04:54.000000000 -0700
@@ -22,7 +22,7 @@ using System.Diagnostics;
 using ICSharpCode.NRefactory.Editor;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// Script implementation based on IDocument.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/ICodeActionProvider.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/ICodeActionProvider.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/ICodeActionProvider.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/ICodeActionProvider.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,7 +27,7 @@ using System;
 using System.Threading;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	public interface ICodeActionProvider
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/ICodeIssueProvider.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/ICodeIssueProvider.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/ICodeIssueProvider.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/ICodeIssueProvider.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@
 using System;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// The code issue provider gets a list of all code issues in a syntax tree.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/IssueAttribute.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/IssueAttribute.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/IssueAttribute.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/IssueAttribute.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,7 +25,7 @@
 // THE SOFTWARE.
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	[AttributeUsage(AttributeTargets.Class)]
 	public class IssueDescriptionAttribute : System.Attribute
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/IssueMarker.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/IssueMarker.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/IssueMarker.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/IssueMarker.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,7 +25,7 @@
 // THE SOFTWARE.
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// The issue marker is used to set how an issue should be marked inside the text editor.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/LambdaHelper.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/LambdaHelper.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/LambdaHelper.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/LambdaHelper.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,10 +25,10 @@
 // THE SOFTWARE.
 
 using System.Linq;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	public class LambdaHelper
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/LocalReferenceFinder.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/LocalReferenceFinder.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/LocalReferenceFinder.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/LocalReferenceFinder.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,13 +26,13 @@
 
 using System.Collections.Generic;
 using System.Linq;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.Utils;
 using System.Diagnostics;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 
 	/// <summary>
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/NamingHelper.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/NamingHelper.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/NamingHelper.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/NamingHelper.cs	2013-04-23 21:04:54.000000000 -0700
@@ -29,7 +29,7 @@ using System.Text;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.Semantics;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	public class NamingHelper
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/PatternHelper.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/PatternHelper.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/PatternHelper.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/PatternHelper.cs	2013-04-23 21:04:54.000000000 -0700
@@ -19,7 +19,7 @@
 using System;
 using ICSharpCode.NRefactory.PatternMatching;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// Helper class for constructing pattern ASTs.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/RefactoringAstHelper.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/RefactoringAstHelper.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/RefactoringAstHelper.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/RefactoringAstHelper.cs	2013-04-23 21:04:54.000000000 -0700
@@ -20,7 +20,7 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// Helper methods for constructing ASTs for refactoring.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/RefactoringContext.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/RefactoringContext.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/RefactoringContext.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/RefactoringContext.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,15 +27,15 @@
 using System;
 using System.Linq;
 using System.Threading;
-using ICSharpCode.NRefactory.CSharp.Resolver;
-using ICSharpCode.NRefactory.CSharp.TypeSystem;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
+using ICSharpCode.NRefactory.PlayScript.TypeSystem;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 using ICSharpCode.NRefactory.Editor;
 using System.Collections.Generic;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	public abstract class RefactoringContext : BaseRefactoringContext
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/Script.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/Script.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/Script.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/Script.cs	2013-04-23 21:04:54.000000000 -0700
@@ -30,7 +30,7 @@ using ICSharpCode.NRefactory.Editor;
 using ICSharpCode.NRefactory.TypeSystem;
 using System.Threading.Tasks;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// Class for creating change scripts.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/Severity.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/Severity.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/Severity.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/Severity.cs	2013-04-23 21:04:54.000000000 -0700
@@ -25,7 +25,7 @@
 // THE SOFTWARE.
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// The severity influences how the task bar reacts on found issues.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/TypeSystemAstBuilder.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/TypeSystemAstBuilder.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/TypeSystemAstBuilder.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/TypeSystemAstBuilder.cs	2013-04-23 21:04:54.000000000 -0700
@@ -5,14 +5,14 @@ using System;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Linq;
-using ICSharpCode.NRefactory.CSharp.Resolver;
-using ICSharpCode.NRefactory.CSharp.TypeSystem;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
+using ICSharpCode.NRefactory.PlayScript.TypeSystem;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 using ICSharpCode.NRefactory.Utils;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// Converts from type system to the C# AST.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/UsingHelper.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/UsingHelper.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/UsingHelper.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/UsingHelper.cs	2013-04-23 21:04:54.000000000 -0700
@@ -20,10 +20,10 @@ using System;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Linq;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Semantics;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	/// <summary>
 	/// Helper methods for managing using declarations.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/VariableReferenceGraph.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/VariableReferenceGraph.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Refactoring/VariableReferenceGraph.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Refactoring/VariableReferenceGraph.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,11 +26,11 @@
 
 using System.Collections.Generic;
 using System.Linq;
-using ICSharpCode.NRefactory.CSharp.Analysis;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Analysis;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using System.Threading;
 
-namespace ICSharpCode.NRefactory.CSharp.Refactoring
+namespace ICSharpCode.NRefactory.PlayScript.Refactoring
 {
 	class VariableReferenceNode
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/AliasNamespaceResolveResult.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/AliasNamespaceResolveResult.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/AliasNamespaceResolveResult.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/AliasNamespaceResolveResult.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,9 +26,9 @@
 using System;
 using ICSharpCode.NRefactory.Semantics;
 using System.Collections.Generic;
-using ICSharpCode.NRefactory.CSharp.TypeSystem;
+using ICSharpCode.NRefactory.PlayScript.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	/// <summary>
 	/// Represents a namespace resolve result that's resolved using an alias.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/AliasTypeResolveResult.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/AliasTypeResolveResult.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/AliasTypeResolveResult.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/AliasTypeResolveResult.cs	2013-04-23 21:04:54.000000000 -0700
@@ -27,9 +27,9 @@
 using System;
 using ICSharpCode.NRefactory.Semantics;
 using System.Collections.Generic;
-using ICSharpCode.NRefactory.CSharp.TypeSystem;
+using ICSharpCode.NRefactory.PlayScript.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	/// <summary>
 	/// Represents a type resolve result that's resolved using an alias.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/AwaitResolveResult.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/AwaitResolveResult.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/AwaitResolveResult.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/AwaitResolveResult.cs	2013-04-23 21:04:54.000000000 -0700
@@ -23,7 +23,7 @@ using System.Linq.Expressions;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	/// <summary>
 	/// Represents the result of an await expression.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/CSharpAstResolver.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/CSharpAstResolver.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/CSharpAstResolver.cs	2013-03-14 23:31:36.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/CSharpAstResolver.cs	2013-04-23 21:04:54.000000000 -0700
@@ -19,11 +19,11 @@
 using System;
 using System.Diagnostics;
 using System.Threading;
-using ICSharpCode.NRefactory.CSharp.TypeSystem;
+using ICSharpCode.NRefactory.PlayScript.TypeSystem;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	/// <summary>
 	/// Resolves C# AST nodes.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/CSharpConversions.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/CSharpConversions.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/CSharpConversions.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/CSharpConversions.cs	2013-04-23 21:04:54.000000000 -0700
@@ -26,7 +26,7 @@ using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.Utils;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	/// <summary>
 	/// Contains logic that determines whether an implicit conversion exists between two types.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/CSharpInvocationResolveResult.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/CSharpInvocationResolveResult.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/CSharpInvocationResolveResult.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/CSharpInvocationResolveResult.cs	2013-04-23 21:04:54.000000000 -0700
@@ -22,7 +22,7 @@ using System.Linq;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	/// <summary>
 	/// Represents the result of a method, constructor or indexer invocation.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/CSharpOperators.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/CSharpOperators.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/CSharpOperators.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/CSharpOperators.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@ using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 using ICSharpCode.NRefactory.Utils;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	sealed class CSharpOperators
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/CSharpResolver.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/CSharpResolver.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/CSharpResolver.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/CSharpResolver.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,13 +24,13 @@ using System.Globalization;
 using System.Linq;
 using System.Text;
 using System.Threading;
-using ICSharpCode.NRefactory.CSharp.TypeSystem;
+using ICSharpCode.NRefactory.PlayScript.TypeSystem;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 using ICSharpCode.NRefactory.Utils;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	/// <summary>
 	/// Contains the main resolver logic.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/CompositeResolveVisitorNavigator.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/CompositeResolveVisitorNavigator.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/CompositeResolveVisitorNavigator.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/CompositeResolveVisitorNavigator.cs	2013-04-23 21:04:54.000000000 -0700
@@ -20,7 +20,7 @@ using System;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	public sealed class CompositeResolveVisitorNavigator : IResolveVisitorNavigator
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/DetectSkippableNodesNavigator.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/DetectSkippableNodesNavigator.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/DetectSkippableNodesNavigator.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/DetectSkippableNodesNavigator.cs	2013-04-23 21:04:54.000000000 -0700
@@ -21,7 +21,7 @@ using System.Collections.Generic;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	/// <summary>
 	/// When an <see cref="IResolveVisitorNavigator"/> is searching for specific nodes
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/DynamicInvocationResolveResult.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/DynamicInvocationResolveResult.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/DynamicInvocationResolveResult.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/DynamicInvocationResolveResult.cs	2013-04-23 21:04:54.000000000 -0700
@@ -23,7 +23,7 @@ using System.Linq;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	public enum DynamicInvocationType {
 		/// <summary>
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/DynamicMemberResolveResult.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/DynamicMemberResolveResult.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/DynamicMemberResolveResult.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/DynamicMemberResolveResult.cs	2013-04-23 21:04:54.000000000 -0700
@@ -23,7 +23,7 @@ using System.Linq;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	/// <summary>
 	/// Represents the result of an access to a member of a dynamic object.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/FindReferenceSearchScope.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/FindReferenceSearchScope.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/FindReferenceSearchScope.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/FindReferenceSearchScope.cs	2013-04-23 21:04:54.000000000 -0700
@@ -19,7 +19,7 @@
 using System;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	/// <summary>
 	/// Represents a scope in which references are searched.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/FindReferencedEntities.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/FindReferencedEntities.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/FindReferencedEntities.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/FindReferencedEntities.cs	2013-04-23 21:04:54.000000000 -0700
@@ -20,7 +20,7 @@ using System;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	/// <summary>
 	/// Find all entities that are referenced in the scanned AST.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/FindReferences.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/FindReferences.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/FindReferences.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/FindReferences.cs	2013-04-23 21:04:54.000000000 -0700
@@ -21,13 +21,13 @@ using System.Collections.Generic;
 using System.Diagnostics;
 using System.Linq;
 using System.Threading;
-using ICSharpCode.NRefactory.CSharp.Refactoring;
-using ICSharpCode.NRefactory.CSharp.TypeSystem;
+using ICSharpCode.NRefactory.PlayScript.Refactoring;
+using ICSharpCode.NRefactory.PlayScript.TypeSystem;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.Utils;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	public delegate void FoundReferenceCallback(AstNode astNode, ResolveResult result);
 	
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/IResolveVisitorNavigator.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/IResolveVisitorNavigator.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/IResolveVisitorNavigator.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/IResolveVisitorNavigator.cs	2013-04-23 21:04:54.000000000 -0700
@@ -20,7 +20,7 @@ using System;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	/// <summary>
 	/// Allows controlling which nodes are resolved by the resolve visitor.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/LambdaResolveResult.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/LambdaResolveResult.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/LambdaResolveResult.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/LambdaResolveResult.cs	2013-04-23 21:04:54.000000000 -0700
@@ -21,7 +21,7 @@ using System.Collections.Generic;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	/// <summary>
 	/// Represents an anonymous method or lambda expression.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/Log.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/Log.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/Log.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/Log.cs	2013-04-23 21:04:54.000000000 -0700
@@ -21,7 +21,7 @@ using System.Collections.Generic;
 using System.Diagnostics;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	/// <summary>
 	/// Resolver logging helper.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/MemberLookup.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/MemberLookup.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/MemberLookup.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/MemberLookup.cs	2013-04-23 21:04:54.000000000 -0700
@@ -24,7 +24,7 @@ using System.Linq;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	/// <summary>
 	/// Implementation of member lookup (C# 4.0 spec, §7.4).
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/MethodGroupResolveResult.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/MethodGroupResolveResult.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/MethodGroupResolveResult.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/MethodGroupResolveResult.cs	2013-04-23 21:04:54.000000000 -0700
@@ -22,12 +22,12 @@ using System.Collections.ObjectModel;
 using System.Diagnostics;
 using System.Linq;
 using System.Text;
-using ICSharpCode.NRefactory.CSharp.TypeSystem;
+using ICSharpCode.NRefactory.PlayScript.TypeSystem;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	/// <summary>
 	/// A method list that belongs to a declaring type.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/NodeListResolveVisitorNavigator.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/NodeListResolveVisitorNavigator.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/NodeListResolveVisitorNavigator.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/NodeListResolveVisitorNavigator.cs	2013-04-23 21:04:55.000000000 -0700
@@ -21,7 +21,7 @@ using System.Collections.Generic;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	/// <summary>
 	/// <see cref="IResolveVisitorNavigator"/> implementation that resolves a list of nodes.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/OverloadResolution.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/OverloadResolution.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/OverloadResolution.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/OverloadResolution.cs	2013-04-23 21:04:55.000000000 -0700
@@ -26,7 +26,7 @@ using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	/// <summary>
 	/// C# overload resolution (C# 4.0 spec: §7.5).
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/OverloadResolutionErrors.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/OverloadResolutionErrors.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/OverloadResolutionErrors.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/OverloadResolutionErrors.cs	2013-04-23 21:04:55.000000000 -0700
@@ -18,7 +18,7 @@
 
 using System;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	[Flags]
 	public enum OverloadResolutionErrors
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/ReducedExtensionMethod.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/ReducedExtensionMethod.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/ReducedExtensionMethod.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/ReducedExtensionMethod.cs	2013-04-23 21:04:55.000000000 -0700
@@ -29,7 +29,7 @@ using System.Collections.Generic;
 using System.Linq;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 
-namespace ICSharpCode.NRefactory.CSharp
+namespace ICSharpCode.NRefactory.PlayScript
 {
 	/// <summary>
 	/// An invocated extension method hides the extension parameter in its parameter list.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/ResolveAtLocation.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/ResolveAtLocation.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/ResolveAtLocation.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/ResolveAtLocation.cs	2013-04-23 21:04:55.000000000 -0700
@@ -18,11 +18,11 @@
 
 using System;
 using System.Threading;
-using ICSharpCode.NRefactory.CSharp.TypeSystem;
+using ICSharpCode.NRefactory.PlayScript.TypeSystem;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	/// <summary>
 	/// Helper class that resolves the node at a specified location.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/ResolveVisitor.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/ResolveVisitor.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/ResolveVisitor.cs	2013-03-14 23:32:08.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/ResolveVisitor.cs	2013-04-23 21:04:55.000000000 -0700
@@ -22,13 +22,13 @@ using System.Diagnostics;
 using System.Linq;
 using System.Text;
 using System.Threading;
-using ICSharpCode.NRefactory.CSharp.Analysis;
-using ICSharpCode.NRefactory.CSharp.TypeSystem;
+using ICSharpCode.NRefactory.PlayScript.Analysis;
+using ICSharpCode.NRefactory.PlayScript.TypeSystem;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	/// <summary>
 	/// Traverses the DOM and resolves expressions.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/TypeInference.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/TypeInference.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/Resolver/TypeInference.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/Resolver/TypeInference.cs	2013-04-23 21:04:55.000000000 -0700
@@ -25,7 +25,7 @@ using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 
-namespace ICSharpCode.NRefactory.CSharp.Resolver
+namespace ICSharpCode.NRefactory.PlayScript.Resolver
 {
 	public enum TypeInferenceAlgorithm
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/AliasNamespaceReference.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/AliasNamespaceReference.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/AliasNamespaceReference.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/AliasNamespaceReference.cs	2013-04-23 21:04:55.000000000 -0700
@@ -17,11 +17,11 @@
 // DEALINGS IN THE SOFTWARE.
 
 using System;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.TypeSystem
+namespace ICSharpCode.NRefactory.PlayScript.TypeSystem
 {
 	/// <summary>
 	/// Looks up an alias (identifier in front of :: operator).
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/AttributeTypeReference.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/AttributeTypeReference.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/AttributeTypeReference.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/AttributeTypeReference.cs	2013-04-23 21:04:55.000000000 -0700
@@ -26,7 +26,7 @@ using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 
-namespace ICSharpCode.NRefactory.CSharp.TypeSystem
+namespace ICSharpCode.NRefactory.PlayScript.TypeSystem
 {
 	/// <summary>
 	/// Type reference used within an attribute.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/CSharpAssembly.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/CSharpAssembly.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/CSharpAssembly.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/CSharpAssembly.cs	2013-04-23 21:04:55.000000000 -0700
@@ -25,7 +25,7 @@ using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 using ICSharpCode.NRefactory.Utils;
 
-namespace ICSharpCode.NRefactory.CSharp.TypeSystem
+namespace ICSharpCode.NRefactory.PlayScript.TypeSystem
 {
 	public class CSharpAssembly : IAssembly
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/CSharpAttribute.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/CSharpAttribute.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/CSharpAttribute.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/CSharpAttribute.cs	2013-04-23 21:04:55.000000000 -0700
@@ -21,13 +21,13 @@ using System.Collections.Generic;
 using System.Collections.ObjectModel;
 using System.Diagnostics;
 using System.Linq;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 using ICSharpCode.NRefactory.Utils;
 
-namespace ICSharpCode.NRefactory.CSharp.TypeSystem
+namespace ICSharpCode.NRefactory.PlayScript.TypeSystem
 {
 	[Serializable]
 	public sealed class CSharpAttribute : IUnresolvedAttribute
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/CSharpDocumentationComment.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/CSharpDocumentationComment.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/CSharpDocumentationComment.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/CSharpDocumentationComment.cs	2013-04-23 21:04:55.000000000 -0700
@@ -17,13 +17,13 @@
 // DEALINGS IN THE SOFTWARE.
 
 using System;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Documentation;
 using ICSharpCode.NRefactory.Editor;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.TypeSystem
+namespace ICSharpCode.NRefactory.PlayScript.TypeSystem
 {
 	/// <summary>
 	/// DocumentationComment with C# cref lookup.
@@ -40,7 +40,7 @@ namespace ICSharpCode.NRefactory.CSharp.
 				// resolve ID string
 				return base.ResolveCref(cref);
 			}
-			var documentationReference = new CSharpParser().ParseDocumentationReference(cref);
+			var documentationReference = new PlayScriptParser().ParseDocumentationReference(cref);
 			var csharpContext = context as CSharpTypeResolveContext;
 			CSharpResolver resolver;
 			if (csharpContext != null) {
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/CSharpTypeResolveContext.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/CSharpTypeResolveContext.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/CSharpTypeResolveContext.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/CSharpTypeResolveContext.cs	2013-04-23 21:04:55.000000000 -0700
@@ -19,7 +19,7 @@
 using System;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.TypeSystem
+namespace ICSharpCode.NRefactory.PlayScript.TypeSystem
 {
 	public sealed class CSharpTypeResolveContext : ITypeResolveContext
 	{
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/CSharpUnresolvedFile.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/CSharpUnresolvedFile.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/CSharpUnresolvedFile.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/CSharpUnresolvedFile.cs	2013-04-23 21:04:55.000000000 -0700
@@ -25,7 +25,7 @@ using ICSharpCode.NRefactory.TypeSystem.
 using ICSharpCode.NRefactory.Utils;
 using System.Linq;
 
-namespace ICSharpCode.NRefactory.CSharp.TypeSystem
+namespace ICSharpCode.NRefactory.PlayScript.TypeSystem
 {
 	/// <summary>
 	/// Represents a file that was parsed and converted for the type system.
@@ -187,9 +187,9 @@ namespace ICSharpCode.NRefactory.CSharp.
 			return GetTypeResolveContext (compilation, loc);
 		}
 
-		public ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver GetResolver (ICompilation compilation, TextLocation loc)
+		public ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver GetResolver (ICompilation compilation, TextLocation loc)
 		{
-			return new ICSharpCode.NRefactory.CSharp.Resolver.CSharpResolver (GetTypeResolveContext (compilation, loc));
+			return new ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver (GetTypeResolveContext (compilation, loc));
 		}
 		
 		public string GetDocumentation(IUnresolvedEntity entity)
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/CSharpUnresolvedTypeDefinition.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/CSharpUnresolvedTypeDefinition.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/CSharpUnresolvedTypeDefinition.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/CSharpUnresolvedTypeDefinition.cs	2013-04-23 21:04:55.000000000 -0700
@@ -21,7 +21,7 @@ using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 using ICSharpCode.NRefactory.Utils;
 
-namespace ICSharpCode.NRefactory.CSharp.TypeSystem
+namespace ICSharpCode.NRefactory.PlayScript.TypeSystem
 {
 	[Serializable, FastSerializerVersion(TypeSystemConvertVisitor.version)]
 	public class CSharpUnresolvedTypeDefinition : DefaultUnresolvedTypeDefinition
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/ConstantValues.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/ConstantValues.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/ConstantValues.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/ConstantValues.cs	2013-04-23 21:04:55.000000000 -0700
@@ -19,14 +19,14 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
-using ICSharpCode.NRefactory.CSharp.Analysis;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Analysis;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 using ICSharpCode.NRefactory.Utils;
 
-namespace ICSharpCode.NRefactory.CSharp.TypeSystem.ConstantValues
+namespace ICSharpCode.NRefactory.PlayScript.TypeSystem.ConstantValues
 {
 	// Contains representations for constant C# expressions.
 	// We use these instead of storing the full AST to reduce the memory usage.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/MemberTypeOrNamespaceReference.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/MemberTypeOrNamespaceReference.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/MemberTypeOrNamespaceReference.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/MemberTypeOrNamespaceReference.cs	2013-04-23 21:04:55.000000000 -0700
@@ -19,13 +19,13 @@
 using System;
 using System.Collections.Generic;
 using System.Collections.ObjectModel;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 using ICSharpCode.NRefactory.Utils;
 
-namespace ICSharpCode.NRefactory.CSharp.TypeSystem
+namespace ICSharpCode.NRefactory.PlayScript.TypeSystem
 {
 	/// <summary>
 	/// Reference to a qualified type or namespace name.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/MethodTypeParameterWithInheritedConstraints.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/MethodTypeParameterWithInheritedConstraints.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/MethodTypeParameterWithInheritedConstraints.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/MethodTypeParameterWithInheritedConstraints.cs	2013-04-23 21:04:55.000000000 -0700
@@ -23,7 +23,7 @@ using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 using ICSharpCode.NRefactory.Utils;
 
-namespace ICSharpCode.NRefactory.CSharp.TypeSystem
+namespace ICSharpCode.NRefactory.PlayScript.TypeSystem
 {
 	[Serializable]
 	public sealed class MethodTypeParameterWithInheritedConstraints : DefaultUnresolvedTypeParameter
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/ResolvedUsingScope.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/ResolvedUsingScope.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/ResolvedUsingScope.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/ResolvedUsingScope.cs	2013-04-23 21:04:55.000000000 -0700
@@ -21,12 +21,12 @@ using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Collections.ObjectModel;
 using System.Diagnostics;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.Utils;
 
-namespace ICSharpCode.NRefactory.CSharp.TypeSystem
+namespace ICSharpCode.NRefactory.PlayScript.TypeSystem
 {
 	/// <summary>
 	/// Resolved version of using scope.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/SimpleTypeOrNamespaceReference.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/SimpleTypeOrNamespaceReference.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/SimpleTypeOrNamespaceReference.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/SimpleTypeOrNamespaceReference.cs	2013-04-23 21:04:55.000000000 -0700
@@ -20,13 +20,13 @@ using System;
 using System.Collections.Generic;
 using System.Collections.ObjectModel;
 
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 using ICSharpCode.NRefactory.Utils;
 
-namespace ICSharpCode.NRefactory.CSharp.TypeSystem
+namespace ICSharpCode.NRefactory.PlayScript.TypeSystem
 {
 	/// <summary>
 	/// Represents a simple C# name. (a single non-qualified identifier with an optional list of type arguments)
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/TypeOrNamespaceReference.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/TypeOrNamespaceReference.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/TypeOrNamespaceReference.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/TypeOrNamespaceReference.cs	2013-04-23 21:04:55.000000000 -0700
@@ -17,11 +17,11 @@
 // DEALINGS IN THE SOFTWARE.
 
 using System;
-using ICSharpCode.NRefactory.CSharp.Resolver;
+using ICSharpCode.NRefactory.PlayScript.Resolver;
 using ICSharpCode.NRefactory.Semantics;
 using ICSharpCode.NRefactory.TypeSystem;
 
-namespace ICSharpCode.NRefactory.CSharp.TypeSystem
+namespace ICSharpCode.NRefactory.PlayScript.TypeSystem
 {
 	/// <summary>
 	/// Represents a reference which could point to a type or namespace.
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/TypeSystemConvertVisitor.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/TypeSystemConvertVisitor.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/TypeSystemConvertVisitor.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/TypeSystemConvertVisitor.cs	2013-04-23 21:04:55.000000000 -0700
@@ -22,12 +22,12 @@ using System.Diagnostics;
 using System.IO;
 using System.Linq;
 using System.Text;
-using ICSharpCode.NRefactory.CSharp.TypeSystem;
-using ICSharpCode.NRefactory.CSharp.TypeSystem.ConstantValues;
+using ICSharpCode.NRefactory.PlayScript.TypeSystem;
+using ICSharpCode.NRefactory.PlayScript.TypeSystem.ConstantValues;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 
-namespace ICSharpCode.NRefactory.CSharp.TypeSystem
+namespace ICSharpCode.NRefactory.PlayScript.TypeSystem
 {
 	/// <summary>
 	/// Produces type and member definitions from the DOM.
@@ -867,7 +867,7 @@ namespace ICSharpCode.NRefactory.CSharp.
 		
 		void ConvertAttributes(IList<IUnresolvedAttribute> outputList, AttributeSection attributeSection)
 		{
-			foreach (CSharp.Attribute attr in attributeSection.Attributes) {
+			foreach (PlayScript.Attribute attr in attributeSection.Attributes) {
 				outputList.Add(ConvertAttribute(attr));
 			}
 		}
@@ -888,7 +888,7 @@ namespace ICSharpCode.NRefactory.CSharp.
 			return tr;
 		}
 		
-		CSharpAttribute ConvertAttribute(CSharp.Attribute attr)
+		CSharpAttribute ConvertAttribute(PlayScript.Attribute attr)
 		{
 			DomRegion region = MakeRegion(attr);
 			ITypeReference type = ConvertAttributeType(attr.Type, interningProvider);
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/UsingScope.cs ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/UsingScope.cs
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/TypeSystem/UsingScope.cs	2013-02-23 22:20:19.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/TypeSystem/UsingScope.cs	2013-04-23 21:04:55.000000000 -0700
@@ -20,12 +20,12 @@ using System;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Linq;
-using ICSharpCode.NRefactory.CSharp.TypeSystem;
+using ICSharpCode.NRefactory.PlayScript.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem;
 using ICSharpCode.NRefactory.TypeSystem.Implementation;
 using ICSharpCode.NRefactory.Utils;
 
-namespace ICSharpCode.NRefactory.CSharp.TypeSystem
+namespace ICSharpCode.NRefactory.PlayScript.TypeSystem
 {
 	/// <summary>
 	/// Represents a scope that contains "using" statements.
Binary files ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/bin/$(Configuration)/ICSharpCode.NRefactory.PlayScript.dll and ./main/src/addins/ICSharpCode.NRefactory.PlayScript/bin/$(Configuration)/ICSharpCode.NRefactory.PlayScript.dll differ
Binary files ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/bin/$(Configuration)/ICSharpCode.NRefactory.PlayScript.dll.mdb and ./main/src/addins/ICSharpCode.NRefactory.PlayScript/bin/$(Configuration)/ICSharpCode.NRefactory.PlayScript.dll.mdb differ
Binary files ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/bin/$(Configuration)/ICSharpCode.NRefactory.dll and ./main/src/addins/ICSharpCode.NRefactory.PlayScript/bin/$(Configuration)/ICSharpCode.NRefactory.dll differ
Binary files ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/bin/$(Configuration)/ICSharpCode.NRefactory.dll.mdb and ./main/src/addins/ICSharpCode.NRefactory.PlayScript/bin/$(Configuration)/ICSharpCode.NRefactory.dll.mdb differ
Binary files ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/bin/$(Configuration)/Mono.Cecil.dll and ./main/src/addins/ICSharpCode.NRefactory.PlayScript/bin/$(Configuration)/Mono.Cecil.dll differ
Binary files ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/bin/$(Configuration)/Mono.Cecil.dll.mdb and ./main/src/addins/ICSharpCode.NRefactory.PlayScript/bin/$(Configuration)/Mono.Cecil.dll.mdb differ
Binary files ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/bin/Debug/ICSharpCode.NRefactory.PlayScript.dll and ./main/src/addins/ICSharpCode.NRefactory.PlayScript/bin/Debug/ICSharpCode.NRefactory.PlayScript.dll differ
Binary files ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/bin/Debug/ICSharpCode.NRefactory.PlayScript.dll.mdb and ./main/src/addins/ICSharpCode.NRefactory.PlayScript/bin/Debug/ICSharpCode.NRefactory.PlayScript.dll.mdb differ
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/bin/Debug/ICSharpCode.NRefactory.PlayScript.xml ./main/src/addins/ICSharpCode.NRefactory.PlayScript/bin/Debug/ICSharpCode.NRefactory.PlayScript.xml
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/bin/Debug/ICSharpCode.NRefactory.PlayScript.xml	1969-12-31 16:00:00.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/bin/Debug/ICSharpCode.NRefactory.PlayScript.xml	2013-04-23 21:04:54.000000000 -0700
@@ -0,0 +1,6201 @@
+<?xml version="1.0"?>
+<doc>
+    <assembly>
+        <name>ICSharpCode.NRefactory.PlayScript</name>
+    </assembly>
+    <members>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Analysis.ControlFlowNode">
+            <summary>
+            Represents a node in the control flow graph of a C# method.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Analysis.ControlFlowNodeType.None">
+            <summary>
+            Unknown node type
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Analysis.ControlFlowNodeType.StartNode">
+            <summary>
+            Node in front of a statement
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Analysis.ControlFlowNodeType.BetweenStatements">
+            <summary>
+            Node between two statements
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Analysis.ControlFlowNodeType.EndNode">
+            <summary>
+            Node at the end of a statement list
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Analysis.ControlFlowNodeType.LoopCondition">
+            <summary>
+            Node representing the position before evaluating the condition of a loop.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Analysis.ControlFlowEdge.IsLeavingTryFinally">
+            <summary>
+            Gets whether this control flow edge is leaving any try-finally statements.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Analysis.ControlFlowEdge.TryFinallyStatements">
+            <summary>
+            Gets the try-finally statements that this control flow edge is leaving.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Analysis.ControlFlowEdgeType.Normal">
+            <summary>
+            Regular control flow.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Analysis.ControlFlowEdgeType.ConditionTrue">
+            <summary>
+            Conditional control flow (edge taken if condition is true)
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Analysis.ControlFlowEdgeType.ConditionFalse">
+            <summary>
+            Conditional control flow (edge taken if condition is false)
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Analysis.ControlFlowEdgeType.Jump">
+            <summary>
+            A jump statement (goto, goto case, break or continue)
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Analysis.ControlFlowGraphBuilder">
+            <summary>
+            Constructs the control flow graph for C# statements.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Analysis.ControlFlowGraphBuilder.EvaluateOnlyPrimitiveConstants">
+            <summary>
+            Gets/Sets whether to handle only primitive expressions as constants (no complex expressions like "a + b").
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Analysis.ControlFlowGraphBuilder.EvaluateConstant(ICSharpCode.NRefactory.PlayScript.Expression)">
+            <summary>
+            Evaluates an expression.
+            </summary>
+            <returns>The constant value of the expression; or null if the expression is not a constant.</returns>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Analysis.ControlFlowGraphBuilder.EvaluateCondition(ICSharpCode.NRefactory.PlayScript.Expression)">
+            <summary>
+            Evaluates an expression.
+            </summary>
+            <returns>The value of the constant boolean expression; or null if the value is not a constant boolean expression.</returns>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Analysis.ControlFlowGraphBuilder.NodeCreationVisitor.CreateConnectedEndNode(ICSharpCode.NRefactory.PlayScript.Statement,ICSharpCode.NRefactory.PlayScript.Analysis.ControlFlowNode)">
+            <summary>
+            Creates an end node for <c>stmt</c> and connects <c>from</c> with the new node.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Analysis.ControlFlowGraphBuilder.ExportGraph(System.Collections.Generic.IList{ICSharpCode.NRefactory.PlayScript.Analysis.ControlFlowNode})">
+            <summary>
+            Debugging helper that exports a control flow graph.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Analysis.DefiniteAssignmentStatus">
+            <summary>
+            Represents the definite assignment status of a variable at a specific location.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Analysis.DefiniteAssignmentStatus.PotentiallyAssigned">
+            <summary>
+            The variable might be assigned or unassigned.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Analysis.DefiniteAssignmentStatus.DefinitelyAssigned">
+            <summary>
+            The variable is definitely assigned.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Analysis.DefiniteAssignmentStatus.AssignedAfterTrueExpression">
+            <summary>
+            The variable is definitely assigned iff the expression results in the value 'true'.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Analysis.DefiniteAssignmentStatus.AssignedAfterFalseExpression">
+            <summary>
+            The variable is definitely assigned iff the expression results in the value 'false'.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Analysis.DefiniteAssignmentStatus.CodeUnreachable">
+            <summary>
+            The code is unreachable.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Analysis.DefiniteAssignmentAnalysis">
+            <summary>
+            Implements the C# definite assignment analysis (C# 4.0 Spec: §5.3 Definite assignment)
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Analysis.DefiniteAssignmentAnalysis.UnassignedVariableUses">
+            <summary>
+            Gets the unassigned usages of the previously analyzed variable.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Analysis.DefiniteAssignmentAnalysis.SetAnalyzedRange(ICSharpCode.NRefactory.PlayScript.Statement,ICSharpCode.NRefactory.PlayScript.Statement,System.Boolean,System.Boolean)">
+            <summary>
+            Sets the range of statements to be analyzed.
+            This method can be used to restrict the analysis to only a part of the method.
+            Only the control flow paths that are fully contained within the selected part will be analyzed.
+            </summary>
+            <remarks>By default, both 'start' and 'end' are inclusive.</remarks>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Analysis.DefiniteAssignmentAnalysis.ExportGraph">
+            <summary>
+            Exports the CFG. This method is intended to help debugging issues related to definite assignment.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Analysis.DefiniteAssignmentAnalysis.EvaluateConstant(ICSharpCode.NRefactory.PlayScript.Expression)">
+            <summary>
+            Evaluates an expression.
+            </summary>
+            <returns>The constant value of the expression; or null if the expression is not a constant.</returns>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Analysis.DefiniteAssignmentAnalysis.EvaluateCondition(ICSharpCode.NRefactory.PlayScript.Expression)">
+            <summary>
+            Evaluates an expression.
+            </summary>
+            <returns>The value of the constant boolean expression; or null if the value is not a constant boolean expression.</returns>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Analysis.ReachabilityAnalysis">
+            <summary>
+            Statement reachability analysis.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Analysis.SemanticHighlightingVisitor`1">
+            <summary>
+            C# Semantic highlighter.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Analysis.SemanticHighlightingVisitor`1.parameterModifierColor">
+            <summary>
+            Used for 'in' modifiers on type parameters.
+            </summary>
+            <remarks>
+            'in' may have a different color when used with 'foreach'.
+            'out' is not colored by semantic highlighting, as syntax highlighting can already detect it as a parameter modifier.
+            </remarks>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Analysis.SemanticHighlightingVisitor`1.inactiveCodeColor">
+            <summary>
+            Used for inactive code (excluded by preprocessor or ConditionalAttribute)
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Analysis.SemanticHighlightingVisitor`1.VisitChildrenUntil(ICSharpCode.NRefactory.PlayScript.AstNode,ICSharpCode.NRefactory.PlayScript.AstNode)">
+            <summary>
+            Visit all children of <c>node</c> until (but excluding) <c>end</c>.
+            If <c>end</c> is a null node, nothing will be visited.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Analysis.SemanticHighlightingVisitor`1.VisitChildrenAfter(ICSharpCode.NRefactory.PlayScript.AstNode,ICSharpCode.NRefactory.PlayScript.AstNode)">
+            <summary>
+            Visit all children of <c>node</c> after (excluding) <c>start</c>.
+            If <c>start</c> is a null node, all children will be visited.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstNode.GetRegion">
+            <summary>
+            Gets the region from StartLocation to EndLocation for this node.
+            The file name of the region is set based on the parent SyntaxTree's file name.
+            If this node is not connected to a whole compilation, the file name will be null.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.AstNode.Ancestors">
+            <summary>
+            Gets the ancestors of this node (excluding this node itself)
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.AstNode.AncestorsAndSelf">
+            <summary>
+            Gets the ancestors of this node (including this node itself)
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.AstNode.Descendants">
+            <summary>
+            Gets all descendants of this node (excluding this node itself).
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.AstNode.DescendantsAndSelf">
+            <summary>
+            Gets all descendants of this node (including this node itself).
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstNode.GetChildByRole``1(ICSharpCode.NRefactory.Role{``0})">
+            <summary>
+            Gets the first child with the specified role.
+            Returns the role's null object if the child is not found.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstNode.AddChildUnsafe(ICSharpCode.NRefactory.PlayScript.AstNode,ICSharpCode.NRefactory.Role)">
+            <summary>
+            Adds a child without performing any safety checks.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstNode.Remove">
+            <summary>
+            Removes this node from its parent.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstNode.ReplaceWith(ICSharpCode.NRefactory.PlayScript.AstNode)">
+            <summary>
+            Replaces this node with the new node.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstNode.Clone">
+            <summary>
+            Clones the whole subtree starting at this AST node.
+            </summary>
+            <remarks>Annotations are copied over to the new nodes; and any annotations implementing ICloneable will be cloned.</remarks>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstNode.GetNodeAt(System.Int32,System.Int32,System.Predicate{ICSharpCode.NRefactory.PlayScript.AstNode})">
+            <summary>
+            Gets the node specified by T at the location line, column. This is useful for getting a specific node from the tree. For example searching
+            the current method declaration.
+            (End exclusive)
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstNode.GetNodeAt(ICSharpCode.NRefactory.TextLocation,System.Predicate{ICSharpCode.NRefactory.PlayScript.AstNode})">
+            <summary>
+            Gets the node specified by pred at location. This is useful for getting a specific node from the tree. For example searching
+            the current method declaration.
+            (End exclusive)
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstNode.GetNodeAt``1(System.Int32,System.Int32)">
+            <summary>
+            Gets the node specified by T at the location line, column. This is useful for getting a specific node from the tree. For example searching
+            the current method declaration.
+            (End exclusive)
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstNode.GetNodeAt``1(ICSharpCode.NRefactory.TextLocation)">
+            <summary>
+            Gets the node specified by T at location. This is useful for getting a specific node from the tree. For example searching
+            the current method declaration.
+            (End exclusive)
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstNode.GetAdjacentNodeAt(System.Int32,System.Int32,System.Predicate{ICSharpCode.NRefactory.PlayScript.AstNode})">
+            <summary>
+            Gets the node specified by pred at the location line, column. This is useful for getting a specific node from the tree. For example searching
+            the current method declaration.
+            (End inclusive)
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstNode.GetAdjacentNodeAt(ICSharpCode.NRefactory.TextLocation,System.Predicate{ICSharpCode.NRefactory.PlayScript.AstNode})">
+            <summary>
+            Gets the node specified by pred at location. This is useful for getting a specific node from the tree. For example searching
+            the current method declaration.
+            (End inclusive)
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstNode.GetAdjacentNodeAt``1(System.Int32,System.Int32)">
+            <summary>
+            Gets the node specified by T at the location line, column. This is useful for getting a specific node from the tree. For example searching
+            the current method declaration.
+            (End inclusive)
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstNode.GetAdjacentNodeAt``1(ICSharpCode.NRefactory.TextLocation)">
+            <summary>
+            Gets the node specified by T at location. This is useful for getting a specific node from the tree. For example searching
+            the current method declaration.
+            (End inclusive)
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstNode.GetNodeContaining(ICSharpCode.NRefactory.TextLocation,ICSharpCode.NRefactory.TextLocation)">
+            <summary>
+            Gets the node that fully contains the range from startLocation to endLocation.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstNode.GetText(ICSharpCode.NRefactory.PlayScript.CSharpFormattingOptions)">
+            <summary>
+            Gets the node as formatted C# output.
+            </summary>
+            <param name="formattingOptions">
+            Formatting options.
+            </param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstNode.Contains(System.Int32,System.Int32)">
+            <summary>
+            Returns true, if the given coordinates (line, column) are in the node.
+            </summary>
+            <returns>
+            True, if the given coordinates are between StartLocation and EndLocation (exclusive); otherwise, false.
+            </returns>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstNode.Contains(ICSharpCode.NRefactory.TextLocation)">
+            <summary>
+            Returns true, if the given coordinates are in the node.
+            </summary>
+            <returns>
+            True, if location is between StartLocation and EndLocation (exclusive); otherwise, false.
+            </returns>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstNode.IsInside(System.Int32,System.Int32)">
+            <summary>
+            Returns true, if the given coordinates (line, column) are in the node.
+            </summary>
+            <returns>
+            True, if the given coordinates are between StartLocation and EndLocation (inclusive); otherwise, false.
+            </returns>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstNode.IsInside(ICSharpCode.NRefactory.TextLocation)">
+            <summary>
+            Returns true, if the given coordinates are in the node.
+            </summary>
+            <returns>
+            True, if location is between StartLocation and EndLocation (inclusive); otherwise, false.
+            </returns>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.AstNodeCollection`1">
+            <summary>
+            Represents the children of an AstNode that have a specific role.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstNodeCollection`1.FirstOrNullObject(System.Func{`0,System.Boolean})">
+            <summary>
+            Returns the first element for which the predicate returns true,
+            or the null node (AstNode with IsNull=true) if no such object is found.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstNodeCollection`1.LastOrNullObject(System.Func{`0,System.Boolean})">
+            <summary>
+            Returns the last element for which the predicate returns true,
+            or the null node (AstNode with IsNull=true) if no such object is found.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstNodeCollection`1.AcceptVisitor(ICSharpCode.NRefactory.PlayScript.IAstVisitor)">
+            <summary>
+            Applies the <paramref name="visitor" /> to all nodes in this collection.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.AstType">
+            <summary>
+            A type reference in the C# AST.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstType.ToTypeReference(ICSharpCode.NRefactory.TypeSystem.InterningProvider)">
+            <summary>
+            Create an ITypeReference for this AstType.
+            Uses the context (ancestors of this node) to determine the correct <see cref="T:ICSharpCode.NRefactory.PlayScript.NameLookupMode" />.
+            </summary>
+            <remarks>
+            The resulting type reference will read the context information from the
+            <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext" />:
+            For resolving type parameters, the CurrentTypeDefinition/CurrentMember is used.
+            For resolving simple names, the current namespace and usings from the CurrentUsingScope
+            (on CSharpTypeResolveContext only) is used.
+            </remarks>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstType.ToTypeReference(ICSharpCode.NRefactory.PlayScript.NameLookupMode,ICSharpCode.NRefactory.TypeSystem.InterningProvider)">
+            <summary>
+            Create an ITypeReference for this AstType.
+            </summary>
+            <remarks>
+            The resulting type reference will read the context information from the
+            <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext" />:
+            For resolving type parameters, the CurrentTypeDefinition/CurrentMember is used.
+            For resolving simple names, the current namespace and usings from the CurrentUsingScope
+            (on CSharpTypeResolveContext only) is used.
+            </remarks>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstType.GetNameLookupMode">
+            <summary>
+            Gets the name lookup mode from the context (looking at the ancestors of this <see cref="T:ICSharpCode.NRefactory.PlayScript.AstType" />).
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstType.MakePointerType">
+            <summary>
+            Creates a pointer type from this type by nesting it in a <see cref="T:ICSharpCode.NRefactory.PlayScript.ComposedType" />.
+            If this type already is a pointer type, this method just increases the PointerRank of the existing pointer type.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstType.MakeArrayType(System.Int32)">
+            <summary>
+            Creates an array type from this type by nesting it in a <see cref="T:ICSharpCode.NRefactory.PlayScript.ComposedType" />.
+            If this type already is an array type, the additional rank is prepended to the existing array specifier list.
+            Thus, <c>new SimpleType("T").MakeArrayType(1).MakeArrayType(2)</c> will result in "T[,][]".
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstType.MakeNullableType">
+            <summary>
+            Creates a nullable type from this type by nesting it in a <see cref="T:ICSharpCode.NRefactory.PlayScript.ComposedType" />.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstType.Member(System.String)">
+            <summary>
+            Builds an expression that can be used to access a static member on this type.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstType.MemberType(System.String,ICSharpCode.NRefactory.PlayScript.AstType[])">
+            <summary>
+            Builds an expression that can be used to access a static member on this type.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstType.MemberType(System.String,System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.PlayScript.AstType})">
+            <summary>
+            Builds an expression that can be used to access a static member on this type.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstType.Invoke(System.String,System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.PlayScript.Expression})">
+            <summary>
+            Builds an invocation expression using this type as target.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstType.Invoke(System.String,ICSharpCode.NRefactory.PlayScript.Expression[])">
+            <summary>
+            Builds an invocation expression using this type as target.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstType.Invoke(System.String,System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.PlayScript.AstType},System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.PlayScript.Expression})">
+            <summary>
+            Builds an invocation expression using this type as target.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstType.Create(System.String)">
+            <summary>
+            Creates a simple AstType from a dotted name.
+            Does not support generics, arrays, etc. - just simple dotted names,
+            e.g. namespace names.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.DocumentationReference">
+            <summary>
+            Represents a 'cref' reference in XML documentation.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.DocumentationReference.EntityType">
+            <summary>
+            Gets/Sets the entity type.
+            Possible values are:
+            <c>EntityType.Operator</c> for operators,
+            <c>EntityType.Indexer</c> for indexers,
+            <c>EntityType.TypeDefinition</c> for references to primitive types,
+            and <c>EntityType.None</c> for everything else.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.DocumentationReference.OperatorType">
+            <summary>
+            Gets/Sets the operator type.
+            This property is only used when EntityType==Operator.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.DocumentationReference.HasParameterList">
+            <summary>
+            Gets/Sets whether a parameter list was provided.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.DocumentationReference.DeclaringType">
+            <summary>
+            Gets/Sets the declaring type.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.DocumentationReference.MemberName">
+            <summary>
+            Gets/sets the member name.
+            This property is only used when EntityType==None.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.DocumentationReference.ConversionOperatorReturnType">
+            <summary>
+            Gets/Sets the return type of conversion operators.
+            This property is only used when EntityType==Operator and OperatorType is explicit or implicit.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.IdentifierExpressionBackreference">
+            <summary>
+            Matches identifier expressions that have the same identifier as the referenced variable/type definition/method definition.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.SyntaxExtensions">
+            <summary>
+            Extension methods for the syntax tree.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.SyntaxTree.FileName">
+            <summary>
+            Gets/Sets the file name of this syntax tree.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.SyntaxTree.ConditionalSymbols">
+            <summary>
+            Gets the conditional symbols used to parse the source file. Note that this list contains
+            the conditional symbols at the start of the first token in the file - including the ones defined
+            in the source file.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.SyntaxTree.TopExpression">
+            <summary>
+            Gets the expression that was on top of the parse stack.
+            This is the only way to get an expression that isn't part of a statment.
+            (eg. when an error follows an expression).
+            This is used for code completion to 'get the expression before a token - like ., &lt;, ('.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.SyntaxTree.GetTypes(System.Boolean)">
+            <summary>
+            Gets all defined types in this syntax tree.
+            </summary>
+            <returns>
+            A list containing <see cref="T:ICSharpCode.NRefactory.PlayScript.TypeDeclaration" /> or <see cref="T:ICSharpCode.NRefactory.PlayScript.DelegateDeclaration" /> nodes.
+            </returns>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.SyntaxTree.ToTypeSystem">
+            <summary>
+            Converts this syntax tree into a parsed file that can be stored in the type system.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.ArraySpecifier">
+            <summary>
+            [,,,]
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.CSharpTokenNode">
+            <summary>
+            Represents a token in C#. Note that the type of the token is defined through the TokenRole.
+            </summary>
+            <remarks>
+            In all non null c# token nodes the Role of a CSharpToken must be a TokenRole.
+            </remarks>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.CSharpUtil.NegateRelationalOperator(ICSharpCode.NRefactory.PlayScript.BinaryOperatorType)">
+            <summary>
+            Get negation of the specified relational operator
+            </summary>
+            <returns>
+            negation of the specified relational operator, or BinaryOperatorType.Any if it's not a relational operator
+            </returns>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.DepthFirstAstVisitor">
+            <summary>
+            AST visitor with a default implementation that visits all node depth-first.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.DepthFirstAstVisitor`1">
+            <summary>
+            AST visitor with a default implementation that visits all node depth-first.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.DepthFirstAstVisitor`2">
+            <summary>
+            AST visitor with a default implementation that visits all node depth-first.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.ErrorNode">
+            <summary>
+            Represents a parsing error in the ast. At the moment it only represents missing closing bracket.
+            This closing bracket is replaced by a node at the highest possible position.
+            (To make GetAstNodeAt (line, col) working).
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.AnonymousMethodExpression">
+            <summary>
+            [async] delegate(Parameters) {Body}
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.AnonymousTypeCreateExpression">
+            <summary>
+            new { [ExpressionList] }
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.ArrayCreateExpression">
+            <summary>
+            new Type[Dimensions]
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.ArrayCreateExpression.AdditionalArraySpecifiers">
+            <summary>
+            Gets additional array ranks (those without size info).
+            Empty for "new int[5,1]"; will contain a single element for "new int[5][]".
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.ArrayInitializerExpression">
+            <summary>
+            { Elements }
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.ArrayInitializerExpression.IsSingleElement">
+            <summary>
+            For ease of use purposes in the resolver the ast representation
+            of { a, b, c }  is { {a}, {b}, {c} }.
+            If IsSingleElement is true then this array initializer expression is a generated one.
+            That has no meaning in the source code (and contains no brace tokens).
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.ArrayInitializerExpression.SingleArrayInitializerExpression">
+            <summary>
+            Single elements in array initializers are represented with this special class.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.AsExpression">
+            <summary>
+            Expression as TypeReference
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.AssignmentExpression">
+            <summary>
+            Left Operator= Right
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AssignmentExpression.GetCorrespondingBinaryOperator(ICSharpCode.NRefactory.PlayScript.AssignmentOperatorType)">
+            <summary>
+            Gets the binary operator for the specified compound assignment operator.
+            Returns null if 'op' is not a compound assignment.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.AssignmentOperatorType.Assign">
+            <summary>left = right</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.AssignmentOperatorType.Add">
+            <summary>left += right</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.AssignmentOperatorType.Subtract">
+            <summary>left -= right</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.AssignmentOperatorType.Multiply">
+            <summary>left *= right</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.AssignmentOperatorType.Divide">
+            <summary>left /= right</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.AssignmentOperatorType.Modulus">
+            <summary>left %= right</summary>
+        </member>
+        <!--FIXME: Invalid documentation markup was found for member F:ICSharpCode.NRefactory.PlayScript.AssignmentOperatorType.ShiftLeft-->
+        <member name="F:ICSharpCode.NRefactory.PlayScript.AssignmentOperatorType.ShiftRight">
+            <summary>left &gt;&gt;= right</summary>
+        </member>
+        <!--FIXME: Invalid documentation markup was found for member F:ICSharpCode.NRefactory.PlayScript.AssignmentOperatorType.BitwiseAnd-->
+        <member name="F:ICSharpCode.NRefactory.PlayScript.AssignmentOperatorType.BitwiseOr">
+            <summary>left |= right</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.AssignmentOperatorType.ExclusiveOr">
+            <summary>left ^= right</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.AssignmentOperatorType.Any">
+            <summary>Any operator (for pattern matching)</summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.BaseReferenceExpression">
+            <summary>
+            base
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.BinaryOperatorExpression">
+            <summary>
+            Left Operator Right
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.BinaryOperatorType.Any">
+            <summary>
+            Any binary operator (used in pattern matching)
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.BinaryOperatorType.BitwiseAnd">
+            <summary>left &amp; right</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.BinaryOperatorType.BitwiseOr">
+            <summary>left | right</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.BinaryOperatorType.ConditionalAnd">
+            <summary>left &amp;&amp; right</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.BinaryOperatorType.ConditionalOr">
+            <summary>left || right</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.BinaryOperatorType.ExclusiveOr">
+            <summary>left ^ right</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.BinaryOperatorType.GreaterThan">
+            <summary>left &gt; right</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.BinaryOperatorType.GreaterThanOrEqual">
+            <summary>left &gt;= right</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.BinaryOperatorType.Equality">
+            <summary>left == right</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.BinaryOperatorType.InEquality">
+            <summary>left != right</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.BinaryOperatorType.LessThan">
+            <summary>left &lt; right</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.BinaryOperatorType.LessThanOrEqual">
+            <summary>left &lt;= right</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.BinaryOperatorType.Add">
+            <summary>left + right</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.BinaryOperatorType.Subtract">
+            <summary>left - right</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.BinaryOperatorType.Multiply">
+            <summary>left * right</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.BinaryOperatorType.Divide">
+            <summary>left / right</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.BinaryOperatorType.Modulus">
+            <summary>left % right</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.BinaryOperatorType.ShiftLeft">
+            <summary>left &lt;&lt; right</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.BinaryOperatorType.ShiftRight">
+            <summary>left &gt;&gt; right</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.BinaryOperatorType.NullCoalescing">
+            <summary>left ?? right</summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.CastExpression">
+            <summary>
+            (CastTo)Expression
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.CheckedExpression">
+            <summary>
+            checked(Expression)
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.ConditionalExpression">
+            <summary>
+            Condition ? TrueExpression : FalseExpression
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.DefaultValueExpression">
+            <summary>
+            default(Type)
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.DirectionExpression">
+            <summary>
+            ref Expression
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.EmptyExpression">
+            <summary>
+            Type&lt;[EMPTY]&gt;
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Expression">
+            <summary>
+            Base class for expressions.
+            </summary>
+            <remarks>
+            This class is useful even though it doesn't provide any additional functionality:
+            It can be used to communicate more information in APIs, e.g. "this subnode will always be an expression"
+            </remarks>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Expression.Member(System.String)">
+            <summary>
+            Builds an member reference expression using this expression as target.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Expression.Indexer(System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.PlayScript.Expression})">
+            <summary>
+            Builds an indexer expression using this expression as target.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Expression.Indexer(ICSharpCode.NRefactory.PlayScript.Expression[])">
+            <summary>
+            Builds an indexer expression using this expression as target.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Expression.Invoke(System.String,System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.PlayScript.Expression})">
+            <summary>
+            Builds an invocation expression using this expression as target.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Expression.Invoke(System.String,ICSharpCode.NRefactory.PlayScript.Expression[])">
+            <summary>
+            Builds an invocation expression using this expression as target.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Expression.Invoke(System.String,System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.PlayScript.AstType},System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.PlayScript.Expression})">
+            <summary>
+            Builds an invocation expression using this expression as target.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Expression.Invoke(System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.PlayScript.Expression})">
+            <summary>
+            Builds an invocation expression using this expression as target.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Expression.Invoke(ICSharpCode.NRefactory.PlayScript.Expression[])">
+            <summary>
+            Builds an invocation expression using this expression as target.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.IndexerExpression">
+            <summary>
+            Target[Arguments]
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.InvocationExpression">
+            <summary>
+            Target(Arguments)
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.IsExpression">
+            <summary>
+            Expression is Type
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.LambdaExpression">
+            <summary>
+            [async] Parameters =&gt; Body
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.MemberReferenceExpression">
+            <summary>
+            Target.MemberName
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.NamedArgumentExpression">
+            <summary>
+            Represents a named argument passed to a method or attribute.
+            name: expression
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.NamedExpression">
+            <summary>
+            name = expression
+            This isn't the same as 'assign' even though it has the same syntax.
+            This expression is used in object initializers and for named attribute arguments [Attr(FieldName = value)].
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.NullReferenceExpression">
+            <summary>
+            null
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.ObjectCreateExpression">
+            <summary>
+            new Type(Arguments) { Initializer }
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.ParenthesizedExpression">
+            <summary>
+            ( Expression )
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.ParenthesizedExpression.ActsAsParenthesizedExpression(ICSharpCode.NRefactory.PlayScript.AstNode)">
+            <summary>
+            Gets whether the expression acts like a parenthesized expression,
+            i.e. whether information about the expected type (for lambda type inference) flows
+            into the inner expression.
+            </summary>
+            <returns>Returns true for ParenthesizedExpression, CheckedExpression or UncheckedExpression; false otherwise.</returns>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.ParenthesizedExpression.UnpackParenthesizedExpression(ICSharpCode.NRefactory.PlayScript.Expression)">
+            <summary>
+            Unpacks the given expression if it is a ParenthesizedExpression, CheckedExpression or UncheckedExpression.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.PointerReferenceExpression">
+            <summary>
+            Target-&gt;MemberName
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.PrimitiveExpression">
+            <summary>
+            Represents a literal value.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.QueryContinuationClause">
+            <summary>
+            Represents a query continuation.
+            "(from .. select ..) into Identifier" or "(from .. group .. by ..) into Identifier"
+            Note that "join .. into .." is not a query continuation!
+            This is always the first(!!) clause in a query expression.
+            The tree for "from a in b select c into d select e" looks like this:
+            new QueryExpression {
+            	new QueryContinuationClause {
+            		PrecedingQuery = new QueryExpression {
+            			new QueryFromClause(a in b),
+            			new QuerySelectClause(c)
+            		},
+            		Identifier = d
+            	},
+            	new QuerySelectClause(e)
+            }
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.QueryJoinClause">
+            <summary>
+            Represents a join or group join clause.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.SizeOfExpression">
+            <summary>
+            sizeof(Type)
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.StackAllocExpression">
+            <summary>
+            stackalloc Type[Count]
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.ThisReferenceExpression">
+            <summary>
+            this
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.TypeOfExpression">
+            <summary>
+            typeof(Type)
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.TypeReferenceExpression">
+            <summary>
+            Represents an AstType as an expression.
+            This is used when calling a method on a primitive type: "int.Parse()"
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.UnaryOperatorExpression">
+            <summary>
+            Operator Expression
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.UnaryOperatorType.Any">
+            <summary>
+            Any unary operator (used in pattern matching)
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.UnaryOperatorType.Not">
+            <summary>Logical not (!a)</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.UnaryOperatorType.BitNot">
+            <summary>Bitwise not (~a)</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.UnaryOperatorType.Minus">
+            <summary>Unary minus (-a)</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.UnaryOperatorType.Plus">
+            <summary>Unary plus (+a)</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.UnaryOperatorType.Increment">
+            <summary>Pre increment (++a)</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.UnaryOperatorType.Decrement">
+            <summary>Pre decrement (--a)</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.UnaryOperatorType.PostIncrement">
+            <summary>Post increment (a++)</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.UnaryOperatorType.PostDecrement">
+            <summary>Post decrement (a--)</summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.UnaryOperatorType.Dereference">
+            <summary>Dereferencing (*a)</summary>
+        </member>
+        <!--FIXME: Invalid documentation markup was found for member F:ICSharpCode.NRefactory.PlayScript.UnaryOperatorType.AddressOf-->
+        <member name="F:ICSharpCode.NRefactory.PlayScript.UnaryOperatorType.Await">
+            <summary>C# 5.0 await</summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.UncheckedExpression">
+            <summary>
+            unchecked(Expression)
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.UndocumentedExpression">
+            <summary>
+            Represents undocumented expressions.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Attribute">
+            <summary>
+            Attribute(Arguments)
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.AttributeSection">
+            <summary>
+            [AttributeTarget: Attributes]
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.CommentType.SingleLine">
+            <summary>
+            "//" comment
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.CommentType.MultiLine">
+            <summary>
+            "/* */" comment
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.CommentType.Documentation">
+            <summary>
+            "///" comment
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.CommentType.InactiveCode">
+            <summary>
+            Inactive code (code in non-taken "#if")
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.CommentType.MultiLineDocumentation">
+            <summary>
+            "/** */" comment
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Comment.IsDocumentation">
+            <summary>
+            Returns true if the <see cref="T:ICSharpCode.NRefactory.PlayScript.CommentType" /> is Documentation or MultiLineDocumentation.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Constraint">
+            <summary>
+            where TypeParameter : BaseTypes
+            </summary>
+            <remarks>
+            new(), struct and class constraints are represented using a PrimitiveType "new", "struct" or "class"
+            </remarks>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.DelegateDeclaration">
+            <summary>
+            delegate ReturnType Name&lt;TypeParameters&gt;(Parameters) where Constraints;
+            </summary>
+        </member>
+        <!--FIXME: Invalid documentation markup was found for member T:ICSharpCode.NRefactory.PlayScript.ExternAliasDeclaration-->
+        <member name="T:ICSharpCode.NRefactory.PlayScript.NamespaceDeclaration">
+            <summary>
+            namespace Name { Members }
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.NamespaceDeclaration.FullName">
+            <summary>
+            Gets the full namespace name (including any parent namespaces)
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.TypeDeclaration">
+            <summary>
+            class Name&lt;TypeParameters&gt; : BaseTypes where Constraints;
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.TypeParameterDeclaration">
+            <summary>
+            [in|out] Name
+            Represents a type parameter.
+            Note: mirroring the C# syntax, constraints are not part of the type parameter declaration, but belong
+            to the parent type or method.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.UsingAliasDeclaration">
+            <summary>
+            using Alias = Import;
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.UsingDeclaration">
+            <summary>
+            using Import;
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.IAstVisitor">
+            <summary>
+            AST visitor.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.IAstVisitor`1">
+            <summary>
+            AST visitor.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.IAstVisitor`2">
+            <summary>
+            AST visitor.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Modifiers.Any">
+            <summary>
+            Special value used to match any modifiers during pattern matching.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.NodeType.TypeReference">
+            <summary>
+            AstType
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.NodeType.TypeDeclaration">
+            <summary>
+            Type or delegate declaration
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.NodeType.Whitespace">
+            <summary>
+            Comment or whitespace or pre-processor directive
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.NodeType.Pattern">
+            <summary>
+            Placeholder for a pattern
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.BlockStatement">
+            <summary>
+            { Statements }
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.BreakStatement">
+            <summary>
+            break;
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.CheckedStatement">
+            <summary>
+            checked BodyBlock
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.ContinueStatement">
+            <summary>
+            continue;
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.DoWhileStatement">
+            <summary>
+            "do EmbeddedStatement while(Condition);"
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.EmptyStatement">
+            <summary>
+            ;
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.ExpressionStatement">
+            <summary>
+            Expression;
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.FixedStatement">
+            <summary>
+            fixed (Type Variables) EmbeddedStatement
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.ForeachStatement">
+            <summary>
+            foreach (Type VariableName in InExpression) EmbeddedStatement
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.ForStatement">
+            <summary>
+            for (Initializers; Condition; Iterators) EmbeddedStatement
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.ForStatement.Initializers">
+            <summary>
+            Gets the list of initializer statements.
+            Note: this contains multiple statements for "for (a = 2, b = 1; a &gt; b; a--)", but contains
+            only a single statement for "for (int a = 2, b = 1; a &gt; b; a--)" (a single VariableDeclarationStatement with two variables)
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.GotoStatement">
+            <summary>
+            "goto Label;"
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.GotoCaseStatement">
+            <summary>
+            or "goto case LabelExpression;"
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.GotoCaseStatement.LabelExpression">
+            <summary>
+            Used for "goto case LabelExpression;"
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.GotoDefaultStatement">
+            <summary>
+            or "goto default;"
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.IfElseStatement">
+            <summary>
+            if (Condition) TrueStatement else FalseStatement
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.LabelStatement">
+            <summary>
+            Label:
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.LockStatement">
+            <summary>
+            lock (Expression) EmbeddedStatement;
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.ReturnStatement">
+            <summary>
+            return Expression;
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Statement">
+            <summary>
+            Base class for statements.
+            </summary>
+            <remarks>
+            This class is useful even though it doesn't provide any additional functionality:
+            It can be used to communicate more information in APIs, e.g. "this subnode will always be a statement"
+            </remarks>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.SwitchStatement">
+            <summary>
+            switch (Expression) { SwitchSections }
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.CaseLabel.Expression">
+            <summary>
+            Gets or sets the expression. The expression can be null - if the expression is null, it's the default switch section.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.ThrowStatement">
+            <summary>
+            throw Expression;
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.TryCatchStatement">
+            <summary>
+            try TryBlock CatchClauses finally FinallyBlock
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.CatchClause">
+            <summary>
+            catch (Type VariableName) { Body }
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.UncheckedStatement">
+            <summary>
+            unchecked BodyBlock
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.UnsafeStatement">
+            <summary>
+            unsafe { Body }
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.UsingStatement">
+            <summary>
+            using (ResourceAcquisition) EmbeddedStatement
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.UsingStatement.ResourceAcquisition">
+            <summary>
+            Either a VariableDeclarationStatement, or an Expression.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.WhileStatement">
+            <summary>
+            "while (Condition) EmbeddedStatement"
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.YieldBreakStatement">
+            <summary>
+            yield break;
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.YieldReturnStatement">
+            <summary>
+            yield return Expression;
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Accessor">
+            <summary>
+            get/set/add/remove
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.CustomEventDeclaration.PrivateImplementationType">
+            <summary>
+            Gets/Sets the type reference of the interface that is explicitly implemented.
+            Null node if this member is not an explicit interface implementation.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.FixedVariableInitializer">
+            <summary>
+            Name [ CountExpression ]
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.IndexerDeclaration.PrivateImplementationType">
+            <summary>
+            Gets/Sets the type reference of the interface that is explicitly implemented.
+            Null node if this member is not an explicit interface implementation.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.MethodDeclaration.PrivateImplementationType">
+            <summary>
+            Gets/Sets the type reference of the interface that is explicitly implemented.
+            Null node if this member is not an explicit interface implementation.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.OperatorDeclaration.GetOperatorType(System.String)">
+            <summary>
+            Gets the operator type from the method name, or null, if the method does not represent one of the known operator types.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.OperatorDeclaration.GetName(ICSharpCode.NRefactory.PlayScript.OperatorType)">
+            <summary>
+            Gets the method name for the operator type. ("op_Addition", "op_Implicit", etc.)
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.OperatorDeclaration.GetToken(ICSharpCode.NRefactory.PlayScript.OperatorType)">
+            <summary>
+            Gets the token for the operator type ("+", "implicit", etc.)
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.PropertyDeclaration.PrivateImplementationType">
+            <summary>
+            Gets/Sets the type reference of the interface that is explicitly implemented.
+            Null node if this member is not an explicit interface implementation.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.CSharpProjectContent.SetAssemblyName(System.String)">
+            <summary>
+            Sets both the short and the full assembly names.
+            </summary>
+            <param name="newAssemblyName">New full assembly name.</param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.CSharpProjectContent.AddOrUpdateFiles(System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.TypeSystem.IUnresolvedFile})">
+            <summary>
+            Adds the specified files to the project content.
+            If a file with the same name already exists, updated the existing file.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.CSharpProjectContent.AddOrUpdateFiles(ICSharpCode.NRefactory.TypeSystem.IUnresolvedFile[])">
+            <summary>
+            Adds the specified files to the project content.
+            If a file with the same name already exists, this method updates the existing file.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.CSharpProjectContent.RemoveFiles(System.Collections.Generic.IEnumerable{System.String})">
+            <summary>
+            Removes the files with the specified names.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.CSharpProjectContent.RemoveFiles(System.String[])">
+            <summary>
+            Removes the files with the specified names.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstFormattingVisitor.ApplyChanges">
+            <summary>
+            Applies the changes to the input document.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.AstFormattingVisitor.ApplyChanges(ICSharpCode.NRefactory.PlayScript.Refactoring.Script)">
+            <summary>
+            Applies the changes to the given Script instance.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.CodeDomConvertVisitor">
+            <summary>
+            Converts from C# AST to CodeDom.
+            </summary>
+            <remarks>
+            The conversion is intended for use in the SharpDevelop forms designer.
+            </remarks>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.CodeDomConvertVisitor.UseFullyQualifiedTypeNames">
+            <summary>
+            Gets/Sets whether the visitor should convert short type names into
+            fully qualified type names.
+            The default is <c>false</c>.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.CodeDomConvertVisitor.AllowSnippetNodes">
+            <summary>
+            Gets whether the visitor is allowed to produce snippet nodes for
+            code that cannot be converted.
+            The default is <c>true</c>. If this property is set to <c>false</c>,
+            unconvertible code will throw a NotSupportedException.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.CodeDomConvertVisitor.Convert(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.PlayScript.SyntaxTree,ICSharpCode.NRefactory.PlayScript.TypeSystem.CSharpUnresolvedFile)">
+            <summary>
+            Converts a syntax tree to CodeDom.
+            </summary>
+            <param name="syntaxTree">The input syntax tree.</param>
+            <param name="compilation">The current compilation.</param>
+            <param name="unresolvedFile">CSharpUnresolvedFile, used for resolving.</param>
+            <returns>Converted CodeCompileUnit</returns>
+            <remarks>
+            This conversion process requires a resolver because it needs to distinguish field/property/event references etc.
+            </remarks>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.CodeDomConvertVisitor.Convert(ICSharpCode.NRefactory.PlayScript.AstNode,ICSharpCode.NRefactory.PlayScript.Resolver.CSharpAstResolver)">
+            <summary>
+            Converts a C# AST node to CodeDom.
+            </summary>
+            <param name="node">The input node.</param>
+            <param name="resolver">The AST resolver.</param>
+            <returns>The node converted into CodeDom</returns>
+            <remarks>
+            This conversion process requires a resolver because it needs to distinguish field/property/event references etc.
+            </remarks>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.CodeDomConvertVisitor.MakeSnippetExpression(ICSharpCode.NRefactory.PlayScript.Expression)">
+            <summary>
+            Converts an expression by storing it as C# snippet.
+            This is used for expressions that cannot be represented in CodeDom.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.CSharpAmbience">
+            <summary>
+            C# ambience.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.InsertParenthesesVisitor">
+            <summary>
+            Inserts the parentheses into the AST that are needed to ensure the AST can be printed correctly.
+            For example, if the AST contains
+            BinaryOperatorExpresson(2, Mul, BinaryOperatorExpression(1, Add, 1))); printing that AST
+            would incorrectly result in "2 * 1 + 1". By running InsertParenthesesVisitor, the necessary
+            parentheses are inserted: "2 * (1 + 1)".
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.InsertParenthesesVisitor.InsertParenthesesForReadability">
+            <summary>
+            Gets/Sets whether the visitor should insert parentheses to make the code better looking.
+            If this property is false, it will insert parentheses only where strictly required by the language spec.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.InsertParenthesesVisitor.GetPrecedence(ICSharpCode.NRefactory.PlayScript.Expression)">
+            <summary>
+            Gets the row number in the C# 4.0 spec operator precedence table.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.InsertParenthesesVisitor.ParenthesizeIfRequired(ICSharpCode.NRefactory.PlayScript.Expression,System.Int32)">
+            <summary>
+            Parenthesizes the expression if it does not have the minimum required precedence.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.IOutputFormatter">
+            <summary>
+            Output formatter for the Output visitor.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.IOutputFormatter.WriteIdentifier(System.String)">
+            <summary>
+            Writes an identifier.
+            If the identifier conflicts with a keyword, the output visitor will
+            call <c>WriteToken("@")</c> before calling WriteIdentifier().
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.IOutputFormatter.WriteKeyword(System.String)">
+            <summary>
+            Writes a keyword to the output.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.IOutputFormatter.WriteToken(System.String)">
+            <summary>
+            Writes a token to the output.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.CSharpOutputVisitor">
+            <summary>
+            Outputs the AST.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.CSharpOutputVisitor.lastWritten">
+            <summary>
+            Used to insert the minimal amount of spaces so that the lexer recognizes the tokens that were written.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.CSharpOutputVisitor.WriteSpecials(ICSharpCode.NRefactory.PlayScript.AstNode,ICSharpCode.NRefactory.PlayScript.AstNode)">
+            <summary>
+            Writes all specials from start to end (exclusive). Does not touch the positionStack.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.CSharpOutputVisitor.WriteSpecialsUpToRole(ICSharpCode.NRefactory.Role)">
+            <summary>
+            Writes all specials between the current position (in the positionStack) and the next
+            node with the specified role. Advances the current position.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.CSharpOutputVisitor.WriteSpecialsUpToNode(ICSharpCode.NRefactory.PlayScript.AstNode)">
+            <summary>
+            Writes all specials between the current position (in the positionStack) and the specified node.
+            Advances the current position.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.CSharpOutputVisitor.Comma(ICSharpCode.NRefactory.PlayScript.AstNode,System.Boolean)">
+            <summary>
+            Writes a comma.
+            </summary>
+            <param name="nextNode">The next node after the comma.</param>
+            <param name="noSpaceAfterComma">When set prevents printing a space after comma.</param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.CSharpOutputVisitor.OptionalComma">
+            <summary>
+            Writes an optional comma, e.g. at the end of an enum declaration or in an array initializer
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.CSharpOutputVisitor.OptionalSemicolon">
+            <summary>
+            Writes an optional semicolon, e.g. at the end of a type or namespace declaration.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.CSharpOutputVisitor.WriteKeyword(ICSharpCode.NRefactory.PlayScript.TokenRole)">
+            <summary>
+            Writes a keyword, and all specials up to
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.CSharpOutputVisitor.Semicolon">
+            <summary>
+            Marks the end of a statement
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.CSharpOutputVisitor.Space(System.Boolean)">
+            <summary>
+            Writes a space depending on policy.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.CSharpOutputVisitor.IsKeyword(System.String,ICSharpCode.NRefactory.PlayScript.AstNode)">
+            <summary>
+            Determines whether the specified identifier is a keyword in the given context.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.CSharpOutputVisitor.ConvertChar(System.Char)">
+            <summary>
+            Gets the escape sequence for the specified character.
+            </summary>
+            <remarks>This method does not convert ' or ".</remarks>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.CSharpOutputVisitor.ConvertString(System.String)">
+            <summary>
+            Converts special characters to escape sequences within the given string.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.TextWriterOutputFormatter">
+            <summary>
+            Writes C# code into a TextWriter.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.CompilerSettings">
+            <summary>
+            C# compiler settings.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.CompilerSettings.#ctor">
+            <summary>
+            Creates a new CompilerSettings instance.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.CompilerSettings.AllowUnsafeBlocks">
+            <summary>
+            Gets/Sets whether <c>unsafe</c> code is allowed.
+            The default is <c>true</c>. If set to false, parsing unsafe code will result in parser errors.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.CompilerSettings.CheckForOverflow">
+            <summary>
+            Gets/Sets whether overflow checking is enabled.
+            The default is <c>false</c>. This setting effects semantic analysis.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.CompilerSettings.LanguageVersion">
+            <summary>
+            Gets/Sets the language version used by the parser.
+            Using language constructs newer than the supplied version will result in parser errors.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.CompilerSettings.ConditionalSymbols">
+            <summary>
+            Gets/Sets the list of conditional symbols that are defined project-wide.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.CompilerSettings.SpecificWarningsAsErrors">
+            <summary>
+            Allows treating specific warnings as errors without setting <see cref="P:ICSharpCode.NRefactory.PlayScript.CompilerSettings.TreatWarningsAsErrors" /> to true.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.CompilerSettings.DisabledWarnings">
+            <summary>
+            Disables the specified warnings.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.PlayScriptParser.Parse(System.String,System.String)">
+            <summary>
+            Parses a C# code file.
+            </summary>
+            <param name="program">The source code to parse.</param>
+            <param name="fileName">The file name. Used to identify the file (e.g. when building a type system).
+            This can be an arbitrary identifier, NRefactory never tries to access the file on disk.</param>
+            <returns>Returns the syntax tree.</returns>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.PlayScriptParser.Parse(System.IO.TextReader,System.String)">
+            <summary>
+            Parses a C# code file.
+            </summary>
+            <param name="reader">The text reader containing the source code to parse.</param>
+            <param name="fileName">The file name. Used to identify the file (e.g. when building a type system).
+            This can be an arbitrary identifier, NRefactory never tries to access the file on disk.</param>
+            <returns>Returns the syntax tree.</returns>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.PlayScriptParser.Parse(Mono.CSharpPs.CompilerCompilationUnit,System.String)">
+            <summary>
+            Converts a Mono.CSharpPs syntax tree into an NRefactory syntax tree.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.PlayScriptParser.CompilationUnitCallback">
+            <summary>
+            Callback that gets called with the Mono.CSharpPs syntax tree whenever some code is parsed.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.PlayScriptParser.GenerateTypeSystemMode">
+            <summary>
+            Specifies whether to run the parser in a special mode for generating the type system.
+            If this property is true, the syntax tree will only contain nodes relevant for the
+            <see cref="M:ICSharpCode.NRefactory.PlayScript.SyntaxTree.ToTypeSystem" /> call and might be missing other nodes (e.g. method bodies).
+            The default is false.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.PlayScriptParser.InitialLocation">
+            <summary>
+            Specifies the text location where parsing starts.
+            This property can be used when parsing a part of a file to make the locations of the AstNodes
+            refer to the position in the whole file.
+            The default is (1,1).
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.PlayScriptParser.Parse(System.IO.Stream,System.String)">
+            <summary>
+            Parses a C# code file.
+            </summary>
+            <param name="stream">The stream containing the source code to parse.</param>
+            <param name="fileName">The file name. Used to identify the file (e.g. when building a type system).
+            This can be an arbitrary identifier, NRefactory never tries to access the file on disk.</param>
+            <returns>Returns the syntax tree.</returns>
+        </member>
+        <!--FIXME: Invalid documentation markup was found for member M:ICSharpCode.NRefactory.PlayScript.PlayScriptParser.Parse(ICSharpCode.NRefactory.Editor.ITextSource,System.String)-->
+        <member name="T:Mono.CSharpPs.IAssignMethod">
+            <summary>
+            This interface is implemented by expressions that can be assigned to.
+            </summary>
+            <remarks>
+            This interface is implemented by Expressions whose values can not
+            store the result on the top of the stack.
+            Expressions implementing this (Properties, Indexers and Arrays) would
+            perform an assignment of the Expression "source" into its final
+            location.
+            No values on the top of the stack are expected to be left by
+            invoking this method.
+            </remarks>
+        </member>
+        <member name="T:Mono.CSharpPs.LocalTemporary">
+            <summary>
+            An Expression to hold a temporary value.
+            </summary>
+            <remarks>
+            The LocalTemporary class is used to hold temporary values of a given
+            type to "simulate" the expression semantics. The local variable is
+            never captured.
+            The local temporary is used to alter the normal flow of code generation
+            basically it creates a local variable, and its emit instruction generates
+            code to access this value, return its address or save its value.
+            If `is_address' is true, then the value that we store is the address to the
+            real value, and not the value itself.
+            This is needed for a value type, because otherwise you just end up making a
+            copy of the value on the stack and modifying it. You really need a pointer
+            to the origional value so that you can modify it in that location. This
+            Does not happen with a class because a class is a pointer -- so you always
+            get the indirection.
+            </remarks>
+        </member>
+        <member name="T:Mono.CSharpPs.Assign">
+            <summary>
+            The Assign node takes care of assigning the value of source into
+            the expression represented by target.
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.Attributable">
+            <summary>
+            Base class for objects that can have Attributes applied to them.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Attributable.ApplyAttributeBuilder(Mono.CSharpPs.Attribute,Mono.CSharpPs.MethodSpec,System.Byte[],Mono.CSharpPs.PredefinedAttributes)">
+            <summary>
+            Use member-specific procedure to apply attribute @a in @cb to the entity being built in @builder
+            </summary>
+        </member>
+        <member name="P:Mono.CSharpPs.Attributable.AttributeTargets">
+            <summary>
+            Returns one AttributeTarget for this element.
+            </summary>
+        </member>
+        <member name="P:Mono.CSharpPs.Attributable.ValidAttributeTargets">
+            <summary>
+            Gets list of valid attribute targets for explicit target declaration.
+            The first array item is default target. Don't break this rule.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Attribute.Error_AttributeEmitError(System.String)">
+            <summary>
+            This is rather hack. We report many emit attribute error with same error to be compatible with
+            csc. But because csc has to report them this way because error came from ilasm we needn't.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Attribute.ResolveAttributeType(System.Boolean)">
+            <summary>
+            Tries to resolve the type of the attribute. Flags an error if it can't, and complain is true.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Attribute.GetValidTargets">
+            <summary>
+            Get a string containing a list of valid targets for the attribute 'attr'
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Attribute.GetIndexerAttributeValue">
+            <summary>
+            Returns custom name of indexer
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Attribute.GetConditionalAttributeValue">
+            <summary>
+            Returns condition of ConditionalAttribute
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Attribute.GetObsoleteAttribute">
+            <summary>
+            Creates the instance of ObsoleteAttribute from this attribute instance
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Attribute.GetClsCompliantAttributeValue">
+            <summary>
+            Returns value of CLSCompliantAttribute contructor parameter but because the method can be called
+            before ApplyAttribute. We need to resolve the arguments.
+            This situation occurs when class deps is differs from Emit order.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Attribute.IsSecurityActionValid">
+            <summary>
+            Tests permitted SecurityAction for assembly or other types
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Attribute.ExtractSecurityPermissionSet(Mono.CSharpPs.MethodSpec,System.Collections.Generic.Dictionary{System.Security.Permissions.SecurityAction,System.Security.PermissionSet}@)">
+            <summary>
+            Creates instance of SecurityAttribute class and add result of CreatePermission method to permission table.
+            </summary>
+            <returns>
+            </returns>
+        </member>
+        <member name="M:Mono.CSharpPs.Attribute.Emit(System.Collections.Generic.Dictionary{Mono.CSharpPs.Attribute,System.Collections.Generic.List{Mono.CSharpPs.Attribute}})">
+            <summary>
+            Emit attribute for Attributable symbol
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Attributes.CheckTargets">
+            <summary>
+            Checks whether attribute target is valid for the current element
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Attributes.SearchMulti(Mono.CSharpPs.PredefinedAttribute)">
+            <summary>
+            Returns all attributes of type 't'. Use it when attribute is AllowMultiple = true
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.AttributeTester">
+            <summary>
+            Helper class for attribute verification routine.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.AttributeTester.Report_ObsoleteMessage(System.ObsoleteAttribute,System.String,Mono.CSharpPs.Location,Mono.CSharpPs.Report)">
+            <summary>
+            Common method for Obsolete error/warning reporting.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.ConstantFold.BinaryFold(Mono.CSharpPs.ResolveContext,Mono.CSharpPs.Binary.Operator,Mono.CSharpPs.Constant,Mono.CSharpPs.Constant,Mono.CSharpPs.Location)">
+            <summary>
+            Constant expression folder for binary operations.
+            Returns null if the expression can not be folded.
+            </summary>
+        </member>
+        <!--FIXME: Invalid documentation markup was found for member F:Mono.CSharpPs.TypeDefinition.pending-->
+        <member name="M:Mono.CSharpPs.TypeDefinition.AddIndexer(Mono.CSharpPs.Indexer)">
+            <summary>
+            Indexer has special handling in constrast to other AddXXX because the name can be driven by IndexerNameAttribute
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.TypeDefinition.ResolveBaseTypes(Mono.CSharpPs.FullNamedExpression@)">
+            <summary>
+            This function computes the Base class and also the
+            list of interfaces that the class or struct @c implements.
+            The return value is an array (might be null) of
+            interfaces implemented (as Types).
+            The @base_class argument is set to the base object or null
+            if this is `System.Object'.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.TypeDefinition.Define">
+            <summary>
+            Populates our TypeBuilder with fields and methods
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.TypeDefinition.VerifyImplements(Mono.CSharpPs.InterfaceMemberBase)">
+            <summary>
+            Performs checks for an explicit interface implementation.  First it
+            checks whether the `interface_type' is a base inteface implementation.
+            Then it checks whether `name' exists in the interface type.
+            </summary>
+        </member>
+        <member name="P:Mono.CSharpPs.TypeDefinition.HasEquals">
+            <summary>
+            Method container contains Equals method
+            </summary>
+        </member>
+        <member name="P:Mono.CSharpPs.TypeDefinition.HasGetHashCode">
+            <summary>
+            Method container contains GetHashCode method
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.ClassOrStruct.DefineDefaultConstructor(System.Boolean)">
+            <summary>
+            Defines the default constructors
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Class.ConditionalConditions">
+            Search for at least one defined condition in ConditionalAttribute of attribute class
+            Valid only for attribute classes.</member>
+        <member name="T:Mono.CSharpPs.Interface">
+            <summary>
+            Interfaces
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.Interface.AllowedModifiers">
+            <summary>
+            Modifiers allowed in a class declaration
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.InterfaceMemberBase.FindBaseMember(Mono.CSharpPs.MemberSpec@,System.Boolean@)">
+            <summary>
+            Gets base method and its return type
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.EmitContext">
+            <summary>
+            An Emit Context is created for each body of code (from methods,
+            properties bodies, indexer bodies or constructor bodies)
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.EmitContext.return_type">
+            <summary>
+            The value that is allowed to be returned or NULL if there is no
+            return type.
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.EmitContext.temporary_storage">
+            <summary>
+            Keeps track of the Type to LocalBuilder temporary storage created
+            to store structures (used to compute the address of the structure
+            value on structure method invocations)
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.EmitContext.return_value">
+            <summary>
+            The location where we store the return value.
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.EmitContext.LoopBegin">
+            <summary>
+            Current loop begin and end labels.
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.EmitContext.DefaultTarget">
+            <summary>
+            Default target in a switch statement.   Only valid if
+            InSwitch is true
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.EmitContext.Switch">
+            <summary>
+            If this is non-null, points to the current switch statement
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.EmitContext.CurrentAnonymousMethod">
+            <summary>
+            Whether we are inside an anonymous method.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.EmitContext.Mark(Mono.CSharpPs.Location)">
+            <summary>
+            This is called immediately before emitting an IL opcode to tell the symbol
+            writer to which source line this opcode belongs.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.EmitContext.GetTemporaryLocal(Mono.CSharpPs.TypeSpec)">
+            <summary>
+            Returns a temporary storage for a variable of type t as
+            a local variable in the current body.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.EmitContext.TemporaryReturn">
+            <summary>
+            ReturnValue creates on demand the LocalBuilder for the
+            return value from the function.  By default this is not
+            used.  This is only required when returns are found inside
+            Try or Catch statements.
+            This method is typically invoked from the Emit phase, so
+            we allow the creation of a return label if it was not
+            requested during the resolution phase.   Could be cleaned
+            up, but it would replicate a lot of logic in the Emit phase
+            of the code that uses it.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Const.Define">
+            <summary>
+            Defines the constant in the @parent
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Const.Emit">
+            <summary>
+            Emits the field value by evaluating the expression
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.Constant">
+            <summary>
+            Base class for constants and literals.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Constant.GetValue">
+            <summary>
+            This is used to obtain the actual value of the literal
+            cast into an object.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Constant.ConvertExplicitly(System.Boolean,Mono.CSharpPs.TypeSpec)">
+            <summary>
+            Maybe ConvertTo name is better. It tries to convert `this' constant to target_type.
+            It throws OverflowException
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Constant.IsDefaultInitializer(Mono.CSharpPs.TypeSpec)">
+            <summary>
+            Need to pass type as the constant can require a boxing
+            and in such case no optimization is possible
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.IntConstant.TryImplicitIntConversion(Mono.CSharpPs.TypeSpec)">
+            <summary>
+            Attempts to perform an implicit constant conversion of the IntConstant
+            into a different data type using casts (See Implicit Constant
+            Expression Conversions)
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.SideEffectConstant">
+            <summary>
+            The value is constant, but when emitted has a side effect.  This is
+            used by BitwiseAnd to ensure that the second expression is invoked
+            regardless of the value of the left side.
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.ResolveContext.Options.CheckedScope">
+            <summary>
+            This flag tracks the `checked' state of the compilation,
+            it controls whether we should generate code that does overflow
+            checking, or if we generate code that ignores overflows.
+            The default setting comes from the command line option to generate
+            checked or unchecked code plus any source code changes using the
+            checked/unchecked statements or expressions.   Contrast this with
+            the ConstantCheckState flag.
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.ResolveContext.Options.ConstantCheckState">
+            <summary>
+            The constant check state is always set to `true' and cant be changed
+            from the command line.  The source code can change this setting with
+            the `checked' and `unchecked' statements and expressions.
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.ResolveContext.Options.DoFlowAnalysis">
+            <summary>
+            Whether control flow analysis is enabled
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.ResolveContext.Options.OmitStructFlowAnalysis">
+            <summary>
+            Whether control flow analysis is disabled on structs
+            (only meaningful when DoFlowAnalysis is set)
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.ResolveContext.Options.ProbingMode">
+            Indicates the current context is in probing mode, no errors are reported.</member>
+        <member name="F:Mono.CSharpPs.ResolveContext.Switch">
+            <summary>
+            If this is non-null, points to the current switch statement
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.CloneContext.RemapBlockCopy(Mono.CSharpPs.Block)">
+            Remaps block to cloned copy if one exists.</member>
+        <member name="F:Mono.CSharpPs.BuilderContext.Options.CheckedScope">
+            <summary>
+            This flag tracks the `checked' state of the compilation,
+            it controls whether we should generate code that does overflow
+            checking, or if we generate code that ignores overflows.
+            The default setting comes from the command line option to generate
+            checked or unchecked code plus any source code changes using the
+            checked/unchecked statements or expressions.   Contrast this with
+            the ConstantCheckState flag.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Convert.ImplicitNumericConversion(Mono.CSharpPs.Expression,Mono.CSharpPs.TypeSpec)">
+            <summary>
+            Implicit Numeric Conversions.
+            expr is the expression to convert, returns a new expression of type
+            target_type or null if an implicit conversion is not possible.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Convert.FindMostEncompassedType(System.Collections.Generic.IList{Mono.CSharpPs.TypeSpec})">
+            <summary>
+            Finds "most encompassed type" according to the spec (13.4.2)
+            amongst the methods in the MethodGroupExpr
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Convert.FindMostSpecificTarget(System.Collections.Generic.IList{Mono.CSharpPs.MethodSpec},Mono.CSharpPs.TypeSpec,System.Boolean)">
+            <summary>
+            Finds the most specific target Tx according to section 13.4.4
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Convert.ImplicitUserConversion(Mono.CSharpPs.ResolveContext,Mono.CSharpPs.Expression,Mono.CSharpPs.TypeSpec,Mono.CSharpPs.Location)">
+            <summary>
+            User-defined Implicit conversions
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Convert.ExplicitUserConversion(Mono.CSharpPs.ResolveContext,Mono.CSharpPs.Expression,Mono.CSharpPs.TypeSpec,Mono.CSharpPs.Location)">
+            <summary>
+            User-defined Explicit conversions
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Convert.ImplicitConversion(Mono.CSharpPs.ResolveContext,Mono.CSharpPs.Expression,Mono.CSharpPs.TypeSpec,Mono.CSharpPs.Location)">
+            <summary>
+            Converts implicitly the resolved expression `expr' into the
+            `target_type'.  It returns a new expression that can be used
+            in a context that expects a `target_type'.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Convert.ImplicitConversionStandard(Mono.CSharpPs.ResolveContext,Mono.CSharpPs.Expression,Mono.CSharpPs.TypeSpec,Mono.CSharpPs.Location)">
+            <summary>
+            Attempts to apply the `Standard Implicit
+            Conversion' rules to the expression `expr' into
+            the `target_type'.  It returns a new expression
+            that can be used in a context that expects a
+            `target_type'.
+            This is different from `ImplicitConversion' in that the
+            user defined implicit conversions are excluded.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Convert.ImplicitConversionRequired(Mono.CSharpPs.ResolveContext,Mono.CSharpPs.Expression,Mono.CSharpPs.TypeSpec,Mono.CSharpPs.Location)">
+            <summary>
+            Attempts to implicitly convert `source' into `target_type', using
+            ImplicitConversion.  If there is no implicit conversion, then
+            an error is signaled
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Convert.ExplicitNumericConversion(Mono.CSharpPs.ResolveContext,Mono.CSharpPs.Expression,Mono.CSharpPs.TypeSpec)">
+            <summary>
+            Performs the explicit numeric conversions
+            There are a few conversions that are not part of the C# standard,
+            they were interim hacks in the C# compiler that were supposed to
+            become explicit operators in the UIntPtr class and IntPtr class,
+            but for historical reasons it did not happen, so the C# compiler
+            ended up with these special hacks.
+            See bug 59800 for details.
+            The conversion are:
+            UIntPtr-&gt;SByte
+            UIntPtr-&gt;Int16
+            UIntPtr-&gt;Int32
+            IntPtr-&gt;UInt64
+            UInt64-&gt;IntPtr
+            SByte-&gt;UIntPtr
+            Int16-&gt;UIntPtr
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Convert.ExplicitReferenceConversionExists(Mono.CSharpPs.TypeSpec,Mono.CSharpPs.TypeSpec)">
+            <summary>
+            Returns whether an explicit reference conversion can be performed
+            from source_type to target_type
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Convert.ExplicitReferenceConversion(Mono.CSharpPs.Expression,Mono.CSharpPs.TypeSpec,Mono.CSharpPs.TypeSpec)">
+            <summary>
+            Implements Explicit Reference conversions
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Convert.ExplicitConversionCore(Mono.CSharpPs.ResolveContext,Mono.CSharpPs.Expression,Mono.CSharpPs.TypeSpec,Mono.CSharpPs.Location)">
+            <summary>
+            Performs an explicit conversion of the expression `expr' whose
+            type is expr.Type to `target_type'.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Convert.ExplicitConversionStandard(Mono.CSharpPs.ResolveContext,Mono.CSharpPs.Expression,Mono.CSharpPs.TypeSpec,Mono.CSharpPs.Location)">
+            <summary>
+            Same as ExplicitConversion, only it doesn't include user defined conversions
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Convert.ExplicitConversion(Mono.CSharpPs.ResolveContext,Mono.CSharpPs.Expression,Mono.CSharpPs.TypeSpec,Mono.CSharpPs.Location)">
+            <summary>
+            Performs an explicit conversion of the expression `expr' whose
+            type is expr.Type to `target_type'.
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.CSharpParser">
+            <summary>
+            The C# Parser
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.CSharpParser.current_block">
+            <summary>
+            Current block is used to add statements as we find
+            them.
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.CSharpParser.current_local_parameters">
+            <summary>
+            This is used by the unary_expression code to resolve
+            a name against a parameter.
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.CSharpParser.oob_stack">
+            An out-of-band stack.</member>
+        <member name="F:Mono.CSharpPs.CSharpParser.yacc_verbose_flag">
+            Controls the verbosity of the errors produced by the parser</member>
+        <member name="F:Mono.CSharpPs.CSharpParser.UnexpectedEOF">
+            Used by the interactive shell, flags whether EOF was reached
+            and an error was produced</member>
+        <member name="F:Mono.CSharpPs.CSharpParser.file">
+            The current file.</member>
+        <member name="F:Mono.CSharpPs.CSharpParser.tmpComment">
+            Temporary Xml documentation cache.
+            For enum types, we need one more temporary store.</member>
+        <member name="F:Mono.CSharpPs.CSharpParser.current_attr_target">
+            Current attribute target</member>
+        <member name="F:Mono.CSharpPs.CSharpParser.InteractiveResult">
+            When using the interactive parser, this holds the
+            resulting expression</member>
+        <member name="F:Mono.CSharpPs.CSharpParser.ErrorOutput">
+             error output stream.
+                  It should be changeable.</member>
+        <member name="M:Mono.CSharpPs.CSharpParser.yyerror(System.String)">
+             simplified error message.
+                  @see <a href="#yyerror(java.lang.String, java.lang.String[])">yyerror</a></member>
+        <member name="M:Mono.CSharpPs.CSharpParser.yyerror(System.String,System.String[])">
+             (syntax) error message.
+                  Can be overwritten to control message format.
+                  @param message text to be displayed.
+                  @param expected vector of acceptable tokens, if available.</member>
+        <member name="F:Mono.CSharpPs.CSharpParser.yyFinal">
+             debugging support, requires the package jay.yydebug.
+                  Set to null to suppress debugging messages.</member>
+        <member name="F:Mono.CSharpPs.CSharpParser.yyExpectingState">
+             index-checked interface to yyNames[].
+                  @param token single character or %token value.
+                  @return token name or [illegal] or [unknown].</member>
+        <member name="M:Mono.CSharpPs.CSharpParser.yyExpectingTokens(System.Int32)">
+             computes list of expected tokens on error by tracing the tables.
+                  @param state for which to compute the list.
+                  @return list of token names.</member>
+        <member name="M:Mono.CSharpPs.CSharpParser.yyparse(Mono.CSharpPs.yyParser.yyInput,System.Object)">
+             the generated parser, with debugging messages.
+                  Maintains a state and a value stack, currently with fixed maximum size.
+                  @param yyLex scanner.
+                  @param yydebug debug message writer implementing yyDebug, or null.
+                  @return result of the last reduction, if any.
+                  @throws yyException on irrecoverable parse error.</member>
+        <member name="F:Mono.CSharpPs.CSharpParser.yyMax">
+             initial size and increment of the state/value stack [default 256].
+                  This is not final so that it can be overwritten outside of invocations
+                  of yyparse().</member>
+        <member name="M:Mono.CSharpPs.CSharpParser.yyDefault(System.Object)">
+             executed at the beginning of a reduce action.
+                  Used as $$ = yyDefault($1), prior to the user-specified action, if any.
+                  Can be overwritten to provide deep copy, etc.
+                  @param first value for $1, or null.
+                  @return first.</member>
+        <member name="M:Mono.CSharpPs.CSharpParser.yyparse(Mono.CSharpPs.yyParser.yyInput)">
+             the generated parser.
+                  Maintains a state and a value stack, currently with fixed maximum size.
+                  @param yyLex scanner.
+                  @return result of the last reduction, if any.
+                  @throws yyException on irrecoverable parse error.</member>
+        <member name="T:Mono.CSharpPs.yyParser.yyException">
+             thrown for irrecoverable syntax errors and stack overflow.</member>
+        <member name="T:Mono.CSharpPs.yyParser.yyInput">
+             must be implemented by a scanner object to supply input to the parser.</member>
+        <member name="M:Mono.CSharpPs.yyParser.yyInput.advance">
+             move on to next token.
+                    @return false if positioned beyond tokens.
+                    @throws IOException on input error.</member>
+        <member name="M:Mono.CSharpPs.yyParser.yyInput.token">
+             classifies current token.
+                    Should not be called if advance() returned false.
+                    @return current %token or single character.</member>
+        <member name="M:Mono.CSharpPs.yyParser.yyInput.value">
+             associated with current token.
+                    Should not be called if advance() returned false.
+                    @return value for token().</member>
+        <member name="T:Mono.CSharpPs.Tokenizer">
+            <summary>
+            Tokenizer for C# source code.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Tokenizer.ParsePragmaDirective(System.String)">
+            <summary>
+            Handles #pragma directive
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.MemberCore">
+            <summary>
+            Base representation for members.  This is used to keep track
+            of Name, Location and Modifier flags, and handling Attributes.
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.MemberCore.mod_flags">
+            <summary>
+            Modifier flags that the user specified in the source code
+            </summary>
+        </member>
+        <member name="P:Mono.CSharpPs.MemberCore.Location">
+            <summary>
+            Location where this declaration happens
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.MemberCore.comment">
+            <summary>
+            XML documentation comment
+            </summary>
+        </member>
+        <member name="P:Mono.CSharpPs.MemberCore.DocCommentHeader">
+            <summary>
+            Represents header string for documentation comment
+            for each member types.
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.MemberCore.caching_flags">
+            <summary>
+            MemberCore flags at first detected then cached
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.MemberCore.Emit">
+            <summary>
+            Base Emit method. This is also entry point for CLS-Compliant verification.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.MemberCore.GetAttributeObsolete">
+            <summary>
+            Returns instance of ObsoleteAttribute for this MemberCore
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.MemberCore.CheckObsoleteness(Mono.CSharpPs.Location)">
+            <summary>
+            Checks for ObsoleteAttribute presence. It's used for testing of all non-types elements
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.MemberCore.IsClsComplianceRequired">
+            <summary>
+            Analyze whether CLS-Compliant verification must be execute for this MemberCore.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.MemberCore.IsExposedFromAssembly">
+            <summary>
+            Returns true when MemberCore is exposed from assembly.
+            </summary>
+        </member>
+        <member name="P:Mono.CSharpPs.MemberCore.CLSAttributeValue">
+            <summary>
+            Goes through class hierarchy and gets value of first found CLSCompliantAttribute.
+            If no is attribute exists then assembly CLSCompliantAttribute is returned.
+            </summary>
+        </member>
+        <member name="P:Mono.CSharpPs.MemberCore.HasClsCompliantAttribute">
+            <summary>
+            Returns true if MemberCore is explicitly marked with CLSCompliantAttribute
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.MemberCore.EnableOverloadChecks(Mono.CSharpPs.MemberCore)">
+            <summary>
+            Returns true when a member supports multiple overloads (methods, indexers, etc)
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.MemberCore.VerifyClsCompliance">
+            <summary>
+            The main virtual method for CLS-Compliant verifications.
+            The method returns true if member is CLS-Compliant and false if member is not
+            CLS-Compliant which means that CLS-Compliant tests are not necessary. A descendants override it
+            and add their extra verifications.
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.Driver">
+            <summary>
+            The compiler driver.
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.ExprClass">
+            <remarks>
+            The ExprClass class contains the is used to pass the
+            classification of an expression (value, variable, namespace,
+            type, method group, property access, event access, indexer access,
+            nothing).
+            </remarks>
+        </member>
+        <member name="T:Mono.CSharpPs.ResolveFlags">
+            <remarks>
+            This is used to tell Resolve in which types of expressions we're
+            interested.
+            </remarks>
+        </member>
+        <member name="T:Mono.CSharpPs.IMemoryLocation">
+            <summary>
+            This interface is implemented by variables
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.IMemoryLocation.AddressOf(Mono.CSharpPs.EmitContext,Mono.CSharpPs.AddressOp)">
+            <summary>
+            The AddressOf method should generate code that loads
+            the address of the object and leaves it on the stack.
+            The `mode' argument is used to notify the expression
+            of whether this will be used to read from the address or
+            write to the address.
+            This is just a hint that can be used to provide good error
+            reporting, and should have no other side effects.
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.Expression">
+            <remarks>
+            Base class for expressions
+            </remarks>
+        </member>
+        <member name="M:Mono.CSharpPs.Expression.DoResolve(Mono.CSharpPs.ResolveContext)">
+            <summary>
+            Performs semantic analysis on the Expression
+            </summary>
+            <remarks>
+            The Resolve method is invoked to perform the semantic analysis
+            on the node.
+            The return value is an expression (it can be the
+            same expression in some cases) or a new
+            expression that better represents this node.
+            For example, optimizations of Unary (LiteralInt)
+            would return a new LiteralInt with a negated
+            value.
+            If there is an error during semantic analysis,
+            then an error should be reported (using Report)
+            and a null value should be returned.
+            There are two side effects expected from calling
+            Resolve(): the the field variable "eclass" should
+            be set to any value of the enumeration
+            `ExprClass' and the type variable should be set
+            to a valid type (this is the type of the
+            expression).
+            </remarks>
+        </member>
+        <member name="M:Mono.CSharpPs.Expression.Resolve(Mono.CSharpPs.ResolveContext,Mono.CSharpPs.ResolveFlags)">
+            <summary>
+            Resolves an expression and performs semantic analysis on it.
+            </summary>
+            <remarks>
+            Currently Resolve wraps DoResolve to perform sanity
+            checking and assertion checking on what we expect from Resolve.
+            </remarks>
+        </member>
+        <member name="M:Mono.CSharpPs.Expression.Resolve(Mono.CSharpPs.ResolveContext)">
+            <summary>
+            Resolves an expression and performs semantic analysis on it.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Expression.ResolveLValue(Mono.CSharpPs.ResolveContext,Mono.CSharpPs.Expression)">
+            <summary>
+            Resolves an expression for LValue assignment
+            </summary>
+            <remarks>
+            Currently ResolveLValue wraps DoResolveLValue to perform sanity
+            checking and assertion checking on what we expect from Resolve
+            </remarks>
+        </member>
+        <member name="M:Mono.CSharpPs.Expression.Emit(Mono.CSharpPs.EmitContext)">
+            <summary>
+            Emits the code for the expression
+            </summary>
+            <remarks>
+            The Emit method is invoked to generate the code
+            for the expression.
+            </remarks>
+        </member>
+        <member name="M:Mono.CSharpPs.Expression.#ctor">
+            <summary>
+            Protected constructor.  Only derivate types should
+            be able to be created
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Expression.ExprClassFromMemberInfo(Mono.CSharpPs.MemberSpec,Mono.CSharpPs.Location)">
+            <summary>
+            Returns a fully formed expression after a MemberLookup
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Expression.GetOperatorTrue(Mono.CSharpPs.ResolveContext,Mono.CSharpPs.Expression,Mono.CSharpPs.Location)">
+            <summary>
+            Returns an expression that can be used to invoke operator true
+            on the expression if it exists.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Expression.GetOperatorFalse(Mono.CSharpPs.ResolveContext,Mono.CSharpPs.Expression,Mono.CSharpPs.Location)">
+            <summary>
+            Returns an expression that can be used to invoke operator false
+            on the expression if it exists.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Expression.Error_UnexpectedKind(Mono.CSharpPs.IMemberContext,Mono.CSharpPs.Expression,System.String,System.String,Mono.CSharpPs.Location)">
+            <summary>
+            Reports that we were expecting `expr' to be of class `expected'
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.ExpressionStatement">
+            <summary>
+            This is just a base class for expressions that can
+            appear on statements (invocations, object creation,
+            assignments, post/pre increment and decrement).  The idea
+            being that they would support an extra Emition interface that
+            does not leave a result on the stack.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.ExpressionStatement.EmitStatement(Mono.CSharpPs.EmitContext)">
+            <summary>
+            Requests the expression to be emitted in a `statement'
+            context.  This means that no new value is left on the
+            stack after invoking this method (constrasted with
+            Emit that will always leave a value on the stack).
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.TypeCast">
+            <summary>
+            This kind of cast is used to encapsulate the child
+            whose type is child.Type into an expression that is
+            reported to return "return_type".  This is used to encapsulate
+            expressions which have compatible types, but need to be dealt
+            at higher levels with.
+            For example, a "byte" expression could be encapsulated in one
+            of these as an "unsigned int".  The type for the expression
+            would be "unsigned int".
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.EnumConstant">
+            <summary>
+            This class is used to wrap literals which belong inside Enums
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.BoxedCast">
+            <summary>
+            This kind of cast is used to encapsulate Value Types in objects.
+            The effect of it is to box the value type emitted by the previous
+            operation.
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.ConvCast">
+            <summary>
+            This is used to perform explicit numeric conversions.
+            Explicit numeric conversions might trigger exceptions in a checked
+            context, so they should generate the conv.ovf opcodes instead of
+            conv opcodes.
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.ClassCast">
+            <summary>
+            This kind of cast is used to encapsulate a child and cast it
+            to the class requested
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.SimpleName">
+            <summary>
+            SimpleName expressions are formed of a single word and only happen at the beginning
+            of a dotted-name.
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.FullNamedExpression">
+            <summary>
+            Represents a namespace or a type.  The name of the class was inspired by
+            section 10.8.1 (Fully Qualified Names).
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.TypeExpr">
+            <summary>
+            Expression that evaluates to a type
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.TypeExpression">
+            <summary>
+            Fully resolved Expression that already evaluated to a type
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.MemberExpr">
+            <summary>
+            This class denotes an expression which evaluates to a member
+            of a struct or a class.
+            </summary>
+        </member>
+        <member name="P:Mono.CSharpPs.MemberExpr.Name">
+            <summary>
+            The name of this member.
+            </summary>
+        </member>
+        <member name="P:Mono.CSharpPs.MemberExpr.IsInstance">
+            <summary>
+            Whether this is an instance member.
+            </summary>
+        </member>
+        <member name="P:Mono.CSharpPs.MemberExpr.IsStatic">
+            <summary>
+            Whether this is a static member.
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.MethodGroupExpr">
+            <summary>
+            MethodGroupExpr represents a group of method candidates which
+            can be resolved to the best method overload
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.MethodGroupExpr.OverloadResolve(Mono.CSharpPs.ResolveContext,Mono.CSharpPs.Arguments@,Mono.CSharpPs.OverloadResolver.IErrorHandler,Mono.CSharpPs.OverloadResolver.Restrictions)">
+            <summary>
+            Find the Applicable Function Members (7.4.2.1)
+            me: Method Group expression with the members to select.
+            it might contain constructors or methods (or anything
+            that maps to a method).
+            Arguments: ArrayList containing resolved Argument objects.
+            loc: The location if we want an error to be reported, or a Null
+            location for "probing" purposes.
+            Returns: The MethodBase (either a ConstructorInfo or a MethodInfo)
+            that is the best match of me on Arguments.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.OverloadResolver.BetterFunction(Mono.CSharpPs.ResolveContext,Mono.CSharpPs.Arguments,Mono.CSharpPs.MemberSpec,Mono.CSharpPs.AParametersCollection,System.Boolean,Mono.CSharpPs.MemberSpec,Mono.CSharpPs.AParametersCollection,System.Boolean)">
+            <summary>
+            Determines "Better function" between candidate
+            and the current best match
+            </summary>
+            <remarks>
+            Returns a boolean indicating :
+            false if candidate ain't better
+            true  if candidate is better than the current best match
+            </remarks>
+        </member>
+        <member name="T:Mono.CSharpPs.EventExpr">
+            <summary>
+            Fully resolved expression that evaluates to an Event
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.VarExpr">
+            Handles `var' contextual keyword; var becomes a keyword only
+            if no type called var exists in a variable scope</member>
+        <member name="T:Mono.CSharpPs.Enum">
+            <summary>
+            Enumeration container
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.Evaluator">
+            <summary>
+            Evaluator: provides an API to evaluate C# statements and
+            expressions dynamically.
+            </summary>
+            <remarks>
+            This class exposes static methods to evaluate expressions in the
+            current program.
+            To initialize the evaluator with a number of compiler
+            options call the Init(string[]args) method with a set of
+            command line options that the compiler recognizes.
+            To interrupt execution of a statement, you can invoke the
+            Evaluator.Interrupt method.
+            </remarks>
+        </member>
+        <member name="F:Mono.CSharpPs.Evaluator.DescribeTypeExpressions">
+            <summary>
+            If true, turns type expressions into valid expressions
+            and calls the describe method on it
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.Evaluator.Terse">
+            <summary>
+            Whether the evaluator will use terse syntax, and the semicolons at the end are optional
+            </summary>
+        </member>
+        <member name="P:Mono.CSharpPs.Evaluator.InteractiveBaseClass">
+            <summary>
+            The base class for the classes that host the user generated code
+            </summary>
+            <remarks>
+            This is the base class that will host the code
+            executed by the Evaluator.  By default
+            this is the Mono.CSharpPs.InteractiveBase class
+            which is useful for interactive use.
+            By changing this property you can control the
+            base class and the static members that are
+            available to your evaluated code.
+            </remarks>
+        </member>
+        <member name="M:Mono.CSharpPs.Evaluator.Interrupt">
+            <summary>
+            Interrupts the evaluation of an expression executing in Evaluate.
+            </summary>
+            <remarks>
+            Use this method to interrupt long-running invocations.
+            </remarks>
+        </member>
+        <member name="M:Mono.CSharpPs.Evaluator.Compile(System.String,Mono.CSharpPs.CompiledMethod@)">
+            <summary>
+            Compiles the input string and returns a delegate that represents the compiled code.
+            </summary>
+            <remarks>
+            Compiles the input string as a C# expression or
+            statement, unlike the Evaluate method, the
+            resulting delegate can be invoked multiple times
+            without incurring in the compilation overhead.
+            If the return value of this function is null,
+            this indicates that the parsing was complete.
+            If the return value is a string it indicates
+            that the input string was partial and that the
+            invoking code should provide more code before
+            the code can be successfully compiled.
+            If you know that you will always get full expressions or
+            statements and do not care about partial input, you can use
+            the other Compile overload.
+            On success, in addition to returning null, the
+            compiled parameter will be set to the delegate
+            that can be invoked to execute the code.
+            </remarks>
+        </member>
+        <member name="M:Mono.CSharpPs.Evaluator.Compile(System.String)">
+            <summary>
+            Compiles the input string and returns a delegate that represents the compiled code.
+            </summary>
+            <remarks>
+            Compiles the input string as a C# expression or
+            statement, unlike the Evaluate method, the
+            resulting delegate can be invoked multiple times
+            without incurring in the compilation overhead.
+            This method can only deal with fully formed input
+            strings and does not provide a completion mechanism.
+            If you must deal with partial input (for example for
+            interactive use) use the other overload.
+            On success, a delegate is returned that can be used
+            to invoke the method.
+            </remarks>
+        </member>
+        <member name="M:Mono.CSharpPs.Evaluator.Evaluate(System.String,System.Object@,System.Boolean@)">
+            <summary>
+            Evaluates and expression or statement and returns any result values.
+            </summary>
+            <remarks>
+            Evaluates the input string as a C# expression or
+            statement.  If the input string is an expression
+            the result will be stored in the result variable
+            and the result_set variable will be set to true.
+            It is necessary to use the result/result_set
+            pair to identify when a result was set (for
+            example, execution of user-provided input can be
+            an expression, a statement or others, and
+            result_set would only be set if the input was an
+            expression.
+            If the return value of this function is null,
+            this indicates that the parsing was complete.
+            If the return value is a string, it indicates
+            that the input is partial and that the user
+            should provide an updated string.
+            </remarks>
+        </member>
+        <member name="M:Mono.CSharpPs.Evaluator.Run(System.String)">
+            <summary>
+            Executes the given expression or statement.
+            </summary>
+            <remarks>
+            Executes the provided statement, returns true
+            on success, false on parsing errors.  Exceptions
+            might be thrown by the called code.
+            </remarks>
+        </member>
+        <member name="M:Mono.CSharpPs.Evaluator.Evaluate(System.String)">
+            <summary>
+            Evaluates and expression or statement and returns the result.
+            </summary>
+            <remarks>
+            Evaluates the input string as a C# expression or
+            statement and returns the value.
+            This method will throw an exception if there is a syntax error,
+            of if the provided input is not an expression but a statement.
+            </remarks>
+        </member>
+        <member name="T:Mono.CSharpPs.Evaluator.QuitValue">
+            <summary>
+            A sentinel value used to indicate that no value was
+            was set by the compiled function.   This is used to
+            differentiate between a function not returning a
+            value and null.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Evaluator.LoadAssembly(System.String)">
+            <summary>
+            Loads the given assembly and exposes the API to the user.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Evaluator.ReferenceAssembly(System.Reflection.Assembly)">
+            <summary>
+            Exposes the API of the given assembly to the Evaluator
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.CompiledMethod">
+            <summary>
+            A delegate that can be used to invoke the
+            compiled expression or statement.
+            </summary>
+            <remarks>
+            Since the Compile methods will compile
+            statements and expressions into the same
+            delegate, you can tell if a value was returned
+            by checking whether the returned value is of type
+            NoValueSet.
+            </remarks>
+        </member>
+        <member name="T:Mono.CSharpPs.InteractiveBase">
+            <summary>
+            The default base class for every interaction line
+            </summary>
+            <remarks>
+            The expressions and statements behave as if they were
+            a static method of this class.   The InteractiveBase class
+            contains a number of useful methods, but can be overwritten
+            by setting the InteractiveBaseType property in the Evaluator
+            </remarks>
+        </member>
+        <member name="F:Mono.CSharpPs.InteractiveBase.Output">
+            <summary>
+            Determines where the standard output of methods in this class will go.
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.InteractiveBase.Error">
+            <summary>
+            Determines where the standard error of methods in this class will go.
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.InteractiveBase.Prompt">
+            <summary>
+            The primary prompt used for interactive use.
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.InteractiveBase.ContinuationPrompt">
+            <summary>
+            The secondary prompt used for interactive use (used when
+            an expression is incomplete).
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.InteractiveBase.QuitRequested">
+            <summary>
+            Used to signal that the user has invoked the  `quit' statement.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.InteractiveBase.ShowVars">
+            <summary>
+            Shows all the variables defined so far.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.InteractiveBase.ShowUsing">
+            <summary>
+            Displays the using statements in effect at this point.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.InteractiveBase.Time(System.Action)">
+            <summary>
+            Times the execution of the given delegate
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.InteractiveBase.LoadPackage(System.String)">
+            <summary>
+            Loads the assemblies from a package
+            </summary>
+            <remarks>
+            Loads the assemblies from a package.   This is equivalent
+            to passing the -pkg: command line flag to the C# compiler
+            on the command line.
+            </remarks>
+        </member>
+        <member name="M:Mono.CSharpPs.InteractiveBase.LoadAssembly(System.String)">
+            <summary>
+            Loads the assembly
+            </summary>
+            <remarks>
+            Loads the specified assembly and makes its types
+            available to the evaluator.  This is equivalent
+            to passing the -pkg: command line flag to the C#
+            compiler on the command line.
+            </remarks>
+        </member>
+        <member name="P:Mono.CSharpPs.InteractiveBase.help">
+            <summary>
+            Returns a list of available static methods.
+            </summary>
+        </member>
+        <member name="P:Mono.CSharpPs.InteractiveBase.quit">
+            <summary>
+            Indicates to the read-eval-print-loop that the interaction should be finished.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.InteractiveBase.Quit">
+            <summary>
+            Same as quit - useful in script scenerios
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.InteractiveBase.Describe(System.Object)">
+            <summary>
+            Describes an object or a type.
+            </summary>
+            <remarks>
+            This method will show a textual representation
+            of the object's type.  If the object is a
+            System.Type it renders the type directly,
+            otherwise it renders the type returned by
+            invoking GetType on the object.
+            </remarks>
+        </member>
+        <member name="T:Mono.CSharpPs.OptionalAssign">
+            <summary>
+            A class used to assign values if the source expression is not void
+            Used by the interactive shell to allow it to call this code to set
+            the return value for an invocation.
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.UnaryMutator">
+            <summary>
+            Unary Mutator expressions (pre and post ++ and --)
+            </summary>
+            <remarks>
+            UnaryMutator implements ++ and -- expressions.   It derives from
+            ExpressionStatement becuase the pre/post increment/decrement
+            operators can be used in a statement context.
+            FIXME: Idea, we could split this up in two classes, one simpler
+            for the common case, and one with the extra fields for more complex
+            classes (indexers require temporary access;  overloaded require method)
+            </remarks>
+        </member>
+        <member name="T:Mono.CSharpPs.Is">
+            <summary>
+            Implementation of the `is' operator.
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.As">
+            <summary>
+            Implementation of the `as' operator.
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.Binary">
+            <summary>
+            Binary operators
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Binary.OperName(Mono.CSharpPs.Binary.Operator)">
+            <summary>
+            Returns a stringified representation of the Operator
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Binary.EmitBranchable(Mono.CSharpPs.EmitContext,System.Reflection.Emit.Label,System.Boolean)">
+            <remarks>
+            EmitBranchable is called from Statement.EmitBoolExpression in the
+            context of a conditional bool expression.  This function will return
+            false if it is was possible to use EmitBranchable, or true if it was.
+            The expression's code is generated, and we will generate a branch to `target'
+            if the resulting expression value is equal to isTrue
+            </remarks>
+        </member>
+        <member name="T:Mono.CSharpPs.Conditional">
+            <summary>
+            Implements the ternary conditional operator (?:)
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.ParameterReference">
+            <summary>
+            This represents a reference to a parameter in the intermediate
+            representation.
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.Invocation">
+            <summary>
+            Invocation of methods or delegates.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.New.Constantify(Mono.CSharpPs.TypeSpec,Mono.CSharpPs.Location)">
+            <summary>
+            Converts complex core type syntax like 'new int ()' to simple constant
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.ArrayCreation">
+            <summary>
+            14.5.10.2: Represents an array creation expression.
+            </summary>
+            <remarks>
+            There are two possible scenarios here: one is an array creation
+            expression that specifies the dimensions and optionally the
+            initialization data and the other which does not need dimensions
+            specified but where initialization data is mandatory.
+            </remarks>
+        </member>
+        <member name="T:Mono.CSharpPs.This">
+            <summary>
+            Represents the `this' construct
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.ArglistAccess">
+            <summary>
+            Represents the `__arglist' construct
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.Arglist">
+            <summary>
+            Represents the `__arglist (....)' construct
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.TypeOf">
+            <summary>
+            Implements the typeof operator
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.SizeOf">
+            <summary>
+            Implements the sizeof expression
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.QualifiedAliasMember">
+            <summary>
+            Implements the qualified-alias-member (::) expression.
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.MemberAccess">
+            <summary>
+            Implements the member access expression
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.CheckedExpr">
+            <summary>
+            Implements checked expressions
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.UnCheckedExpr">
+            <summary>
+            Implements the unchecked expression
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.ElementAccess">
+            <summary>
+            An Element Access expression.
+            During semantic analysis these are transformed into
+            IndexerAccess, ArrayAccess or a PointerArithmetic.
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.ArrayAccess">
+            <summary>
+            Implements array access
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.EmptyExpression">
+            <summary>
+            This class exists solely to pass the Type around and to be a dummy
+            that can be passed to the conversion functions (this is used by
+            foreach implementation to typecast the object return value from
+            get_Current into the proper type.  All code has been generated and
+            we only care about the side effect conversions to be performed
+            This is also now used as a placeholder where a no-action expression
+            is needed (the `New' class).
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.FixedField">
+            <summary>
+            Fixed buffer implementation
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.TypeParameterExpr">
+            <summary>
+            A TypeExpr which already resolved to a type parameter.
+            </summary>
+        </member>
+        <member name="P:Mono.CSharpPs.TypeArguments.Arguments">
+            <summary>
+            We may only be used after Resolve() is called and return the fully
+            resolved types.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.TypeArguments.Resolve(Mono.CSharpPs.IMemberContext)">
+            <summary>
+            Resolve the type arguments.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.GenericTypeExpr.#ctor(Mono.CSharpPs.TypeSpec,Mono.CSharpPs.TypeArguments,Mono.CSharpPs.Location)">
+            <summary>
+            Instantiate the generic type `t' with the type arguments `args'.
+            Use this constructor if you already know the fully resolved
+            generic type.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.TypeManager.CSharpName(Mono.CSharpPs.TypeSpec)">
+            <summary>
+            Returns the C# name of a type if possible, or the full type name otherwise
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.TypeManager.HasElementType(Mono.CSharpPs.TypeSpec)">
+            <summary>
+            This method is not implemented by MS runtime for dynamic types
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.TypeManager.VerifyUnmanaged(Mono.CSharpPs.ModuleContainer,Mono.CSharpPs.TypeSpec,Mono.CSharpPs.Location)">
+            <summary>
+            Utility function that can be used to probe whether a type
+            is managed or not.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.TypeManager.IsInstantiationOfSameGenericType(Mono.CSharpPs.TypeSpec,Mono.CSharpPs.TypeSpec)">
+            <summary>
+            Check whether `type' and `parent' are both instantiations of the same
+            generic type.  Note that we do not check the type parameters here.
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.Location">
+            <summary>
+            Keeps track of the location in the program
+            </summary>
+            <remarks>
+            This uses a compact representation and a couple of auxiliary
+            structures to keep track of tokens to (file,line and column)
+            mappings. The usage of the bits is:
+            - 16 bits for "checkpoint" which is a mixed concept of
+            file and "line segment"
+            - 8 bits for line delta (offset) from the line segment
+            - 8 bits for column number.
+            http://lists.ximian.com/pipermail/mono-devel-list/2004-December/009508.html
+            </remarks>
+        </member>
+        <member name="P:Mono.CSharpPs.Location.IsNull">
+            <summary>
+            Whether the Location is Null
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.MethodOrOperator.ConditionalConditions">
+            <summary>
+            Returns true if method has conditional attribute and the conditions is not defined (method is excluded).
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.IMethodData">
+            <summary>
+            Interface for MethodData class. Holds links to parent members to avoid member duplication.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.MethodData.DefineMethodBuilder(Mono.CSharpPs.TypeDefinition,System.String,Mono.CSharpPs.ParametersCompiled)">
+            <summary>
+            Create the MethodBuilder for the method
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Namespace.#ctor(Mono.CSharpPs.Namespace,System.String)">
+            <summary>
+            Constructor Takes the current namespace and the
+            name.  This is bootstrapped with parent == null
+            and name = ""
+            </summary>
+        </member>
+        <member name="P:Mono.CSharpPs.Namespace.Name">
+            <summary>
+            The qualified name of the current namespace
+            </summary>
+        </member>
+        <member name="P:Mono.CSharpPs.Namespace.Parent">
+            <summary>
+            The parent of this namespace, used by the parser to "Pop"
+            the current namespace declaration
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.ParameterBase">
+            <summary>
+            Abstract Base class for parameters of a method.
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.ReturnParameter">
+            <summary>
+            Class for applying custom attributes on the return type
+            </summary>
+        </member>
+        <member name="P:Mono.CSharpPs.ReturnParameter.ValidAttributeTargets">
+            <summary>
+            Is never called
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.ParametersCompiled">
+            <summary>
+            Represents the methods parameters
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.PendingImplementation.container">
+            <summary>
+            The container for this PendingImplementation
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.PendingImplementation.pending_implementations">
+            <summary>
+            This is the array of TypeAndMethods that describes the pending implementations
+            (both interfaces and abstract methods in base class)
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.PendingImplementation.IsInterfaceMethod(Mono.CSharpPs.MemberName,Mono.CSharpPs.TypeSpec,Mono.CSharpPs.MethodData,Mono.CSharpPs.MethodSpec@,System.Boolean@)">
+            <summary>
+            Whether the specified method is an interface method implementation
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.PendingImplementation.InterfaceMethod(Mono.CSharpPs.MemberName,Mono.CSharpPs.TypeSpec,Mono.CSharpPs.MethodData,Mono.CSharpPs.PendingImplementation.Operation,Mono.CSharpPs.MethodSpec@,System.Boolean@)">
+            <remarks>
+            If a method in Type `t' (or null to look in all interfaces
+            and the base abstract class) with name `Name', return type `ret_type' and
+            arguments `args' implements an interface, this method will
+            return the MethodInfo that this method implements.
+            If `name' is null, we operate solely on the method's signature.  This is for
+            instance used when implementing indexers.
+            The `Operation op' controls whether to lookup, clear the pending bit, or clear
+            all the methods with the given signature.
+            The `MethodInfo need_proxy' is used when we're implementing an interface's
+            indexer in a class.  If the new indexer's IndexerName does not match the one
+            that was used in the interface, then we always need to create a proxy for it.
+            </remarks>
+        </member>
+        <member name="M:Mono.CSharpPs.PendingImplementation.DefineProxy(Mono.CSharpPs.TypeSpec,Mono.CSharpPs.MethodSpec,Mono.CSharpPs.MethodSpec)">
+            <summary>
+            C# allows this kind of scenarios:
+            interface I { void M (); }
+            class X { public void M (); }
+            class Y : X, I { }
+            For that case, we create an explicit implementation function
+            I.M in Y.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.PendingImplementation.BaseImplements(Mono.CSharpPs.TypeSpec,Mono.CSharpPs.MethodSpec,Mono.CSharpPs.MethodSpec@)">
+            <summary>
+            This function tells whether one of our base classes implements
+            the given method (which turns out, it is valid to have an interface
+            implementation in a base
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.PendingImplementation.VerifyPendingMethods">
+            <summary>
+            Verifies that any pending abstract methods or interface methods
+            were implemented.
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.EventProperty">
+            <summary>
+            For case when event is declared like property (with add and remove accessors).
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.EventField">
+            <summary>
+            Event is declared like field.
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.Report.extra_information">
+            <summary>
+            List of symbols related to reported error/warning. You have to fill it before error/warning is reported.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Report.SymbolRelatedToPreviousError(Mono.CSharpPs.Location,System.String)">
+            <summary>
+            In most error cases is very useful to have information about symbol that caused the error.
+            Call this method before you call Report.Error when it makes sense.
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.WarningRegions">
+            <summary>
+            Handles #pragma warning
+            </summary>
+        </member>
+        <!--FIXME: Invalid documentation markup was found for member M:Mono.CSharpPs.Statement.Resolve(Mono.CSharpPs.BlockContext)-->
+        <member name="M:Mono.CSharpPs.Statement.ResolveUnreachable(Mono.CSharpPs.BlockContext,System.Boolean)">
+            <summary>
+            We already know that the statement is unreachable, but we still
+            need to resolve it to catch errors.
+            </summary>
+        </member>
+        <member name="M:Mono.CSharpPs.Statement.DoEmit(Mono.CSharpPs.EmitContext)">
+            <summary>
+            Return value indicates whether all code paths emitted return.
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.Return">
+            <summary>
+            Implements the return statement
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.GotoDefault">
+            <summary>
+            `goto default' statement
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.GotoCase">
+            <summary>
+            `goto case' statement
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.Block">
+            <summary>
+            Block represents a C# block.
+            </summary>
+            <remarks>
+            This class is used in a number of places: either to represent
+            explicit blocks that the programmer places or implicit blocks.
+            Implicit blocks are used as labels or to introduce variable
+            declarations.
+            Top-level blocks derive from Block, and they are called ToplevelBlock
+            they contain extra information that is not necessary on normal blocks.
+            </remarks>
+        </member>
+        <member name="F:Mono.CSharpPs.Switch.SwitchType">
+            <summary>
+            The governing switch type
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.AsForEachType">
+            <summary>
+            PlayScript ForEach type.
+            </summary>/</member>
+        <member name="F:Mono.CSharpPs.AsForEachType.CSharpForEach">
+            <summary>
+            Generate a normal cs foreach statement.
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.AsForEachType.ForEachKey">
+            <summary>
+            Generate an PlayScript for (var a in collection) statement.  Yields keys.
+            </summary>
+        </member>
+        <member name="F:Mono.CSharpPs.AsForEachType.ForEachValue">
+            <summary>
+            Generate an PlayScript for each (var a in collection) statement.  Yields values.
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.Foreach">
+            <summary>
+            Implementation of the foreach C# statement
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.CompletionResult">
+            <summary>
+            An exception used to terminate the compiler resolution phase and provide completions
+            </summary>
+            <remarks>
+            This is thrown when we want to return the completions or
+            terminate the completion process by AST nodes used in
+            the completion process.
+            </remarks>
+        </member>
+        <member name="M:Mono.CSharpPs.TypeSpecComparer.Unify.MayBecomeEqualGenericTypes(Mono.CSharpPs.TypeSpec,Mono.CSharpPs.TypeSpec)">
+            <summary>
+            Check whether `a' and `b' may become equal generic types.
+            The algorithm to do that is a little bit complicated.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.QueryExpressionExpansionResult.RangeVariables">
+            <summary>
+            Maps original range variables to some node in the new tree that represents them.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.QueryExpressionExpansionResult.Expressions">
+            <summary>
+            Maps clauses to method calls. The keys will always be either a <see cref="T:ICSharpCode.NRefactory.PlayScript.QueryClause" /> or a <see cref="T:ICSharpCode.NRefactory.PlayScript.QueryOrdering" /></summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.QueryExpressionExpander.ExpandQueryExpressions(ICSharpCode.NRefactory.PlayScript.AstNode)">
+            <summary>
+            Expands all occurances of query patterns in the specified node. Returns a clone of the node with all query patterns expanded, or null if there was no query pattern to expand.
+            </summary>
+            <param name="node">
+            </param>
+            <returns>
+            </returns>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.AddUsingAction">
+            <summary>
+            1) When a type cannot be resolved, offers to add a using declaration
+            or to replace it with the fully qualified type name.
+            2) When an extension method cannot be resolved, offers to add a using declaration.
+            3) When the caret is on a namespace name, offers to add a using declaration
+            and simplify the type references to use the new shorter option.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.ConvertAsToCastAction">
+            <summary>
+            Converts an 'as' expression to a cast expression
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.ConvertCastToAsAction">
+            <summary>
+            Converts a cast expression to an 'as' expression
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.MultipleEnumerationIssue.GatherVisitor.SplitNode(ICSharpCode.NRefactory.PlayScript.Refactoring.VariableReferenceNode)">
+            <summary>
+            split references in the specified node into sub nodes according to the value they uses
+            </summary>
+            <param name="node">node to split</param>
+            <returns>list of sub nodes</returns>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.MultipleEnumerationIssue.GatherVisitor.GetAssignmentUsageGraph(ICSharpCode.NRefactory.PlayScript.Refactoring.VariableReferenceNode)">
+            <summary>
+            convert a variable reference graph starting from the specified node to an assignment usage graph,
+            in which nodes are connect if and only if they contains references using the same assigned value
+            </summary>
+            <param name="startNode">starting node of the variable reference graph</param>
+            <returns>
+            list of VariableReferenceNode, each of which is a starting node of a sub-graph in which references all
+            use the same assigned value
+            </returns>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.DocumentScript">
+            <summary>
+            Script implementation based on IDocument.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.UsingHelper">
+            <summary>
+            Helper methods for managing using declarations.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.UsingHelper.InsertUsingAndRemoveRedundantNamespaceUsage(ICSharpCode.NRefactory.PlayScript.Refactoring.RefactoringContext,ICSharpCode.NRefactory.PlayScript.Refactoring.Script,System.String)">
+            <summary>
+            Inserts 'using ns;' in the current scope, and then removes all explicit
+            usages of ns that were made redundant by the new using.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.UsingHelper.InsertUsing(ICSharpCode.NRefactory.PlayScript.Refactoring.RefactoringContext,ICSharpCode.NRefactory.PlayScript.Refactoring.Script,ICSharpCode.NRefactory.PlayScript.AstNode)">
+            <summary>
+            Inserts 'newUsing' in the current scope.
+            This method will try to insert new usings in the correct position (depending on
+            where the existing usings are; and maintaining the sort order).
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.UsingHelper.SortUsingBlock(System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.PlayScript.AstNode},ICSharpCode.NRefactory.PlayScript.Refactoring.BaseRefactoringContext)">
+            <summary>
+            Sorts the specified usings.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.PatternHelper">
+            <summary>
+            Helper class for constructing pattern ASTs.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.PatternHelper.CommutativeOperator(ICSharpCode.NRefactory.PlayScript.Expression,ICSharpCode.NRefactory.PlayScript.BinaryOperatorType,ICSharpCode.NRefactory.PlayScript.Expression)">
+            <summary>
+            Produces a choice pattern for <c>expr1 op expr2</c> or <c>expr2 op expr1</c>.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.RefactoringAstHelper">
+            <summary>
+            Helper methods for constructing ASTs for refactoring.
+            These helpers work with frozen ASTs, i.e. they clone input nodes.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.RefactoringAstHelper.RemoveTarget(ICSharpCode.NRefactory.PlayScript.MemberReferenceExpression)">
+            <summary>
+            Removes the target from a member reference while preserving the identifier and type arguments.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.RefactoringAstHelper.RemoveTarget(ICSharpCode.NRefactory.PlayScript.MemberType)">
+            <summary>
+            Removes the target from a member reference while preserving the identifier and type arguments.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.Script">
+            <summary>
+            Class for creating change scripts.
+            'Original document' = document without the change script applied.
+            'Current document' = document with the change script (as far as it is already created) applies.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.Script.GetCurrentOffset(System.Int32)">
+            <summary>
+            Given an offset in the original document (at the start of script execution),
+            returns the offset in the current document.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.Script.GetCurrentOffset(ICSharpCode.NRefactory.TextLocation)">
+            <summary>
+            Given an offset in the original document (at the start of script execution),
+            returns the offset in the current document.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.Script.CreateTrackedSegment(System.Int32,System.Int32)">
+            <summary>
+            Creates a tracked segment for the specified (offset,length)-segment.
+            Offset is interpreted to be an offset in the current document.
+            </summary>
+            <returns>
+            A segment that initially has the specified values, and updates
+            on every <see cref="M:ICSharpCode.NRefactory.PlayScript.Refactoring.Script.Replace(System.Int32,System.Int32,System.String)" /> call.
+            </returns>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.Script.Replace(System.Int32,System.Int32,System.String)">
+            <summary>
+            Replaces text.
+            </summary>
+            <param name="offset">The starting offset of the text to be replaced.</param>
+            <param name="length">The length of the text to be replaced.</param>
+            <param name="newText">The new text.</param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.Script.Rename(ICSharpCode.NRefactory.TypeSystem.IEntity,System.String)">
+            <summary>
+            Renames the specified entity.
+            </summary>
+            <param name="entity">
+            The Entity to rename
+            </param>
+            <param name="name">
+            The new name, if null the user is prompted for a new name.
+            </param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.Script.RenameTypeParameter(ICSharpCode.NRefactory.TypeSystem.IType,System.String)">
+            <summary>
+            Renames the specified entity.
+            </summary>
+            <param name="type">
+            The Entity to rename
+            </param>
+            <param name="name">
+            The new name, if null the user is prompted for a new name.
+            </param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.Script.Rename(ICSharpCode.NRefactory.TypeSystem.IVariable,System.String)">
+            <summary>
+            Renames the specified variable.
+            </summary>
+            <param name="variable">
+            The Variable to rename
+            </param>
+            <param name="name">
+            The new name, if null the user is prompted for a new name.
+            </param>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Refactoring.Script.NewTypeContext.CurrentNamespace">
+            <summary>
+            The class should be placed in a new file to the current namespace.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Refactoring.Script.NewTypeContext.UnitTests">
+            <summary>
+            The class should be placed in the unit tests. (not implemented atm.)
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.Script.CreateNewType(ICSharpCode.NRefactory.PlayScript.AstNode,ICSharpCode.NRefactory.PlayScript.Refactoring.Script.NewTypeContext)">
+            <summary>
+            Creates a new file containing the type, namespace and correct usings.
+            (Note: Should take care of IDE specific things, file headers, add to project, correct name).
+            </summary>
+            <param name="newType">
+            New type to be created.
+            </param>
+            <param name="context">
+            The Context in which the new type should be created.
+            </param>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.TypeSystemAstBuilder">
+            <summary>
+            Converts from type system to the C# AST.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.TypeSystemAstBuilder.#ctor(ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver)">
+            <summary>
+            Creates a new TypeSystemAstBuilder.
+            </summary>
+            <param name="resolver">
+            A resolver initialized for the position where the type will be inserted.
+            </param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.TypeSystemAstBuilder.#ctor">
+            <summary>
+            Creates a new TypeSystemAstBuilder.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.TypeSystemAstBuilder.AddAnnotations">
+            <summary>
+            Specifies whether the ast builder should add annotations to type references.
+            The default value is <c>false</c>.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.TypeSystemAstBuilder.ShowAccessibility">
+            <summary>
+            Controls the accessibility modifiers are shown.
+            The default value is <c>true</c>.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.TypeSystemAstBuilder.ShowModifiers">
+            <summary>
+            Controls the non-accessibility modifiers are shown.
+            The default value is <c>true</c>.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.TypeSystemAstBuilder.ShowBaseTypes">
+            <summary>
+            Controls whether base type references are shown.
+            The default value is <c>true</c>.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.TypeSystemAstBuilder.ShowTypeParameters">
+            <summary>
+            Controls whether type parameter declarations are shown.
+            The default value is <c>true</c>.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.TypeSystemAstBuilder.ShowTypeParameterConstraints">
+            <summary>
+            Controls whether constraints on type parameter declarations are shown.
+            Has no effect if ShowTypeParameters is false.
+            The default value is <c>true</c>.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.TypeSystemAstBuilder.ShowParameterNames">
+            <summary>
+            Controls whether the names of parameters are shown.
+            The default value is <c>true</c>.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.TypeSystemAstBuilder.ShowConstantValues">
+            <summary>
+            Controls whether to show default values of optional parameters, and the values of constant fields.
+            The default value is <c>true</c>.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.TypeSystemAstBuilder.AlwaysUseShortTypeNames">
+            <summary>
+            Controls whether to use fully-qualified type names or short type names.
+            The default value is <c>false</c>.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.TypeSystemAstBuilder.GenerateBody">
+            <summary>
+            Controls whether to generate a body that throws a <c>System.NotImplementedException</c>.
+            The default value is <c>false</c>.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.TypeSystemAstBuilder.UseCustomEvents">
+            <summary>
+            Controls whether to generate custom events.
+            The default value is <c>false</c>.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.TypeSystemAstBuilder.ConvertUnboundTypeArguments">
+            <summary>
+            Controls if unbound type argument names are inserted in the ast or not.
+            The default value is <c>false</c>.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.TypeSystemAstBuilder.UseAliases">
+            <summary>
+            Controls if aliases should be used inside the type name or not.
+            The default value is <c>true</c>.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.TypeSystemAstBuilder.TypeMatches(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.ITypeDefinition,System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType})">
+            <summary>
+            Gets whether 'type' is the same as 'typeDef' parameterized with the given type arguments.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.TypeSystemAstBuilder.AddTypeArguments(ICSharpCode.NRefactory.PlayScript.AstType,ICSharpCode.NRefactory.TypeSystem.ITypeDefinition,System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType},System.Int32,System.Int32)">
+            <summary>
+            Adds type arguments to the result type.
+            </summary>
+            <param name="result">The result AST node (a SimpleType or MemberType)</param>
+            <param name="typeDef">The type definition that owns the type parameters</param>
+            <param name="typeArguments">The list of type arguments</param>
+            <param name="startIndex">Index of first type argument to add</param>
+            <param name="endIndex">Index after last type argument to add</param>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.AwaitResolveResult">
+            <summary>
+            Represents the result of an await expression.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.AwaitResolveResult.GetAwaiterInvocation">
+            <summary>
+            The method representing the GetAwaiter() call. Can be an <see cref="T:ICSharpCode.NRefactory.Semantics.InvocationResolveResult" /> or a <see cref="T:ICSharpCode.NRefactory.PlayScript.Resolver.DynamicInvocationResolveResult" />.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.AwaitResolveResult.AwaiterType">
+            <summary>
+            Awaiter type. Will not be null (but can be UnknownType).
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.AwaitResolveResult.IsCompletedProperty">
+            <summary>
+            Property representing the IsCompleted property on the awaiter type. Can be null if the awaiter type or the property was not found, or when awaiting a dynamic expression.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.AwaitResolveResult.OnCompletedMethod">
+            <summary>
+            Method representing the OnCompleted method on the awaiter type. Can be null if the awaiter type or the method was not found, or when awaiting a dynamic expression.
+            This can also refer to an UnsafeOnCompleted method, if the awaiter type implements <c>System.Runtime.CompilerServices.ICriticalNotifyCompletion</c>.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.AwaitResolveResult.GetResultMethod">
+            <summary>
+            Method representing the GetResult method on the awaiter type. Can be null if the awaiter type or the method was not found, or when awaiting a dynamic expression.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.DynamicInvocationType.Invocation">
+            <summary>
+            The invocation is a normal invocation ( 'a(b)' ).
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.DynamicInvocationType.Indexing">
+            <summary>
+            The invocation is an indexing ( 'a[b]' ).
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.DynamicInvocationType.ObjectCreation">
+            <summary>
+            The invocation is an object creation ( 'new a(b)' ). Also used when invoking a base constructor ( ' : base(a) ' ) and chaining constructors ( ' : this(a) ').
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.DynamicInvocationResolveResult">
+            <summary>
+            Represents the result of an invocation of a member of a dynamic object.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.DynamicInvocationResolveResult.Target">
+            <summary>
+            Target of the invocation. Can be a dynamic expression or a <see cref="T:ICSharpCode.NRefactory.PlayScript.Resolver.MethodGroupResolveResult" />.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.DynamicInvocationResolveResult.InvocationType">
+            <summary>
+            Type of the invocation.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.DynamicInvocationResolveResult.Arguments">
+            <summary>
+            Arguments for the call. Named arguments will be instances of <see cref="T:ICSharpCode.NRefactory.Semantics.NamedArgumentResolveResult" />.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.DynamicInvocationResolveResult.InitializerStatements">
+            <summary>
+            Gets the list of initializer statements that are appplied to the result of this invocation.
+            This is used to represent object and collection initializers.
+            With the initializer statements, the <see cref="T:ICSharpCode.NRefactory.Semantics.InitializedObjectResolveResult" /> is used
+            to refer to the result of this invocation.
+            Initializer statements can only exist if the <see cref="F:ICSharpCode.NRefactory.PlayScript.Resolver.DynamicInvocationResolveResult.InvocationType" /> is <see cref="F:ICSharpCode.NRefactory.PlayScript.Resolver.DynamicInvocationType.ObjectCreation" />.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.DynamicMemberResolveResult">
+            <summary>
+            Represents the result of an access to a member of a dynamic object.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.DynamicMemberResolveResult.Target">
+            <summary>
+            Target of the member access (a dynamic object).
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.DynamicMemberResolveResult.Member">
+            <summary>
+            Name of the accessed member.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpConversions">
+            <summary>
+            Contains logic that determines whether an implicit conversion exists between two types.
+            </summary>
+            <remarks>
+            This class is thread-safe.
+            </remarks>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpConversions.Get(ICSharpCode.NRefactory.TypeSystem.ICompilation)">
+            <summary>
+            Gets the Conversions instance for the specified <see cref="T:ICSharpCode.NRefactory.TypeSystem.ICompilation" />.
+            This will make use of the context's cache manager to reuse the Conversions instance.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpConversions.IsConstraintConvertible(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType)">
+            <summary>
+            Gets whether the type 'fromType' is convertible to 'toType'
+            using one of the conversions allowed when satisying constraints (§4.4.4)
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpConversions.IdentityConversion(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType)">
+            <summary>
+            Gets whether there is an identity conversion from <paramref name="fromType" /> to <paramref name="toType" /></summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpConversions.UnpackGenericArrayInterface(ICSharpCode.NRefactory.TypeSystem.IType)">
+            <summary>
+            For IList{T}, ICollection{T}, IEnumerable{T} and IReadOnlyList{T}, returns T.
+            Otherwise, returns null.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpConversions.ImplicitTypeParameterConversion(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType)">
+            <summary>
+            Implicit conversions involving type parameters.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpConversions.IsEncompassedBy(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType)">
+            <summary>
+            Gets whether type A is encompassed by type B.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpConversions.IsDelegateCompatible(ICSharpCode.NRefactory.TypeSystem.IMethod,ICSharpCode.NRefactory.TypeSystem.IMethod,System.Boolean)">
+            <summary>
+            Gets whether a method <paramref name="m" /> is compatible with a delegate type.
+            §15.2 Delegate compatibility
+            </summary>
+            <param name="m">The method to test for compatibility</param>
+            <param name="invoke">The invoke method of the delegate</param>
+            <param name="isExtensionMethodInvocation">Gets whether m is accessed using extension method syntax.
+            If this parameter is true, the first parameter of <paramref name="m" /> will be ignored.</param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpConversions.BetterConversion(ICSharpCode.NRefactory.Semantics.ResolveResult,ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType)">
+            <summary>
+            Gets the better conversion (C# 4.0 spec, §7.5.3.3)
+            </summary>
+            <returns>0 = neither is better; 1 = t1 is better; 2 = t2 is better</returns>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpConversions.UnpackTask(ICSharpCode.NRefactory.TypeSystem.IType)">
+            <summary>
+            Unpacks the generic Task[T]. Returns null if the input is not Task[T].
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpConversions.BetterConversion(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType)">
+            <summary>
+            Gets the better conversion (C# 4.0 spec, §7.5.3.4)
+            </summary>
+            <returns>0 = neither is better; 1 = t1 is better; 2 = t2 is better</returns>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpConversions.BetterConversionTarget(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType)">
+            <summary>
+            Gets the better conversion target (C# 4.0 spec, §7.5.3.5)
+            </summary>
+            <returns>0 = neither is better; 1 = t1 is better; 2 = t2 is better</returns>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpAstResolver">
+            <summary>
+            Resolves C# AST nodes.
+            </summary>
+            <remarks>This class is thread-safe.</remarks>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpAstResolver.#ctor(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.PlayScript.SyntaxTree,ICSharpCode.NRefactory.PlayScript.TypeSystem.CSharpUnresolvedFile)">
+            <summary>
+            Creates a new C# AST resolver.
+            Use this overload if you are resolving within a complete C# file.
+            </summary>
+            <param name="compilation">The current compilation.</param>
+            <param name="syntaxTree">The syntax tree to be resolved.</param>
+            <param name="unresolvedFile">
+            Optional: Result of <see cref="M:ICSharpCode.NRefactory.PlayScript.SyntaxTree.ToTypeSystem" /> for the file being resolved.
+            <para>
+            This is used for setting up the context on the resolver. The unresolved file must be registered in the compilation.
+            </para><para>
+            When a unresolvedFile is specified, the resolver will use the member's StartLocation/EndLocation to identify
+            member declarations in the AST with members in the type system.
+            When no unresolvedFile is specified (<c>null</c> value for this parameter), the resolver will instead compare the
+            member's signature in the AST with the signature in the type system.
+            </para></param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpAstResolver.#ctor(ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver,ICSharpCode.NRefactory.PlayScript.AstNode,ICSharpCode.NRefactory.PlayScript.TypeSystem.CSharpUnresolvedFile)">
+            <summary>
+            Creates a new C# AST resolver.
+            Use this overload if you are resolving code snippets (not necessarily complete files).
+            </summary>
+            <param name="resolver">The resolver state at the root node (to be more precise: just outside the root node).</param>
+            <param name="rootNode">The root node of the tree to be resolved.</param>
+            <param name="unresolvedFile">
+            Optional: Result of <see cref="M:ICSharpCode.NRefactory.PlayScript.SyntaxTree.ToTypeSystem" /> for the file being resolved.
+            <para>
+            This is used for setting up the context on the resolver. The unresolved file must be registered in the compilation.
+            </para><para>
+            When a unresolvedFile is specified, the resolver will use the member's StartLocation/EndLocation to identify
+            member declarations in the AST with members in the type system.
+            When no unresolvedFile is specified (<c>null</c> value for this parameter), the resolver will instead compare the
+            member's signature in the AST with the signature in the type system.
+            </para></param>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpAstResolver.TypeResolveContext">
+            <summary>
+            Gets the type resolve context for the root resolver.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpAstResolver.Compilation">
+            <summary>
+            Gets the compilation for this resolver.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpAstResolver.RootNode">
+            <summary>
+            Gets the root node for which this CSharpAstResolver was created.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpAstResolver.UnresolvedFile">
+            <summary>
+            Gets the unresolved file used by this CSharpAstResolver.
+            Can return null.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpAstResolver.ApplyNavigator(ICSharpCode.NRefactory.PlayScript.Resolver.IResolveVisitorNavigator,System.Threading.CancellationToken)">
+            <summary>
+            Applies a resolver navigator. This will resolve the nodes requested by the navigator, and will inform the
+            navigator of the results.
+            This method must be called as the first operation on the CSharpAstResolver, it is invalid to apply a navigator
+            after a portion of the file was already resolved.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpAstResolver.Resolve(ICSharpCode.NRefactory.PlayScript.AstNode,System.Threading.CancellationToken)">
+            <summary>
+            Resolves the specified node.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpAstResolver.GetResolverStateBefore(ICSharpCode.NRefactory.PlayScript.AstNode,System.Threading.CancellationToken)">
+            <summary>
+            Gets the resolver state immediately before the specified node.
+            That is, if the node is a variable declaration, the returned state will not contain the newly declared variable.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpAstResolver.GetResolverStateAfter(ICSharpCode.NRefactory.PlayScript.AstNode,System.Threading.CancellationToken)">
+            <summary>
+            Gets the resolver state immediately after the specified node.
+            That is, if the node is a variable declaration, the returned state will include the newly declared variable.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpAstResolver.GetExpectedType(ICSharpCode.NRefactory.PlayScript.Expression,System.Threading.CancellationToken)">
+            <summary>
+            Gets the expected type for the specified node. This is the type being that a node is being converted to.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpAstResolver.GetConversion(ICSharpCode.NRefactory.PlayScript.Expression,System.Threading.CancellationToken)">
+            <summary>
+            Gets the conversion that is being applied to the specified expression.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpAstResolver.IsUnresolvableNode(ICSharpCode.NRefactory.PlayScript.AstNode)">
+            <summary>
+            Gets whether the specified node is unresolvable.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpInvocationResolveResult">
+            <summary>
+            Represents the result of a method, constructor or indexer invocation.
+            Provides additional C#-specific information for InvocationResolveResult.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpInvocationResolveResult.IsExtensionMethodInvocation">
+            <summary>
+            Gets whether this invocation is calling an extension method using extension method syntax.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpInvocationResolveResult.IsDelegateInvocation">
+            <summary>
+            Gets whether this invocation is calling a delegate (without explicitly calling ".Invoke()").
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpInvocationResolveResult.IsExpandedForm">
+            <summary>
+            Gets whether a params-Array is being used in its expanded form.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpInvocationResolveResult.reducedMethod">
+            <summary>
+            If IsExtensionMethodInvocation is true this property holds the reduced method.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpInvocationResolveResult.GetArgumentToParameterMap">
+            <summary>
+            Gets an array that maps argument indices to parameter indices.
+            For arguments that could not be mapped to any parameter, the value will be -1.
+            parameterIndex = ArgumentToParameterMap[argumentIndex]
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpOperators.Get(ICSharpCode.NRefactory.TypeSystem.ICompilation)">
+            <summary>
+            Gets the CSharpOperators instance for the specified <see cref="T:ICSharpCode.NRefactory.TypeSystem.ICompilation" />.
+            This will make use of the context's cache manager (if available) to reuse the CSharpOperators instance.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver">
+            <summary>
+            Contains the main resolver logic.
+            </summary>
+            <remarks>
+            This class is thread-safe.
+            </remarks>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.Compilation">
+            <summary>
+            Gets the compilation used by the resolver.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.CurrentTypeResolveContext">
+            <summary>
+            Gets the current type resolve context.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.CheckForOverflow">
+            <summary>
+            Gets whether the current context is <c>checked</c>.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.WithCheckForOverflow(System.Boolean)">
+            <summary>
+            Sets whether the current context is <c>checked</c>.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.IsWithinLambdaExpression">
+            <summary>
+            Gets whether the resolver is currently within a lambda expression.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.WithIsWithinLambdaExpression(System.Boolean)">
+            <summary>
+            Sets whether the resolver is currently within a lambda expression.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.CurrentMember">
+            <summary>
+            Gets the current member definition that is used to look up identifiers as parameters
+            or type parameters.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.WithCurrentMember(ICSharpCode.NRefactory.TypeSystem.IMember)">
+            <summary>
+            Sets the current member definition.
+            </summary>
+            <remarks>Don't forget to also set CurrentTypeDefinition when setting CurrentMember;
+            setting one of the properties does not automatically set the other.</remarks>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.CurrentUsingScope">
+            <summary>
+            Gets the current using scope that is used to look up identifiers as class names.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.WithCurrentUsingScope(ICSharpCode.NRefactory.PlayScript.TypeSystem.ResolvedUsingScope)">
+            <summary>
+            Sets the current using scope that is used to look up identifiers as class names.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.CurrentTypeDefinition">
+            <summary>
+            Gets the current type definition.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.WithCurrentTypeDefinition(ICSharpCode.NRefactory.TypeSystem.ITypeDefinition)">
+            <summary>
+            Sets the current type definition.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.PushBlock">
+            <summary>
+            Opens a new scope for local variables.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.PopBlock">
+            <summary>
+            Closes the current scope for local variables; removing all variables in that scope.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.AddVariable(ICSharpCode.NRefactory.TypeSystem.IVariable)">
+            <summary>
+            Adds a new variable or lambda parameter to the current block.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.PopLastVariable">
+            <summary>
+            Removes the variable that was just added.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.LocalVariables">
+            <summary>
+            Gets all currently visible local variables and lambda parameters.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.PushObjectInitializer(ICSharpCode.NRefactory.Semantics.ResolveResult)">
+            <summary>
+            Pushes the type of the object that is currently being initialized.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.IsInObjectInitializer">
+            <summary>
+            Gets whether this context is within an object initializer.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.CurrentObjectInitializer">
+            <summary>
+            Gets the current object initializer. This usually is an <see cref="T:ICSharpCode.NRefactory.Semantics.InitializedObjectResolveResult" />
+            or (for nested initializers) a semantic tree based on an <see cref="T:ICSharpCode.NRefactory.Semantics.InitializedObjectResolveResult" />.
+            Returns ErrorResolveResult if there is no object initializer.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.CurrentObjectInitializerType">
+            <summary>
+            Gets the type of the object currently being initialized.
+            Returns SharedTypes.Unknown if no object initializer is currently open (or if the object initializer
+            has unknown type).
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.Clone">
+            <summary>
+            Creates a copy of this CSharp resolver.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.HandleEnumComparison(ICSharpCode.NRefactory.PlayScript.BinaryOperatorType,ICSharpCode.NRefactory.TypeSystem.IType,System.Boolean,ICSharpCode.NRefactory.Semantics.ResolveResult,ICSharpCode.NRefactory.Semantics.ResolveResult)">
+            <summary>
+            Handle the case where an enum value is compared with another enum value
+            bool operator op(E x, E y);
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.HandleEnumSubtraction(System.Boolean,ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.Semantics.ResolveResult,ICSharpCode.NRefactory.Semantics.ResolveResult)">
+            <summary>
+            Handle the case where an enum value is subtracted from another enum value
+            U operator –(E x, E y);
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.HandleEnumOperator(System.Boolean,ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.PlayScript.BinaryOperatorType,ICSharpCode.NRefactory.Semantics.ResolveResult,ICSharpCode.NRefactory.Semantics.ResolveResult)">
+            <summary>
+            Handle the following enum operators:
+            E operator +(E x, U y);
+            E operator +(U x, E y);
+            E operator –(E x, U y);
+            E operator &amp;(E x, E y);
+            E operator |(E x, E y);
+            E operator ^(E x, E y);
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.ResolveAlias(System.String)">
+            <summary>
+            Looks up an alias (identifier in front of :: operator)
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.CreateMemberLookup">
+            <summary>
+            Creates a MemberLookup instance using this resolver's settings.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.CreateMemberLookup(ICSharpCode.NRefactory.PlayScript.NameLookupMode)">
+            <summary>
+            Creates a MemberLookup instance using this resolver's settings.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.GetExtensionMethods(System.String,System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType})">
+            <summary>
+            Gets all extension methods that are available in the current context.
+            </summary>
+            <param name="name">Name of the extension method. Pass null to retrieve all extension methods.</param>
+            <param name="typeArguments">Explicitly provided type arguments.
+            An empty list will return all matching extension method definitions;
+            a non-empty list will return <see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedMethod" />s for all extension methods
+            with the matching number of type parameters.</param>
+            <remarks>
+            The results are stored in nested lists because they are grouped by using scope.
+            That is, for "using SomeExtensions; namespace X { using MoreExtensions; ... }",
+            the return value will be
+            new List {
+            new List { all extensions from MoreExtensions },
+            new List { all extensions from SomeExtensions }
+            }
+            </remarks>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.GetExtensionMethods(ICSharpCode.NRefactory.TypeSystem.IType,System.String,System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType},System.Boolean)">
+            <summary>
+            Gets the extension methods that are called 'name'
+            and are applicable with a first argument type of 'targetType'.
+            </summary>
+            <param name="targetType">Type of the 'this' argument</param>
+            <param name="name">Name of the extension method. Pass null to retrieve all extension methods.</param>
+            <param name="typeArguments">Explicitly provided type arguments.
+            An empty list will return all matching extension method definitions;
+            a non-empty list will return <see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedMethod" />s for all extension methods
+            with the matching number of type parameters.</param>
+            <param name="substituteInferredTypes">
+            Specifies whether to produce a <see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedMethod" />
+            when type arguments could be inferred from <paramref name="targetType" />. This parameter
+            is only used for inferred types and has no effect if <paramref name="typeArguments" /> is non-empty.
+            </param>
+            <remarks>
+            The results are stored in nested lists because they are grouped by using scope.
+            That is, for "using SomeExtensions; namespace X { using MoreExtensions; ... }",
+            the return value will be
+            new List {
+            new List { all extensions from MoreExtensions },
+            new List { all extensions from SomeExtensions }
+            }
+            </remarks>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.IsEligibleExtensionMethod(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IMethod,System.Boolean,ICSharpCode.NRefactory.TypeSystem.IType[]@)">
+            <summary>
+            Checks whether the specified extension method is eligible on the target type.
+            </summary>
+            <param name="targetType">Target type that is passed as first argument to the extension method.</param>
+            <param name="method">The extension method.</param>
+            <param name="useTypeInference">Whether to perform type inference for the method.
+            Use <c>false</c> if <paramref name="method" /> is already parameterized (e.g. when type arguments were given explicitly).
+            Otherwise, use <c>true</c>.
+            </param>
+            <param name="outInferredTypes">If the method is generic and <paramref name="useTypeInference" /> is <c>true</c>,
+            and at least some of the type arguments could be inferred, this parameter receives the inferred type arguments.
+            Since only the type for the first parameter is considered, not all type arguments may be inferred.
+            If an array is returned, any slot with an uninferred type argument will be set to the method's
+            corresponding type parameter.
+            </param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.GetAllExtensionMethods">
+            <summary>
+            Gets all extension methods available in the current using scope.
+            This list includes unaccessible
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.ResolveInvocation(ICSharpCode.NRefactory.Semantics.ResolveResult,ICSharpCode.NRefactory.Semantics.ResolveResult[],System.String[])">
+            <summary>
+            Resolves an invocation.
+            </summary>
+            <param name="target">The target of the invocation. Usually a MethodGroupResolveResult.</param>
+            <param name="arguments">
+            Arguments passed to the method.
+            The resolver may mutate this array to wrap elements in <see cref="T:ICSharpCode.NRefactory.Semantics.ConversionResolveResult" />s!
+            </param>
+            <param name="argumentNames">
+            The argument names. Pass the null string for positional arguments.
+            </param>
+            <returns>InvocationResolveResult or UnknownMethodResolveResult</returns>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.ResolveIndexer(ICSharpCode.NRefactory.Semantics.ResolveResult,ICSharpCode.NRefactory.Semantics.ResolveResult[],System.String[])">
+            <summary>
+            Resolves an indexer access.
+            </summary>
+            <param name="target">Target expression.</param>
+            <param name="arguments">
+            Arguments passed to the indexer.
+            The resolver may mutate this array to wrap elements in <see cref="T:ICSharpCode.NRefactory.Semantics.ConversionResolveResult" />s!
+            </param>
+            <param name="argumentNames">
+            The argument names. Pass the null string for positional arguments.
+            </param>
+            <returns>ArrayAccessResolveResult, InvocationResolveResult, or ErrorResolveResult</returns>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.AdjustArrayAccessArguments(ICSharpCode.NRefactory.Semantics.ResolveResult[])">
+            <summary>
+            Converts all arguments to int,uint,long or ulong.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.ResolveObjectCreation(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.Semantics.ResolveResult[],System.String[],System.Boolean,System.Collections.Generic.IList{ICSharpCode.NRefactory.Semantics.ResolveResult})">
+            <summary>
+            Resolves an object creation.
+            </summary>
+            <param name="type">Type of the object to create.</param>
+            <param name="arguments">
+            Arguments passed to the constructor.
+            The resolver may mutate this array to wrap elements in <see cref="T:ICSharpCode.NRefactory.Semantics.ConversionResolveResult" />s!
+            </param>
+            <param name="argumentNames">
+            The argument names. Pass the null string for positional arguments.
+            </param>
+            <param name="allowProtectedAccess">
+            Whether to allow calling protected constructors.
+            This should be false except when resolving constructor initializers.
+            </param>
+            <param name="initializerStatements">
+            Statements for Objects/Collections initializer.
+            <see cref="F:ICSharpCode.NRefactory.Semantics.InvocationResolveResult.InitializerStatements" /></param>
+            <returns>InvocationResolveResult or ErrorResolveResult</returns>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.ResolveSizeOf(ICSharpCode.NRefactory.TypeSystem.IType)">
+            <summary>
+            Resolves 'sizeof(type)'.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.ResolveThisReference">
+            <summary>
+            Resolves 'this'.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.ResolveBaseReference">
+            <summary>
+            Resolves 'base'.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.ResolveCondition(ICSharpCode.NRefactory.Semantics.ResolveResult)">
+            <summary>
+            Converts the input to <c>bool</c> using the rules for boolean expressions.
+            That is, <c>operator true</c> is used if a regular conversion to <c>bool</c> is not possible.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.ResolveConditionFalse(ICSharpCode.NRefactory.Semantics.ResolveResult)">
+            <summary>
+            Converts the negated input to <c>bool</c> using the rules for boolean expressions.
+            Computes <c>!(bool)input</c> if the implicit cast to bool is valid; otherwise
+            computes <c>input.operator false()</c>.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.ResolveArrayCreation(ICSharpCode.NRefactory.TypeSystem.IType,System.Int32[],ICSharpCode.NRefactory.Semantics.ResolveResult[])">
+            <summary>
+            Resolves an array creation.
+            </summary>
+            <param name="elementType">
+            The array element type.
+            Pass null to resolve an implicitly-typed array creation.
+            </param>
+            <param name="sizeArguments">
+            The size arguments.
+            The length of this array will be used as the number of dimensions of the array type.
+            Negative values will be treated as errors.
+            </param>
+            <param name="initializerElements">
+            The initializer elements. May be null if no array initializer was specified.
+            The resolver may mutate this array to wrap elements in <see cref="T:ICSharpCode.NRefactory.Semantics.ConversionResolveResult" />s!
+            </param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver.ResolveArrayCreation(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.Semantics.ResolveResult[],ICSharpCode.NRefactory.Semantics.ResolveResult[])">
+            <summary>
+            Resolves an array creation.
+            </summary>
+            <param name="elementType">
+            The array element type.
+            Pass null to resolve an implicitly-typed array creation.
+            </param>
+            <param name="sizeArguments">
+            The size arguments.
+            The length of this array will be used as the number of dimensions of the array type.
+            The resolver may mutate this array to wrap elements in <see cref="T:ICSharpCode.NRefactory.Semantics.ConversionResolveResult" />s!
+            </param>
+            <param name="initializerElements">
+            The initializer elements. May be null if no array initializer was specified.
+            The resolver may mutate this array to wrap elements in <see cref="T:ICSharpCode.NRefactory.Semantics.ConversionResolveResult" />s!
+            </param>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.DetectSkippableNodesNavigator">
+            <summary>
+            When an <see cref="T:ICSharpCode.NRefactory.PlayScript.Resolver.IResolveVisitorNavigator" /> is searching for specific nodes
+            (e.g. all IdentifierExpressions), it has to scan the whole syntax tree for those nodes.
+            However, scanning in the ResolveVisitor is expensive (e.g. any lambda that is scanned must be resolved),
+            so it makes sense to detect when a whole subtree is scan-only, and skip that tree instead.
+            The DetectSkippableNodesNavigator performs this job by running the input IResolveVisitorNavigator
+            over the whole AST, and detecting subtrees that are scan-only, and replaces them with Skip.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.DetectSkippableNodesNavigator.Scan(ICSharpCode.NRefactory.PlayScript.AstNode)">
+            <inheritdoc />
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.DetectSkippableNodesNavigator.Resolved(ICSharpCode.NRefactory.PlayScript.AstNode,ICSharpCode.NRefactory.Semantics.ResolveResult)">
+            <inheritdoc />
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.DetectSkippableNodesNavigator.ProcessConversion(ICSharpCode.NRefactory.PlayScript.Expression,ICSharpCode.NRefactory.Semantics.ResolveResult,ICSharpCode.NRefactory.Semantics.Conversion,ICSharpCode.NRefactory.TypeSystem.IType)">
+            <inheritdoc />
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.FindReferencedEntities">
+            <summary>
+            Find all entities that are referenced in the scanned AST.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.FindReferencedEntities.#ctor(System.Action{ICSharpCode.NRefactory.PlayScript.AstNode,ICSharpCode.NRefactory.TypeSystem.IEntity})">
+            <summary>
+            Creates a new FindReferencedEntities instance that
+            looks for entity definitions.
+            The visitor will report type definitions and member definitions (not specialized members).
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.FindReferencedEntities.#ctor(System.Action{ICSharpCode.NRefactory.PlayScript.AstNode,ICSharpCode.NRefactory.TypeSystem.IType},System.Action{ICSharpCode.NRefactory.PlayScript.AstNode,ICSharpCode.NRefactory.TypeSystem.IMember})">
+            <summary>
+            Creates a new FindReferencedEntities instance that
+            looks for types and members.
+            The visitor will report parameterized types and potentially specialized members.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.FindReferences">
+            <summary>
+            'Find references' implementation.
+            </summary>
+            <remarks>
+            This class is thread-safe.
+            The intended multi-threaded usage is to call GetSearchScopes() once, and then
+            call FindReferencesInFile() concurrently on multiple threads (parallel foreach over all interesting files).
+            </remarks>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.FindReferences.FindTypeReferencesEvenIfAliased">
+            <summary>
+            Specifies whether to find type references even if an alias is being used.
+            Aliases may be <c>var</c> or <c>using Alias = ...;</c>.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.FindReferences.FindOnlySpecializedReferences">
+            <summary>
+            Specifies whether find references should only look for specialized matches
+            with equal type parameter substitution to the member we are searching for.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.FindReferences.FindCallsThroughVirtualBaseMethod">
+            <summary>
+            If this option is enabled, find references on a overridden member
+            will find calls to the base member.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.FindReferences.FindCallsThroughInterface">
+            <summary>
+            If this option is enabled, find references on a member implementing
+            an interface will also find calls to the interface.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.FindReferences.WholeVirtualSlot">
+            <summary>
+            If this option is enabled, find references will look for all references
+            to the virtual method slot.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.FindReferences.SearchInDocumentationComments">
+            <summary>
+            Specifies whether to look for references in documentation comments.
+            This will find entity references in <c>cref</c> attributes and
+            parameter references in <c>&lt;param&gt;</c> and <c>&lt;paramref&gt;</c> tags.
+            TODO: implement this feature.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.FindReferences.GetEffectiveAccessibility(ICSharpCode.NRefactory.TypeSystem.IEntity)">
+            <summary>
+            Gets the effective accessibility of the specified entity -
+            that is, the accessibility viewed from the top level.
+            </summary>
+            <remarks>
+            internal member in public class -&gt; internal
+            public member in internal class -&gt; internal
+            protected member in public class -&gt; protected
+            protected member in internal class -&gt; protected and internal
+            </remarks>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.FindReferences.GetInterestingFiles(ICSharpCode.NRefactory.PlayScript.Resolver.IFindReferenceSearchScope,ICSharpCode.NRefactory.TypeSystem.ICompilation)">
+            <summary>
+            Gets the file names that possibly contain references to the element being searched for.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.FindReferences.FindReferencesInFile(ICSharpCode.NRefactory.PlayScript.Resolver.IFindReferenceSearchScope,ICSharpCode.NRefactory.PlayScript.TypeSystem.CSharpUnresolvedFile,ICSharpCode.NRefactory.PlayScript.SyntaxTree,ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.PlayScript.Resolver.FoundReferenceCallback,System.Threading.CancellationToken)">
+            <summary>
+            Finds all references in the given file.
+            </summary>
+            <param name="searchScope">The search scope for which to look.</param>
+            <param name="unresolvedFile">The type system representation of the file being searched.</param>
+            <param name="syntaxTree">The syntax tree of the file being searched.</param>
+            <param name="compilation">The compilation for the project that contains the file.</param>
+            <param name="callback">Callback used to report the references that were found.</param>
+            <param name="cancellationToken">CancellationToken that may be used to cancel the operation.</param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.FindReferences.FindReferencesInFile(System.Collections.Generic.IList{ICSharpCode.NRefactory.PlayScript.Resolver.IFindReferenceSearchScope},ICSharpCode.NRefactory.PlayScript.TypeSystem.CSharpUnresolvedFile,ICSharpCode.NRefactory.PlayScript.SyntaxTree,ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.PlayScript.Resolver.FoundReferenceCallback,System.Threading.CancellationToken)">
+            <summary>
+            Finds all references in the given file.
+            </summary>
+            <param name="searchScopes">The search scopes for which to look.</param>
+            <param name="unresolvedFile">The type system representation of the file being searched.</param>
+            <param name="syntaxTree">The syntax tree of the file being searched.</param>
+            <param name="compilation">The compilation for the project that contains the file.</param>
+            <param name="callback">Callback used to report the references that were found.</param>
+            <param name="cancellationToken">CancellationToken that may be used to cancel the operation.</param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.FindReferences.FindLocalReferences(ICSharpCode.NRefactory.TypeSystem.IVariable,ICSharpCode.NRefactory.PlayScript.TypeSystem.CSharpUnresolvedFile,ICSharpCode.NRefactory.PlayScript.SyntaxTree,ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.PlayScript.Resolver.FoundReferenceCallback,System.Threading.CancellationToken)">
+            <summary>
+            Finds all references of a given variable.
+            </summary>
+            <param name="variable">The variable for which to look.</param>
+            <param name="unresolvedFile">The type system representation of the file being searched.</param>
+            <param name="syntaxTree">The syntax tree of the file being searched.</param>
+            <param name="compilation">The compilation.</param>
+            <param name="callback">Callback used to report the references that were found.</param>
+            <param name="cancellationToken">Cancellation token that may be used to cancel the operation.</param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.FindReferences.FindTypeParameterReferences(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.PlayScript.TypeSystem.CSharpUnresolvedFile,ICSharpCode.NRefactory.PlayScript.SyntaxTree,ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.PlayScript.Resolver.FoundReferenceCallback,System.Threading.CancellationToken)">
+            <summary>
+            Finds all references of a given type parameter.
+            </summary>
+            <param name="typeParameter">The type parameter for which to look.</param>
+            <param name="unresolvedFile">The type system representation of the file being searched.</param>
+            <param name="syntaxTree">The syntax tree of the file being searched.</param>
+            <param name="compilation">The compilation.</param>
+            <param name="callback">Callback used to report the references that were found.</param>
+            <param name="cancellationToken">Cancellation token that may be used to cancel the operation.</param>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.IFindReferenceSearchScope">
+            <summary>
+            Represents a scope in which references are searched.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.IFindReferenceSearchScope.Compilation">
+            <summary>
+            Gets the compilation in which the entity being search for was defined.
+            This is not necessarily the same compilation as is being searched in.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.IFindReferenceSearchScope.SearchTerm">
+            <summary>
+            Gets the search term. Only files that contain this identifier need to be parsed.
+            Can return null if all files need to be parsed.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.IFindReferenceSearchScope.Accessibility">
+            <summary>
+            Gets the accessibility that defines the search scope.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.IFindReferenceSearchScope.TopLevelTypeDefinition">
+            <summary>
+            Gets the top-level entity that defines the search scope.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.IFindReferenceSearchScope.GetNavigator(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.PlayScript.Resolver.FoundReferenceCallback)">
+            <summary>
+            Creates a navigator that can find references to this entity and reports
+            them to the specified callback.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.IResolveVisitorNavigator">
+            <summary>
+            Allows controlling which nodes are resolved by the resolve visitor.
+            </summary>
+            <seealso cref="T:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveVisitor" />
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.IResolveVisitorNavigator.Scan(ICSharpCode.NRefactory.PlayScript.AstNode)">
+            <summary>
+            Asks the navigator whether to scan, skip, or resolve a node.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.IResolveVisitorNavigator.Resolved(ICSharpCode.NRefactory.PlayScript.AstNode,ICSharpCode.NRefactory.Semantics.ResolveResult)">
+            <summary>
+            Notifies the navigator that a node was resolved.
+            </summary>
+            <param name="node">The node that was resolved</param>
+            <param name="result">Resolve result</param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.IResolveVisitorNavigator.ProcessConversion(ICSharpCode.NRefactory.PlayScript.Expression,ICSharpCode.NRefactory.Semantics.ResolveResult,ICSharpCode.NRefactory.Semantics.Conversion,ICSharpCode.NRefactory.TypeSystem.IType)">
+            <summary>
+            Notifies the navigator that a conversion was applied.
+            </summary>
+            <param name="expression">The expression that was resolved.</param>
+            <param name="result">The resolve result of the expression.</param>
+            <param name="conversion">The conversion applied to the expressed.</param>
+            <param name="targetType">The target type of the conversion.</param>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveVisitorNavigationMode">
+            <summary>
+            Represents the operation mode of the resolve visitor.
+            </summary>
+            <seealso cref="T:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveVisitor" />
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveVisitorNavigationMode.Scan">
+            <summary>
+            Scan into the children of the current node, without resolving the current node.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveVisitorNavigationMode.Skip">
+            <summary>
+            Skip the current node - do not scan into it; do not resolve it.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveVisitorNavigationMode.Resolve">
+            <summary>
+            Resolve the current node.
+            Subnodes which are not required for resolving the current node
+            will ask the navigator again whether they should be resolved.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.LambdaResolveResult">
+            <summary>
+            Represents an anonymous method or lambda expression.
+            Note: the lambda has no type.
+            To retrieve the delegate type, look at the anonymous function conversion.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.LambdaResolveResult.HasParameterList">
+            <summary>
+            Gets whether there is a parameter list.
+            This property always returns true for C# 3.0-lambdas, but may return false
+            for C# 2.0 anonymous methods.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.LambdaResolveResult.IsAnonymousMethod">
+            <summary>
+            Gets whether this lambda is using the C# 2.0 anonymous method syntax.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.LambdaResolveResult.IsImplicitlyTyped">
+            <summary>
+            Gets whether the lambda parameters are implicitly typed.
+            </summary>
+            <remarks>This property returns false for anonymous methods without parameter list.</remarks>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.LambdaResolveResult.IsAsync">
+            <summary>
+            Gets whether the lambda is async.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.LambdaResolveResult.GetInferredReturnType(ICSharpCode.NRefactory.TypeSystem.IType[])">
+            <summary>
+            Gets the return type inferred when the parameter types are inferred to be <paramref name="parameterTypes" /></summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.LambdaResolveResult.Parameters">
+            <summary>
+            Gets the list of parameters.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.LambdaResolveResult.IsValid(ICSharpCode.NRefactory.TypeSystem.IType[],ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.PlayScript.Resolver.CSharpConversions)">
+            <summary>
+            Gets whether the lambda body is valid for the given parameter types and return type.
+            </summary>
+            <returns>
+            Produces a conversion with <see cref="P:ICSharpCode.NRefactory.Semantics.Conversion.IsAnonymousFunctionConversion" />=<c>true</c> if the lambda is valid;
+            otherwise returns <see cref="F:ICSharpCode.NRefactory.Semantics.Conversion.None" />.
+            </returns>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.LambdaResolveResult.Body">
+            <summary>
+            Gets the resolve result for the lambda body.
+            Returns a resolve result for 'void' for statement lambdas.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.Log">
+            <summary>
+            Resolver logging helper.
+            Wraps System.Diagnostics.Debug so that resolver-specific logging can be enabled/disabled on demand.
+            (it's a huge amount of debug spew and slows down the resolver quite a bit)
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.MemberLookup">
+            <summary>
+            Implementation of member lookup (C# 4.0 spec, §7.4).
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.MemberLookup.IsInvocable(ICSharpCode.NRefactory.TypeSystem.IMember)">
+            <summary>
+            Gets whether the member is considered to be invocable.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.MemberLookup.IsProtectedAccessAllowed(ICSharpCode.NRefactory.TypeSystem.IType)">
+            <summary>
+            Gets whether access to protected instance members of the target type is possible.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.MemberLookup.IsAccessible(ICSharpCode.NRefactory.TypeSystem.IEntity,System.Boolean)">
+            <summary>
+            Gets whether <paramref name="entity" /> is accessible in the current class.
+            </summary>
+            <param name="entity">The entity to test</param>
+            <param name="allowProtectedAccess">
+            Whether protected access to instance members is allowed.
+            True if the type of the reference is derived from the current class.
+            Protected static members may be accessibe even if false is passed for this parameter.
+            </param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.MemberLookup.GetAccessibleMembers(ICSharpCode.NRefactory.Semantics.ResolveResult)">
+            <summary>
+            Retrieves all members that are accessible and not hidden (by being overridden or shadowed).
+            Returns both members and nested type definitions. Does not include extension methods.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.MemberLookup.Lookup(ICSharpCode.NRefactory.Semantics.ResolveResult,System.String,System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType},System.Boolean)">
+            <summary>
+            Performs a member lookup.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.MemberLookup.LookupIndexers(ICSharpCode.NRefactory.TypeSystem.IType)">
+            <summary>
+            Looks up the indexers on the target type.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.MemberLookup.AddNestedTypes(ICSharpCode.NRefactory.TypeSystem.IType,System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.TypeSystem.IType},System.Int32,System.Collections.Generic.List{ICSharpCode.NRefactory.PlayScript.Resolver.MemberLookup.LookupGroup},System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.TypeSystem.IType}@,System.Collections.Generic.List{ICSharpCode.NRefactory.TypeSystem.IType}@)">
+            <summary>
+            Adds the nested types to 'newNestedTypes' and removes any hidden members from the existing lookup groups.
+            </summary>
+            <param name="type">Declaring type of the nested types</param>
+            <param name="nestedTypes">List of nested types to add.</param>
+            <param name="typeArgumentCount">The number of type arguments - used for hiding types from the base class</param>
+            <param name="lookupGroups">List of existing lookup groups</param>
+            <param name="typeBaseTypes">The base types of 'type' (initialized on demand)</param>
+            <param name="newNestedTypes">The target list (created on demand).</param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.MemberLookup.AddMembers(ICSharpCode.NRefactory.TypeSystem.IType,System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.TypeSystem.IMember},System.Boolean,System.Collections.Generic.List{ICSharpCode.NRefactory.PlayScript.Resolver.MemberLookup.LookupGroup},System.Boolean,System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.TypeSystem.IType}@,System.Collections.Generic.List{ICSharpCode.NRefactory.TypeSystem.IParameterizedMember}@,ICSharpCode.NRefactory.TypeSystem.IMember@)">
+            <summary>
+            Adds members to 'newMethods'/'newNonMethod'.
+            Removes any members in the existing lookup groups that were hidden by added members.
+            Substitutes 'virtual' members in the existing lookup groups for added 'override' members.
+            </summary>
+            <param name="type">Declaring type of the members</param>
+            <param name="members">List of members to add.</param>
+            <param name="allowProtectedAccess">Whether protected members are accessible</param>
+            <param name="lookupGroups">List of existing lookup groups</param>
+            <param name="treatAllParameterizedMembersAsMethods">Whether to treat properties as methods</param>
+            <param name="typeBaseTypes">The base types of 'type' (initialized on demand)</param>
+            <param name="newMethods">The target list for methods (created on demand).</param>
+            <param name="newNonMethod">The target variable for non-method members.</param>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.MethodListWithDeclaringType">
+            <summary>
+            A method list that belongs to a declaring type.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.MethodListWithDeclaringType.DeclaringType">
+            <summary>
+            The declaring type.
+            </summary>
+            <remarks>
+            Not all methods in this list necessarily have this as their declaring type.
+            For example, this program:
+            <code>
+            class Base {
+            public virtual void M() {}
+            }
+            class Derived : Base {
+            public override void M() {}
+            public void M(int i) {}
+            }
+            </code>
+            results in two lists:
+            <c>new MethodListWithDeclaringType(Base) { Derived.M() }</c>,
+            <c>new MethodListWithDeclaringType(Derived) { Derived.M(int) }</c></remarks>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.MethodGroupResolveResult">
+            <summary>
+            Represents a group of methods.
+            A method reference used to create a delegate is resolved to a MethodGroupResolveResult.
+            The MethodGroupResolveResult has no type.
+            To retrieve the delegate type or the chosen overload, look at the method group conversion.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.MethodGroupResolveResult.TargetResult">
+            <summary>
+            Gets the resolve result for the target object.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.MethodGroupResolveResult.TargetType">
+            <summary>
+            Gets the type of the reference to the target object.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.MethodGroupResolveResult.MethodName">
+            <summary>
+            Gets the name of the methods in this group.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.MethodGroupResolveResult.Methods">
+            <summary>
+            Gets the methods that were found.
+            This list does not include extension methods.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.MethodGroupResolveResult.MethodsGroupedByDeclaringType">
+            <summary>
+            Gets the methods that were found, grouped by their declaring type.
+            This list does not include extension methods.
+            Base types come first in the list.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.MethodGroupResolveResult.TypeArguments">
+            <summary>
+            Gets the type arguments that were explicitly provided.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.MethodGroupResolveResult.extensionMethods">
+            <summary>
+            List of extension methods, used to avoid re-calculating it in ResolveInvocation() when it was already
+            calculated by ResolveMemberAccess().
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.MethodGroupResolveResult.GetExtensionMethods">
+            <summary>
+            Gets all candidate extension methods.
+            Note: this includes candidates that are not eligible due to an inapplicable
+            this argument.
+            The candidates will only be specialized if the type arguments were provided explicitly.
+            </summary>
+            <remarks>
+            The results are stored in nested lists because they are grouped by using scope.
+            That is, for "using SomeExtensions; namespace X { using MoreExtensions; ... }",
+            the return value will be
+            new List {
+            new List { all extensions from MoreExtensions },
+            new List { all extensions from SomeExtensions }
+            }
+            </remarks>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.MethodGroupResolveResult.GetEligibleExtensionMethods(System.Boolean)">
+            <summary>
+            Gets the eligible extension methods.
+            </summary>
+            <param name="substituteInferredTypes">
+            Specifies whether to produce a <see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedMethod" />
+            when type arguments could be inferred from <see cref="P:ICSharpCode.NRefactory.PlayScript.Resolver.MethodGroupResolveResult.TargetType" />.
+            This setting is only used for inferred types and has no effect if the type parameters are
+            specified explicitly.
+            </param>
+            <remarks>
+            The results are stored in nested lists because they are grouped by using scope.
+            That is, for "using SomeExtensions; namespace X { using MoreExtensions; ... }",
+            the return value will be
+            new List {
+            new List { all extensions from MoreExtensions },
+            new List { all extensions from SomeExtensions }
+            }
+            </remarks>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.NodeListResolveVisitorNavigator">
+            <summary>
+                <see cref="T:ICSharpCode.NRefactory.PlayScript.Resolver.IResolveVisitorNavigator" /> implementation that resolves a list of nodes.
+            We will skip all nodes which are not the target nodes or ancestors of the target nodes.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.NodeListResolveVisitorNavigator.#ctor(ICSharpCode.NRefactory.PlayScript.AstNode[])">
+            <summary>
+            Creates a new NodeListResolveVisitorNavigator that resolves the specified nodes.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.NodeListResolveVisitorNavigator.#ctor(System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.PlayScript.AstNode},System.Boolean)">
+            <summary>
+            Creates a new NodeListResolveVisitorNavigator that resolves the specified nodes.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.NodeListResolveVisitorNavigator.Scan(ICSharpCode.NRefactory.PlayScript.AstNode)">
+            <inheritdoc />
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution">
+            <summary>
+            C# overload resolution (C# 4.0 spec: §7.5).
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.Candidate.IsExpandedForm">
+            <summary>
+            Returns the normal form candidate, if this is an expanded candidate.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.Candidate.ParameterTypes">
+            <summary>
+            Gets the parameter types. In the first step, these are the types without any substition.
+            After type inference, substitutions will be performed.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.Candidate.ArgumentToParameterMap">
+            <summary>
+            argument index -&gt; parameter index; -1 for arguments that could not be mapped
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.Candidate.Parameters">
+            <summary>
+            Gets the original member parameters (before any substitution!)
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.Candidate.TypeParameters">
+            <summary>
+            Gets the original method type parameters (before any substitution!)
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.Candidate.ArgumentConversions">
+            <summary>
+            Conversions applied to the arguments.
+            This field is set by the CheckApplicability step.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.IsExtensionMethodInvocation">
+            <summary>
+            Gets/Sets whether the methods are extension methods that are being called using extension method syntax.
+            </summary>
+            <remarks>
+            Setting this property to true restricts the possible conversions on the first argument to
+            implicit identity, reference, or boxing conversions.
+            </remarks>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.AllowExpandingParams">
+            <summary>
+            Gets/Sets whether expanding 'params' into individual elements is allowed.
+            The default value is true.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.AllowOptionalParameters">
+            <summary>
+            Gets/Sets whether optional parameters may be left at their default value.
+            The default value is true.
+            If this property is set to false, optional parameters will be treated like regular parameters.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.CheckForOverflow">
+            <summary>
+            Gets/Sets whether ConversionResolveResults created by this OverloadResolution
+            instance apply overflow checking.
+            The default value is false.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.Arguments">
+            <summary>
+            Gets the arguments for which this OverloadResolution instance was created.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.AddCandidate(ICSharpCode.NRefactory.TypeSystem.IParameterizedMember)">
+            <summary>
+            Adds a candidate to overload resolution.
+            </summary>
+            <param name="member">The candidate member to add.</param>
+            <returns>The errors that prevent the member from being applicable, if any.
+            Note: this method does not return errors that do not affect applicability.</returns>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.AddCandidate(ICSharpCode.NRefactory.TypeSystem.IParameterizedMember,ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolutionErrors)">
+            <summary>
+            Adds a candidate to overload resolution.
+            </summary>
+            <param name="member">The candidate member to add.</param>
+            <param name="additionalErrors">Additional errors that apply to the candidate.
+            This is used to represent errors during member lookup (e.g. OverloadResolutionErrors.Inaccessible)
+            in overload resolution.</param>
+            <returns>The errors that prevent the member from being applicable, if any.
+            Note: this method does not return errors that do not affect applicability.</returns>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.CalculateCandidate(ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.Candidate)">
+            <summary>
+            Calculates applicability etc. for the candidate.
+            </summary>
+            <returns>True if the calculation was successful, false if the candidate should be removed without reporting an error</returns>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.AddMethodLists(System.Collections.Generic.IList{ICSharpCode.NRefactory.PlayScript.Resolver.MethodListWithDeclaringType})">
+            <summary>
+            Adds all candidates from the method lists.
+            This method implements the logic that causes applicable methods in derived types to hide
+            all methods in base types.
+            </summary>
+            <param name="methodLists">The methods, grouped by declaring type. Base types must come first in the list.</param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.ValidateConstraints(ICSharpCode.NRefactory.TypeSystem.ITypeParameter,ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.TypeVisitor)">
+            <summary>
+            Validates whether the given type argument satisfies the constraints for the given type parameter.
+            </summary>
+            <param name="typeParameter">The type parameter.</param>
+            <param name="typeArgument">The type argument.</param>
+            <param name="substitution">The substitution that defines how type parameters are replaced with type arguments.
+            The substitution is used to check constraints that depend on other type parameters (or recursively on the same type parameter).
+            May be null if no substitution should be used.</param>
+            <returns>True if the constraints are satisfied; false otherwise.</returns>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.IsApplicable(ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolutionErrors)">
+            <summary>
+            Returns whether a candidate with the given errors is still considered to be applicable.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.BetterFunctionMember(ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.Candidate,ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.Candidate)">
+            <summary>
+            Returns 1 if c1 is better than c2; 2 if c2 is better than c1; or 0 if neither is better.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.ILiftedOperator">
+            <summary>
+            Implement this interface to give overload resolution a hint that the member represents a lifted operator,
+            which is used in the tie-breaking rules.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.BestCandidateErrors">
+            <summary>
+            Returns the errors that apply to the best candidate.
+            This includes additional errors that do not affect applicability (e.g. AmbiguousMatch, MethodConstraintsNotSatisfied)
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.ArgumentConversions">
+            <summary>
+            Gets the implicit conversions that are being applied to the arguments.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.GetArgumentToParameterMap">
+            <summary>
+            Gets an array that maps argument indices to parameter indices.
+            For arguments that could not be mapped to any parameter, the value will be -1.
+            parameterIndex = GetArgumentToParameterMap()[argumentIndex]
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.GetArgumentsWithConversions">
+            <summary>
+            Returns the arguments for the method call in the order they were provided (not in the order of the parameters).
+            Arguments are wrapped in a <see cref="T:ICSharpCode.NRefactory.Semantics.ConversionResolveResult" /> if an implicit conversion is being applied
+            to them when calling the method.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.GetArgumentsWithConversionsAndNames">
+            <summary>
+            Returns the arguments for the method call in the order they were provided (not in the order of the parameters).
+            Arguments are wrapped in a <see cref="T:ICSharpCode.NRefactory.Semantics.ConversionResolveResult" /> if an implicit conversion is being applied
+            to them when calling the method.
+            For arguments where an explicit argument name was provided, the argument will
+            be wrapped in a <see cref="T:ICSharpCode.NRefactory.Semantics.NamedArgumentResolveResult" />.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolution.CreateResolveResult(ICSharpCode.NRefactory.Semantics.ResolveResult,System.Collections.Generic.IList{ICSharpCode.NRefactory.Semantics.ResolveResult},ICSharpCode.NRefactory.TypeSystem.IType)">
+            <summary>
+            Creates a ResolveResult representing the result of overload resolution.
+            </summary>
+            <param name="targetResolveResult">
+            The target expression of the call. May be <c>null</c> for static methods/constructors.
+            </param>
+            <param name="initializerStatements">
+            Statements for Objects/Collections initializer.
+            <see cref="F:ICSharpCode.NRefactory.Semantics.InvocationResolveResult.InitializerStatements" /><param name="returnTypeOverride">
+            If not null, use this instead of the ReturnType of the member as the type of the created resolve result.
+            </param></param>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolutionErrors.TooManyPositionalArguments">
+            <summary>
+            Too many positional arguments (some could not be mapped to any parameter).
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolutionErrors.NoParameterFoundForNamedArgument">
+            <summary>
+            A named argument could not be mapped to any parameter
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolutionErrors.TypeInferenceFailed">
+            <summary>
+            Type inference failed for a generic method.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolutionErrors.WrongNumberOfTypeArguments">
+            <summary>
+            Type arguments were explicitly specified, but did not match the number of type parameters.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolutionErrors.ConstructedTypeDoesNotSatisfyConstraint">
+            <summary>
+            After substituting type parameters with the inferred types; a constructed type within the formal parameters
+            does not satisfy its constraint.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolutionErrors.MissingArgumentForRequiredParameter">
+            <summary>
+            No argument was mapped to a non-optional parameter
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolutionErrors.MultipleArgumentsForSingleParameter">
+            <summary>
+            Several arguments were mapped to a single (non-params-array) parameter
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolutionErrors.ParameterPassingModeMismatch">
+            <summary>
+            'ref'/'out' passing mode doesn't match for at least 1 parameter
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolutionErrors.ArgumentTypeMismatch">
+            <summary>
+            Argument type cannot be converted to parameter type
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolutionErrors.AmbiguousMatch">
+            <summary>
+            There is no unique best overload.
+            This error does not apply to any single candidate, but only to the overall result of overload resolution.
+            </summary>
+            <remarks>
+            This error does not prevent a candidate from being applicable.
+            </remarks>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolutionErrors.Inaccessible">
+            <summary>
+            The member is not accessible.
+            </summary>
+            <remarks>
+            This error is generated by member lookup; not by overload resolution.
+            </remarks>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.OverloadResolutionErrors.MethodConstraintsNotSatisfied">
+            <summary>
+            A generic method
+            </summary>
+            <remarks>
+            This error does not prevent a candidate from being applicable.
+            </remarks>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveAtLocation">
+            <summary>
+            Helper class that resolves the node at a specified location.
+            Can be used for implementing tool tips.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveVisitor">
+            <summary>
+            Traverses the DOM and resolves expressions.
+            </summary>
+            <remarks>
+            The ResolveVisitor does two jobs at the same time: it tracks the resolve context (properties on CSharpResolver)
+            and it resolves the expressions visited.
+            To allow using the context tracking without having to resolve every expression in the file (e.g. when you want to resolve
+            only a single node deep within the DOM), you can use the <see cref="T:ICSharpCode.NRefactory.PlayScript.Resolver.IResolveVisitorNavigator" /> interface.
+            The navigator allows you to switch the between scanning mode and resolving mode.
+            In scanning mode, the context is tracked (local variables registered etc.), but nodes are not resolved.
+            While scanning, the navigator will get asked about every node that the resolve visitor is about to enter.
+            This allows the navigator whether to keep scanning, whether switch to resolving mode, or whether to completely skip the
+            subtree rooted at that node.
+            In resolving mode, the context is tracked and nodes will be resolved.
+            The resolve visitor may decide that it needs to resolve other nodes as well in order to resolve the current node.
+            In this case, those nodes will be resolved automatically, without asking the navigator interface.
+            For child nodes that are not essential to resolving, the resolve visitor will switch back to scanning mode (and thus will
+            ask the navigator for further instructions).
+            Moreover, there is the <c>ResolveAll</c> mode - it works similar to resolving mode, but will not switch back to scanning mode.
+            The whole subtree will be resolved without notifying the navigator.
+            </remarks>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveVisitor.currentQueryResult">
+            <summary>Resolve result of the current LINQ query.</summary>
+            <remarks>We do not have to put this into the stored state (resolver) because
+            query expressions are always resolved in a single operation.</remarks>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveVisitor.#ctor(ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver,ICSharpCode.NRefactory.PlayScript.TypeSystem.CSharpUnresolvedFile)">
+            <summary>
+            Creates a new ResolveVisitor instance.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveVisitor.ResetContext(ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver,System.Action)">
+            <summary>
+            Resets the visitor to the stored position, runs the action, and then reverts the visitor to the previous position.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveVisitor.Scan(ICSharpCode.NRefactory.PlayScript.AstNode)">
+            <summary>
+            Scans the AST rooted at the given node.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveVisitor.Resolve(ICSharpCode.NRefactory.PlayScript.AstNode)">
+            <summary>
+            Equivalent to 'Scan', but also resolves the node at the same time.
+            This method should be only used if the CSharpResolver passed to the ResolveVisitor was manually set
+            to the correct state.
+            Otherwise, use <c>resolver.Scan(syntaxTree); var result = resolver.GetResolveResult(node);</c>
+            instead.
+            --
+            This method now is internal, because it is difficult to use correctly.
+            Users of the public API should use Scan()+GetResolveResult() instead.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveVisitor.ProcessConversion(ICSharpCode.NRefactory.PlayScript.Expression,ICSharpCode.NRefactory.Semantics.ResolveResult,ICSharpCode.NRefactory.Semantics.Conversion,ICSharpCode.NRefactory.TypeSystem.IType)">
+            <summary>
+            Convert 'rr' to the target type using the specified conversion.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveVisitor.ProcessConversion(ICSharpCode.NRefactory.PlayScript.Expression,ICSharpCode.NRefactory.Semantics.ResolveResult,ICSharpCode.NRefactory.TypeSystem.IType)">
+            <summary>
+            Convert 'rr' to the target type.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveVisitor.ResolveAndProcessConversion(ICSharpCode.NRefactory.PlayScript.Expression,ICSharpCode.NRefactory.TypeSystem.IType)">
+            <summary>
+            Resolves the specified expression and processes the conversion to targetType.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveVisitor.GetResolveResult(ICSharpCode.NRefactory.PlayScript.AstNode)">
+            <summary>
+            Gets the resolve result for the specified node.
+            If the node was not resolved by the navigator, this method will resolve it.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveVisitor.GetResolverStateBefore(ICSharpCode.NRefactory.PlayScript.AstNode)">
+            <summary>
+            Gets the resolver state in front of the specified node.
+            If the node was not visited by a previous scanning process, the
+            AST will be scanned again to determine the state.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveVisitor.GetArguments(System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.PlayScript.Expression},System.String[]@)">
+            <summary>
+            Gets and resolves the arguments; unpacking any NamedArgumentExpressions.
+            </summary>
+            <remarks>
+            Callers of GetArguments must also call either ProcessConversionsInInvocation or MarkUnknownNamedArguments
+            to ensure the named arguments get resolved.
+            Also, as named arguments get resolved by the parent node, the parent node must not scan
+            into the argument list without being resolved - see NeedsResolvingDueToNamedArguments().
+            </remarks>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveVisitor.IsStaticResult(ICSharpCode.NRefactory.Semantics.ResolveResult,ICSharpCode.NRefactory.Semantics.ResolveResult)">
+            <summary>
+            Gets whether 'rr' is considered a static access on the target identifier.
+            </summary>
+            <param name="rr">Resolve Result of the MemberReferenceExpression</param>
+            <param name="invocationRR">Resolve Result of the InvocationExpression</param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveVisitor.ImplicitlyTypedLambda.GetAnyHypothesis">
+            <summary>
+            Get any hypothesis for this lambda.
+            This method is used as fallback if the lambda isn't merged the normal way (AnonymousFunctionConversion)
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveVisitor.LambdaTypeHypothesis">
+            <summary>
+            Every possible set of parameter types gets its own 'hypothetical world'.
+            It uses a nested ResolveVisitor that has its own resolve cache, so that resolve results cannot leave the hypothetical world.
+            Only after overload resolution is applied and the actual parameter types are known, the winning hypothesis will be merged
+            with the parent ResolveVisitor.
+            This is done when the AnonymousFunctionConversion is applied on the parent visitor.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveVisitor.UnpackTask(ICSharpCode.NRefactory.TypeSystem.IType)">
+            <summary>
+            Gets the T in Task&lt;T&gt;.
+            Returns void for non-generic Task.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveVisitor.IsTask(ICSharpCode.NRefactory.TypeSystem.IType)">
+            <summary>
+            Gets whether the specified type is Task or Task&lt;T&gt;.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveVisitor.WrapResult(ICSharpCode.NRefactory.Semantics.ResolveResult)">
+            <summary>
+            Wraps the result in an identity conversion.
+            This is necessary so that '$from x in variable$ select x*2' does not resolve
+            to the LocalResolveResult for the variable, which would confuse find references.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.ResolveVisitor.GetSingleRangeVariable(ICSharpCode.NRefactory.PlayScript.QueryExpression)">
+            <summary>
+            Gets the name of the range variable in the specified query.
+            If the query has multiple range variables, this method returns null.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.TypeInferenceAlgorithm.CSharp4">
+            <summary>
+            C# 4.0 type inference.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.TypeInferenceAlgorithm.Improved">
+            <summary>
+            Improved algorithm (not part of any specification) using FindTypeInBounds for fixing.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Resolver.TypeInferenceAlgorithm.ImprovedReturnAllResults">
+            <summary>
+            Improved algorithm (not part of any specification) using FindTypeInBounds for fixing;
+            uses <see cref="T:ICSharpCode.NRefactory.TypeSystem.IntersectionType" /> to report all results (in case of ambiguities).
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.TypeInference">
+            <summary>
+            Implements C# 4.0 Type Inference (§7.5.2).
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.TypeInference.Algorithm">
+            <summary>
+            Gets/Sets the type inference algorithm used.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.TypeInference.InferTypeArguments(System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.ITypeParameter},System.Collections.Generic.IList{ICSharpCode.NRefactory.Semantics.ResolveResult},System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType},System.Boolean@,System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType})">
+            <summary>
+            Performs type inference.
+            </summary>
+            <param name="typeParameters">The method type parameters that should be inferred.</param>
+            <param name="arguments">The arguments passed to the method.</param>
+            <param name="parameterTypes">The parameter types of the method.</param>
+            <param name="success">Out: whether type inference was successful</param>
+            <param name="classTypeArguments">
+            Class type arguments. These are substituted for class type parameters in the formal parameter types
+            when inferring a method group or lambda.
+            </param>
+            <returns>The inferred type arguments.</returns>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.TypeInference.InferTypeArgumentsFromBounds(System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.ITypeParameter},ICSharpCode.NRefactory.TypeSystem.IType,System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType},System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType},System.Boolean@)">
+            <summary>
+            Infers type arguments for the <paramref name="typeParameters" /> occurring in the <paramref name="targetType" />
+            so that the resulting type (after substition) satisfies the given bounds.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.TypeInference.MakeExactInference(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType)">
+            <summary>
+            Make exact inference from U to V.
+            C# 4.0 spec: §7.5.2.8 Exact inferences
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.TypeInference.MakeLowerBoundInference(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType)">
+            <summary>
+            Make lower bound inference from U to V.
+            C# 4.0 spec: §7.5.2.9 Lower-bound inferences
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.TypeInference.MakeUpperBoundInference(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IType)">
+            <summary>
+            Make upper bound inference from U to V.
+            C# 4.0 spec: §7.5.2.10 Upper-bound inferences
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.TypeInference.GetBestCommonType(System.Collections.Generic.IList{ICSharpCode.NRefactory.Semantics.ResolveResult},System.Boolean@)">
+            <summary>
+            Gets the best common type (C# 4.0 spec: §7.5.2.14) of a set of expressions.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Resolver.TypeInference.FindTypeInBounds(System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType},System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType})">
+            <summary>
+            Finds a type that satisfies the given lower and upper bounds.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Completion.ICompletionDataFactory.CreateMemberCompletionData(ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.TypeSystem.IEntity)">
+            <summary>
+            Creates the member completion data.
+            Form: Type.Member
+            Used for generating enum members Foo.A, Foo.B where the enum 'Foo' is valid.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Completion.ICompletionDataFactory.CreateLiteralCompletionData(System.String,System.String,System.String)">
+            <summary>
+            Creates a generic completion data.
+            </summary>
+            <param name="title">
+            The title of the completion data
+            </param>
+            <param name="description">
+            The description of the literal.
+            </param>
+            <param name="insertText">
+            The insert text. If null, title is taken.
+            </param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Completion.ICompletionDataFactory.CreateImportCompletionData(ICSharpCode.NRefactory.TypeSystem.IType,System.Boolean)">
+            <summary>
+            Creates a completion data that adds the required using for the created type.
+            </summary>
+            <param name="type">The type to import</param>
+            <param name="useFullName">If set to true the full name of the type needs to be used.</param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Completion.IParameterCompletionDataFactory.CreateConstructorProvider(System.Int32,ICSharpCode.NRefactory.TypeSystem.IType,ICSharpCode.NRefactory.PlayScript.AstNode)">
+            <summary>
+            Creates a constructor provider skipping the parent of thisInitializer.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.NameLookupMode.Expression">
+            <summary>
+            Normal name lookup in expressions
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.NameLookupMode.InvocationTarget">
+            <summary>
+            Name lookup in expression, where the expression is the target of an invocation.
+            Such a lookup will only return methods and delegate-typed fields.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.NameLookupMode.Type">
+            <summary>
+            Normal name lookup in type references.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.NameLookupMode.TypeInUsingDeclaration">
+            <summary>
+            Name lookup in the type reference inside a using declaration.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.NameLookupMode.BaseTypeReference">
+            <summary>
+            Name lookup for base type references.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.TypeSystem.AliasNamespaceReference">
+            <summary>
+            Looks up an alias (identifier in front of :: operator).
+            </summary>
+            <remarks>
+            The member lookup performed by the :: operator is handled
+            by <see cref="T:ICSharpCode.NRefactory.PlayScript.TypeSystem.MemberTypeOrNamespaceReference" />.
+            </remarks>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.TypeSystem.AttributeTypeReference">
+            <summary>
+            Type reference used within an attribute.
+            Looks up both 'withoutSuffix' and 'withSuffix' and returns the type that exists.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.TypeSystem.ConstantValues.ErrorConstantValue">
+            <summary>
+            Used for constants that could not be converted to IConstantValue.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.TypeSystem.ConstantValues.IncrementConstantValue">
+            <summary>
+            Increments an integer <see cref="T:ICSharpCode.NRefactory.TypeSystem.IConstantValue" /> by a fixed amount without changing the type.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.TypeSystem.ConstantValues.PrimitiveConstantExpression">
+            <summary>
+            C#'s equivalent to the SimpleConstantValue.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.TypeSystem.ConstantValues.ConstantArrayCreation">
+            <summary>
+            Represents an array creation (as used within an attribute argument)
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.TypeSystem.ConstantValues.SizeOfConstantValue">
+            <summary>
+            Used for sizeof() expressions in constants.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.TypeSystem.CSharpDocumentationComment">
+            <summary>
+            DocumentationComment with C# cref lookup.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.TypeSystem.CSharpUnresolvedFile">
+            <summary>
+            Represents a file that was parsed and converted for the type system.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.TypeSystem.ResolvedUsingScope">
+            <summary>
+            Resolved version of using scope.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.TypeSystem.ResolvedUsingScope.HasAlias(System.String)">
+            <summary>
+            Gets whether this using scope has an alias (either using or extern)
+            with the specified name.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.TypeSystem.TypeOrNamespaceReference">
+            <summary>
+            Represents a reference which could point to a type or namespace.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.TypeSystem.TypeOrNamespaceReference.Resolve(ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver)">
+            <summary>
+            Resolves the reference and returns the ResolveResult.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.TypeSystem.TypeOrNamespaceReference.ResolveType(ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver)">
+            <summary>
+            Returns the type that is referenced; or an <c>UnknownType</c> if the type isn't found.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.TypeSystem.TypeOrNamespaceReference.ResolveNamespace(ICSharpCode.NRefactory.PlayScript.Resolver.CSharpResolver)">
+            <summary>
+            Returns the namespace that is referenced; or null if no such namespace is found.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.TypeSystem.MemberTypeOrNamespaceReference">
+            <summary>
+            Reference to a qualified type or namespace name.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.TypeSystem.MemberTypeOrNamespaceReference.AddSuffix(System.String)">
+            <summary>
+            Adds a suffix to the identifier.
+            Does not modify the existing type reference, but returns a new one.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.TypeSystem.SimpleTypeOrNamespaceReference">
+            <summary>
+            Represents a simple C# name. (a single non-qualified identifier with an optional list of type arguments)
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.TypeSystem.SimpleTypeOrNamespaceReference.AddSuffix(System.String)">
+            <summary>
+            Adds a suffix to the identifier.
+            Does not modify the existing type reference, but returns a new one.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.TypeSystem.TypeSystemConvertVisitor">
+            <summary>
+            Produces type and member definitions from the DOM.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.TypeSystem.TypeSystemConvertVisitor.version">
+            <summary>
+            Version of the C# type system loader.
+            Should be incremented when fixing bugs so that project contents cached on disk
+            (which might be incorrect due to the bug) are re-created.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.TypeSystem.TypeSystemConvertVisitor.InterningProvider">
+            <summary>
+            Gets/Sets the interning provider to use.
+            The default value is a new <see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SimpleInterningProvider" /> instance.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.TypeSystem.TypeSystemConvertVisitor.SkipXmlDocumentation">
+            <summary>
+            Gets/Sets whether to ignore XML documentation.
+            The default value is false.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.TypeSystem.TypeSystemConvertVisitor.#ctor(System.String)">
+            <summary>
+            Creates a new TypeSystemConvertVisitor.
+            </summary>
+            <param name="fileName">The file name (used for DomRegions).</param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.TypeSystem.TypeSystemConvertVisitor.#ctor(ICSharpCode.NRefactory.PlayScript.TypeSystem.CSharpUnresolvedFile,ICSharpCode.NRefactory.PlayScript.TypeSystem.UsingScope,ICSharpCode.NRefactory.PlayScript.TypeSystem.CSharpUnresolvedTypeDefinition)">
+            <summary>
+            Creates a new TypeSystemConvertVisitor and initializes it with a given context.
+            </summary>
+            <param name="unresolvedFile">The parsed file to which members should be added.</param>
+            <param name="currentUsingScope">The current using scope.</param>
+            <param name="currentTypeDefinition">The current type definition.</param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.TypeSystem.TypeSystemConvertVisitor.AddDefaultMethodsToDelegate(ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedTypeDefinition,ICSharpCode.NRefactory.TypeSystem.ITypeReference,System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.TypeSystem.IUnresolvedParameter})">
+            <summary>
+            Adds the 'Invoke', 'BeginInvoke', 'EndInvoke' methods, and a constructor, to the <paramref name="delegateType" />.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.TypeSystem.UsingScope">
+            <summary>
+            Represents a scope that contains "using" statements.
+            This is either the file itself, or a namespace declaration.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.TypeSystem.UsingScope.#ctor">
+            <summary>
+            Creates a new root using scope.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.TypeSystem.UsingScope.#ctor(ICSharpCode.NRefactory.PlayScript.TypeSystem.UsingScope,System.String)">
+            <summary>
+            Creates a new nested using scope.
+            </summary>
+            <param name="parent">The parent using scope.</param>
+            <param name="shortName">The short namespace name.</param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.TypeSystem.UsingScope.HasAlias(System.String)">
+            <summary>
+            Gets whether this using scope has an alias (either using or extern)
+            with the specified name.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.TypeSystem.UsingScope.Resolve(ICSharpCode.NRefactory.TypeSystem.ICompilation)">
+            <summary>
+            Resolves the namespace represented by this using scope.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.PreProcessorDirective.Take">
+            <summary>
+            For an '#if' directive, specifies whether the condition evaluated to true.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Completion.CSharpCompletionEngine.AutoCompleteEmptyMatchOnCurlyBracket">
+            <summary>
+            The auto complete empty match on curly bracket. (only taken into account when AutoCompleteEmptyMatch is true )
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Completion.CSharpCompletionEngine.GetImportCompletionData(System.Int32)">
+            <summary>
+            Gets the types that needs to be imported via using or full type name.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Completion.CSharpCompletionEngineBase">
+            <summary>
+            Acts as a common base between code completion and parameter completion.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.TokenRole">
+            <summary>
+            A specific role only used for C# tokens
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.TokenRole.Token">
+            <summary>
+            Gets the token as string. Note that the token Name and Token value may differ.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.TokenRole.Length">
+            <summary>
+            Gets the char length of the token.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.BaseRefactoringContext.UseExplicitTypes">
+            <summary>
+            Gets a value indicating if 'var' keyword should be used or explicit types.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.BaseRefactoringContext.CreateDefiniteAssignmentAnalysis(ICSharpCode.NRefactory.PlayScript.Statement)">
+            <summary>
+            Creates a new definite assignment analysis object with a given root statement.
+            </summary>
+            <returns>
+            The definite assignment analysis object.
+            </returns>
+            <param name="root">
+            The root statement.
+            </param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.BaseRefactoringContext.CreateReachabilityAnalysis(ICSharpCode.NRefactory.PlayScript.Statement)">
+            <summary>
+            Creates a new reachability analysis object with a given statement.
+            </summary>
+            <param name="statement">
+            The statement to start the analysis.
+            </param>
+            <returns>
+            The reachability analysis object.
+            </returns>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.BaseRefactoringContext.ParseFormatString(System.String)">
+            <summary>
+            Parses a composite format string.
+            </summary>
+            <returns>
+            The format string parsing result.
+            </returns>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.BaseRefactoringContext.TranslateString(System.String)">
+            <summary>
+            Translates the english input string to the context language.
+            </summary>
+            <returns>
+            The translated string.
+            </returns>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.BaseRefactoringContext.Services">
+            <summary>
+            Gets a service container used to associate services with this context.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.BaseRefactoringContext.GetService(System.Type)">
+            <summary>
+            Retrieves a service from the refactoring context.
+            If the service is not found in the <see cref="P:ICSharpCode.NRefactory.PlayScript.Refactoring.BaseRefactoringContext.Services" /> container.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.CodeIssue">
+            <summary>
+            A code issue marks a region of text with an issue and can provide solution actions for this issue.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.CodeIssue.Description">
+            <summary>
+            Gets the description of the issue.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.CodeIssue.Start">
+            <summary>
+            Gets the issue start location.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.CodeIssue.End">
+            <summary>
+            Gets the issue end location.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.CodeIssue.Actions">
+            <summary>
+            Gets a list of potential solutions for the issue.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.CodeIssue.#ctor(System.String,ICSharpCode.NRefactory.TextLocation,ICSharpCode.NRefactory.TextLocation,System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.PlayScript.Refactoring.CodeAction})">
+            <summary>
+            Initializes a new instance of the <see cref="T:ICSharpCode.NRefactory.PlayScript.Refactoring.CodeIssue" /> class.
+            </summary>
+            <param name="description">
+            The desription of the issue.
+            </param>
+            <param name="start">
+            The issue start location.
+            </param>
+            <param name="end">
+            the issue end location.
+            </param>
+            <param name="actions">
+            A list of potential solutions for the issue.
+            </param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.CodeIssue.#ctor(System.String,ICSharpCode.NRefactory.TextLocation,ICSharpCode.NRefactory.TextLocation,ICSharpCode.NRefactory.PlayScript.Refactoring.CodeAction)">
+            <summary>
+            Initializes a new instance of the <see cref="T:ICSharpCode.NRefactory.PlayScript.Refactoring.CodeIssue" /> class.
+            </summary>
+            <param name="description">
+            The desription of the issue.
+            </param>
+            <param name="start">
+            The issue start location.
+            </param>
+            <param name="end">
+            the issue end location.
+            </param>
+            <param name="action">
+            A potential solution for the issue.
+            </param>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.CodeAction">
+            <summary>
+            A code action provides a code transformation with a description.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.CodeAction.Description">
+            <summary>
+            Gets the description.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.CodeAction.Run">
+            <summary>
+            Gets the code transformation.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.CodeAction.#ctor(System.String,System.Action{ICSharpCode.NRefactory.PlayScript.Refactoring.Script})">
+            <summary>
+            Initializes a new instance of the <see cref="T:ICSharpCode.NRefactory.PlayScript.Refactoring.CodeAction" /> class.
+            </summary>
+            <param name="description">
+            The description.
+            </param>
+            <param name="action">
+            The code transformation.
+            </param>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.ICodeIssueProvider">
+            <summary>
+            The code issue provider gets a list of all code issues in a syntax tree.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.ICodeIssueProvider.GetIssues(ICSharpCode.NRefactory.PlayScript.Refactoring.BaseRefactoringContext)">
+            <summary>
+            Gets all code issues inside a syntax tree.
+            </summary>
+            <param name="context">
+            The refactoring context of the issues to get.
+            </param>
+        </member>
+        <!--FIXME: Invalid documentation markup was found for member P:ICSharpCode.NRefactory.PlayScript.ContextActionAttribute.BoundToIssue-->
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Severity">
+            <summary>
+            The severity influences how the task bar reacts on found issues.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Severity.None">
+            <summary>
+            None means that the task bar doesn't show the issue.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Severity.Error">
+            <summary>
+            Errors are shown in red and that the task bar is in error state if 1 error is found.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Severity.Warning">
+            <summary>
+            Warnings are shown in yellow and set the task bar to warning state (if no error is found).
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Severity.Suggestion">
+            <summary>
+            Suggestions are shown in green and doesn't influence the task bar state
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Severity.Hint">
+            <summary>
+            Hints are shown in blue and doesn't influence the task bar state
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.IssueMarker">
+            <summary>
+            The issue marker is used to set how an issue should be marked inside the text editor.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.IssueMarker.None">
+            <summary>
+            The issue is not shown inside the text editor. (But in the task bar)
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.IssueMarker.Underline">
+            <summary>
+            The region is marked as underline in the severity color.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.IssueMarker.GrayOut">
+            <summary>
+            The text is grayed out.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.GatherVisitorBase">
+            <summary>
+            A base class for writing issue provider visitor implementations.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.GatherVisitorBase.#ctor(ICSharpCode.NRefactory.PlayScript.Refactoring.BaseRefactoringContext)">
+            <summary>
+            Initializes a new instance of the <see cref="T:ICSharpCode.NRefactory.PlayScript.GatherVisitorBase" /> class.
+            </summary>
+            <param name="ctx">
+            The refactoring context.
+            </param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.GatherVisitorBase.GetIssues">
+            <summary>
+            Gets all the issues using the context root node as base.
+            </summary>
+            <returns>
+            The issues.
+            </returns>
+        </member>
+        <!--FIXME: Invalid documentation markup was found for member T:ICSharpCode.NRefactory.PlayScript.Refactoring.ConditionalToNullCoalescingIssue-->
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.NotImplementedExceptionIssue">
+            <summary>
+            This inspector just shows that there is a not implemented exception. It doesn't offer a fix.
+            Should only be shown in overview bar, no underlining.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.RedundantInternalIssue">
+            <summary>
+            Finds redundant internal modifiers.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.RedundantNamespaceUsageIssue">
+            <summary>
+            Finds redundant namespace usages.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.RedundantPrivateIssue">
+            <summary>
+            Finds redundant internal modifiers.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.RedundantThisIssue">
+            <summary>
+            Finds redundant namespace usages.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.RedundantThisIssue.IgnoreConstructors">
+            <summary>
+            Specifies whether to ignore redundant 'this' in constructors.
+            "this.Name = name;"
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.RedundantUsingIssue">
+            <summary>
+            Finds redundant using declarations.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.RedundantUsingIssue.NamespacesToKeep">
+            <summary>
+            The list of namespaces that should be kept even if they are not being used.
+            Used in SharpDevelop to always keep the "System" namespace around.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.StringIsNullOrEmptyIssue">
+            <summary>
+            Checks for str == null &amp;&amp; str == " "
+            Converts to: string.IsNullOrEmpty (str)
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.UseVarKeywordIssue">
+            <summary>
+            Checks for places where the 'var' keyword can be used. Note that the action is actually done with a context
+            action.
+            </summary>
+        </member>
+        <!--FIXME: Invalid documentation markup was found for member T:ICSharpCode.NRefactory.PlayScript.Refactoring.IntroduceFormatItemAction-->
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.CreateEventInvocatorAction.UseExplictType">
+            <summary>
+            If <c>true</c> an explicit type will be used for the handler variable; otherwise, 'var' will be used as type.
+            Default value is <c>false</c></summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.ConvertHexToDecAction">
+            <summary>
+            Convert a hex numer to dec. For example: 0x10 -&gt; 16
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.ConvertForeachToForAction">
+            <summary>
+            Converts a foreach loop to for.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.ConvertDecToHexAction">
+            <summary>
+            Convert a dec numer to hex. For example: 16 -&gt; 0x10
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.CheckIfParameterIsNullAction">
+            <summary>
+            Creates a 'if (param == null) throw new System.ArgumentNullException ();' contruct for a parameter.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.AddAnotherAccessorAction">
+            <summary>
+            Add another accessor to a property declaration that has only one.
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Refactoring.NamingStyle.PascalCase">
+            <summary>
+            PascalCase
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Refactoring.NamingStyle.CamelCase">
+            <summary>
+            camelCase
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Refactoring.NamingStyle.AllUpper">
+            <summary>
+            ALLUPPER
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Refactoring.NamingStyle.AllLower">
+            <summary>
+            alllower
+            </summary>
+        </member>
+        <member name="F:ICSharpCode.NRefactory.PlayScript.Refactoring.NamingStyle.FirstUpper">
+            <summary>
+            Firstupper
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.NamingRule.RequiredPrefixes">
+            <summary>
+            If set, identifiers are required to be prefixed with one of these values.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.NamingRule.AllowedPrefixes">
+            <summary>
+            If set, identifiers are allowed to be prefixed with one of these values.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.NamingRule.RequiredSuffixes">
+            <summary>
+            If set, identifiers are required to be suffixed with one of these values.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.NamingRule.ForbiddenPrefixes">
+            <summary>
+            If set, identifiers cannot be prefixed by any of these values.
+            </summary>
+        </member>
+        <!--FIXME: Invalid documentation markup was found for member P:ICSharpCode.NRefactory.PlayScript.Refactoring.NamingRule.ForbiddenSuffixes-->
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.NamingRule.AffectedEntity">
+            <summary>
+            Gets or sets the affected entity.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Refactoring.NamingRule.VisibilityMask">
+            <summary>
+            Gets or sets the modifiers mask
+            </summary>
+        </member>
+        <!--FIXME: Invalid documentation markup was found for member P:ICSharpCode.NRefactory.PlayScript.Refactoring.NamingRule.NamingStyle-->
+        <member name="T:ICSharpCode.NRefactory.PlayScript.TextEditorOptions">
+            <summary>
+            The text editor options class holds basic information about the text editor settings that influences code generation and formatting beside
+            the CSharpFormattingOptions.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.TextEditorOptions.TabsToSpaces">
+            <summary>
+            Gets or sets a value indicating if tabs need to be replaced by spaces. If that is true, all indenting will be done with spaces only,
+            otherwise the indenting will start with tabs.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.TextEditorOptions.TabSize">
+            <summary>
+            Gets or sets the size of the tab chacter as spaces.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.TextEditorOptions.IndentSize">
+            <summary>
+            Gets or sets the size of a single indent as spaces.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.TextEditorOptions.ContinuationIndent">
+            <summary>
+            Gets or sets the continuation indent. A continuation indent is the indent that will be put after an embedded statement that is no block.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.TextEditorOptions.LabelIndent">
+            <summary>
+            Gets or sets the label indent. A label indent is the indent that will be put before an label.
+            (Note: it may be negative -IndentSize would cause that labels are unindented)
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.TextEditorOptions.EolMarker">
+            <summary>
+            Gets or sets the eol marker.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.TextEditorOptions.IndentBlankLines">
+            <summary>
+            If true blank lines will be indented up to the indent level, otherwise blank lines will have the length 0.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.TextEditorOptions.WrapLineLength">
+            <summary>
+            Gets or sets the length of the desired line length. The formatting engine will wrap at wrap points set to Wrapping.WrapIfTooLong if the line length is too long.
+            0 means do not wrap.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.SpecializedCodeAction`1">
+            <summary>
+            A specialized code action creates a code action assoziated with one special type of ast nodes.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.SpecializedCodeAction`1.GetAction(ICSharpCode.NRefactory.PlayScript.Refactoring.RefactoringContext,`0)">
+            <summary>
+            Gets the action for the specified ast node.
+            </summary>
+            <returns>
+            The code action. May return <c>null</c>, if no action can be provided.
+            </returns>
+            <param name="context">
+            The refactoring conext.
+            </param>
+            <param name="node">
+            The AstNode it's ensured that the node is always != null, if called.
+            </param>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.NewLineNode">
+            <summary>
+            A New line node represents a line break in the text.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.WhitespaceNode">
+            <summary>
+            A Whitespace node contains only whitespaces.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.TextNode">
+            <summary>
+            A text node contains text without syntactic or semantic information.
+            (non parseable part of a text)
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.FormattingOptionsFactory">
+            <summary>
+            The formatting options factory creates pre defined formatting option styles.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.FormattingOptionsFactory.CreateEmpty">
+            <summary>
+            Creates empty CSharpFormatting options.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.FormattingOptionsFactory.CreateMono">
+            <summary>
+            Creates mono indent style CSharpFormatting options.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.FormattingOptionsFactory.CreateSharpDevelop">
+            <summary>
+            Creates sharp develop indent style CSharpFormatting options.
+            </summary>
+        </member>
+        <!--FIXME: Invalid documentation markup was found for member M:ICSharpCode.NRefactory.PlayScript.FormattingOptionsFactory.CreateKRStyle-->
+        <member name="M:ICSharpCode.NRefactory.PlayScript.FormattingOptionsFactory.CreateAllman">
+            <summary>
+            Creates allman indent style CSharpFormatting options used in Visual Studio.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.FormattingOptionsFactory.CreateWhitesmiths">
+            <summary>
+            The Whitesmiths style, also called Wishart style to a lesser extent, is less common today than the previous three. It was originally used in the documentation for the first commercial C compiler, the Whitesmiths Compiler.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.FormattingOptionsFactory.CreateGNU">
+            <summary>
+            Like the Allman and Whitesmiths styles, GNU style puts braces on a line by themselves, indented by 2 spaces,
+            except when opening a function definition, where they are not indented.
+            In either case, the contained code is indented by 2 spaces from the braces.
+            Popularised by Richard Stallman, the layout may be influenced by his background of writing Lisp code.
+            In Lisp the equivalent to a block (a progn)
+            is a first class data entity and giving it its own indent level helps to emphasize that,
+            whereas in C a block is just syntax.
+            Although not directly related to indentation, GNU coding style also includes a space before the bracketed
+            list of arguments to a function.
+            </summary>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.NamingHelper.GenerateVariableName(ICSharpCode.NRefactory.PlayScript.AstType,System.String)">
+            <summary>
+            Generates a variable name for a variable of the specified type.
+            </summary>
+            <returns>
+            The variable name.
+            </returns>
+            <param name="type">
+            The type of the variable.
+            </param>
+            <param name="baseName">
+            Suggested base name.
+            </param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.NamingHelper.GenerateVariableName(ICSharpCode.NRefactory.TypeSystem.IType,System.String)">
+            <summary>
+            Generates a variable name for a variable of the specified type.
+            </summary>
+            <returns>
+            The variable name.
+            </returns>
+            <param name="type">
+            The type of the variable.
+            </param>
+            <param name="baseName">
+            Suggested base name.
+            </param>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.ITypeCriterion.SatisfiedBy(ICSharpCode.NRefactory.TypeSystem.IType)">
+            <summary>
+            Checks if the given type satisfies the critrion.
+            </summary>
+            <returns>
+                <c>true</c>, if the type satisfies the criterion, <c>false</c> otherwise.
+            </returns>
+            <param name="type">
+            The type to check.
+            </param>
+        </member>
+        <member name="P:Mono.CSharpPs.SeekableStreamReader.Position">
+            <remarks>
+            This value corresponds to the current position in a stream of characters.
+            The StreamReader hides its manipulation of the underlying byte stream and all
+            character set/decoding issues.  Thus, we cannot use this position to guess at
+            the corresponding position in the underlying byte stream even though there is
+            a correlation between them.
+            </remarks>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Refactoring.LocalReferenceFinder">
+            <summary>
+            Finds references to <see cref="T:ICSharpCode.NRefactory.TypeSystem.IVariable">IVariables</see>.
+            </summary>
+            <remarks>
+            This class is more efficient than <see cref="T:ICSharpCode.NRefactory.PlayScript.Resolver.FindReferences" />
+            if there is already a resolved tree or if multiple searches needs
+            to be performed.
+            </remarks>
+        </member>
+        <member name="M:ICSharpCode.NRefactory.PlayScript.Refactoring.LocalReferenceFinder.FindReferences(ICSharpCode.NRefactory.PlayScript.AstNode,ICSharpCode.NRefactory.TypeSystem.IVariable)">
+            <summary>
+            Finds the references to <paramref name="variable" />.
+            </summary>
+            <param name="rootNode">
+            Root node for the search.
+            </param>
+            <param name="variable">
+            The variable to find references for.
+            </param>
+            <remarks>
+            When a single <see cref="T:ICSharpCode.NRefactory.PlayScript.Refactoring.LocalReferenceFinder" /> is reused for multiple
+            searches, which references outside of <paramref name="rootNode" /> are
+            or are not reported is undefined.
+            </remarks>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.AliasTypeResolveResult">
+            <summary>
+            Represents a type resolve result that's resolved using an alias.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.AliasTypeResolveResult.Alias">
+            <summary>
+            The alias used.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.Resolver.AliasNamespaceResolveResult">
+            <summary>
+            Represents a namespace resolve result that's resolved using an alias.
+            </summary>
+        </member>
+        <member name="P:ICSharpCode.NRefactory.PlayScript.Resolver.AliasNamespaceResolveResult.Alias">
+            <summary>
+            The alias used.
+            </summary>
+        </member>
+        <member name="T:ICSharpCode.NRefactory.PlayScript.ReducedExtensionMethod">
+            <summary>
+            An invocated extension method hides the extension parameter in its parameter list.
+            It's used to hide the internals of extension method invocation in certain situation to simulate the
+            syntactic way of writing extension methods on semantic level.
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.AsIn">
+            <summary>
+            Implementation of the ActionScript `in' operator.
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.AsUndefinedLiteral">
+            <summary>
+            Implementation of the ActionScript `undefined' object constant.
+            </summary>
+        </member>
+        <member name="T:Mono.CSharpPs.AsXmlQueryExpression">
+            <summary>
+            Implementation of the ActionScript E4X xml query.
+            </summary>
+        </member>
+        <member name="T:Mono.PlayScript.PlayScriptParser">
+            <summary>
+            The PlayScript Parser
+            </summary>
+        </member>
+        <member name="F:Mono.PlayScript.PlayScriptParser.current_block">
+            <summary>
+            Current block is used to add statements as we find
+            them.
+            </summary>
+        </member>
+        <member name="F:Mono.PlayScript.PlayScriptParser.current_local_parameters">
+            <summary>
+            This is used by the unary_expression code to resolve
+            a name against a parameter.
+            </summary>
+        </member>
+        <member name="F:Mono.PlayScript.PlayScriptParser.oob_stack">
+            An out-of-band stack.</member>
+        <member name="F:Mono.PlayScript.PlayScriptParser.yacc_verbose_flag">
+            Controls the verbosity of the errors produced by the parser</member>
+        <member name="F:Mono.PlayScript.PlayScriptParser.UnexpectedEOF">
+            Used by the interactive shell, flags whether EOF was reached
+            and an error was produced</member>
+        <member name="F:Mono.PlayScript.PlayScriptParser.file">
+            The current file.</member>
+        <member name="F:Mono.PlayScript.PlayScriptParser.tmpComment">
+            Temporary Xml documentation cache.
+            For enum types, we need one more temporary store.</member>
+        <member name="F:Mono.PlayScript.PlayScriptParser.current_attr_target">
+            Current attribute target</member>
+        <member name="F:Mono.PlayScript.PlayScriptParser.InteractiveResult">
+            When using the interactive parser, this holds the
+            resulting expression</member>
+        <member name="F:Mono.PlayScript.PlayScriptParser.ErrorOutput">
+             error output stream.
+                  It should be changeable.</member>
+        <member name="M:Mono.PlayScript.PlayScriptParser.yyerror(System.String)">
+             simplified error message.
+                  @see <a href="#yyerror(java.lang.String, java.lang.String[])">yyerror</a></member>
+        <member name="M:Mono.PlayScript.PlayScriptParser.yyerror(System.String,System.String[])">
+             (syntax) error message.
+                  Can be overwritten to control message format.
+                  @param message text to be displayed.
+                  @param expected vector of acceptable tokens, if available.</member>
+        <member name="F:Mono.PlayScript.PlayScriptParser.yyFinal">
+             debugging support, requires the package jay.yydebug.
+                  Set to null to suppress debugging messages.</member>
+        <member name="F:Mono.PlayScript.PlayScriptParser.yyExpectingState">
+             index-checked interface to yyNames[].
+                  @param token single character or %token value.
+                  @return token name or [illegal] or [unknown].</member>
+        <member name="M:Mono.PlayScript.PlayScriptParser.yyExpectingTokens(System.Int32)">
+             computes list of expected tokens on error by tracing the tables.
+                  @param state for which to compute the list.
+                  @return list of token names.</member>
+        <member name="M:Mono.PlayScript.PlayScriptParser.yyparse(Mono.PlayScript.yyParser.yyInput,System.Object)">
+             the generated parser, with debugging messages.
+                  Maintains a state and a value stack, currently with fixed maximum size.
+                  @param yyLex scanner.
+                  @param yydebug debug message writer implementing yyDebug, or null.
+                  @return result of the last reduction, if any.
+                  @throws yyException on irrecoverable parse error.</member>
+        <member name="F:Mono.PlayScript.PlayScriptParser.yyMax">
+             initial size and increment of the state/value stack [default 256].
+                  This is not final so that it can be overwritten outside of invocations
+                  of yyparse().</member>
+        <member name="M:Mono.PlayScript.PlayScriptParser.yyDefault(System.Object)">
+             executed at the beginning of a reduce action.
+                  Used as $$ = yyDefault($1), prior to the user-specified action, if any.
+                  Can be overwritten to provide deep copy, etc.
+                  @param first value for $1, or null.
+                  @return first.</member>
+        <member name="M:Mono.PlayScript.PlayScriptParser.yyparse(Mono.PlayScript.yyParser.yyInput)">
+             the generated parser.
+                  Maintains a state and a value stack, currently with fixed maximum size.
+                  @param yyLex scanner.
+                  @return result of the last reduction, if any.
+                  @throws yyException on irrecoverable parse error.</member>
+        <member name="T:Mono.PlayScript.yyParser.yyException">
+             thrown for irrecoverable syntax errors and stack overflow.</member>
+        <member name="T:Mono.PlayScript.yyParser.yyInput">
+             must be implemented by a scanner object to supply input to the parser.</member>
+        <member name="M:Mono.PlayScript.yyParser.yyInput.advance">
+             move on to next token.
+                    @return false if positioned beyond tokens.
+                    @throws IOException on input error.</member>
+        <member name="M:Mono.PlayScript.yyParser.yyInput.token">
+             classifies current token.
+                    Should not be called if advance() returned false.
+                    @return current %token or single character.</member>
+        <member name="M:Mono.PlayScript.yyParser.yyInput.value">
+             associated with current token.
+                    Should not be called if advance() returned false.
+                    @return value for token().</member>
+        <member name="T:Mono.PlayScript.Tokenizer">
+            <summary>
+            Tokenizer for C# source code.
+            </summary>
+        </member>
+        <member name="M:Mono.PlayScript.Tokenizer.ParsePragmaDirective(System.String)">
+            <summary>
+            Handles #pragma directive
+            </summary>
+        </member>
+    </members>
+</doc>
Binary files ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/bin/Debug/ICSharpCode.NRefactory.dll and ./main/src/addins/ICSharpCode.NRefactory.PlayScript/bin/Debug/ICSharpCode.NRefactory.dll differ
Binary files ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/bin/Debug/ICSharpCode.NRefactory.dll.mdb and ./main/src/addins/ICSharpCode.NRefactory.PlayScript/bin/Debug/ICSharpCode.NRefactory.dll.mdb differ
Binary files ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/bin/Debug/Mono.Cecil.dll and ./main/src/addins/ICSharpCode.NRefactory.PlayScript/bin/Debug/Mono.Cecil.dll differ
Binary files ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/bin/Debug/Mono.Cecil.dll.mdb and ./main/src/addins/ICSharpCode.NRefactory.PlayScript/bin/Debug/Mono.Cecil.dll.mdb differ
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/obj/Debug/ICSharpCode.NRefactory.CSharp.csproj.FilesWrittenAbsolute.txt ./main/src/addins/ICSharpCode.NRefactory.PlayScript/obj/Debug/ICSharpCode.NRefactory.CSharp.csproj.FilesWrittenAbsolute.txt
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/obj/Debug/ICSharpCode.NRefactory.CSharp.csproj.FilesWrittenAbsolute.txt	2013-04-23 17:52:56.000000000 -0700
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/obj/Debug/ICSharpCode.NRefactory.CSharp.csproj.FilesWrittenAbsolute.txt	1969-12-31 16:00:00.000000000 -0800
@@ -1,4 +0,0 @@
-/Users/bcooley/projects/monodevelop-as3/main/external/nrefactory/bin/Debug/ICSharpCode.NRefactory.CSharp.dll.mdb
-/Users/bcooley/projects/monodevelop-as3/main/external/nrefactory/bin/Debug/ICSharpCode.NRefactory.CSharp.dll
-/Users/bcooley/projects/monodevelop-as3/main/external/nrefactory/ICSharpCode.NRefactory.CSharp/obj/Debug/ICSharpCode.NRefactory.CSharp.dll
-/Users/bcooley/projects/monodevelop-as3/main/external/nrefactory/ICSharpCode.NRefactory.CSharp/obj/Debug/ICSharpCode.NRefactory.CSharp.dll.mdb
Binary files ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/obj/Debug/ICSharpCode.NRefactory.CSharp.dll and ./main/src/addins/ICSharpCode.NRefactory.PlayScript/obj/Debug/ICSharpCode.NRefactory.CSharp.dll differ
Binary files ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/obj/Debug/ICSharpCode.NRefactory.CSharp.dll.mdb and ./main/src/addins/ICSharpCode.NRefactory.PlayScript/obj/Debug/ICSharpCode.NRefactory.CSharp.dll.mdb differ
diff -rupN -x .DS_Store -x '*.snk' ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/obj/Debug/ICSharpCode.NRefactory.PlayScript.csproj.FilesWrittenAbsolute.txt ./main/src/addins/ICSharpCode.NRefactory.PlayScript/obj/Debug/ICSharpCode.NRefactory.PlayScript.csproj.FilesWrittenAbsolute.txt
--- ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/obj/Debug/ICSharpCode.NRefactory.PlayScript.csproj.FilesWrittenAbsolute.txt	1969-12-31 16:00:00.000000000 -0800
+++ ./main/src/addins/ICSharpCode.NRefactory.PlayScript/obj/Debug/ICSharpCode.NRefactory.PlayScript.csproj.FilesWrittenAbsolute.txt	2013-04-23 21:04:54.000000000 -0700
@@ -0,0 +1,4 @@
+/Users/bcooley/projects/monodevelop-as3/main/src/addins/ICSharpCode.NRefactory.PlayScript/bin/Debug/ICSharpCode.NRefactory.PlayScript.dll.mdb
+/Users/bcooley/projects/monodevelop-as3/main/src/addins/ICSharpCode.NRefactory.PlayScript/bin/Debug/ICSharpCode.NRefactory.PlayScript.dll
+/Users/bcooley/projects/monodevelop-as3/main/src/addins/ICSharpCode.NRefactory.PlayScript/obj/Debug/ICSharpCode.NRefactory.PlayScript.dll
+/Users/bcooley/projects/monodevelop-as3/main/src/addins/ICSharpCode.NRefactory.PlayScript/obj/Debug/ICSharpCode.NRefactory.PlayScript.dll.mdb
Binary files ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/obj/Debug/ICSharpCode.NRefactory.PlayScript.dll and ./main/src/addins/ICSharpCode.NRefactory.PlayScript/obj/Debug/ICSharpCode.NRefactory.PlayScript.dll differ
Binary files ./main/external/nrefactory/ICSharpCode.NRefactory.CSharp/obj/Debug/ICSharpCode.NRefactory.PlayScript.dll.mdb and ./main/src/addins/ICSharpCode.NRefactory.PlayScript/obj/Debug/ICSharpCode.NRefactory.PlayScript.dll.mdb differ
